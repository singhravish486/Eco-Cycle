"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/react-reconciler";
exports.ids = ["vendor-chunks/react-reconciler"];
exports.modules = {

/***/ "(ssr)/./node_modules/react-reconciler/cjs/react-reconciler-constants.development.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/react-reconciler/cjs/react-reconciler-constants.development.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("/**\n * @license React\n * react-reconciler-constants.development.js\n *\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\n true &&\n  ((exports.ConcurrentRoot = 1),\n  (exports.ContinuousEventPriority = 8),\n  (exports.DefaultEventPriority = 32),\n  (exports.DiscreteEventPriority = 2),\n  (exports.IdleEventPriority = 268435456),\n  (exports.LegacyRoot = 0),\n  (exports.NoEventPriority = 0));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmVhY3QtcmVjb25jaWxlci9janMvcmVhY3QtcmVjb25jaWxlci1jb25zdGFudHMuZGV2ZWxvcG1lbnQuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVhO0FBQ2IsS0FBcUM7QUFDckMsSUFBSSxzQkFBc0I7QUFDMUIsR0FBRywrQkFBK0I7QUFDbEMsR0FBRyw0QkFBNEI7QUFDL0IsR0FBRyw2QkFBNkI7QUFDaEMsR0FBRyx5QkFBeUI7QUFDNUIsR0FBRyxrQkFBa0I7QUFDckIsR0FBRyx1QkFBdUIiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcUmF2aXNoIFNpbmdoXFxFQ09GXFxlY29cXGVjby1jeWNsZVxcbm9kZV9tb2R1bGVzXFxyZWFjdC1yZWNvbmNpbGVyXFxjanNcXHJlYWN0LXJlY29uY2lsZXItY29uc3RhbnRzLmRldmVsb3BtZW50LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGxpY2Vuc2UgUmVhY3RcbiAqIHJlYWN0LXJlY29uY2lsZXItY29uc3RhbnRzLmRldmVsb3BtZW50LmpzXG4gKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG5cInVzZSBzdHJpY3RcIjtcblwicHJvZHVjdGlvblwiICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOViAmJlxuICAoKGV4cG9ydHMuQ29uY3VycmVudFJvb3QgPSAxKSxcbiAgKGV4cG9ydHMuQ29udGludW91c0V2ZW50UHJpb3JpdHkgPSA4KSxcbiAgKGV4cG9ydHMuRGVmYXVsdEV2ZW50UHJpb3JpdHkgPSAzMiksXG4gIChleHBvcnRzLkRpc2NyZXRlRXZlbnRQcmlvcml0eSA9IDIpLFxuICAoZXhwb3J0cy5JZGxlRXZlbnRQcmlvcml0eSA9IDI2ODQzNTQ1NiksXG4gIChleHBvcnRzLkxlZ2FjeVJvb3QgPSAwKSxcbiAgKGV4cG9ydHMuTm9FdmVudFByaW9yaXR5ID0gMCkpO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/react-reconciler/cjs/react-reconciler-constants.development.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/react-reconciler/cjs/react-reconciler.development.js":
/*!***************************************************************************!*\
  !*** ./node_modules/react-reconciler/cjs/react-reconciler.development.js ***!
  \***************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/**\n * @license React\n * react-reconciler.development.js\n *\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */ \n true && (module.exports = function($$$config) {\n    function findHook(fiber, id) {\n        for(fiber = fiber.memoizedState; null !== fiber && 0 < id;)fiber = fiber.next, id--;\n        return fiber;\n    }\n    function copyWithSetImpl(obj, path, index, value) {\n        if (index >= path.length) return value;\n        var key = path[index], updated = isArrayImpl(obj) ? obj.slice() : assign({}, obj);\n        updated[key] = copyWithSetImpl(obj[key], path, index + 1, value);\n        return updated;\n    }\n    function copyWithRename(obj, oldPath, newPath) {\n        if (oldPath.length !== newPath.length) console.warn(\"copyWithRename() expects paths of the same length\");\n        else {\n            for(var i = 0; i < newPath.length - 1; i++)if (oldPath[i] !== newPath[i]) {\n                console.warn(\"copyWithRename() expects paths to be the same except for the deepest key\");\n                return;\n            }\n            return copyWithRenameImpl(obj, oldPath, newPath, 0);\n        }\n    }\n    function copyWithRenameImpl(obj, oldPath, newPath, index) {\n        var oldKey = oldPath[index], updated = isArrayImpl(obj) ? obj.slice() : assign({}, obj);\n        index + 1 === oldPath.length ? (updated[newPath[index]] = updated[oldKey], isArrayImpl(updated) ? updated.splice(oldKey, 1) : delete updated[oldKey]) : updated[oldKey] = copyWithRenameImpl(obj[oldKey], oldPath, newPath, index + 1);\n        return updated;\n    }\n    function copyWithDeleteImpl(obj, path, index) {\n        var key = path[index], updated = isArrayImpl(obj) ? obj.slice() : assign({}, obj);\n        if (index + 1 === path.length) return isArrayImpl(updated) ? updated.splice(key, 1) : delete updated[key], updated;\n        updated[key] = copyWithDeleteImpl(obj[key], path, index + 1);\n        return updated;\n    }\n    function shouldSuspendImpl() {\n        return !1;\n    }\n    function shouldErrorImpl() {\n        return null;\n    }\n    function createFiber(tag, pendingProps, key, mode) {\n        return new FiberNode(tag, pendingProps, key, mode);\n    }\n    function scheduleRoot(root, element) {\n        root.context === emptyContextObject && (updateContainerSync(element, root, null, null), flushSyncWork());\n    }\n    function scheduleRefresh(root, update) {\n        if (null !== resolveFamily) {\n            var staleFamilies = update.staleFamilies;\n            update = update.updatedFamilies;\n            flushPassiveEffects();\n            scheduleFibersWithFamiliesRecursively(root.current, update, staleFamilies);\n            flushSyncWork();\n        }\n    }\n    function setRefreshHandler(handler) {\n        resolveFamily = handler;\n    }\n    function warnInvalidHookAccess() {\n        console.error(\"Do not call Hooks inside useEffect(...), useMemo(...), or other built-in Hooks. You can only call Hooks at the top level of your React function. For more information, see https://react.dev/link/rules-of-hooks\");\n    }\n    function warnInvalidContextAccess() {\n        console.error(\"Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo().\");\n    }\n    function noop() {}\n    function warnForMissingKey() {}\n    function setToSortedString(set) {\n        var array = [];\n        set.forEach(function(value) {\n            array.push(value);\n        });\n        return array.sort().join(\", \");\n    }\n    function getIteratorFn(maybeIterable) {\n        if (null === maybeIterable || \"object\" !== typeof maybeIterable) return null;\n        maybeIterable = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[\"@@iterator\"];\n        return \"function\" === typeof maybeIterable ? maybeIterable : null;\n    }\n    function getComponentNameFromType(type) {\n        if (null == type) return null;\n        if (\"function\" === typeof type) return type.$$typeof === REACT_CLIENT_REFERENCE ? null : type.displayName || type.name || null;\n        if (\"string\" === typeof type) return type;\n        switch(type){\n            case REACT_FRAGMENT_TYPE:\n                return \"Fragment\";\n            case REACT_PORTAL_TYPE:\n                return \"Portal\";\n            case REACT_PROFILER_TYPE:\n                return \"Profiler\";\n            case REACT_STRICT_MODE_TYPE:\n                return \"StrictMode\";\n            case REACT_SUSPENSE_TYPE:\n                return \"Suspense\";\n            case REACT_SUSPENSE_LIST_TYPE:\n                return \"SuspenseList\";\n        }\n        if (\"object\" === typeof type) switch(\"number\" === typeof type.tag && console.error(\"Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue.\"), type.$$typeof){\n            case REACT_CONTEXT_TYPE:\n                return (type.displayName || \"Context\") + \".Provider\";\n            case REACT_CONSUMER_TYPE:\n                return (type._context.displayName || \"Context\") + \".Consumer\";\n            case REACT_FORWARD_REF_TYPE:\n                var innerType = type.render;\n                type = type.displayName;\n                type || (type = innerType.displayName || innerType.name || \"\", type = \"\" !== type ? \"ForwardRef(\" + type + \")\" : \"ForwardRef\");\n                return type;\n            case REACT_MEMO_TYPE:\n                return innerType = type.displayName || null, null !== innerType ? innerType : getComponentNameFromType(type.type) || \"Memo\";\n            case REACT_LAZY_TYPE:\n                innerType = type._payload;\n                type = type._init;\n                try {\n                    return getComponentNameFromType(type(innerType));\n                } catch (x) {}\n        }\n        return null;\n    }\n    function getComponentNameFromFiber(fiber) {\n        var type = fiber.type;\n        switch(fiber.tag){\n            case 24:\n                return \"Cache\";\n            case 9:\n                return (type._context.displayName || \"Context\") + \".Consumer\";\n            case 10:\n                return (type.displayName || \"Context\") + \".Provider\";\n            case 18:\n                return \"DehydratedFragment\";\n            case 11:\n                return fiber = type.render, fiber = fiber.displayName || fiber.name || \"\", type.displayName || (\"\" !== fiber ? \"ForwardRef(\" + fiber + \")\" : \"ForwardRef\");\n            case 7:\n                return \"Fragment\";\n            case 26:\n            case 27:\n            case 5:\n                return type;\n            case 4:\n                return \"Portal\";\n            case 3:\n                return \"Root\";\n            case 6:\n                return \"Text\";\n            case 16:\n                return getComponentNameFromType(type);\n            case 8:\n                return type === REACT_STRICT_MODE_TYPE ? \"StrictMode\" : \"Mode\";\n            case 22:\n                return \"Offscreen\";\n            case 12:\n                return \"Profiler\";\n            case 21:\n                return \"Scope\";\n            case 13:\n                return \"Suspense\";\n            case 19:\n                return \"SuspenseList\";\n            case 25:\n                return \"TracingMarker\";\n            case 1:\n            case 0:\n            case 14:\n            case 15:\n                if (\"function\" === typeof type) return type.displayName || type.name || null;\n                if (\"string\" === typeof type) return type;\n                break;\n            case 29:\n                type = fiber._debugInfo;\n                if (null != type) {\n                    for(var i = type.length - 1; 0 <= i; i--)if (\"string\" === typeof type[i].name) return type[i].name;\n                }\n                if (null !== fiber.return) return getComponentNameFromFiber(fiber.return);\n        }\n        return null;\n    }\n    function disabledLog() {}\n    function disableLogs() {\n        if (0 === disabledDepth) {\n            prevLog = console.log;\n            prevInfo = console.info;\n            prevWarn = console.warn;\n            prevError = console.error;\n            prevGroup = console.group;\n            prevGroupCollapsed = console.groupCollapsed;\n            prevGroupEnd = console.groupEnd;\n            var props = {\n                configurable: !0,\n                enumerable: !0,\n                value: disabledLog,\n                writable: !0\n            };\n            Object.defineProperties(console, {\n                info: props,\n                log: props,\n                warn: props,\n                error: props,\n                group: props,\n                groupCollapsed: props,\n                groupEnd: props\n            });\n        }\n        disabledDepth++;\n    }\n    function reenableLogs() {\n        disabledDepth--;\n        if (0 === disabledDepth) {\n            var props = {\n                configurable: !0,\n                enumerable: !0,\n                writable: !0\n            };\n            Object.defineProperties(console, {\n                log: assign({}, props, {\n                    value: prevLog\n                }),\n                info: assign({}, props, {\n                    value: prevInfo\n                }),\n                warn: assign({}, props, {\n                    value: prevWarn\n                }),\n                error: assign({}, props, {\n                    value: prevError\n                }),\n                group: assign({}, props, {\n                    value: prevGroup\n                }),\n                groupCollapsed: assign({}, props, {\n                    value: prevGroupCollapsed\n                }),\n                groupEnd: assign({}, props, {\n                    value: prevGroupEnd\n                })\n            });\n        }\n        0 > disabledDepth && console.error(\"disabledDepth fell below zero. This is a bug in React. Please file an issue.\");\n    }\n    function describeBuiltInComponentFrame(name) {\n        if (void 0 === prefix) try {\n            throw Error();\n        } catch (x) {\n            var match = x.stack.trim().match(/\\n( *(at )?)/);\n            prefix = match && match[1] || \"\";\n            suffix = -1 < x.stack.indexOf(\"\\n    at\") ? \" (<anonymous>)\" : -1 < x.stack.indexOf(\"@\") ? \"@unknown:0:0\" : \"\";\n        }\n        return \"\\n\" + prefix + name + suffix;\n    }\n    function describeNativeComponentFrame(fn, construct) {\n        if (!fn || reentry) return \"\";\n        var frame = componentFrameCache.get(fn);\n        if (void 0 !== frame) return frame;\n        reentry = !0;\n        frame = Error.prepareStackTrace;\n        Error.prepareStackTrace = void 0;\n        var previousDispatcher = null;\n        previousDispatcher = ReactSharedInternals.H;\n        ReactSharedInternals.H = null;\n        disableLogs();\n        try {\n            var RunInRootFrame = {\n                DetermineComponentFrameRoot: function() {\n                    try {\n                        if (construct) {\n                            var Fake = function() {\n                                throw Error();\n                            };\n                            Object.defineProperty(Fake.prototype, \"props\", {\n                                set: function() {\n                                    throw Error();\n                                }\n                            });\n                            if (\"object\" === typeof Reflect && Reflect.construct) {\n                                try {\n                                    Reflect.construct(Fake, []);\n                                } catch (x) {\n                                    var control = x;\n                                }\n                                Reflect.construct(fn, [], Fake);\n                            } else {\n                                try {\n                                    Fake.call();\n                                } catch (x$0) {\n                                    control = x$0;\n                                }\n                                fn.call(Fake.prototype);\n                            }\n                        } else {\n                            try {\n                                throw Error();\n                            } catch (x$1) {\n                                control = x$1;\n                            }\n                            (Fake = fn()) && \"function\" === typeof Fake.catch && Fake.catch(function() {});\n                        }\n                    } catch (sample) {\n                        if (sample && control && \"string\" === typeof sample.stack) return [\n                            sample.stack,\n                            control.stack\n                        ];\n                    }\n                    return [\n                        null,\n                        null\n                    ];\n                }\n            };\n            RunInRootFrame.DetermineComponentFrameRoot.displayName = \"DetermineComponentFrameRoot\";\n            var namePropDescriptor = Object.getOwnPropertyDescriptor(RunInRootFrame.DetermineComponentFrameRoot, \"name\");\n            namePropDescriptor && namePropDescriptor.configurable && Object.defineProperty(RunInRootFrame.DetermineComponentFrameRoot, \"name\", {\n                value: \"DetermineComponentFrameRoot\"\n            });\n            var _RunInRootFrame$Deter = RunInRootFrame.DetermineComponentFrameRoot(), sampleStack = _RunInRootFrame$Deter[0], controlStack = _RunInRootFrame$Deter[1];\n            if (sampleStack && controlStack) {\n                var sampleLines = sampleStack.split(\"\\n\"), controlLines = controlStack.split(\"\\n\");\n                for(_RunInRootFrame$Deter = namePropDescriptor = 0; namePropDescriptor < sampleLines.length && !sampleLines[namePropDescriptor].includes(\"DetermineComponentFrameRoot\");)namePropDescriptor++;\n                for(; _RunInRootFrame$Deter < controlLines.length && !controlLines[_RunInRootFrame$Deter].includes(\"DetermineComponentFrameRoot\");)_RunInRootFrame$Deter++;\n                if (namePropDescriptor === sampleLines.length || _RunInRootFrame$Deter === controlLines.length) for(namePropDescriptor = sampleLines.length - 1, _RunInRootFrame$Deter = controlLines.length - 1; 1 <= namePropDescriptor && 0 <= _RunInRootFrame$Deter && sampleLines[namePropDescriptor] !== controlLines[_RunInRootFrame$Deter];)_RunInRootFrame$Deter--;\n                for(; 1 <= namePropDescriptor && 0 <= _RunInRootFrame$Deter; namePropDescriptor--, _RunInRootFrame$Deter--)if (sampleLines[namePropDescriptor] !== controlLines[_RunInRootFrame$Deter]) {\n                    if (1 !== namePropDescriptor || 1 !== _RunInRootFrame$Deter) {\n                        do if (namePropDescriptor--, _RunInRootFrame$Deter--, 0 > _RunInRootFrame$Deter || sampleLines[namePropDescriptor] !== controlLines[_RunInRootFrame$Deter]) {\n                            var _frame = \"\\n\" + sampleLines[namePropDescriptor].replace(\" at new \", \" at \");\n                            fn.displayName && _frame.includes(\"<anonymous>\") && (_frame = _frame.replace(\"<anonymous>\", fn.displayName));\n                            \"function\" === typeof fn && componentFrameCache.set(fn, _frame);\n                            return _frame;\n                        }\n                        while (1 <= namePropDescriptor && 0 <= _RunInRootFrame$Deter);\n                    }\n                    break;\n                }\n            }\n        } finally{\n            reentry = !1, ReactSharedInternals.H = previousDispatcher, reenableLogs(), Error.prepareStackTrace = frame;\n        }\n        sampleLines = (sampleLines = fn ? fn.displayName || fn.name : \"\") ? describeBuiltInComponentFrame(sampleLines) : \"\";\n        \"function\" === typeof fn && componentFrameCache.set(fn, sampleLines);\n        return sampleLines;\n    }\n    function describeFiber(fiber) {\n        switch(fiber.tag){\n            case 26:\n            case 27:\n            case 5:\n                return describeBuiltInComponentFrame(fiber.type);\n            case 16:\n                return describeBuiltInComponentFrame(\"Lazy\");\n            case 13:\n                return describeBuiltInComponentFrame(\"Suspense\");\n            case 19:\n                return describeBuiltInComponentFrame(\"SuspenseList\");\n            case 0:\n            case 15:\n                return fiber = describeNativeComponentFrame(fiber.type, !1), fiber;\n            case 11:\n                return fiber = describeNativeComponentFrame(fiber.type.render, !1), fiber;\n            case 1:\n                return fiber = describeNativeComponentFrame(fiber.type, !0), fiber;\n            default:\n                return \"\";\n        }\n    }\n    function getStackByFiberInDevAndProd(workInProgress) {\n        try {\n            var info = \"\";\n            do {\n                info += describeFiber(workInProgress);\n                var debugInfo = workInProgress._debugInfo;\n                if (debugInfo) for(var i = debugInfo.length - 1; 0 <= i; i--){\n                    var entry = debugInfo[i];\n                    if (\"string\" === typeof entry.name) {\n                        var JSCompiler_temp_const = info, env = entry.env;\n                        var JSCompiler_inline_result = describeBuiltInComponentFrame(entry.name + (env ? \" [\" + env + \"]\" : \"\"));\n                        info = JSCompiler_temp_const + JSCompiler_inline_result;\n                    }\n                }\n                workInProgress = workInProgress.return;\n            }while (workInProgress);\n            return info;\n        } catch (x) {\n            return \"\\nError generating stack: \" + x.message + \"\\n\" + x.stack;\n        }\n    }\n    function getCurrentFiberStackInDev() {\n        return null === current ? \"\" : getStackByFiberInDevAndProd(current);\n    }\n    function runWithFiberInDEV(fiber, callback, arg0, arg1, arg2, arg3, arg4) {\n        var previousFiber = current;\n        ReactSharedInternals.getCurrentStack = null === fiber ? null : getCurrentFiberStackInDev;\n        isRendering = !1;\n        current = fiber;\n        try {\n            return callback(arg0, arg1, arg2, arg3, arg4);\n        } finally{\n            current = previousFiber;\n        }\n        throw Error(\"runWithFiberInDEV should never be called in production. This is a bug in React.\");\n    }\n    function getNearestMountedFiber(fiber) {\n        var node = fiber, nearestMounted = fiber;\n        if (fiber.alternate) for(; node.return;)node = node.return;\n        else {\n            fiber = node;\n            do node = fiber, 0 !== (node.flags & 4098) && (nearestMounted = node.return), fiber = node.return;\n            while (fiber);\n        }\n        return 3 === node.tag ? nearestMounted : null;\n    }\n    function assertIsMounted(fiber) {\n        if (getNearestMountedFiber(fiber) !== fiber) throw Error(\"Unable to find node on an unmounted component.\");\n    }\n    function findCurrentFiberUsingSlowPath(fiber) {\n        var alternate = fiber.alternate;\n        if (!alternate) {\n            alternate = getNearestMountedFiber(fiber);\n            if (null === alternate) throw Error(\"Unable to find node on an unmounted component.\");\n            return alternate !== fiber ? null : fiber;\n        }\n        for(var a = fiber, b = alternate;;){\n            var parentA = a.return;\n            if (null === parentA) break;\n            var parentB = parentA.alternate;\n            if (null === parentB) {\n                b = parentA.return;\n                if (null !== b) {\n                    a = b;\n                    continue;\n                }\n                break;\n            }\n            if (parentA.child === parentB.child) {\n                for(parentB = parentA.child; parentB;){\n                    if (parentB === a) return assertIsMounted(parentA), fiber;\n                    if (parentB === b) return assertIsMounted(parentA), alternate;\n                    parentB = parentB.sibling;\n                }\n                throw Error(\"Unable to find node on an unmounted component.\");\n            }\n            if (a.return !== b.return) a = parentA, b = parentB;\n            else {\n                for(var didFindChild = !1, _child = parentA.child; _child;){\n                    if (_child === a) {\n                        didFindChild = !0;\n                        a = parentA;\n                        b = parentB;\n                        break;\n                    }\n                    if (_child === b) {\n                        didFindChild = !0;\n                        b = parentA;\n                        a = parentB;\n                        break;\n                    }\n                    _child = _child.sibling;\n                }\n                if (!didFindChild) {\n                    for(_child = parentB.child; _child;){\n                        if (_child === a) {\n                            didFindChild = !0;\n                            a = parentB;\n                            b = parentA;\n                            break;\n                        }\n                        if (_child === b) {\n                            didFindChild = !0;\n                            b = parentB;\n                            a = parentA;\n                            break;\n                        }\n                        _child = _child.sibling;\n                    }\n                    if (!didFindChild) throw Error(\"Child was not found in either parent set. This indicates a bug in React related to the return pointer. Please file an issue.\");\n                }\n            }\n            if (a.alternate !== b) throw Error(\"Return fibers should always be each others' alternates. This error is likely caused by a bug in React. Please file an issue.\");\n        }\n        if (3 !== a.tag) throw Error(\"Unable to find node on an unmounted component.\");\n        return a.stateNode.current === a ? fiber : alternate;\n    }\n    function findCurrentHostFiber(parent) {\n        parent = findCurrentFiberUsingSlowPath(parent);\n        return null !== parent ? findCurrentHostFiberImpl(parent) : null;\n    }\n    function findCurrentHostFiberImpl(node) {\n        var tag = node.tag;\n        if (5 === tag || 26 === tag || 27 === tag || 6 === tag) return node;\n        for(node = node.child; null !== node;){\n            tag = findCurrentHostFiberImpl(node);\n            if (null !== tag) return tag;\n            node = node.sibling;\n        }\n        return null;\n    }\n    function findCurrentHostFiberWithNoPortalsImpl(node) {\n        var tag = node.tag;\n        if (5 === tag || 26 === tag || 27 === tag || 6 === tag) return node;\n        for(node = node.child; null !== node;){\n            if (4 !== node.tag && (tag = findCurrentHostFiberWithNoPortalsImpl(node), null !== tag)) return tag;\n            node = node.sibling;\n        }\n        return null;\n    }\n    function createCursor(defaultValue) {\n        return {\n            current: defaultValue\n        };\n    }\n    function pop(cursor, fiber) {\n        0 > index$jscomp$0 ? console.error(\"Unexpected pop.\") : (fiber !== fiberStack[index$jscomp$0] && console.error(\"Unexpected Fiber popped.\"), cursor.current = valueStack[index$jscomp$0], valueStack[index$jscomp$0] = null, fiberStack[index$jscomp$0] = null, index$jscomp$0--);\n    }\n    function push(cursor, value, fiber) {\n        index$jscomp$0++;\n        valueStack[index$jscomp$0] = cursor.current;\n        fiberStack[index$jscomp$0] = fiber;\n        cursor.current = value;\n    }\n    function clz32Fallback(x) {\n        x >>>= 0;\n        return 0 === x ? 32 : 31 - (log$1(x) / LN2 | 0) | 0;\n    }\n    function getLabelForLane(lane) {\n        if (lane & 1) return \"SyncHydrationLane\";\n        if (lane & 2) return \"Sync\";\n        if (lane & 4) return \"InputContinuousHydration\";\n        if (lane & 8) return \"InputContinuous\";\n        if (lane & 16) return \"DefaultHydration\";\n        if (lane & 32) return \"Default\";\n        if (lane & 64) return \"TransitionHydration\";\n        if (lane & 4194176) return \"Transition\";\n        if (lane & 62914560) return \"Retry\";\n        if (lane & 67108864) return \"SelectiveHydration\";\n        if (lane & 134217728) return \"IdleHydration\";\n        if (lane & 268435456) return \"Idle\";\n        if (lane & 536870912) return \"Offscreen\";\n        if (lane & 1073741824) return \"Deferred\";\n    }\n    function getHighestPriorityLanes(lanes) {\n        var pendingSyncLanes = lanes & 42;\n        if (0 !== pendingSyncLanes) return pendingSyncLanes;\n        switch(lanes & -lanes){\n            case 1:\n                return 1;\n            case 2:\n                return 2;\n            case 4:\n                return 4;\n            case 8:\n                return 8;\n            case 16:\n                return 16;\n            case 32:\n                return 32;\n            case 64:\n                return 64;\n            case 128:\n            case 256:\n            case 512:\n            case 1024:\n            case 2048:\n            case 4096:\n            case 8192:\n            case 16384:\n            case 32768:\n            case 65536:\n            case 131072:\n            case 262144:\n            case 524288:\n            case 1048576:\n            case 2097152:\n                return lanes & 4194176;\n            case 4194304:\n            case 8388608:\n            case 16777216:\n            case 33554432:\n                return lanes & 62914560;\n            case 67108864:\n                return 67108864;\n            case 134217728:\n                return 134217728;\n            case 268435456:\n                return 268435456;\n            case 536870912:\n                return 536870912;\n            case 1073741824:\n                return 0;\n            default:\n                return console.error(\"Should have found matching lanes. This is a bug in React.\"), lanes;\n        }\n    }\n    function getNextLanes(root, wipLanes) {\n        var pendingLanes = root.pendingLanes;\n        if (0 === pendingLanes) return 0;\n        var nextLanes = 0, suspendedLanes = root.suspendedLanes, pingedLanes = root.pingedLanes, warmLanes = root.warmLanes;\n        root = 0 !== root.finishedLanes;\n        var nonIdlePendingLanes = pendingLanes & 134217727;\n        0 !== nonIdlePendingLanes ? (pendingLanes = nonIdlePendingLanes & ~suspendedLanes, 0 !== pendingLanes ? nextLanes = getHighestPriorityLanes(pendingLanes) : (pingedLanes &= nonIdlePendingLanes, 0 !== pingedLanes ? nextLanes = getHighestPriorityLanes(pingedLanes) : root || (warmLanes = nonIdlePendingLanes & ~warmLanes, 0 !== warmLanes && (nextLanes = getHighestPriorityLanes(warmLanes))))) : (nonIdlePendingLanes = pendingLanes & ~suspendedLanes, 0 !== nonIdlePendingLanes ? nextLanes = getHighestPriorityLanes(nonIdlePendingLanes) : 0 !== pingedLanes ? nextLanes = getHighestPriorityLanes(pingedLanes) : root || (warmLanes = pendingLanes & ~warmLanes, 0 !== warmLanes && (nextLanes = getHighestPriorityLanes(warmLanes))));\n        return 0 === nextLanes ? 0 : 0 !== wipLanes && wipLanes !== nextLanes && 0 === (wipLanes & suspendedLanes) && (suspendedLanes = nextLanes & -nextLanes, warmLanes = wipLanes & -wipLanes, suspendedLanes >= warmLanes || 32 === suspendedLanes && 0 !== (warmLanes & 4194176)) ? wipLanes : nextLanes;\n    }\n    function checkIfRootIsPrerendering(root, renderLanes) {\n        return 0 === (root.pendingLanes & ~(root.suspendedLanes & ~root.pingedLanes) & renderLanes);\n    }\n    function computeExpirationTime(lane, currentTime) {\n        switch(lane){\n            case 1:\n            case 2:\n            case 4:\n            case 8:\n                return currentTime + 250;\n            case 16:\n            case 32:\n            case 64:\n            case 128:\n            case 256:\n            case 512:\n            case 1024:\n            case 2048:\n            case 4096:\n            case 8192:\n            case 16384:\n            case 32768:\n            case 65536:\n            case 131072:\n            case 262144:\n            case 524288:\n            case 1048576:\n            case 2097152:\n                return currentTime + 5e3;\n            case 4194304:\n            case 8388608:\n            case 16777216:\n            case 33554432:\n                return -1;\n            case 67108864:\n            case 134217728:\n            case 268435456:\n            case 536870912:\n            case 1073741824:\n                return -1;\n            default:\n                return console.error(\"Should have found matching lanes. This is a bug in React.\"), -1;\n        }\n    }\n    function claimNextTransitionLane() {\n        var lane = nextTransitionLane;\n        nextTransitionLane <<= 1;\n        0 === (nextTransitionLane & 4194176) && (nextTransitionLane = 128);\n        return lane;\n    }\n    function claimNextRetryLane() {\n        var lane = nextRetryLane;\n        nextRetryLane <<= 1;\n        0 === (nextRetryLane & 62914560) && (nextRetryLane = 4194304);\n        return lane;\n    }\n    function createLaneMap(initial) {\n        for(var laneMap = [], i = 0; 31 > i; i++)laneMap.push(initial);\n        return laneMap;\n    }\n    function markRootUpdated$1(root, updateLane) {\n        root.pendingLanes |= updateLane;\n        268435456 !== updateLane && (root.suspendedLanes = 0, root.pingedLanes = 0, root.warmLanes = 0);\n    }\n    function markRootFinished(root, finishedLanes, remainingLanes, spawnedLane, updatedLanes, suspendedRetryLanes) {\n        var previouslyPendingLanes = root.pendingLanes;\n        root.pendingLanes = remainingLanes;\n        root.suspendedLanes = 0;\n        root.pingedLanes = 0;\n        root.warmLanes = 0;\n        root.expiredLanes &= remainingLanes;\n        root.entangledLanes &= remainingLanes;\n        root.errorRecoveryDisabledLanes &= remainingLanes;\n        root.shellSuspendCounter = 0;\n        var entanglements = root.entanglements, expirationTimes = root.expirationTimes, hiddenUpdates = root.hiddenUpdates;\n        for(remainingLanes = previouslyPendingLanes & ~remainingLanes; 0 < remainingLanes;){\n            var index = 31 - clz32(remainingLanes), lane = 1 << index;\n            entanglements[index] = 0;\n            expirationTimes[index] = -1;\n            var hiddenUpdatesForLane = hiddenUpdates[index];\n            if (null !== hiddenUpdatesForLane) for(hiddenUpdates[index] = null, index = 0; index < hiddenUpdatesForLane.length; index++){\n                var update = hiddenUpdatesForLane[index];\n                null !== update && (update.lane &= -536870913);\n            }\n            remainingLanes &= ~lane;\n        }\n        0 !== spawnedLane && markSpawnedDeferredLane(root, spawnedLane, 0);\n        0 !== suspendedRetryLanes && 0 === updatedLanes && 0 !== root.tag && (root.suspendedLanes |= suspendedRetryLanes & ~(previouslyPendingLanes & ~finishedLanes));\n    }\n    function markSpawnedDeferredLane(root, spawnedLane, entangledLanes) {\n        root.pendingLanes |= spawnedLane;\n        root.suspendedLanes &= ~spawnedLane;\n        var spawnedLaneIndex = 31 - clz32(spawnedLane);\n        root.entangledLanes |= spawnedLane;\n        root.entanglements[spawnedLaneIndex] = root.entanglements[spawnedLaneIndex] | 1073741824 | entangledLanes & 4194218;\n    }\n    function markRootEntangled(root, entangledLanes) {\n        var rootEntangledLanes = root.entangledLanes |= entangledLanes;\n        for(root = root.entanglements; rootEntangledLanes;){\n            var index = 31 - clz32(rootEntangledLanes), lane = 1 << index;\n            lane & entangledLanes | root[index] & entangledLanes && (root[index] |= entangledLanes);\n            rootEntangledLanes &= ~lane;\n        }\n    }\n    function addFiberToLanesMap(root, fiber, lanes) {\n        if (isDevToolsPresent) for(root = root.pendingUpdatersLaneMap; 0 < lanes;){\n            var index = 31 - clz32(lanes), lane = 1 << index;\n            root[index].add(fiber);\n            lanes &= ~lane;\n        }\n    }\n    function movePendingFibersToMemoized(root, lanes) {\n        if (isDevToolsPresent) for(var pendingUpdatersLaneMap = root.pendingUpdatersLaneMap, memoizedUpdaters = root.memoizedUpdaters; 0 < lanes;){\n            var index = 31 - clz32(lanes);\n            root = 1 << index;\n            index = pendingUpdatersLaneMap[index];\n            0 < index.size && (index.forEach(function(fiber) {\n                var alternate = fiber.alternate;\n                null !== alternate && memoizedUpdaters.has(alternate) || memoizedUpdaters.add(fiber);\n            }), index.clear());\n            lanes &= ~root;\n        }\n    }\n    function lanesToEventPriority(lanes) {\n        lanes &= -lanes;\n        return 2 < lanes ? 8 < lanes ? 0 !== (lanes & 134217727) ? 32 : 268435456 : 8 : 2;\n    }\n    function injectInternals(internals) {\n        if (\"undefined\" === typeof __REACT_DEVTOOLS_GLOBAL_HOOK__) return !1;\n        var hook = __REACT_DEVTOOLS_GLOBAL_HOOK__;\n        if (hook.isDisabled) return !0;\n        if (!hook.supportsFiber) return console.error(\"The installed version of React DevTools is too old and will not work with the current version of React. Please update React DevTools. https://react.dev/link/react-devtools\"), !0;\n        try {\n            rendererID = hook.inject(internals), injectedHook = hook;\n        } catch (err) {\n            console.error(\"React instrumentation encountered an error: %s.\", err);\n        }\n        return hook.checkDCE ? !0 : !1;\n    }\n    function onCommitRoot$1(root, eventPriority) {\n        if (injectedHook && \"function\" === typeof injectedHook.onCommitFiberRoot) try {\n            var didError = 128 === (root.current.flags & 128);\n            switch(eventPriority){\n                case 2:\n                    var schedulerPriority = ImmediatePriority;\n                    break;\n                case 8:\n                    schedulerPriority = UserBlockingPriority;\n                    break;\n                case 32:\n                    schedulerPriority = NormalPriority$1;\n                    break;\n                case 268435456:\n                    schedulerPriority = IdlePriority;\n                    break;\n                default:\n                    schedulerPriority = NormalPriority$1;\n            }\n            injectedHook.onCommitFiberRoot(rendererID, root, schedulerPriority, didError);\n        } catch (err) {\n            hasLoggedError || (hasLoggedError = !0, console.error(\"React instrumentation encountered an error: %s\", err));\n        }\n    }\n    function setIsStrictModeForDevtools(newIsStrictMode) {\n        \"function\" === typeof log && unstable_setDisableYieldValue(newIsStrictMode);\n        if (injectedHook && \"function\" === typeof injectedHook.setStrictMode) try {\n            injectedHook.setStrictMode(rendererID, newIsStrictMode);\n        } catch (err) {\n            hasLoggedError || (hasLoggedError = !0, console.error(\"React instrumentation encountered an error: %s\", err));\n        }\n    }\n    function injectProfilingHooks(profilingHooks) {\n        injectedProfilingHooks = profilingHooks;\n    }\n    function markCommitStopped() {\n        null !== injectedProfilingHooks && \"function\" === typeof injectedProfilingHooks.markCommitStopped && injectedProfilingHooks.markCommitStopped();\n    }\n    function markComponentRenderStarted(fiber) {\n        null !== injectedProfilingHooks && \"function\" === typeof injectedProfilingHooks.markComponentRenderStarted && injectedProfilingHooks.markComponentRenderStarted(fiber);\n    }\n    function markComponentRenderStopped() {\n        null !== injectedProfilingHooks && \"function\" === typeof injectedProfilingHooks.markComponentRenderStopped && injectedProfilingHooks.markComponentRenderStopped();\n    }\n    function markRenderStarted(lanes) {\n        null !== injectedProfilingHooks && \"function\" === typeof injectedProfilingHooks.markRenderStarted && injectedProfilingHooks.markRenderStarted(lanes);\n    }\n    function markRenderStopped() {\n        null !== injectedProfilingHooks && \"function\" === typeof injectedProfilingHooks.markRenderStopped && injectedProfilingHooks.markRenderStopped();\n    }\n    function markStateUpdateScheduled(fiber, lane) {\n        null !== injectedProfilingHooks && \"function\" === typeof injectedProfilingHooks.markStateUpdateScheduled && injectedProfilingHooks.markStateUpdateScheduled(fiber, lane);\n    }\n    function is(x, y) {\n        return x === y && (0 !== x || 1 / x === 1 / y) || x !== x && y !== y;\n    }\n    function createCapturedValueAtFiber(value, source) {\n        if (\"object\" === typeof value && null !== value) {\n            var existing = CapturedStacks.get(value);\n            if (void 0 !== existing) return existing;\n            source = {\n                value: value,\n                source: source,\n                stack: getStackByFiberInDevAndProd(source)\n            };\n            CapturedStacks.set(value, source);\n            return source;\n        }\n        return {\n            value: value,\n            source: source,\n            stack: getStackByFiberInDevAndProd(source)\n        };\n    }\n    function pushTreeFork(workInProgress, totalChildren) {\n        warnIfNotHydrating();\n        forkStack[forkStackIndex++] = treeForkCount;\n        forkStack[forkStackIndex++] = treeForkProvider;\n        treeForkProvider = workInProgress;\n        treeForkCount = totalChildren;\n    }\n    function pushTreeId(workInProgress, totalChildren, index) {\n        warnIfNotHydrating();\n        idStack[idStackIndex++] = treeContextId;\n        idStack[idStackIndex++] = treeContextOverflow;\n        idStack[idStackIndex++] = treeContextProvider;\n        treeContextProvider = workInProgress;\n        var baseIdWithLeadingBit = treeContextId;\n        workInProgress = treeContextOverflow;\n        var baseLength = 32 - clz32(baseIdWithLeadingBit) - 1;\n        baseIdWithLeadingBit &= ~(1 << baseLength);\n        index += 1;\n        var length = 32 - clz32(totalChildren) + baseLength;\n        if (30 < length) {\n            var numberOfOverflowBits = baseLength - baseLength % 5;\n            length = (baseIdWithLeadingBit & (1 << numberOfOverflowBits) - 1).toString(32);\n            baseIdWithLeadingBit >>= numberOfOverflowBits;\n            baseLength -= numberOfOverflowBits;\n            treeContextId = 1 << 32 - clz32(totalChildren) + baseLength | index << baseLength | baseIdWithLeadingBit;\n            treeContextOverflow = length + workInProgress;\n        } else treeContextId = 1 << length | index << baseLength | baseIdWithLeadingBit, treeContextOverflow = workInProgress;\n    }\n    function pushMaterializedTreeId(workInProgress) {\n        warnIfNotHydrating();\n        null !== workInProgress.return && (pushTreeFork(workInProgress, 1), pushTreeId(workInProgress, 1, 0));\n    }\n    function popTreeContext(workInProgress) {\n        for(; workInProgress === treeForkProvider;)treeForkProvider = forkStack[--forkStackIndex], forkStack[forkStackIndex] = null, treeForkCount = forkStack[--forkStackIndex], forkStack[forkStackIndex] = null;\n        for(; workInProgress === treeContextProvider;)treeContextProvider = idStack[--idStackIndex], idStack[idStackIndex] = null, treeContextOverflow = idStack[--idStackIndex], idStack[idStackIndex] = null, treeContextId = idStack[--idStackIndex], idStack[idStackIndex] = null;\n    }\n    function warnIfNotHydrating() {\n        isHydrating || console.error(\"Expected to be hydrating. This is a bug in React. Please file an issue.\");\n    }\n    function requiredContext(c) {\n        null === c && console.error(\"Expected host context to exist. This error is likely caused by a bug in React. Please file an issue.\");\n        return c;\n    }\n    function pushHostContainer(fiber, nextRootInstance) {\n        push(rootInstanceStackCursor, nextRootInstance, fiber);\n        push(contextFiberStackCursor, fiber, fiber);\n        push(contextStackCursor, null, fiber);\n        nextRootInstance = getRootHostContext(nextRootInstance);\n        pop(contextStackCursor, fiber);\n        push(contextStackCursor, nextRootInstance, fiber);\n    }\n    function popHostContainer(fiber) {\n        pop(contextStackCursor, fiber);\n        pop(contextFiberStackCursor, fiber);\n        pop(rootInstanceStackCursor, fiber);\n    }\n    function getHostContext() {\n        return requiredContext(contextStackCursor.current);\n    }\n    function pushHostContext(fiber) {\n        null !== fiber.memoizedState && push(hostTransitionProviderCursor, fiber, fiber);\n        var context = requiredContext(contextStackCursor.current), nextContext = getChildHostContext(context, fiber.type);\n        context !== nextContext && (push(contextFiberStackCursor, fiber, fiber), push(contextStackCursor, nextContext, fiber));\n    }\n    function popHostContext(fiber) {\n        contextFiberStackCursor.current === fiber && (pop(contextStackCursor, fiber), pop(contextFiberStackCursor, fiber));\n        hostTransitionProviderCursor.current === fiber && (pop(hostTransitionProviderCursor, fiber), isPrimaryRenderer ? HostTransitionContext._currentValue = NotPendingTransition : HostTransitionContext._currentValue2 = NotPendingTransition);\n    }\n    function findNotableNode(node, indent) {\n        return void 0 === node.serverProps && 0 === node.serverTail.length && 1 === node.children.length && 3 < node.distanceFromLeaf && node.distanceFromLeaf > 15 - indent ? findNotableNode(node.children[0], indent) : node;\n    }\n    function indentation(indent) {\n        return \"  \" + \"  \".repeat(indent);\n    }\n    function added(indent) {\n        return \"+ \" + \"  \".repeat(indent);\n    }\n    function removed(indent) {\n        return \"- \" + \"  \".repeat(indent);\n    }\n    function describeFiberType(fiber) {\n        switch(fiber.tag){\n            case 26:\n            case 27:\n            case 5:\n                return fiber.type;\n            case 16:\n                return \"Lazy\";\n            case 13:\n                return \"Suspense\";\n            case 19:\n                return \"SuspenseList\";\n            case 0:\n            case 15:\n                return fiber = fiber.type, fiber.displayName || fiber.name || null;\n            case 11:\n                return fiber = fiber.type.render, fiber.displayName || fiber.name || null;\n            case 1:\n                return fiber = fiber.type, fiber.displayName || fiber.name || null;\n            default:\n                return null;\n        }\n    }\n    function describeTextNode(content, maxLength) {\n        return needsEscaping.test(content) ? (content = JSON.stringify(content), content.length > maxLength - 2 ? 8 > maxLength ? '{\"...\"}' : \"{\" + content.slice(0, maxLength - 7) + '...\"}' : \"{\" + content + \"}\") : content.length > maxLength ? 5 > maxLength ? '{\"...\"}' : content.slice(0, maxLength - 3) + \"...\" : content;\n    }\n    function describeTextDiff(clientText, serverProps, indent) {\n        var maxLength = 120 - 2 * indent;\n        if (null === serverProps) return added(indent) + describeTextNode(clientText, maxLength) + \"\\n\";\n        if (\"string\" === typeof serverProps) {\n            for(var firstDiff = 0; firstDiff < serverProps.length && firstDiff < clientText.length && serverProps.charCodeAt(firstDiff) === clientText.charCodeAt(firstDiff); firstDiff++);\n            firstDiff > maxLength - 8 && 10 < firstDiff && (clientText = \"...\" + clientText.slice(firstDiff - 8), serverProps = \"...\" + serverProps.slice(firstDiff - 8));\n            return added(indent) + describeTextNode(clientText, maxLength) + \"\\n\" + removed(indent) + describeTextNode(serverProps, maxLength) + \"\\n\";\n        }\n        return indentation(indent) + describeTextNode(clientText, maxLength) + \"\\n\";\n    }\n    function objectName(object) {\n        return Object.prototype.toString.call(object).replace(/^\\[object (.*)\\]$/, function(m, p0) {\n            return p0;\n        });\n    }\n    function describeValue(value, maxLength) {\n        switch(typeof value){\n            case \"string\":\n                return value = JSON.stringify(value), value.length > maxLength ? 5 > maxLength ? '\"...\"' : value.slice(0, maxLength - 4) + '...\"' : value;\n            case \"object\":\n                if (null === value) return \"null\";\n                if (isArrayImpl(value)) return \"[...]\";\n                if (value.$$typeof === REACT_ELEMENT_TYPE) return (maxLength = getComponentNameFromType(value.type)) ? \"<\" + maxLength + \">\" : \"<...>\";\n                var name = objectName(value);\n                if (\"Object\" === name) {\n                    name = \"\";\n                    maxLength -= 2;\n                    for(var propName in value)if (value.hasOwnProperty(propName)) {\n                        var jsonPropName = JSON.stringify(propName);\n                        jsonPropName !== '\"' + propName + '\"' && (propName = jsonPropName);\n                        maxLength -= propName.length - 2;\n                        jsonPropName = describeValue(value[propName], 15 > maxLength ? maxLength : 15);\n                        maxLength -= jsonPropName.length;\n                        if (0 > maxLength) {\n                            name += \"\" === name ? \"...\" : \", ...\";\n                            break;\n                        }\n                        name += (\"\" === name ? \"\" : \",\") + propName + \":\" + jsonPropName;\n                    }\n                    return \"{\" + name + \"}\";\n                }\n                return name;\n            case \"function\":\n                return (maxLength = value.displayName || value.name) ? \"function \" + maxLength : \"function\";\n            default:\n                return String(value);\n        }\n    }\n    function describePropValue(value, maxLength) {\n        return \"string\" !== typeof value || needsEscaping.test(value) ? \"{\" + describeValue(value, maxLength - 2) + \"}\" : value.length > maxLength - 2 ? 5 > maxLength ? '\"...\"' : '\"' + value.slice(0, maxLength - 5) + '...\"' : '\"' + value + '\"';\n    }\n    function describeExpandedElement(type, props, rowPrefix) {\n        var remainingRowLength = 120 - rowPrefix.length - type.length, properties = [], propName;\n        for(propName in props)if (props.hasOwnProperty(propName) && \"children\" !== propName) {\n            var propValue = describePropValue(props[propName], 120 - rowPrefix.length - propName.length - 1);\n            remainingRowLength -= propName.length + propValue.length + 2;\n            properties.push(propName + \"=\" + propValue);\n        }\n        return 0 === properties.length ? rowPrefix + \"<\" + type + \">\\n\" : 0 < remainingRowLength ? rowPrefix + \"<\" + type + \" \" + properties.join(\" \") + \">\\n\" : rowPrefix + \"<\" + type + \"\\n\" + rowPrefix + \"  \" + properties.join(\"\\n\" + rowPrefix + \"  \") + \"\\n\" + rowPrefix + \">\\n\";\n    }\n    function describePropertiesDiff(clientObject, serverObject, indent) {\n        var properties = \"\", remainingServerProperties = assign({}, serverObject), propName;\n        for(propName in clientObject)if (clientObject.hasOwnProperty(propName)) {\n            delete remainingServerProperties[propName];\n            var maxLength = 120 - 2 * indent - propName.length - 2, clientPropValue = describeValue(clientObject[propName], maxLength);\n            serverObject.hasOwnProperty(propName) ? (maxLength = describeValue(serverObject[propName], maxLength), properties += added(indent) + propName + \": \" + clientPropValue + \"\\n\", properties += removed(indent) + propName + \": \" + maxLength + \"\\n\") : properties += added(indent) + propName + \": \" + clientPropValue + \"\\n\";\n        }\n        for(var _propName in remainingServerProperties)remainingServerProperties.hasOwnProperty(_propName) && (clientObject = describeValue(remainingServerProperties[_propName], 120 - 2 * indent - _propName.length - 2), properties += removed(indent) + _propName + \": \" + clientObject + \"\\n\");\n        return properties;\n    }\n    function describeElementDiff(type, clientProps, serverProps, indent) {\n        var content = \"\", serverPropNames = new Map();\n        for(propName$jscomp$0 in serverProps)serverProps.hasOwnProperty(propName$jscomp$0) && serverPropNames.set(propName$jscomp$0.toLowerCase(), propName$jscomp$0);\n        if (1 === serverPropNames.size && serverPropNames.has(\"children\")) content += describeExpandedElement(type, clientProps, indentation(indent));\n        else {\n            for(var _propName2 in clientProps)if (clientProps.hasOwnProperty(_propName2) && \"children\" !== _propName2) {\n                var maxLength$jscomp$0 = 120 - 2 * (indent + 1) - _propName2.length - 1, serverPropName = serverPropNames.get(_propName2.toLowerCase());\n                if (void 0 !== serverPropName) {\n                    serverPropNames.delete(_propName2.toLowerCase());\n                    var propName$jscomp$0 = clientProps[_propName2];\n                    serverPropName = serverProps[serverPropName];\n                    var clientPropValue = describePropValue(propName$jscomp$0, maxLength$jscomp$0);\n                    maxLength$jscomp$0 = describePropValue(serverPropName, maxLength$jscomp$0);\n                    \"object\" === typeof propName$jscomp$0 && null !== propName$jscomp$0 && \"object\" === typeof serverPropName && null !== serverPropName && \"Object\" === objectName(propName$jscomp$0) && \"Object\" === objectName(serverPropName) && (2 < Object.keys(propName$jscomp$0).length || 2 < Object.keys(serverPropName).length || -1 < clientPropValue.indexOf(\"...\") || -1 < maxLength$jscomp$0.indexOf(\"...\")) ? content += indentation(indent + 1) + _propName2 + \"={{\\n\" + describePropertiesDiff(propName$jscomp$0, serverPropName, indent + 2) + indentation(indent + 1) + \"}}\\n\" : (content += added(indent + 1) + _propName2 + \"=\" + clientPropValue + \"\\n\", content += removed(indent + 1) + _propName2 + \"=\" + maxLength$jscomp$0 + \"\\n\");\n                } else content += indentation(indent + 1) + _propName2 + \"=\" + describePropValue(clientProps[_propName2], maxLength$jscomp$0) + \"\\n\";\n            }\n            serverPropNames.forEach(function(propName) {\n                if (\"children\" !== propName) {\n                    var maxLength = 120 - 2 * (indent + 1) - propName.length - 1;\n                    content += removed(indent + 1) + propName + \"=\" + describePropValue(serverProps[propName], maxLength) + \"\\n\";\n                }\n            });\n            content = \"\" === content ? indentation(indent) + \"<\" + type + \">\\n\" : indentation(indent) + \"<\" + type + \"\\n\" + content + indentation(indent) + \">\\n\";\n        }\n        type = serverProps.children;\n        clientProps = clientProps.children;\n        if (\"string\" === typeof type || \"number\" === typeof type || \"bigint\" === typeof type) {\n            serverPropNames = \"\";\n            if (\"string\" === typeof clientProps || \"number\" === typeof clientProps || \"bigint\" === typeof clientProps) serverPropNames = \"\" + clientProps;\n            content += describeTextDiff(serverPropNames, \"\" + type, indent + 1);\n        } else if (\"string\" === typeof clientProps || \"number\" === typeof clientProps || \"bigint\" === typeof clientProps) content = null == type ? content + describeTextDiff(\"\" + clientProps, null, indent + 1) : content + describeTextDiff(\"\" + clientProps, void 0, indent + 1);\n        return content;\n    }\n    function describeSiblingFiber(fiber, indent) {\n        var type = describeFiberType(fiber);\n        if (null === type) {\n            type = \"\";\n            for(fiber = fiber.child; fiber;)type += describeSiblingFiber(fiber, indent), fiber = fiber.sibling;\n            return type;\n        }\n        return indentation(indent) + \"<\" + type + \">\\n\";\n    }\n    function describeNode(node, indent) {\n        var skipToNode = findNotableNode(node, indent);\n        if (skipToNode !== node && (1 !== node.children.length || node.children[0] !== skipToNode)) return indentation(indent) + \"...\\n\" + describeNode(skipToNode, indent + 1);\n        skipToNode = \"\";\n        var debugInfo = node.fiber._debugInfo;\n        if (debugInfo) for(var i = 0; i < debugInfo.length; i++){\n            var serverComponentName = debugInfo[i].name;\n            \"string\" === typeof serverComponentName && (skipToNode += indentation(indent) + \"<\" + serverComponentName + \">\\n\", indent++);\n        }\n        debugInfo = \"\";\n        i = node.fiber.pendingProps;\n        if (6 === node.fiber.tag) debugInfo = describeTextDiff(i, node.serverProps, indent), indent++;\n        else if (serverComponentName = describeFiberType(node.fiber), null !== serverComponentName) if (void 0 === node.serverProps) {\n            debugInfo = indent;\n            var maxLength = 120 - 2 * debugInfo - serverComponentName.length - 2, content = \"\";\n            for(propName in i)if (i.hasOwnProperty(propName) && \"children\" !== propName) {\n                var propValue = describePropValue(i[propName], 15);\n                maxLength -= propName.length + propValue.length + 2;\n                if (0 > maxLength) {\n                    content += \" ...\";\n                    break;\n                }\n                content += \" \" + propName + \"=\" + propValue;\n            }\n            debugInfo = indentation(debugInfo) + \"<\" + serverComponentName + content + \">\\n\";\n            indent++;\n        } else null === node.serverProps ? (debugInfo = describeExpandedElement(serverComponentName, i, added(indent)), indent++) : \"string\" === typeof node.serverProps ? console.error(\"Should not have matched a non HostText fiber to a Text node. This is a bug in React.\") : (debugInfo = describeElementDiff(serverComponentName, i, node.serverProps, indent), indent++);\n        var propName = \"\";\n        i = node.fiber.child;\n        for(serverComponentName = 0; i && serverComponentName < node.children.length;)maxLength = node.children[serverComponentName], maxLength.fiber === i ? (propName += describeNode(maxLength, indent), serverComponentName++) : propName += describeSiblingFiber(i, indent), i = i.sibling;\n        i && 0 < node.children.length && (propName += indentation(indent) + \"...\\n\");\n        i = node.serverTail;\n        null === node.serverProps && indent--;\n        for(node = 0; node < i.length; node++)serverComponentName = i[node], propName = \"string\" === typeof serverComponentName ? propName + (removed(indent) + describeTextNode(serverComponentName, 120 - 2 * indent) + \"\\n\") : propName + describeExpandedElement(serverComponentName.type, serverComponentName.props, removed(indent));\n        return skipToNode + debugInfo + propName;\n    }\n    function describeDiff(rootNode) {\n        try {\n            return \"\\n\\n\" + describeNode(rootNode, 0);\n        } catch (x) {\n            return \"\";\n        }\n    }\n    function buildHydrationDiffNode(fiber, distanceFromLeaf) {\n        if (null === fiber.return) {\n            if (null === hydrationDiffRootDEV) hydrationDiffRootDEV = {\n                fiber: fiber,\n                children: [],\n                serverProps: void 0,\n                serverTail: [],\n                distanceFromLeaf: distanceFromLeaf\n            };\n            else {\n                if (hydrationDiffRootDEV.fiber !== fiber) throw Error(\"Saw multiple hydration diff roots in a pass. This is a bug in React.\");\n                hydrationDiffRootDEV.distanceFromLeaf > distanceFromLeaf && (hydrationDiffRootDEV.distanceFromLeaf = distanceFromLeaf);\n            }\n            return hydrationDiffRootDEV;\n        }\n        var siblings = buildHydrationDiffNode(fiber.return, distanceFromLeaf + 1).children;\n        if (0 < siblings.length && siblings[siblings.length - 1].fiber === fiber) return siblings = siblings[siblings.length - 1], siblings.distanceFromLeaf > distanceFromLeaf && (siblings.distanceFromLeaf = distanceFromLeaf), siblings;\n        distanceFromLeaf = {\n            fiber: fiber,\n            children: [],\n            serverProps: void 0,\n            serverTail: [],\n            distanceFromLeaf: distanceFromLeaf\n        };\n        siblings.push(distanceFromLeaf);\n        return distanceFromLeaf;\n    }\n    function warnNonHydratedInstance(fiber, rejectedCandidate) {\n        didSuspendOrErrorDEV || (fiber = buildHydrationDiffNode(fiber, 0), fiber.serverProps = null, null !== rejectedCandidate && (rejectedCandidate = describeHydratableInstanceForDevWarnings(rejectedCandidate), fiber.serverTail.push(rejectedCandidate)));\n    }\n    function throwOnHydrationMismatch(fiber) {\n        var diff = \"\", diffRoot = hydrationDiffRootDEV;\n        null !== diffRoot && (hydrationDiffRootDEV = null, diff = describeDiff(diffRoot));\n        queueHydrationError(createCapturedValueAtFiber(Error(\"Hydration failed because the server rendered HTML didn't match the client. As a result this tree will be regenerated on the client. This can happen if a SSR-ed Client Component used:\\n\\n- A server/client branch `if (typeof window !== 'undefined')`.\\n- Variable input such as `Date.now()` or `Math.random()` which changes each time it's called.\\n- Date formatting in a user's locale which doesn't match the server.\\n- External changing data without sending a snapshot of it along with the HTML.\\n- Invalid HTML tag nesting.\\n\\nIt can also happen if the client has a browser extension installed which messes with the HTML before React loaded.\\n\\nhttps://react.dev/link/hydration-mismatch\" + diff), fiber));\n        throw HydrationMismatchException;\n    }\n    function prepareToHydrateHostInstance(fiber, hostContext) {\n        if (!supportsHydration) throw Error(\"Expected prepareToHydrateHostInstance() to never be called. This error is likely caused by a bug in React. Please file an issue.\");\n        hydrateInstance(fiber.stateNode, fiber.type, fiber.memoizedProps, hostContext, fiber) || throwOnHydrationMismatch(fiber);\n    }\n    function popToNextHostParent(fiber) {\n        for(hydrationParentFiber = fiber.return; hydrationParentFiber;)switch(hydrationParentFiber.tag){\n            case 3:\n            case 27:\n                rootOrSingletonContext = !0;\n                return;\n            case 5:\n            case 13:\n                rootOrSingletonContext = !1;\n                return;\n            default:\n                hydrationParentFiber = hydrationParentFiber.return;\n        }\n    }\n    function popHydrationState(fiber) {\n        if (!supportsHydration || fiber !== hydrationParentFiber) return !1;\n        if (!isHydrating) return popToNextHostParent(fiber), isHydrating = !0, !1;\n        var shouldClear = !1;\n        supportsSingletons ? 3 !== fiber.tag && 27 !== fiber.tag && (5 !== fiber.tag || shouldDeleteUnhydratedTailInstances(fiber.type) && !shouldSetTextContent(fiber.type, fiber.memoizedProps)) && (shouldClear = !0) : 3 !== fiber.tag && (5 !== fiber.tag || shouldDeleteUnhydratedTailInstances(fiber.type) && !shouldSetTextContent(fiber.type, fiber.memoizedProps)) && (shouldClear = !0);\n        if (shouldClear && nextHydratableInstance) {\n            for(shouldClear = nextHydratableInstance; shouldClear;){\n                var diffNode = buildHydrationDiffNode(fiber, 0), description = describeHydratableInstanceForDevWarnings(shouldClear);\n                diffNode.serverTail.push(description);\n                shouldClear = \"Suspense\" === description.type ? getNextHydratableInstanceAfterSuspenseInstance(shouldClear) : getNextHydratableSibling(shouldClear);\n            }\n            throwOnHydrationMismatch(fiber);\n        }\n        popToNextHostParent(fiber);\n        if (13 === fiber.tag) {\n            if (!supportsHydration) throw Error(\"Expected skipPastDehydratedSuspenseInstance() to never be called. This error is likely caused by a bug in React. Please file an issue.\");\n            fiber = fiber.memoizedState;\n            fiber = null !== fiber ? fiber.dehydrated : null;\n            if (!fiber) throw Error(\"Expected to have a hydrated suspense instance. This error is likely caused by a bug in React. Please file an issue.\");\n            nextHydratableInstance = getNextHydratableInstanceAfterSuspenseInstance(fiber);\n        } else nextHydratableInstance = hydrationParentFiber ? getNextHydratableSibling(fiber.stateNode) : null;\n        return !0;\n    }\n    function resetHydrationState() {\n        supportsHydration && (nextHydratableInstance = hydrationParentFiber = null, didSuspendOrErrorDEV = isHydrating = !1);\n    }\n    function queueHydrationError(error) {\n        null === hydrationErrors ? hydrationErrors = [\n            error\n        ] : hydrationErrors.push(error);\n    }\n    function emitPendingHydrationWarnings() {\n        var diffRoot = hydrationDiffRootDEV;\n        null !== diffRoot && (hydrationDiffRootDEV = null, diffRoot = describeDiff(diffRoot), console.error(\"A tree hydrated but some attributes of the server rendered HTML didn't match the client properties. This won't be patched up. This can happen if a SSR-ed Client Component used:\\n\\n- A server/client branch `if (typeof window !== 'undefined')`.\\n- Variable input such as `Date.now()` or `Math.random()` which changes each time it's called.\\n- Date formatting in a user's locale which doesn't match the server.\\n- External changing data without sending a snapshot of it along with the HTML.\\n- Invalid HTML tag nesting.\\n\\nIt can also happen if the client has a browser extension installed which messes with the HTML before React loaded.\\n\\n%s%s\", \"https://react.dev/link/hydration-mismatch\", diffRoot));\n    }\n    function finishQueueingConcurrentUpdates() {\n        for(var endIndex = concurrentQueuesIndex, i = concurrentlyUpdatedLanes = concurrentQueuesIndex = 0; i < endIndex;){\n            var fiber = concurrentQueues[i];\n            concurrentQueues[i++] = null;\n            var queue = concurrentQueues[i];\n            concurrentQueues[i++] = null;\n            var update = concurrentQueues[i];\n            concurrentQueues[i++] = null;\n            var lane = concurrentQueues[i];\n            concurrentQueues[i++] = null;\n            if (null !== queue && null !== update) {\n                var pending = queue.pending;\n                null === pending ? update.next = update : (update.next = pending.next, pending.next = update);\n                queue.pending = update;\n            }\n            0 !== lane && markUpdateLaneFromFiberToRoot(fiber, update, lane);\n        }\n    }\n    function enqueueUpdate$1(fiber, queue, update, lane) {\n        concurrentQueues[concurrentQueuesIndex++] = fiber;\n        concurrentQueues[concurrentQueuesIndex++] = queue;\n        concurrentQueues[concurrentQueuesIndex++] = update;\n        concurrentQueues[concurrentQueuesIndex++] = lane;\n        concurrentlyUpdatedLanes |= lane;\n        fiber.lanes |= lane;\n        fiber = fiber.alternate;\n        null !== fiber && (fiber.lanes |= lane);\n    }\n    function enqueueConcurrentHookUpdate(fiber, queue, update, lane) {\n        enqueueUpdate$1(fiber, queue, update, lane);\n        return getRootForUpdatedFiber(fiber);\n    }\n    function enqueueConcurrentRenderForLane(fiber, lane) {\n        enqueueUpdate$1(fiber, null, null, lane);\n        return getRootForUpdatedFiber(fiber);\n    }\n    function markUpdateLaneFromFiberToRoot(sourceFiber, update, lane) {\n        sourceFiber.lanes |= lane;\n        var alternate = sourceFiber.alternate;\n        null !== alternate && (alternate.lanes |= lane);\n        for(var isHidden = !1, parent = sourceFiber.return; null !== parent;)parent.childLanes |= lane, alternate = parent.alternate, null !== alternate && (alternate.childLanes |= lane), 22 === parent.tag && (sourceFiber = parent.stateNode, null === sourceFiber || sourceFiber._visibility & 1 || (isHidden = !0)), sourceFiber = parent, parent = parent.return;\n        isHidden && null !== update && 3 === sourceFiber.tag && (parent = sourceFiber.stateNode, isHidden = 31 - clz32(lane), parent = parent.hiddenUpdates, sourceFiber = parent[isHidden], null === sourceFiber ? parent[isHidden] = [\n            update\n        ] : sourceFiber.push(update), update.lane = lane | 536870912);\n    }\n    function getRootForUpdatedFiber(sourceFiber) {\n        if (nestedUpdateCount > NESTED_UPDATE_LIMIT) throw nestedPassiveUpdateCount = nestedUpdateCount = 0, rootWithPassiveNestedUpdates = rootWithNestedUpdates = null, Error(\"Maximum update depth exceeded. This can happen when a component repeatedly calls setState inside componentWillUpdate or componentDidUpdate. React limits the number of nested updates to prevent infinite loops.\");\n        nestedPassiveUpdateCount > NESTED_PASSIVE_UPDATE_LIMIT && (nestedPassiveUpdateCount = 0, rootWithPassiveNestedUpdates = null, console.error(\"Maximum update depth exceeded. This can happen when a component calls setState inside useEffect, but useEffect either doesn't have a dependency array, or one of the dependencies changes on every render.\"));\n        null === sourceFiber.alternate && 0 !== (sourceFiber.flags & 4098) && warnAboutUpdateOnNotYetMountedFiberInDEV(sourceFiber);\n        for(var node = sourceFiber, parent = node.return; null !== parent;)null === node.alternate && 0 !== (node.flags & 4098) && warnAboutUpdateOnNotYetMountedFiberInDEV(sourceFiber), node = parent, parent = node.return;\n        return 3 === node.tag ? node.stateNode : null;\n    }\n    function pushNestedEffectDurations() {\n        var prevEffectDuration = profilerEffectDuration;\n        profilerEffectDuration = 0;\n        return prevEffectDuration;\n    }\n    function popNestedEffectDurations(prevEffectDuration) {\n        var elapsedTime = profilerEffectDuration;\n        profilerEffectDuration = prevEffectDuration;\n        return elapsedTime;\n    }\n    function bubbleNestedEffectDurations(prevEffectDuration) {\n        var elapsedTime = profilerEffectDuration;\n        profilerEffectDuration += prevEffectDuration;\n        return elapsedTime;\n    }\n    function startProfilerTimer(fiber) {\n        profilerStartTime = now();\n        0 > fiber.actualStartTime && (fiber.actualStartTime = profilerStartTime);\n    }\n    function stopProfilerTimerIfRunningAndRecordDuration(fiber) {\n        if (0 <= profilerStartTime) {\n            var elapsedTime = now() - profilerStartTime;\n            fiber.actualDuration += elapsedTime;\n            fiber.selfBaseDuration = elapsedTime;\n            profilerStartTime = -1;\n        }\n    }\n    function stopProfilerTimerIfRunningAndRecordIncompleteDuration(fiber) {\n        if (0 <= profilerStartTime) {\n            var elapsedTime = now() - profilerStartTime;\n            fiber.actualDuration += elapsedTime;\n            profilerStartTime = -1;\n        }\n    }\n    function recordEffectDuration() {\n        if (0 <= profilerStartTime) {\n            var elapsedTime = now() - profilerStartTime;\n            profilerStartTime = -1;\n            profilerEffectDuration += elapsedTime;\n        }\n    }\n    function startEffectTimer() {\n        profilerStartTime = now();\n    }\n    function transferActualDuration(fiber) {\n        for(var child = fiber.child; child;)fiber.actualDuration += child.actualDuration, child = child.sibling;\n    }\n    function ensureRootIsScheduled(root) {\n        root !== lastScheduledRoot && null === root.next && (null === lastScheduledRoot ? firstScheduledRoot = lastScheduledRoot = root : lastScheduledRoot = lastScheduledRoot.next = root);\n        mightHavePendingSyncWork = !0;\n        null !== ReactSharedInternals.actQueue ? didScheduleMicrotask_act || (didScheduleMicrotask_act = !0, scheduleImmediateTask(processRootScheduleInMicrotask)) : didScheduleMicrotask || (didScheduleMicrotask = !0, scheduleImmediateTask(processRootScheduleInMicrotask));\n    }\n    function flushSyncWorkAcrossRoots_impl(syncTransitionLanes, onlyLegacy) {\n        if (!isFlushingWork && mightHavePendingSyncWork) {\n            isFlushingWork = !0;\n            do {\n                var didPerformSomeWork = !1;\n                for(var root = firstScheduledRoot; null !== root;){\n                    if (!onlyLegacy) if (0 !== syncTransitionLanes) {\n                        var pendingLanes = root.pendingLanes;\n                        if (0 === pendingLanes) var nextLanes = 0;\n                        else {\n                            var suspendedLanes = root.suspendedLanes, pingedLanes = root.pingedLanes;\n                            nextLanes = (1 << 31 - clz32(42 | syncTransitionLanes) + 1) - 1;\n                            nextLanes &= pendingLanes & ~(suspendedLanes & ~pingedLanes);\n                            nextLanes = nextLanes & 201326677 ? nextLanes & 201326677 | 1 : nextLanes ? nextLanes | 2 : 0;\n                        }\n                        0 !== nextLanes && (didPerformSomeWork = !0, performSyncWorkOnRoot(root, nextLanes));\n                    } else nextLanes = workInProgressRootRenderLanes, nextLanes = getNextLanes(root, root === workInProgressRoot ? nextLanes : 0), 0 === (nextLanes & 3) || checkIfRootIsPrerendering(root, nextLanes) || (didPerformSomeWork = !0, performSyncWorkOnRoot(root, nextLanes));\n                    root = root.next;\n                }\n            }while (didPerformSomeWork);\n            isFlushingWork = !1;\n        }\n    }\n    function processRootScheduleInMicrotask() {\n        mightHavePendingSyncWork = didScheduleMicrotask_act = didScheduleMicrotask = !1;\n        var syncTransitionLanes = 0;\n        0 !== currentEventTransitionLane && (shouldAttemptEagerTransition() && (syncTransitionLanes = currentEventTransitionLane), currentEventTransitionLane = 0);\n        for(var currentTime = now$1(), prev = null, root = firstScheduledRoot; null !== root;){\n            var next = root.next, nextLanes = scheduleTaskForRootDuringMicrotask(root, currentTime);\n            if (0 === nextLanes) root.next = null, null === prev ? firstScheduledRoot = next : prev.next = next, null === next && (lastScheduledRoot = prev);\n            else if (prev = root, 0 !== syncTransitionLanes || 0 !== (nextLanes & 3)) mightHavePendingSyncWork = !0;\n            root = next;\n        }\n        flushSyncWorkAcrossRoots_impl(syncTransitionLanes, !1);\n    }\n    function scheduleTaskForRootDuringMicrotask(root, currentTime) {\n        for(var suspendedLanes = root.suspendedLanes, pingedLanes = root.pingedLanes, expirationTimes = root.expirationTimes, lanes = root.pendingLanes & -62914561; 0 < lanes;){\n            var index = 31 - clz32(lanes), lane = 1 << index, expirationTime = expirationTimes[index];\n            if (-1 === expirationTime) {\n                if (0 === (lane & suspendedLanes) || 0 !== (lane & pingedLanes)) expirationTimes[index] = computeExpirationTime(lane, currentTime);\n            } else expirationTime <= currentTime && (root.expiredLanes |= lane);\n            lanes &= ~lane;\n        }\n        currentTime = workInProgressRoot;\n        suspendedLanes = workInProgressRootRenderLanes;\n        suspendedLanes = getNextLanes(root, root === currentTime ? suspendedLanes : 0);\n        pingedLanes = root.callbackNode;\n        if (0 === suspendedLanes || root === currentTime && workInProgressSuspendedReason === SuspendedOnData || null !== root.cancelPendingCommit) return null !== pingedLanes && cancelCallback(pingedLanes), root.callbackNode = null, root.callbackPriority = 0;\n        if (0 === (suspendedLanes & 3) || checkIfRootIsPrerendering(root, suspendedLanes)) {\n            currentTime = suspendedLanes & -suspendedLanes;\n            if (currentTime !== root.callbackPriority || null !== ReactSharedInternals.actQueue && pingedLanes !== fakeActCallbackNode$1) cancelCallback(pingedLanes);\n            else return currentTime;\n            switch(lanesToEventPriority(suspendedLanes)){\n                case 2:\n                case 8:\n                    suspendedLanes = UserBlockingPriority;\n                    break;\n                case 32:\n                    suspendedLanes = NormalPriority$1;\n                    break;\n                case 268435456:\n                    suspendedLanes = IdlePriority;\n                    break;\n                default:\n                    suspendedLanes = NormalPriority$1;\n            }\n            pingedLanes = performWorkOnRootViaSchedulerTask.bind(null, root);\n            null !== ReactSharedInternals.actQueue ? (ReactSharedInternals.actQueue.push(pingedLanes), suspendedLanes = fakeActCallbackNode$1) : suspendedLanes = scheduleCallback$3(suspendedLanes, pingedLanes);\n            root.callbackPriority = currentTime;\n            root.callbackNode = suspendedLanes;\n            return currentTime;\n        }\n        null !== pingedLanes && cancelCallback(pingedLanes);\n        root.callbackPriority = 2;\n        root.callbackNode = null;\n        return 2;\n    }\n    function performWorkOnRootViaSchedulerTask(root, didTimeout) {\n        nestedUpdateScheduled = currentUpdateIsNested = !1;\n        var originalCallbackNode = root.callbackNode;\n        if (flushPassiveEffects() && root.callbackNode !== originalCallbackNode) return null;\n        var workInProgressRootRenderLanes$jscomp$0 = workInProgressRootRenderLanes;\n        workInProgressRootRenderLanes$jscomp$0 = getNextLanes(root, root === workInProgressRoot ? workInProgressRootRenderLanes$jscomp$0 : 0);\n        if (0 === workInProgressRootRenderLanes$jscomp$0) return null;\n        performWorkOnRoot(root, workInProgressRootRenderLanes$jscomp$0, didTimeout);\n        scheduleTaskForRootDuringMicrotask(root, now$1());\n        return null != root.callbackNode && root.callbackNode === originalCallbackNode ? performWorkOnRootViaSchedulerTask.bind(null, root) : null;\n    }\n    function performSyncWorkOnRoot(root, lanes) {\n        if (flushPassiveEffects()) return null;\n        currentUpdateIsNested = nestedUpdateScheduled;\n        nestedUpdateScheduled = !1;\n        performWorkOnRoot(root, lanes, !0);\n    }\n    function cancelCallback(callbackNode) {\n        callbackNode !== fakeActCallbackNode$1 && null !== callbackNode && cancelCallback$1(callbackNode);\n    }\n    function scheduleImmediateTask(cb) {\n        null !== ReactSharedInternals.actQueue && ReactSharedInternals.actQueue.push(function() {\n            cb();\n            return null;\n        });\n        supportsMicrotasks ? scheduleMicrotask(function() {\n            (executionContext & (RenderContext | CommitContext)) !== NoContext ? scheduleCallback$3(ImmediatePriority, cb) : cb();\n        }) : scheduleCallback$3(ImmediatePriority, cb);\n    }\n    function requestTransitionLane() {\n        0 === currentEventTransitionLane && (currentEventTransitionLane = claimNextTransitionLane());\n        return currentEventTransitionLane;\n    }\n    function entangleAsyncAction(transition, thenable) {\n        if (null === currentEntangledListeners) {\n            var entangledListeners = currentEntangledListeners = [];\n            currentEntangledPendingCount = 0;\n            currentEntangledLane = requestTransitionLane();\n            currentEntangledActionThenable = {\n                status: \"pending\",\n                value: void 0,\n                then: function(resolve) {\n                    entangledListeners.push(resolve);\n                }\n            };\n        }\n        currentEntangledPendingCount++;\n        thenable.then(pingEngtangledActionScope, pingEngtangledActionScope);\n        return thenable;\n    }\n    function pingEngtangledActionScope() {\n        if (0 === --currentEntangledPendingCount && null !== currentEntangledListeners) {\n            null !== currentEntangledActionThenable && (currentEntangledActionThenable.status = \"fulfilled\");\n            var listeners = currentEntangledListeners;\n            currentEntangledListeners = null;\n            currentEntangledLane = 0;\n            currentEntangledActionThenable = null;\n            for(var i = 0; i < listeners.length; i++)(0, listeners[i])();\n        }\n    }\n    function chainThenableValue(thenable, result) {\n        var listeners = [], thenableWithOverride = {\n            status: \"pending\",\n            value: null,\n            reason: null,\n            then: function(resolve) {\n                listeners.push(resolve);\n            }\n        };\n        thenable.then(function() {\n            thenableWithOverride.status = \"fulfilled\";\n            thenableWithOverride.value = result;\n            for(var i = 0; i < listeners.length; i++)(0, listeners[i])(result);\n        }, function(error) {\n            thenableWithOverride.status = \"rejected\";\n            thenableWithOverride.reason = error;\n            for(error = 0; error < listeners.length; error++)(0, listeners[error])(void 0);\n        });\n        return thenableWithOverride;\n    }\n    function initializeUpdateQueue(fiber) {\n        fiber.updateQueue = {\n            baseState: fiber.memoizedState,\n            firstBaseUpdate: null,\n            lastBaseUpdate: null,\n            shared: {\n                pending: null,\n                lanes: 0,\n                hiddenCallbacks: null\n            },\n            callbacks: null\n        };\n    }\n    function cloneUpdateQueue(current, workInProgress) {\n        current = current.updateQueue;\n        workInProgress.updateQueue === current && (workInProgress.updateQueue = {\n            baseState: current.baseState,\n            firstBaseUpdate: current.firstBaseUpdate,\n            lastBaseUpdate: current.lastBaseUpdate,\n            shared: current.shared,\n            callbacks: null\n        });\n    }\n    function createUpdate(lane) {\n        return {\n            lane: lane,\n            tag: UpdateState,\n            payload: null,\n            callback: null,\n            next: null\n        };\n    }\n    function enqueueUpdate(fiber, update, lane) {\n        var updateQueue = fiber.updateQueue;\n        if (null === updateQueue) return null;\n        updateQueue = updateQueue.shared;\n        if (currentlyProcessingQueue === updateQueue && !didWarnUpdateInsideUpdate) {\n            var componentName = getComponentNameFromFiber(fiber);\n            console.error(\"An update (setState, replaceState, or forceUpdate) was scheduled from inside an update function. Update functions should be pure, with zero side-effects. Consider using componentDidUpdate or a callback.\\n\\nPlease update the following component: %s\", componentName);\n            didWarnUpdateInsideUpdate = !0;\n        }\n        if ((executionContext & RenderContext) !== NoContext) return componentName = updateQueue.pending, null === componentName ? update.next = update : (update.next = componentName.next, componentName.next = update), updateQueue.pending = update, update = getRootForUpdatedFiber(fiber), markUpdateLaneFromFiberToRoot(fiber, null, lane), update;\n        enqueueUpdate$1(fiber, updateQueue, update, lane);\n        return getRootForUpdatedFiber(fiber);\n    }\n    function entangleTransitions(root, fiber, lane) {\n        fiber = fiber.updateQueue;\n        if (null !== fiber && (fiber = fiber.shared, 0 !== (lane & 4194176))) {\n            var queueLanes = fiber.lanes;\n            queueLanes &= root.pendingLanes;\n            lane |= queueLanes;\n            fiber.lanes = lane;\n            markRootEntangled(root, lane);\n        }\n    }\n    function enqueueCapturedUpdate(workInProgress, capturedUpdate) {\n        var queue = workInProgress.updateQueue, current = workInProgress.alternate;\n        if (null !== current && (current = current.updateQueue, queue === current)) {\n            var newFirst = null, newLast = null;\n            queue = queue.firstBaseUpdate;\n            if (null !== queue) {\n                do {\n                    var clone = {\n                        lane: queue.lane,\n                        tag: queue.tag,\n                        payload: queue.payload,\n                        callback: null,\n                        next: null\n                    };\n                    null === newLast ? newFirst = newLast = clone : newLast = newLast.next = clone;\n                    queue = queue.next;\n                }while (null !== queue);\n                null === newLast ? newFirst = newLast = capturedUpdate : newLast = newLast.next = capturedUpdate;\n            } else newFirst = newLast = capturedUpdate;\n            queue = {\n                baseState: current.baseState,\n                firstBaseUpdate: newFirst,\n                lastBaseUpdate: newLast,\n                shared: current.shared,\n                callbacks: current.callbacks\n            };\n            workInProgress.updateQueue = queue;\n            return;\n        }\n        workInProgress = queue.lastBaseUpdate;\n        null === workInProgress ? queue.firstBaseUpdate = capturedUpdate : workInProgress.next = capturedUpdate;\n        queue.lastBaseUpdate = capturedUpdate;\n    }\n    function suspendIfUpdateReadFromEntangledAsyncAction() {\n        if (didReadFromEntangledAsyncAction) {\n            var entangledActionThenable = currentEntangledActionThenable;\n            if (null !== entangledActionThenable) throw entangledActionThenable;\n        }\n    }\n    function processUpdateQueue(workInProgress, props, instance$jscomp$0, renderLanes) {\n        didReadFromEntangledAsyncAction = !1;\n        var queue = workInProgress.updateQueue;\n        hasForceUpdate = !1;\n        currentlyProcessingQueue = queue.shared;\n        var firstBaseUpdate = queue.firstBaseUpdate, lastBaseUpdate = queue.lastBaseUpdate, pendingQueue = queue.shared.pending;\n        if (null !== pendingQueue) {\n            queue.shared.pending = null;\n            var lastPendingUpdate = pendingQueue, firstPendingUpdate = lastPendingUpdate.next;\n            lastPendingUpdate.next = null;\n            null === lastBaseUpdate ? firstBaseUpdate = firstPendingUpdate : lastBaseUpdate.next = firstPendingUpdate;\n            lastBaseUpdate = lastPendingUpdate;\n            var current = workInProgress.alternate;\n            null !== current && (current = current.updateQueue, pendingQueue = current.lastBaseUpdate, pendingQueue !== lastBaseUpdate && (null === pendingQueue ? current.firstBaseUpdate = firstPendingUpdate : pendingQueue.next = firstPendingUpdate, current.lastBaseUpdate = lastPendingUpdate));\n        }\n        if (null !== firstBaseUpdate) {\n            var newState = queue.baseState;\n            lastBaseUpdate = 0;\n            current = firstPendingUpdate = lastPendingUpdate = null;\n            pendingQueue = firstBaseUpdate;\n            do {\n                var updateLane = pendingQueue.lane & -536870913, isHiddenUpdate = updateLane !== pendingQueue.lane;\n                if (isHiddenUpdate ? (workInProgressRootRenderLanes & updateLane) === updateLane : (renderLanes & updateLane) === updateLane) {\n                    0 !== updateLane && updateLane === currentEntangledLane && (didReadFromEntangledAsyncAction = !0);\n                    null !== current && (current = current.next = {\n                        lane: 0,\n                        tag: pendingQueue.tag,\n                        payload: pendingQueue.payload,\n                        callback: null,\n                        next: null\n                    });\n                    a: {\n                        updateLane = workInProgress;\n                        var partialState = pendingQueue;\n                        var nextProps = props, instance = instance$jscomp$0;\n                        switch(partialState.tag){\n                            case ReplaceState:\n                                partialState = partialState.payload;\n                                if (\"function\" === typeof partialState) {\n                                    isDisallowedContextReadInDEV = !0;\n                                    var nextState = partialState.call(instance, newState, nextProps);\n                                    if (updateLane.mode & 8) {\n                                        setIsStrictModeForDevtools(!0);\n                                        try {\n                                            partialState.call(instance, newState, nextProps);\n                                        } finally{\n                                            setIsStrictModeForDevtools(!1);\n                                        }\n                                    }\n                                    isDisallowedContextReadInDEV = !1;\n                                    newState = nextState;\n                                    break a;\n                                }\n                                newState = partialState;\n                                break a;\n                            case CaptureUpdate:\n                                updateLane.flags = updateLane.flags & -65537 | 128;\n                            case UpdateState:\n                                nextState = partialState.payload;\n                                if (\"function\" === typeof nextState) {\n                                    isDisallowedContextReadInDEV = !0;\n                                    partialState = nextState.call(instance, newState, nextProps);\n                                    if (updateLane.mode & 8) {\n                                        setIsStrictModeForDevtools(!0);\n                                        try {\n                                            nextState.call(instance, newState, nextProps);\n                                        } finally{\n                                            setIsStrictModeForDevtools(!1);\n                                        }\n                                    }\n                                    isDisallowedContextReadInDEV = !1;\n                                } else partialState = nextState;\n                                if (null === partialState || void 0 === partialState) break a;\n                                newState = assign({}, newState, partialState);\n                                break a;\n                            case ForceUpdate:\n                                hasForceUpdate = !0;\n                        }\n                    }\n                    updateLane = pendingQueue.callback;\n                    null !== updateLane && (workInProgress.flags |= 64, isHiddenUpdate && (workInProgress.flags |= 8192), isHiddenUpdate = queue.callbacks, null === isHiddenUpdate ? queue.callbacks = [\n                        updateLane\n                    ] : isHiddenUpdate.push(updateLane));\n                } else isHiddenUpdate = {\n                    lane: updateLane,\n                    tag: pendingQueue.tag,\n                    payload: pendingQueue.payload,\n                    callback: pendingQueue.callback,\n                    next: null\n                }, null === current ? (firstPendingUpdate = current = isHiddenUpdate, lastPendingUpdate = newState) : current = current.next = isHiddenUpdate, lastBaseUpdate |= updateLane;\n                pendingQueue = pendingQueue.next;\n                if (null === pendingQueue) if (pendingQueue = queue.shared.pending, null === pendingQueue) break;\n                else isHiddenUpdate = pendingQueue, pendingQueue = isHiddenUpdate.next, isHiddenUpdate.next = null, queue.lastBaseUpdate = isHiddenUpdate, queue.shared.pending = null;\n            }while (1);\n            null === current && (lastPendingUpdate = newState);\n            queue.baseState = lastPendingUpdate;\n            queue.firstBaseUpdate = firstPendingUpdate;\n            queue.lastBaseUpdate = current;\n            null === firstBaseUpdate && (queue.shared.lanes = 0);\n            workInProgressRootSkippedLanes |= lastBaseUpdate;\n            workInProgress.lanes = lastBaseUpdate;\n            workInProgress.memoizedState = newState;\n        }\n        currentlyProcessingQueue = null;\n    }\n    function callCallback(callback, context) {\n        if (\"function\" !== typeof callback) throw Error(\"Invalid argument passed as callback. Expected a function. Instead received: \" + callback);\n        callback.call(context);\n    }\n    function commitHiddenCallbacks(updateQueue, context) {\n        var hiddenCallbacks = updateQueue.shared.hiddenCallbacks;\n        if (null !== hiddenCallbacks) for(updateQueue.shared.hiddenCallbacks = null, updateQueue = 0; updateQueue < hiddenCallbacks.length; updateQueue++)callCallback(hiddenCallbacks[updateQueue], context);\n    }\n    function commitCallbacks(updateQueue, context) {\n        var callbacks = updateQueue.callbacks;\n        if (null !== callbacks) for(updateQueue.callbacks = null, updateQueue = 0; updateQueue < callbacks.length; updateQueue++)callCallback(callbacks[updateQueue], context);\n    }\n    function shallowEqual(objA, objB) {\n        if (objectIs(objA, objB)) return !0;\n        if (\"object\" !== typeof objA || null === objA || \"object\" !== typeof objB || null === objB) return !1;\n        var keysA = Object.keys(objA), keysB = Object.keys(objB);\n        if (keysA.length !== keysB.length) return !1;\n        for(keysB = 0; keysB < keysA.length; keysB++){\n            var currentKey = keysA[keysB];\n            if (!hasOwnProperty.call(objB, currentKey) || !objectIs(objA[currentKey], objB[currentKey])) return !1;\n        }\n        return !0;\n    }\n    function createThenableState() {\n        return {\n            didWarnAboutUncachedPromise: !1,\n            thenables: []\n        };\n    }\n    function isThenableResolved(thenable) {\n        thenable = thenable.status;\n        return \"fulfilled\" === thenable || \"rejected\" === thenable;\n    }\n    function noop$1() {}\n    function trackUsedThenable(thenableState, thenable, index) {\n        null !== ReactSharedInternals.actQueue && (ReactSharedInternals.didUsePromise = !0);\n        var trackedThenables = thenableState.thenables;\n        index = trackedThenables[index];\n        void 0 === index ? trackedThenables.push(thenable) : index !== thenable && (thenableState.didWarnAboutUncachedPromise || (thenableState.didWarnAboutUncachedPromise = !0, console.error(\"A component was suspended by an uncached promise. Creating promises inside a Client Component or hook is not yet supported, except via a Suspense-compatible library or framework.\")), thenable.then(noop$1, noop$1), thenable = index);\n        switch(thenable.status){\n            case \"fulfilled\":\n                return thenable.value;\n            case \"rejected\":\n                throw thenableState = thenable.reason, checkIfUseWrappedInAsyncCatch(thenableState), thenableState;\n            default:\n                if (\"string\" === typeof thenable.status) thenable.then(noop$1, noop$1);\n                else {\n                    thenableState = workInProgressRoot;\n                    if (null !== thenableState && 100 < thenableState.shellSuspendCounter) throw Error(\"async/await is not yet supported in Client Components, only Server Components. This error is often caused by accidentally adding `'use client'` to a module that was originally written for the server.\");\n                    thenableState = thenable;\n                    thenableState.status = \"pending\";\n                    thenableState.then(function(fulfilledValue) {\n                        if (\"pending\" === thenable.status) {\n                            var fulfilledThenable = thenable;\n                            fulfilledThenable.status = \"fulfilled\";\n                            fulfilledThenable.value = fulfilledValue;\n                        }\n                    }, function(error) {\n                        if (\"pending\" === thenable.status) {\n                            var rejectedThenable = thenable;\n                            rejectedThenable.status = \"rejected\";\n                            rejectedThenable.reason = error;\n                        }\n                    });\n                }\n                switch(thenable.status){\n                    case \"fulfilled\":\n                        return thenable.value;\n                    case \"rejected\":\n                        throw thenableState = thenable.reason, checkIfUseWrappedInAsyncCatch(thenableState), thenableState;\n                }\n                suspendedThenable = thenable;\n                needsToResetSuspendedThenableDEV = !0;\n                throw SuspenseException;\n        }\n    }\n    function getSuspendedThenable() {\n        if (null === suspendedThenable) throw Error(\"Expected a suspended thenable. This is a bug in React. Please file an issue.\");\n        var thenable = suspendedThenable;\n        suspendedThenable = null;\n        needsToResetSuspendedThenableDEV = !1;\n        return thenable;\n    }\n    function checkIfUseWrappedInAsyncCatch(rejectedReason) {\n        if (rejectedReason === SuspenseException) throw Error(\"Hooks are not supported inside an async component. This error is often caused by accidentally adding `'use client'` to a module that was originally written for the server.\");\n    }\n    function pushDebugInfo(debugInfo) {\n        var previousDebugInfo = currentDebugInfo;\n        null != debugInfo && (currentDebugInfo = null === previousDebugInfo ? debugInfo : previousDebugInfo.concat(debugInfo));\n        return previousDebugInfo;\n    }\n    function validateFragmentProps(element, fiber, returnFiber) {\n        for(var keys = Object.keys(element.props), i = 0; i < keys.length; i++){\n            var key = keys[i];\n            if (\"children\" !== key && \"key\" !== key) {\n                null === fiber && (fiber = createFiberFromElement(element, returnFiber.mode, 0), fiber._debugInfo = currentDebugInfo, fiber.return = returnFiber);\n                runWithFiberInDEV(fiber, function(erroredKey) {\n                    console.error(\"Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.\", erroredKey);\n                }, key);\n                break;\n            }\n        }\n    }\n    function unwrapThenable(thenable) {\n        var index = thenableIndexCounter$1;\n        thenableIndexCounter$1 += 1;\n        null === thenableState$1 && (thenableState$1 = createThenableState());\n        return trackUsedThenable(thenableState$1, thenable, index);\n    }\n    function coerceRef(workInProgress, element) {\n        element = element.props.ref;\n        workInProgress.ref = void 0 !== element ? element : null;\n    }\n    function throwOnInvalidObjectType(returnFiber, newChild) {\n        if (newChild.$$typeof === REACT_LEGACY_ELEMENT_TYPE) throw Error('A React Element from an older version of React was rendered. This is not supported. It can happen if:\\n- Multiple copies of the \"react\" package is used.\\n- A library pre-bundled an old copy of \"react\" or \"react/jsx-runtime\".\\n- A compiler tries to \"inline\" JSX instead of using the runtime.');\n        returnFiber = Object.prototype.toString.call(newChild);\n        throw Error(\"Objects are not valid as a React child (found: \" + (\"[object Object]\" === returnFiber ? \"object with keys {\" + Object.keys(newChild).join(\", \") + \"}\" : returnFiber) + \"). If you meant to render a collection of children, use an array instead.\");\n    }\n    function warnOnFunctionType(returnFiber, invalidChild) {\n        var parentName = getComponentNameFromFiber(returnFiber) || \"Component\";\n        ownerHasFunctionTypeWarning[parentName] || (ownerHasFunctionTypeWarning[parentName] = !0, invalidChild = invalidChild.displayName || invalidChild.name || \"Component\", 3 === returnFiber.tag ? console.error(\"Functions are not valid as a React child. This may happen if you return %s instead of <%s /> from render. Or maybe you meant to call this function rather than return it.\\n  root.render(%s)\", invalidChild, invalidChild, invalidChild) : console.error(\"Functions are not valid as a React child. This may happen if you return %s instead of <%s /> from render. Or maybe you meant to call this function rather than return it.\\n  <%s>{%s}</%s>\", invalidChild, invalidChild, parentName, invalidChild, parentName));\n    }\n    function warnOnSymbolType(returnFiber, invalidChild) {\n        var parentName = getComponentNameFromFiber(returnFiber) || \"Component\";\n        ownerHasSymbolTypeWarning[parentName] || (ownerHasSymbolTypeWarning[parentName] = !0, invalidChild = String(invalidChild), 3 === returnFiber.tag ? console.error(\"Symbols are not valid as a React child.\\n  root.render(%s)\", invalidChild) : console.error(\"Symbols are not valid as a React child.\\n  <%s>%s</%s>\", parentName, invalidChild, parentName));\n    }\n    function createChildReconciler(shouldTrackSideEffects) {\n        function deleteChild(returnFiber, childToDelete) {\n            if (shouldTrackSideEffects) {\n                var deletions = returnFiber.deletions;\n                null === deletions ? (returnFiber.deletions = [\n                    childToDelete\n                ], returnFiber.flags |= 16) : deletions.push(childToDelete);\n            }\n        }\n        function deleteRemainingChildren(returnFiber, currentFirstChild) {\n            if (!shouldTrackSideEffects) return null;\n            for(; null !== currentFirstChild;)deleteChild(returnFiber, currentFirstChild), currentFirstChild = currentFirstChild.sibling;\n            return null;\n        }\n        function mapRemainingChildren(currentFirstChild) {\n            for(var existingChildren = new Map(); null !== currentFirstChild;)null !== currentFirstChild.key ? existingChildren.set(currentFirstChild.key, currentFirstChild) : existingChildren.set(currentFirstChild.index, currentFirstChild), currentFirstChild = currentFirstChild.sibling;\n            return existingChildren;\n        }\n        function useFiber(fiber, pendingProps) {\n            fiber = createWorkInProgress(fiber, pendingProps);\n            fiber.index = 0;\n            fiber.sibling = null;\n            return fiber;\n        }\n        function placeChild(newFiber, lastPlacedIndex, newIndex) {\n            newFiber.index = newIndex;\n            if (!shouldTrackSideEffects) return newFiber.flags |= 1048576, lastPlacedIndex;\n            newIndex = newFiber.alternate;\n            if (null !== newIndex) return newIndex = newIndex.index, newIndex < lastPlacedIndex ? (newFiber.flags |= 33554434, lastPlacedIndex) : newIndex;\n            newFiber.flags |= 33554434;\n            return lastPlacedIndex;\n        }\n        function placeSingleChild(newFiber) {\n            shouldTrackSideEffects && null === newFiber.alternate && (newFiber.flags |= 33554434);\n            return newFiber;\n        }\n        function updateTextNode(returnFiber, current, textContent, lanes) {\n            if (null === current || 6 !== current.tag) return current = createFiberFromText(textContent, returnFiber.mode, lanes), current.return = returnFiber, current._debugOwner = returnFiber, current._debugInfo = currentDebugInfo, current;\n            current = useFiber(current, textContent);\n            current.return = returnFiber;\n            current._debugInfo = currentDebugInfo;\n            return current;\n        }\n        function updateElement(returnFiber, current, element, lanes) {\n            var elementType = element.type;\n            if (elementType === REACT_FRAGMENT_TYPE) return current = updateFragment(returnFiber, current, element.props.children, lanes, element.key), validateFragmentProps(element, current, returnFiber), current;\n            if (null !== current && (current.elementType === elementType || isCompatibleFamilyForHotReloading(current, element) || \"object\" === typeof elementType && null !== elementType && elementType.$$typeof === REACT_LAZY_TYPE && callLazyInitInDEV(elementType) === current.type)) return current = useFiber(current, element.props), coerceRef(current, element), current.return = returnFiber, current._debugOwner = element._owner, current._debugInfo = currentDebugInfo, current;\n            current = createFiberFromElement(element, returnFiber.mode, lanes);\n            coerceRef(current, element);\n            current.return = returnFiber;\n            current._debugInfo = currentDebugInfo;\n            return current;\n        }\n        function updatePortal(returnFiber, current, portal, lanes) {\n            if (null === current || 4 !== current.tag || current.stateNode.containerInfo !== portal.containerInfo || current.stateNode.implementation !== portal.implementation) return current = createFiberFromPortal(portal, returnFiber.mode, lanes), current.return = returnFiber, current._debugInfo = currentDebugInfo, current;\n            current = useFiber(current, portal.children || []);\n            current.return = returnFiber;\n            current._debugInfo = currentDebugInfo;\n            return current;\n        }\n        function updateFragment(returnFiber, current, fragment, lanes, key) {\n            if (null === current || 7 !== current.tag) return current = createFiberFromFragment(fragment, returnFiber.mode, lanes, key), current.return = returnFiber, current._debugOwner = returnFiber, current._debugInfo = currentDebugInfo, current;\n            current = useFiber(current, fragment);\n            current.return = returnFiber;\n            current._debugInfo = currentDebugInfo;\n            return current;\n        }\n        function createChild(returnFiber, newChild, lanes) {\n            if (\"string\" === typeof newChild && \"\" !== newChild || \"number\" === typeof newChild || \"bigint\" === typeof newChild) return newChild = createFiberFromText(\"\" + newChild, returnFiber.mode, lanes), newChild.return = returnFiber, newChild._debugOwner = returnFiber, newChild._debugInfo = currentDebugInfo, newChild;\n            if (\"object\" === typeof newChild && null !== newChild) {\n                switch(newChild.$$typeof){\n                    case REACT_ELEMENT_TYPE:\n                        return lanes = createFiberFromElement(newChild, returnFiber.mode, lanes), coerceRef(lanes, newChild), lanes.return = returnFiber, returnFiber = pushDebugInfo(newChild._debugInfo), lanes._debugInfo = currentDebugInfo, currentDebugInfo = returnFiber, lanes;\n                    case REACT_PORTAL_TYPE:\n                        return newChild = createFiberFromPortal(newChild, returnFiber.mode, lanes), newChild.return = returnFiber, newChild._debugInfo = currentDebugInfo, newChild;\n                    case REACT_LAZY_TYPE:\n                        var _prevDebugInfo = pushDebugInfo(newChild._debugInfo);\n                        newChild = callLazyInitInDEV(newChild);\n                        returnFiber = createChild(returnFiber, newChild, lanes);\n                        currentDebugInfo = _prevDebugInfo;\n                        return returnFiber;\n                }\n                if (isArrayImpl(newChild) || getIteratorFn(newChild)) return lanes = createFiberFromFragment(newChild, returnFiber.mode, lanes, null), lanes.return = returnFiber, lanes._debugOwner = returnFiber, returnFiber = pushDebugInfo(newChild._debugInfo), lanes._debugInfo = currentDebugInfo, currentDebugInfo = returnFiber, lanes;\n                if (\"function\" === typeof newChild.then) return _prevDebugInfo = pushDebugInfo(newChild._debugInfo), returnFiber = createChild(returnFiber, unwrapThenable(newChild), lanes), currentDebugInfo = _prevDebugInfo, returnFiber;\n                if (newChild.$$typeof === REACT_CONTEXT_TYPE) return createChild(returnFiber, readContextDuringReconciliation(returnFiber, newChild), lanes);\n                throwOnInvalidObjectType(returnFiber, newChild);\n            }\n            \"function\" === typeof newChild && warnOnFunctionType(returnFiber, newChild);\n            \"symbol\" === typeof newChild && warnOnSymbolType(returnFiber, newChild);\n            return null;\n        }\n        function updateSlot(returnFiber, oldFiber, newChild, lanes) {\n            var key = null !== oldFiber ? oldFiber.key : null;\n            if (\"string\" === typeof newChild && \"\" !== newChild || \"number\" === typeof newChild || \"bigint\" === typeof newChild) return null !== key ? null : updateTextNode(returnFiber, oldFiber, \"\" + newChild, lanes);\n            if (\"object\" === typeof newChild && null !== newChild) {\n                switch(newChild.$$typeof){\n                    case REACT_ELEMENT_TYPE:\n                        return newChild.key === key ? (key = pushDebugInfo(newChild._debugInfo), returnFiber = updateElement(returnFiber, oldFiber, newChild, lanes), currentDebugInfo = key, returnFiber) : null;\n                    case REACT_PORTAL_TYPE:\n                        return newChild.key === key ? updatePortal(returnFiber, oldFiber, newChild, lanes) : null;\n                    case REACT_LAZY_TYPE:\n                        return key = pushDebugInfo(newChild._debugInfo), newChild = callLazyInitInDEV(newChild), returnFiber = updateSlot(returnFiber, oldFiber, newChild, lanes), currentDebugInfo = key, returnFiber;\n                }\n                if (isArrayImpl(newChild) || getIteratorFn(newChild)) {\n                    if (null !== key) return null;\n                    key = pushDebugInfo(newChild._debugInfo);\n                    returnFiber = updateFragment(returnFiber, oldFiber, newChild, lanes, null);\n                    currentDebugInfo = key;\n                    return returnFiber;\n                }\n                if (\"function\" === typeof newChild.then) return key = pushDebugInfo(newChild._debugInfo), returnFiber = updateSlot(returnFiber, oldFiber, unwrapThenable(newChild), lanes), currentDebugInfo = key, returnFiber;\n                if (newChild.$$typeof === REACT_CONTEXT_TYPE) return updateSlot(returnFiber, oldFiber, readContextDuringReconciliation(returnFiber, newChild), lanes);\n                throwOnInvalidObjectType(returnFiber, newChild);\n            }\n            \"function\" === typeof newChild && warnOnFunctionType(returnFiber, newChild);\n            \"symbol\" === typeof newChild && warnOnSymbolType(returnFiber, newChild);\n            return null;\n        }\n        function updateFromMap(existingChildren, returnFiber, newIdx, newChild, lanes) {\n            if (\"string\" === typeof newChild && \"\" !== newChild || \"number\" === typeof newChild || \"bigint\" === typeof newChild) return existingChildren = existingChildren.get(newIdx) || null, updateTextNode(returnFiber, existingChildren, \"\" + newChild, lanes);\n            if (\"object\" === typeof newChild && null !== newChild) {\n                switch(newChild.$$typeof){\n                    case REACT_ELEMENT_TYPE:\n                        return newIdx = existingChildren.get(null === newChild.key ? newIdx : newChild.key) || null, existingChildren = pushDebugInfo(newChild._debugInfo), returnFiber = updateElement(returnFiber, newIdx, newChild, lanes), currentDebugInfo = existingChildren, returnFiber;\n                    case REACT_PORTAL_TYPE:\n                        return existingChildren = existingChildren.get(null === newChild.key ? newIdx : newChild.key) || null, updatePortal(returnFiber, existingChildren, newChild, lanes);\n                    case REACT_LAZY_TYPE:\n                        var _prevDebugInfo7 = pushDebugInfo(newChild._debugInfo);\n                        newChild = callLazyInitInDEV(newChild);\n                        returnFiber = updateFromMap(existingChildren, returnFiber, newIdx, newChild, lanes);\n                        currentDebugInfo = _prevDebugInfo7;\n                        return returnFiber;\n                }\n                if (isArrayImpl(newChild) || getIteratorFn(newChild)) return newIdx = existingChildren.get(newIdx) || null, existingChildren = pushDebugInfo(newChild._debugInfo), returnFiber = updateFragment(returnFiber, newIdx, newChild, lanes, null), currentDebugInfo = existingChildren, returnFiber;\n                if (\"function\" === typeof newChild.then) return _prevDebugInfo7 = pushDebugInfo(newChild._debugInfo), returnFiber = updateFromMap(existingChildren, returnFiber, newIdx, unwrapThenable(newChild), lanes), currentDebugInfo = _prevDebugInfo7, returnFiber;\n                if (newChild.$$typeof === REACT_CONTEXT_TYPE) return updateFromMap(existingChildren, returnFiber, newIdx, readContextDuringReconciliation(returnFiber, newChild), lanes);\n                throwOnInvalidObjectType(returnFiber, newChild);\n            }\n            \"function\" === typeof newChild && warnOnFunctionType(returnFiber, newChild);\n            \"symbol\" === typeof newChild && warnOnSymbolType(returnFiber, newChild);\n            return null;\n        }\n        function warnOnInvalidKey(returnFiber, workInProgress, child, knownKeys) {\n            if (\"object\" !== typeof child || null === child) return knownKeys;\n            switch(child.$$typeof){\n                case REACT_ELEMENT_TYPE:\n                case REACT_PORTAL_TYPE:\n                    warnForMissingKey(returnFiber, workInProgress, child);\n                    var key = child.key;\n                    if (\"string\" !== typeof key) break;\n                    if (null === knownKeys) {\n                        knownKeys = new Set();\n                        knownKeys.add(key);\n                        break;\n                    }\n                    if (!knownKeys.has(key)) {\n                        knownKeys.add(key);\n                        break;\n                    }\n                    runWithFiberInDEV(workInProgress, function() {\n                        console.error(\"Encountered two children with the same key, `%s`. Keys should be unique so that components maintain their identity across updates. Non-unique keys may cause children to be duplicated and/or omitted \\u2014 the behavior is unsupported and could change in a future version.\", key);\n                    });\n                    break;\n                case REACT_LAZY_TYPE:\n                    child = callLazyInitInDEV(child), warnOnInvalidKey(returnFiber, workInProgress, child, knownKeys);\n            }\n            return knownKeys;\n        }\n        function reconcileChildrenArray(returnFiber, currentFirstChild, newChildren, lanes) {\n            for(var knownKeys = null, resultingFirstChild = null, previousNewFiber = null, oldFiber = currentFirstChild, newIdx = currentFirstChild = 0, nextOldFiber = null; null !== oldFiber && newIdx < newChildren.length; newIdx++){\n                oldFiber.index > newIdx ? (nextOldFiber = oldFiber, oldFiber = null) : nextOldFiber = oldFiber.sibling;\n                var newFiber = updateSlot(returnFiber, oldFiber, newChildren[newIdx], lanes);\n                if (null === newFiber) {\n                    null === oldFiber && (oldFiber = nextOldFiber);\n                    break;\n                }\n                knownKeys = warnOnInvalidKey(returnFiber, newFiber, newChildren[newIdx], knownKeys);\n                shouldTrackSideEffects && oldFiber && null === newFiber.alternate && deleteChild(returnFiber, oldFiber);\n                currentFirstChild = placeChild(newFiber, currentFirstChild, newIdx);\n                null === previousNewFiber ? resultingFirstChild = newFiber : previousNewFiber.sibling = newFiber;\n                previousNewFiber = newFiber;\n                oldFiber = nextOldFiber;\n            }\n            if (newIdx === newChildren.length) return deleteRemainingChildren(returnFiber, oldFiber), isHydrating && pushTreeFork(returnFiber, newIdx), resultingFirstChild;\n            if (null === oldFiber) {\n                for(; newIdx < newChildren.length; newIdx++)oldFiber = createChild(returnFiber, newChildren[newIdx], lanes), null !== oldFiber && (knownKeys = warnOnInvalidKey(returnFiber, oldFiber, newChildren[newIdx], knownKeys), currentFirstChild = placeChild(oldFiber, currentFirstChild, newIdx), null === previousNewFiber ? resultingFirstChild = oldFiber : previousNewFiber.sibling = oldFiber, previousNewFiber = oldFiber);\n                isHydrating && pushTreeFork(returnFiber, newIdx);\n                return resultingFirstChild;\n            }\n            for(oldFiber = mapRemainingChildren(oldFiber); newIdx < newChildren.length; newIdx++)nextOldFiber = updateFromMap(oldFiber, returnFiber, newIdx, newChildren[newIdx], lanes), null !== nextOldFiber && (knownKeys = warnOnInvalidKey(returnFiber, nextOldFiber, newChildren[newIdx], knownKeys), shouldTrackSideEffects && null !== nextOldFiber.alternate && oldFiber.delete(null === nextOldFiber.key ? newIdx : nextOldFiber.key), currentFirstChild = placeChild(nextOldFiber, currentFirstChild, newIdx), null === previousNewFiber ? resultingFirstChild = nextOldFiber : previousNewFiber.sibling = nextOldFiber, previousNewFiber = nextOldFiber);\n            shouldTrackSideEffects && oldFiber.forEach(function(child) {\n                return deleteChild(returnFiber, child);\n            });\n            isHydrating && pushTreeFork(returnFiber, newIdx);\n            return resultingFirstChild;\n        }\n        function reconcileChildrenIterator(returnFiber, currentFirstChild, newChildren, lanes) {\n            if (null == newChildren) throw Error(\"An iterable object provided no iterator.\");\n            for(var resultingFirstChild = null, previousNewFiber = null, oldFiber = currentFirstChild, newIdx = currentFirstChild = 0, nextOldFiber = null, knownKeys = null, step = newChildren.next(); null !== oldFiber && !step.done; newIdx++, step = newChildren.next()){\n                oldFiber.index > newIdx ? (nextOldFiber = oldFiber, oldFiber = null) : nextOldFiber = oldFiber.sibling;\n                var newFiber = updateSlot(returnFiber, oldFiber, step.value, lanes);\n                if (null === newFiber) {\n                    null === oldFiber && (oldFiber = nextOldFiber);\n                    break;\n                }\n                knownKeys = warnOnInvalidKey(returnFiber, newFiber, step.value, knownKeys);\n                shouldTrackSideEffects && oldFiber && null === newFiber.alternate && deleteChild(returnFiber, oldFiber);\n                currentFirstChild = placeChild(newFiber, currentFirstChild, newIdx);\n                null === previousNewFiber ? resultingFirstChild = newFiber : previousNewFiber.sibling = newFiber;\n                previousNewFiber = newFiber;\n                oldFiber = nextOldFiber;\n            }\n            if (step.done) return deleteRemainingChildren(returnFiber, oldFiber), isHydrating && pushTreeFork(returnFiber, newIdx), resultingFirstChild;\n            if (null === oldFiber) {\n                for(; !step.done; newIdx++, step = newChildren.next())oldFiber = createChild(returnFiber, step.value, lanes), null !== oldFiber && (knownKeys = warnOnInvalidKey(returnFiber, oldFiber, step.value, knownKeys), currentFirstChild = placeChild(oldFiber, currentFirstChild, newIdx), null === previousNewFiber ? resultingFirstChild = oldFiber : previousNewFiber.sibling = oldFiber, previousNewFiber = oldFiber);\n                isHydrating && pushTreeFork(returnFiber, newIdx);\n                return resultingFirstChild;\n            }\n            for(oldFiber = mapRemainingChildren(oldFiber); !step.done; newIdx++, step = newChildren.next())nextOldFiber = updateFromMap(oldFiber, returnFiber, newIdx, step.value, lanes), null !== nextOldFiber && (knownKeys = warnOnInvalidKey(returnFiber, nextOldFiber, step.value, knownKeys), shouldTrackSideEffects && null !== nextOldFiber.alternate && oldFiber.delete(null === nextOldFiber.key ? newIdx : nextOldFiber.key), currentFirstChild = placeChild(nextOldFiber, currentFirstChild, newIdx), null === previousNewFiber ? resultingFirstChild = nextOldFiber : previousNewFiber.sibling = nextOldFiber, previousNewFiber = nextOldFiber);\n            shouldTrackSideEffects && oldFiber.forEach(function(child) {\n                return deleteChild(returnFiber, child);\n            });\n            isHydrating && pushTreeFork(returnFiber, newIdx);\n            return resultingFirstChild;\n        }\n        function reconcileChildFibersImpl(returnFiber, currentFirstChild, newChild, lanes) {\n            \"object\" === typeof newChild && null !== newChild && newChild.type === REACT_FRAGMENT_TYPE && null === newChild.key && (validateFragmentProps(newChild, null, returnFiber), newChild = newChild.props.children);\n            if (\"object\" === typeof newChild && null !== newChild) {\n                switch(newChild.$$typeof){\n                    case REACT_ELEMENT_TYPE:\n                        var prevDebugInfo = pushDebugInfo(newChild._debugInfo);\n                        a: {\n                            for(var key = newChild.key; null !== currentFirstChild;){\n                                if (currentFirstChild.key === key) {\n                                    key = newChild.type;\n                                    if (key === REACT_FRAGMENT_TYPE) {\n                                        if (7 === currentFirstChild.tag) {\n                                            deleteRemainingChildren(returnFiber, currentFirstChild.sibling);\n                                            lanes = useFiber(currentFirstChild, newChild.props.children);\n                                            lanes.return = returnFiber;\n                                            lanes._debugOwner = newChild._owner;\n                                            lanes._debugInfo = currentDebugInfo;\n                                            validateFragmentProps(newChild, lanes, returnFiber);\n                                            returnFiber = lanes;\n                                            break a;\n                                        }\n                                    } else if (currentFirstChild.elementType === key || isCompatibleFamilyForHotReloading(currentFirstChild, newChild) || \"object\" === typeof key && null !== key && key.$$typeof === REACT_LAZY_TYPE && callLazyInitInDEV(key) === currentFirstChild.type) {\n                                        deleteRemainingChildren(returnFiber, currentFirstChild.sibling);\n                                        lanes = useFiber(currentFirstChild, newChild.props);\n                                        coerceRef(lanes, newChild);\n                                        lanes.return = returnFiber;\n                                        lanes._debugOwner = newChild._owner;\n                                        lanes._debugInfo = currentDebugInfo;\n                                        returnFiber = lanes;\n                                        break a;\n                                    }\n                                    deleteRemainingChildren(returnFiber, currentFirstChild);\n                                    break;\n                                } else deleteChild(returnFiber, currentFirstChild);\n                                currentFirstChild = currentFirstChild.sibling;\n                            }\n                            newChild.type === REACT_FRAGMENT_TYPE ? (lanes = createFiberFromFragment(newChild.props.children, returnFiber.mode, lanes, newChild.key), lanes.return = returnFiber, lanes._debugOwner = returnFiber, lanes._debugInfo = currentDebugInfo, validateFragmentProps(newChild, lanes, returnFiber), returnFiber = lanes) : (lanes = createFiberFromElement(newChild, returnFiber.mode, lanes), coerceRef(lanes, newChild), lanes.return = returnFiber, lanes._debugInfo = currentDebugInfo, returnFiber = lanes);\n                        }\n                        returnFiber = placeSingleChild(returnFiber);\n                        currentDebugInfo = prevDebugInfo;\n                        return returnFiber;\n                    case REACT_PORTAL_TYPE:\n                        a: {\n                            prevDebugInfo = newChild;\n                            for(newChild = prevDebugInfo.key; null !== currentFirstChild;){\n                                if (currentFirstChild.key === newChild) if (4 === currentFirstChild.tag && currentFirstChild.stateNode.containerInfo === prevDebugInfo.containerInfo && currentFirstChild.stateNode.implementation === prevDebugInfo.implementation) {\n                                    deleteRemainingChildren(returnFiber, currentFirstChild.sibling);\n                                    lanes = useFiber(currentFirstChild, prevDebugInfo.children || []);\n                                    lanes.return = returnFiber;\n                                    returnFiber = lanes;\n                                    break a;\n                                } else {\n                                    deleteRemainingChildren(returnFiber, currentFirstChild);\n                                    break;\n                                }\n                                else deleteChild(returnFiber, currentFirstChild);\n                                currentFirstChild = currentFirstChild.sibling;\n                            }\n                            lanes = createFiberFromPortal(prevDebugInfo, returnFiber.mode, lanes);\n                            lanes.return = returnFiber;\n                            returnFiber = lanes;\n                        }\n                        return placeSingleChild(returnFiber);\n                    case REACT_LAZY_TYPE:\n                        return prevDebugInfo = pushDebugInfo(newChild._debugInfo), newChild = callLazyInitInDEV(newChild), returnFiber = reconcileChildFibersImpl(returnFiber, currentFirstChild, newChild, lanes), currentDebugInfo = prevDebugInfo, returnFiber;\n                }\n                if (isArrayImpl(newChild)) return prevDebugInfo = pushDebugInfo(newChild._debugInfo), returnFiber = reconcileChildrenArray(returnFiber, currentFirstChild, newChild, lanes), currentDebugInfo = prevDebugInfo, returnFiber;\n                if (getIteratorFn(newChild)) {\n                    prevDebugInfo = pushDebugInfo(newChild._debugInfo);\n                    key = getIteratorFn(newChild);\n                    if (\"function\" !== typeof key) throw Error(\"An object is not an iterable. This error is likely caused by a bug in React. Please file an issue.\");\n                    var newChildren = key.call(newChild);\n                    if (newChildren === newChild) {\n                        if (0 !== returnFiber.tag || \"[object GeneratorFunction]\" !== Object.prototype.toString.call(returnFiber.type) || \"[object Generator]\" !== Object.prototype.toString.call(newChildren)) didWarnAboutGenerators || console.error(\"Using Iterators as children is unsupported and will likely yield unexpected results because enumerating a generator mutates it. You may convert it to an array with `Array.from()` or the `[...spread]` operator before rendering. You can also use an Iterable that can iterate multiple times over the same items.\"), didWarnAboutGenerators = !0;\n                    } else newChild.entries !== key || didWarnAboutMaps || (console.error(\"Using Maps as children is not supported. Use an array of keyed ReactElements instead.\"), didWarnAboutMaps = !0);\n                    returnFiber = reconcileChildrenIterator(returnFiber, currentFirstChild, newChildren, lanes);\n                    currentDebugInfo = prevDebugInfo;\n                    return returnFiber;\n                }\n                if (\"function\" === typeof newChild.then) return prevDebugInfo = pushDebugInfo(newChild._debugInfo), returnFiber = reconcileChildFibersImpl(returnFiber, currentFirstChild, unwrapThenable(newChild), lanes), currentDebugInfo = prevDebugInfo, returnFiber;\n                if (newChild.$$typeof === REACT_CONTEXT_TYPE) return reconcileChildFibersImpl(returnFiber, currentFirstChild, readContextDuringReconciliation(returnFiber, newChild), lanes);\n                throwOnInvalidObjectType(returnFiber, newChild);\n            }\n            if (\"string\" === typeof newChild && \"\" !== newChild || \"number\" === typeof newChild || \"bigint\" === typeof newChild) return prevDebugInfo = \"\" + newChild, null !== currentFirstChild && 6 === currentFirstChild.tag ? (deleteRemainingChildren(returnFiber, currentFirstChild.sibling), lanes = useFiber(currentFirstChild, prevDebugInfo), lanes.return = returnFiber, returnFiber = lanes) : (deleteRemainingChildren(returnFiber, currentFirstChild), lanes = createFiberFromText(prevDebugInfo, returnFiber.mode, lanes), lanes.return = returnFiber, lanes._debugOwner = returnFiber, lanes._debugInfo = currentDebugInfo, returnFiber = lanes), placeSingleChild(returnFiber);\n            \"function\" === typeof newChild && warnOnFunctionType(returnFiber, newChild);\n            \"symbol\" === typeof newChild && warnOnSymbolType(returnFiber, newChild);\n            return deleteRemainingChildren(returnFiber, currentFirstChild);\n        }\n        return function(returnFiber, currentFirstChild, newChild, lanes) {\n            var prevDebugInfo = currentDebugInfo;\n            currentDebugInfo = null;\n            try {\n                thenableIndexCounter$1 = 0;\n                var firstChildFiber = reconcileChildFibersImpl(returnFiber, currentFirstChild, newChild, lanes);\n                thenableState$1 = null;\n                return firstChildFiber;\n            } catch (x) {\n                if (x === SuspenseException) throw x;\n                var fiber = createFiber(29, x, null, returnFiber.mode);\n                fiber.lanes = lanes;\n                fiber.return = returnFiber;\n                var debugInfo = fiber._debugInfo = currentDebugInfo;\n                fiber._debugOwner = returnFiber._debugOwner;\n                if (null != debugInfo) {\n                    for(var i = debugInfo.length - 1; 0 <= i; i--)if (\"string\" === typeof debugInfo[i].stack) {\n                        fiber._debugOwner = debugInfo[i];\n                        break;\n                    }\n                }\n                return fiber;\n            } finally{\n                currentDebugInfo = prevDebugInfo;\n            }\n        };\n    }\n    function pushHiddenContext(fiber, context) {\n        var prevEntangledRenderLanes = entangledRenderLanes;\n        push(prevEntangledRenderLanesCursor, prevEntangledRenderLanes, fiber);\n        push(currentTreeHiddenStackCursor, context, fiber);\n        entangledRenderLanes = prevEntangledRenderLanes | context.baseLanes;\n    }\n    function reuseHiddenContextOnStack(fiber) {\n        push(prevEntangledRenderLanesCursor, entangledRenderLanes, fiber);\n        push(currentTreeHiddenStackCursor, currentTreeHiddenStackCursor.current, fiber);\n    }\n    function popHiddenContext(fiber) {\n        entangledRenderLanes = prevEntangledRenderLanesCursor.current;\n        pop(currentTreeHiddenStackCursor, fiber);\n        pop(prevEntangledRenderLanesCursor, fiber);\n    }\n    function pushPrimaryTreeSuspenseHandler(handler) {\n        var current = handler.alternate;\n        push(suspenseStackCursor, suspenseStackCursor.current & SubtreeSuspenseContextMask, handler);\n        push(suspenseHandlerStackCursor, handler, handler);\n        null === shellBoundary && (null === current || null !== currentTreeHiddenStackCursor.current ? shellBoundary = handler : null !== current.memoizedState && (shellBoundary = handler));\n    }\n    function pushOffscreenSuspenseHandler(fiber) {\n        if (22 === fiber.tag) {\n            if (push(suspenseStackCursor, suspenseStackCursor.current, fiber), push(suspenseHandlerStackCursor, fiber, fiber), null === shellBoundary) {\n                var current = fiber.alternate;\n                null !== current && null !== current.memoizedState && (shellBoundary = fiber);\n            }\n        } else reuseSuspenseHandlerOnStack(fiber);\n    }\n    function reuseSuspenseHandlerOnStack(fiber) {\n        push(suspenseStackCursor, suspenseStackCursor.current, fiber);\n        push(suspenseHandlerStackCursor, suspenseHandlerStackCursor.current, fiber);\n    }\n    function popSuspenseHandler(fiber) {\n        pop(suspenseHandlerStackCursor, fiber);\n        shellBoundary === fiber && (shellBoundary = null);\n        pop(suspenseStackCursor, fiber);\n    }\n    function findFirstSuspended(row) {\n        for(var node = row; null !== node;){\n            if (13 === node.tag) {\n                var state = node.memoizedState;\n                if (null !== state && (state = state.dehydrated, null === state || isSuspenseInstancePending(state) || isSuspenseInstanceFallback(state))) return node;\n            } else if (19 === node.tag && void 0 !== node.memoizedProps.revealOrder) {\n                if (0 !== (node.flags & 128)) return node;\n            } else if (null !== node.child) {\n                node.child.return = node;\n                node = node.child;\n                continue;\n            }\n            if (node === row) break;\n            for(; null === node.sibling;){\n                if (null === node.return || node.return === row) return null;\n                node = node.return;\n            }\n            node.sibling.return = node.return;\n            node = node.sibling;\n        }\n        return null;\n    }\n    function mountHookTypesDev() {\n        var hookName = currentHookNameInDev;\n        null === hookTypesDev ? hookTypesDev = [\n            hookName\n        ] : hookTypesDev.push(hookName);\n    }\n    function updateHookTypesDev() {\n        var hookName = currentHookNameInDev;\n        if (null !== hookTypesDev && (hookTypesUpdateIndexDev++, hookTypesDev[hookTypesUpdateIndexDev] !== hookName)) {\n            var componentName = getComponentNameFromFiber(currentlyRenderingFiber$1);\n            if (!didWarnAboutMismatchedHooksForComponent.has(componentName) && (didWarnAboutMismatchedHooksForComponent.add(componentName), null !== hookTypesDev)) {\n                for(var table = \"\", i = 0; i <= hookTypesUpdateIndexDev; i++){\n                    var oldHookName = hookTypesDev[i], newHookName = i === hookTypesUpdateIndexDev ? hookName : oldHookName;\n                    for(oldHookName = i + 1 + \". \" + oldHookName; 30 > oldHookName.length;)oldHookName += \" \";\n                    oldHookName += newHookName + \"\\n\";\n                    table += oldHookName;\n                }\n                console.error(\"React has detected a change in the order of Hooks called by %s. This will lead to bugs and errors if not fixed. For more information, read the Rules of Hooks: https://react.dev/link/rules-of-hooks\\n\\n   Previous render            Next render\\n   ------------------------------------------------------\\n%s   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\\n\", componentName, table);\n            }\n        }\n    }\n    function checkDepsAreArrayDev(deps) {\n        void 0 === deps || null === deps || isArrayImpl(deps) || console.error(\"%s received a final argument that is not an array (instead, received `%s`). When specified, the final argument must be an array.\", currentHookNameInDev, typeof deps);\n    }\n    function warnOnUseFormStateInDev() {\n        var componentName = getComponentNameFromFiber(currentlyRenderingFiber$1);\n        didWarnAboutUseFormState.has(componentName) || (didWarnAboutUseFormState.add(componentName), console.error(\"ReactDOM.useFormState has been renamed to React.useActionState. Please update %s to use React.useActionState.\", componentName));\n    }\n    function throwInvalidHookError() {\n        throw Error(\"Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:\\n1. You might have mismatching versions of React and the renderer (such as React DOM)\\n2. You might be breaking the Rules of Hooks\\n3. You might have more than one copy of React in the same app\\nSee https://react.dev/link/invalid-hook-call for tips about how to debug and fix this problem.\");\n    }\n    function areHookInputsEqual(nextDeps, prevDeps) {\n        if (ignorePreviousDependencies) return !1;\n        if (null === prevDeps) return console.error(\"%s received a final argument during this render, but not during the previous render. Even though the final argument is optional, its type cannot change between renders.\", currentHookNameInDev), !1;\n        nextDeps.length !== prevDeps.length && console.error(\"The final argument passed to %s changed size between renders. The order and size of this array must remain constant.\\n\\nPrevious: %s\\nIncoming: %s\", currentHookNameInDev, \"[\" + prevDeps.join(\", \") + \"]\", \"[\" + nextDeps.join(\", \") + \"]\");\n        for(var i = 0; i < prevDeps.length && i < nextDeps.length; i++)if (!objectIs(nextDeps[i], prevDeps[i])) return !1;\n        return !0;\n    }\n    function renderWithHooks(current, workInProgress, Component, props, secondArg, nextRenderLanes) {\n        renderLanes = nextRenderLanes;\n        currentlyRenderingFiber$1 = workInProgress;\n        hookTypesDev = null !== current ? current._debugHookTypes : null;\n        hookTypesUpdateIndexDev = -1;\n        ignorePreviousDependencies = null !== current && current.type !== workInProgress.type;\n        if (\"[object AsyncFunction]\" === Object.prototype.toString.call(Component) || \"[object AsyncGeneratorFunction]\" === Object.prototype.toString.call(Component)) nextRenderLanes = getComponentNameFromFiber(currentlyRenderingFiber$1), didWarnAboutAsyncClientComponent.has(nextRenderLanes) || (didWarnAboutAsyncClientComponent.add(nextRenderLanes), console.error(\"async/await is not yet supported in Client Components, only Server Components. This error is often caused by accidentally adding `'use client'` to a module that was originally written for the server.\"));\n        workInProgress.memoizedState = null;\n        workInProgress.updateQueue = null;\n        workInProgress.lanes = 0;\n        ReactSharedInternals.H = null !== current && null !== current.memoizedState ? HooksDispatcherOnUpdateInDEV : null !== hookTypesDev ? HooksDispatcherOnMountWithHookTypesInDEV : HooksDispatcherOnMountInDEV;\n        shouldDoubleInvokeUserFnsInHooksDEV = nextRenderLanes = (workInProgress.mode & 8) !== NoMode;\n        var children = callComponentInDEV(Component, props, secondArg);\n        shouldDoubleInvokeUserFnsInHooksDEV = !1;\n        didScheduleRenderPhaseUpdateDuringThisPass && (children = renderWithHooksAgain(workInProgress, Component, props, secondArg));\n        if (nextRenderLanes) {\n            setIsStrictModeForDevtools(!0);\n            try {\n                children = renderWithHooksAgain(workInProgress, Component, props, secondArg);\n            } finally{\n                setIsStrictModeForDevtools(!1);\n            }\n        }\n        finishRenderingHooks(current, workInProgress);\n        return children;\n    }\n    function finishRenderingHooks(current, workInProgress) {\n        workInProgress._debugHookTypes = hookTypesDev;\n        null === workInProgress.dependencies ? null !== thenableState && (workInProgress.dependencies = {\n            lanes: 0,\n            firstContext: null,\n            _debugThenableState: thenableState\n        }) : workInProgress.dependencies._debugThenableState = thenableState;\n        ReactSharedInternals.H = ContextOnlyDispatcher;\n        var didRenderTooFewHooks = null !== currentHook && null !== currentHook.next;\n        renderLanes = 0;\n        hookTypesDev = currentHookNameInDev = workInProgressHook = currentHook = currentlyRenderingFiber$1 = null;\n        hookTypesUpdateIndexDev = -1;\n        null !== current && (current.flags & 31457280) !== (workInProgress.flags & 31457280) && console.error(\"Internal React error: Expected static flag was missing. Please notify the React team.\");\n        didScheduleRenderPhaseUpdate = !1;\n        thenableIndexCounter = 0;\n        thenableState = null;\n        if (didRenderTooFewHooks) throw Error(\"Rendered fewer hooks than expected. This may be caused by an accidental early return statement.\");\n        null === current || didReceiveUpdate || (current = current.dependencies, null !== current && checkIfContextChanged(current) && (didReceiveUpdate = !0));\n        needsToResetSuspendedThenableDEV ? (needsToResetSuspendedThenableDEV = !1, current = !0) : current = !1;\n        current && (workInProgress = getComponentNameFromFiber(workInProgress) || \"Unknown\", didWarnAboutUseWrappedInTryCatch.has(workInProgress) || didWarnAboutAsyncClientComponent.has(workInProgress) || (didWarnAboutUseWrappedInTryCatch.add(workInProgress), console.error(\"`use` was called from inside a try/catch block. This is not allowed and can lead to unexpected behavior. To handle errors triggered by `use`, wrap your component in a error boundary.\")));\n    }\n    function renderWithHooksAgain(workInProgress, Component, props, secondArg) {\n        currentlyRenderingFiber$1 = workInProgress;\n        var numberOfReRenders = 0;\n        do {\n            didScheduleRenderPhaseUpdateDuringThisPass && (thenableState = null);\n            thenableIndexCounter = 0;\n            didScheduleRenderPhaseUpdateDuringThisPass = !1;\n            if (numberOfReRenders >= RE_RENDER_LIMIT) throw Error(\"Too many re-renders. React limits the number of renders to prevent an infinite loop.\");\n            numberOfReRenders += 1;\n            ignorePreviousDependencies = !1;\n            workInProgressHook = currentHook = null;\n            if (null != workInProgress.updateQueue) {\n                var children = workInProgress.updateQueue;\n                children.lastEffect = null;\n                children.events = null;\n                children.stores = null;\n                null != children.memoCache && (children.memoCache.index = 0);\n            }\n            hookTypesUpdateIndexDev = -1;\n            ReactSharedInternals.H = HooksDispatcherOnRerenderInDEV;\n            children = callComponentInDEV(Component, props, secondArg);\n        }while (didScheduleRenderPhaseUpdateDuringThisPass);\n        return children;\n    }\n    function TransitionAwareHostComponent() {\n        var dispatcher = ReactSharedInternals.H, maybeThenable = dispatcher.useState()[0];\n        maybeThenable = \"function\" === typeof maybeThenable.then ? useThenable(maybeThenable) : maybeThenable;\n        dispatcher = dispatcher.useState()[0];\n        (null !== currentHook ? currentHook.memoizedState : null) !== dispatcher && (currentlyRenderingFiber$1.flags |= 1024);\n        return maybeThenable;\n    }\n    function checkDidRenderIdHook() {\n        var didRenderIdHook = 0 !== localIdCounter;\n        localIdCounter = 0;\n        return didRenderIdHook;\n    }\n    function bailoutHooks(current, workInProgress, lanes) {\n        workInProgress.updateQueue = current.updateQueue;\n        workInProgress.flags = (workInProgress.mode & 16) !== NoMode ? workInProgress.flags & -201328645 : workInProgress.flags & -2053;\n        current.lanes &= ~lanes;\n    }\n    function resetHooksOnUnwind(workInProgress) {\n        if (didScheduleRenderPhaseUpdate) {\n            for(workInProgress = workInProgress.memoizedState; null !== workInProgress;){\n                var queue = workInProgress.queue;\n                null !== queue && (queue.pending = null);\n                workInProgress = workInProgress.next;\n            }\n            didScheduleRenderPhaseUpdate = !1;\n        }\n        renderLanes = 0;\n        hookTypesDev = workInProgressHook = currentHook = currentlyRenderingFiber$1 = null;\n        hookTypesUpdateIndexDev = -1;\n        currentHookNameInDev = null;\n        didScheduleRenderPhaseUpdateDuringThisPass = !1;\n        thenableIndexCounter = localIdCounter = 0;\n        thenableState = null;\n    }\n    function mountWorkInProgressHook() {\n        var hook = {\n            memoizedState: null,\n            baseState: null,\n            baseQueue: null,\n            queue: null,\n            next: null\n        };\n        null === workInProgressHook ? currentlyRenderingFiber$1.memoizedState = workInProgressHook = hook : workInProgressHook = workInProgressHook.next = hook;\n        return workInProgressHook;\n    }\n    function updateWorkInProgressHook() {\n        if (null === currentHook) {\n            var nextCurrentHook = currentlyRenderingFiber$1.alternate;\n            nextCurrentHook = null !== nextCurrentHook ? nextCurrentHook.memoizedState : null;\n        } else nextCurrentHook = currentHook.next;\n        var nextWorkInProgressHook = null === workInProgressHook ? currentlyRenderingFiber$1.memoizedState : workInProgressHook.next;\n        if (null !== nextWorkInProgressHook) workInProgressHook = nextWorkInProgressHook, currentHook = nextCurrentHook;\n        else {\n            if (null === nextCurrentHook) {\n                if (null === currentlyRenderingFiber$1.alternate) throw Error(\"Update hook called on initial render. This is likely a bug in React. Please file an issue.\");\n                throw Error(\"Rendered more hooks than during the previous render.\");\n            }\n            currentHook = nextCurrentHook;\n            nextCurrentHook = {\n                memoizedState: currentHook.memoizedState,\n                baseState: currentHook.baseState,\n                baseQueue: currentHook.baseQueue,\n                queue: currentHook.queue,\n                next: null\n            };\n            null === workInProgressHook ? currentlyRenderingFiber$1.memoizedState = workInProgressHook = nextCurrentHook : workInProgressHook = workInProgressHook.next = nextCurrentHook;\n        }\n        return workInProgressHook;\n    }\n    function useThenable(thenable) {\n        var index = thenableIndexCounter;\n        thenableIndexCounter += 1;\n        null === thenableState && (thenableState = createThenableState());\n        thenable = trackUsedThenable(thenableState, thenable, index);\n        index = currentlyRenderingFiber$1;\n        null === (null === workInProgressHook ? index.memoizedState : workInProgressHook.next) && (index = index.alternate, ReactSharedInternals.H = null !== index && null !== index.memoizedState ? HooksDispatcherOnUpdateInDEV : HooksDispatcherOnMountInDEV);\n        return thenable;\n    }\n    function use(usable) {\n        if (null !== usable && \"object\" === typeof usable) {\n            if (\"function\" === typeof usable.then) return useThenable(usable);\n            if (usable.$$typeof === REACT_CONTEXT_TYPE) return readContext(usable);\n        }\n        throw Error(\"An unsupported type was passed to use(): \" + String(usable));\n    }\n    function useMemoCache(size) {\n        var memoCache = null, updateQueue = currentlyRenderingFiber$1.updateQueue;\n        null !== updateQueue && (memoCache = updateQueue.memoCache);\n        if (null == memoCache) {\n            var current = currentlyRenderingFiber$1.alternate;\n            null !== current && (current = current.updateQueue, null !== current && (current = current.memoCache, null != current && (memoCache = {\n                data: current.data.map(function(array) {\n                    return array.slice();\n                }),\n                index: 0\n            })));\n        }\n        null == memoCache && (memoCache = {\n            data: [],\n            index: 0\n        });\n        null === updateQueue && (updateQueue = createFunctionComponentUpdateQueue(), currentlyRenderingFiber$1.updateQueue = updateQueue);\n        updateQueue.memoCache = memoCache;\n        updateQueue = memoCache.data[memoCache.index];\n        if (void 0 === updateQueue || ignorePreviousDependencies) for(updateQueue = memoCache.data[memoCache.index] = Array(size), current = 0; current < size; current++)updateQueue[current] = REACT_MEMO_CACHE_SENTINEL;\n        else updateQueue.length !== size && console.error(\"Expected a constant size argument for each invocation of useMemoCache. The previous cache was allocated with size %s but size %s was requested.\", updateQueue.length, size);\n        memoCache.index++;\n        return updateQueue;\n    }\n    function basicStateReducer(state, action) {\n        return \"function\" === typeof action ? action(state) : action;\n    }\n    function mountReducer(reducer, initialArg, init) {\n        var hook = mountWorkInProgressHook();\n        if (void 0 !== init) {\n            var initialState = init(initialArg);\n            if (shouldDoubleInvokeUserFnsInHooksDEV) {\n                setIsStrictModeForDevtools(!0);\n                try {\n                    init(initialArg);\n                } finally{\n                    setIsStrictModeForDevtools(!1);\n                }\n            }\n        } else initialState = initialArg;\n        hook.memoizedState = hook.baseState = initialState;\n        reducer = {\n            pending: null,\n            lanes: 0,\n            dispatch: null,\n            lastRenderedReducer: reducer,\n            lastRenderedState: initialState\n        };\n        hook.queue = reducer;\n        reducer = reducer.dispatch = dispatchReducerAction.bind(null, currentlyRenderingFiber$1, reducer);\n        return [\n            hook.memoizedState,\n            reducer\n        ];\n    }\n    function updateReducer(reducer) {\n        var hook = updateWorkInProgressHook();\n        return updateReducerImpl(hook, currentHook, reducer);\n    }\n    function updateReducerImpl(hook, current, reducer) {\n        var queue = hook.queue;\n        if (null === queue) throw Error(\"Should have a queue. You are likely calling Hooks conditionally, which is not allowed. (https://react.dev/link/invalid-hook-call)\");\n        queue.lastRenderedReducer = reducer;\n        var baseQueue = hook.baseQueue, pendingQueue = queue.pending;\n        if (null !== pendingQueue) {\n            if (null !== baseQueue) {\n                var baseFirst = baseQueue.next;\n                baseQueue.next = pendingQueue.next;\n                pendingQueue.next = baseFirst;\n            }\n            current.baseQueue !== baseQueue && console.error(\"Internal error: Expected work-in-progress queue to be a clone. This is a bug in React.\");\n            current.baseQueue = baseQueue = pendingQueue;\n            queue.pending = null;\n        }\n        pendingQueue = hook.baseState;\n        if (null === baseQueue) hook.memoizedState = pendingQueue;\n        else {\n            current = baseQueue.next;\n            var newBaseQueueFirst = baseFirst = null, newBaseQueueLast = null, update = current, didReadFromEntangledAsyncAction = !1;\n            do {\n                var updateLane = update.lane & -536870913;\n                if (updateLane !== update.lane ? (workInProgressRootRenderLanes & updateLane) === updateLane : (renderLanes & updateLane) === updateLane) {\n                    var revertLane = update.revertLane;\n                    if (0 === revertLane) null !== newBaseQueueLast && (newBaseQueueLast = newBaseQueueLast.next = {\n                        lane: 0,\n                        revertLane: 0,\n                        action: update.action,\n                        hasEagerState: update.hasEagerState,\n                        eagerState: update.eagerState,\n                        next: null\n                    }), updateLane === currentEntangledLane && (didReadFromEntangledAsyncAction = !0);\n                    else if ((renderLanes & revertLane) === revertLane) {\n                        update = update.next;\n                        revertLane === currentEntangledLane && (didReadFromEntangledAsyncAction = !0);\n                        continue;\n                    } else updateLane = {\n                        lane: 0,\n                        revertLane: update.revertLane,\n                        action: update.action,\n                        hasEagerState: update.hasEagerState,\n                        eagerState: update.eagerState,\n                        next: null\n                    }, null === newBaseQueueLast ? (newBaseQueueFirst = newBaseQueueLast = updateLane, baseFirst = pendingQueue) : newBaseQueueLast = newBaseQueueLast.next = updateLane, currentlyRenderingFiber$1.lanes |= revertLane, workInProgressRootSkippedLanes |= revertLane;\n                    updateLane = update.action;\n                    shouldDoubleInvokeUserFnsInHooksDEV && reducer(pendingQueue, updateLane);\n                    pendingQueue = update.hasEagerState ? update.eagerState : reducer(pendingQueue, updateLane);\n                } else revertLane = {\n                    lane: updateLane,\n                    revertLane: update.revertLane,\n                    action: update.action,\n                    hasEagerState: update.hasEagerState,\n                    eagerState: update.eagerState,\n                    next: null\n                }, null === newBaseQueueLast ? (newBaseQueueFirst = newBaseQueueLast = revertLane, baseFirst = pendingQueue) : newBaseQueueLast = newBaseQueueLast.next = revertLane, currentlyRenderingFiber$1.lanes |= updateLane, workInProgressRootSkippedLanes |= updateLane;\n                update = update.next;\n            }while (null !== update && update !== current);\n            null === newBaseQueueLast ? baseFirst = pendingQueue : newBaseQueueLast.next = newBaseQueueFirst;\n            if (!objectIs(pendingQueue, hook.memoizedState) && (didReceiveUpdate = !0, didReadFromEntangledAsyncAction && (reducer = currentEntangledActionThenable, null !== reducer))) throw reducer;\n            hook.memoizedState = pendingQueue;\n            hook.baseState = baseFirst;\n            hook.baseQueue = newBaseQueueLast;\n            queue.lastRenderedState = pendingQueue;\n        }\n        null === baseQueue && (queue.lanes = 0);\n        return [\n            hook.memoizedState,\n            queue.dispatch\n        ];\n    }\n    function rerenderReducer(reducer) {\n        var hook = updateWorkInProgressHook(), queue = hook.queue;\n        if (null === queue) throw Error(\"Should have a queue. You are likely calling Hooks conditionally, which is not allowed. (https://react.dev/link/invalid-hook-call)\");\n        queue.lastRenderedReducer = reducer;\n        var dispatch = queue.dispatch, lastRenderPhaseUpdate = queue.pending, newState = hook.memoizedState;\n        if (null !== lastRenderPhaseUpdate) {\n            queue.pending = null;\n            var update = lastRenderPhaseUpdate = lastRenderPhaseUpdate.next;\n            do newState = reducer(newState, update.action), update = update.next;\n            while (update !== lastRenderPhaseUpdate);\n            objectIs(newState, hook.memoizedState) || (didReceiveUpdate = !0);\n            hook.memoizedState = newState;\n            null === hook.baseQueue && (hook.baseState = newState);\n            queue.lastRenderedState = newState;\n        }\n        return [\n            newState,\n            dispatch\n        ];\n    }\n    function mountSyncExternalStore(subscribe, getSnapshot, getServerSnapshot) {\n        var fiber = currentlyRenderingFiber$1, hook = mountWorkInProgressHook();\n        if (isHydrating) {\n            if (void 0 === getServerSnapshot) throw Error(\"Missing getServerSnapshot, which is required for server-rendered content. Will revert to client rendering.\");\n            var nextSnapshot = getServerSnapshot();\n            didWarnUncachedGetSnapshot || nextSnapshot === getServerSnapshot() || (console.error(\"The result of getServerSnapshot should be cached to avoid an infinite loop\"), didWarnUncachedGetSnapshot = !0);\n        } else {\n            nextSnapshot = getSnapshot();\n            didWarnUncachedGetSnapshot || (getServerSnapshot = getSnapshot(), objectIs(nextSnapshot, getServerSnapshot) || (console.error(\"The result of getSnapshot should be cached to avoid an infinite loop\"), didWarnUncachedGetSnapshot = !0));\n            if (null === workInProgressRoot) throw Error(\"Expected a work-in-progress root. This is a bug in React. Please file an issue.\");\n            0 !== (workInProgressRootRenderLanes & 60) || pushStoreConsistencyCheck(fiber, getSnapshot, nextSnapshot);\n        }\n        hook.memoizedState = nextSnapshot;\n        getServerSnapshot = {\n            value: nextSnapshot,\n            getSnapshot: getSnapshot\n        };\n        hook.queue = getServerSnapshot;\n        mountEffect(subscribeToStore.bind(null, fiber, getServerSnapshot, subscribe), [\n            subscribe\n        ]);\n        fiber.flags |= 2048;\n        pushEffect(HasEffect | Passive, updateStoreInstance.bind(null, fiber, getServerSnapshot, nextSnapshot, getSnapshot), {\n            destroy: void 0\n        }, null);\n        return nextSnapshot;\n    }\n    function updateSyncExternalStore(subscribe, getSnapshot, getServerSnapshot) {\n        var fiber = currentlyRenderingFiber$1, hook = updateWorkInProgressHook(), isHydrating$jscomp$0 = isHydrating;\n        if (isHydrating$jscomp$0) {\n            if (void 0 === getServerSnapshot) throw Error(\"Missing getServerSnapshot, which is required for server-rendered content. Will revert to client rendering.\");\n            getServerSnapshot = getServerSnapshot();\n        } else if (getServerSnapshot = getSnapshot(), !didWarnUncachedGetSnapshot) {\n            var cachedSnapshot = getSnapshot();\n            objectIs(getServerSnapshot, cachedSnapshot) || (console.error(\"The result of getSnapshot should be cached to avoid an infinite loop\"), didWarnUncachedGetSnapshot = !0);\n        }\n        if (cachedSnapshot = !objectIs((currentHook || hook).memoizedState, getServerSnapshot)) hook.memoizedState = getServerSnapshot, didReceiveUpdate = !0;\n        hook = hook.queue;\n        var create = subscribeToStore.bind(null, fiber, hook, subscribe);\n        updateEffectImpl(2048, Passive, create, [\n            subscribe\n        ]);\n        if (hook.getSnapshot !== getSnapshot || cachedSnapshot || null !== workInProgressHook && workInProgressHook.memoizedState.tag & HasEffect) {\n            fiber.flags |= 2048;\n            pushEffect(HasEffect | Passive, updateStoreInstance.bind(null, fiber, hook, getServerSnapshot, getSnapshot), {\n                destroy: void 0\n            }, null);\n            if (null === workInProgressRoot) throw Error(\"Expected a work-in-progress root. This is a bug in React. Please file an issue.\");\n            isHydrating$jscomp$0 || 0 !== (renderLanes & 60) || pushStoreConsistencyCheck(fiber, getSnapshot, getServerSnapshot);\n        }\n        return getServerSnapshot;\n    }\n    function pushStoreConsistencyCheck(fiber, getSnapshot, renderedSnapshot) {\n        fiber.flags |= 16384;\n        fiber = {\n            getSnapshot: getSnapshot,\n            value: renderedSnapshot\n        };\n        getSnapshot = currentlyRenderingFiber$1.updateQueue;\n        null === getSnapshot ? (getSnapshot = createFunctionComponentUpdateQueue(), currentlyRenderingFiber$1.updateQueue = getSnapshot, getSnapshot.stores = [\n            fiber\n        ]) : (renderedSnapshot = getSnapshot.stores, null === renderedSnapshot ? getSnapshot.stores = [\n            fiber\n        ] : renderedSnapshot.push(fiber));\n    }\n    function updateStoreInstance(fiber, inst, nextSnapshot, getSnapshot) {\n        inst.value = nextSnapshot;\n        inst.getSnapshot = getSnapshot;\n        checkIfSnapshotChanged(inst) && forceStoreRerender(fiber);\n    }\n    function subscribeToStore(fiber, inst, subscribe) {\n        return subscribe(function() {\n            checkIfSnapshotChanged(inst) && forceStoreRerender(fiber);\n        });\n    }\n    function checkIfSnapshotChanged(inst) {\n        var latestGetSnapshot = inst.getSnapshot;\n        inst = inst.value;\n        try {\n            var nextValue = latestGetSnapshot();\n            return !objectIs(inst, nextValue);\n        } catch (error) {\n            return !0;\n        }\n    }\n    function forceStoreRerender(fiber) {\n        var root = enqueueConcurrentRenderForLane(fiber, 2);\n        null !== root && scheduleUpdateOnFiber(root, fiber, 2);\n    }\n    function mountStateImpl(initialState) {\n        var hook = mountWorkInProgressHook();\n        if (\"function\" === typeof initialState) {\n            var initialStateInitializer = initialState;\n            initialState = initialStateInitializer();\n            if (shouldDoubleInvokeUserFnsInHooksDEV) {\n                setIsStrictModeForDevtools(!0);\n                try {\n                    initialStateInitializer();\n                } finally{\n                    setIsStrictModeForDevtools(!1);\n                }\n            }\n        }\n        hook.memoizedState = hook.baseState = initialState;\n        hook.queue = {\n            pending: null,\n            lanes: 0,\n            dispatch: null,\n            lastRenderedReducer: basicStateReducer,\n            lastRenderedState: initialState\n        };\n        return hook;\n    }\n    function mountState(initialState) {\n        initialState = mountStateImpl(initialState);\n        var queue = initialState.queue, dispatch = dispatchSetState.bind(null, currentlyRenderingFiber$1, queue);\n        queue.dispatch = dispatch;\n        return [\n            initialState.memoizedState,\n            dispatch\n        ];\n    }\n    function mountOptimistic(passthrough) {\n        var hook = mountWorkInProgressHook();\n        hook.memoizedState = hook.baseState = passthrough;\n        var queue = {\n            pending: null,\n            lanes: 0,\n            dispatch: null,\n            lastRenderedReducer: null,\n            lastRenderedState: null\n        };\n        hook.queue = queue;\n        hook = dispatchOptimisticSetState.bind(null, currentlyRenderingFiber$1, !0, queue);\n        queue.dispatch = hook;\n        return [\n            passthrough,\n            hook\n        ];\n    }\n    function updateOptimistic(passthrough, reducer) {\n        var hook = updateWorkInProgressHook();\n        return updateOptimisticImpl(hook, currentHook, passthrough, reducer);\n    }\n    function updateOptimisticImpl(hook, current, passthrough, reducer) {\n        hook.baseState = passthrough;\n        return updateReducerImpl(hook, currentHook, \"function\" === typeof reducer ? reducer : basicStateReducer);\n    }\n    function rerenderOptimistic(passthrough, reducer) {\n        var hook = updateWorkInProgressHook();\n        if (null !== currentHook) return updateOptimisticImpl(hook, currentHook, passthrough, reducer);\n        hook.baseState = passthrough;\n        return [\n            passthrough,\n            hook.queue.dispatch\n        ];\n    }\n    function dispatchActionState(fiber, actionQueue, setPendingState, setState, payload) {\n        if (isRenderPhaseUpdate(fiber)) throw Error(\"Cannot update form state while rendering.\");\n        fiber = actionQueue.action;\n        if (null !== fiber) {\n            var actionNode = {\n                payload: payload,\n                action: fiber,\n                next: null,\n                isTransition: !0,\n                status: \"pending\",\n                value: null,\n                reason: null,\n                listeners: [],\n                then: function(listener) {\n                    actionNode.listeners.push(listener);\n                }\n            };\n            null !== ReactSharedInternals.T ? setPendingState(!0) : actionNode.isTransition = !1;\n            setState(actionNode);\n            setPendingState = actionQueue.pending;\n            null === setPendingState ? (actionNode.next = actionQueue.pending = actionNode, runActionStateAction(actionQueue, actionNode)) : (actionNode.next = setPendingState.next, actionQueue.pending = setPendingState.next = actionNode);\n        }\n    }\n    function runActionStateAction(actionQueue, node) {\n        var action = node.action, payload = node.payload, prevState = actionQueue.state;\n        if (node.isTransition) {\n            var prevTransition = ReactSharedInternals.T, currentTransition = {};\n            ReactSharedInternals.T = currentTransition;\n            ReactSharedInternals.T._updatedFibers = new Set();\n            try {\n                var returnValue = action(prevState, payload), onStartTransitionFinish = ReactSharedInternals.S;\n                null !== onStartTransitionFinish && onStartTransitionFinish(currentTransition, returnValue);\n                handleActionReturnValue(actionQueue, node, returnValue);\n            } catch (error) {\n                onActionError(actionQueue, node, error);\n            } finally{\n                ReactSharedInternals.T = prevTransition, null === prevTransition && currentTransition._updatedFibers && (actionQueue = currentTransition._updatedFibers.size, currentTransition._updatedFibers.clear(), 10 < actionQueue && console.warn(\"Detected a large number of updates inside startTransition. If this is due to a subscription please re-write it to use React provided hooks. Otherwise concurrent mode guarantees are off the table.\"));\n            }\n        } else try {\n            currentTransition = action(prevState, payload), handleActionReturnValue(actionQueue, node, currentTransition);\n        } catch (error$2) {\n            onActionError(actionQueue, node, error$2);\n        }\n    }\n    function handleActionReturnValue(actionQueue, node, returnValue) {\n        null !== returnValue && \"object\" === typeof returnValue && \"function\" === typeof returnValue.then ? (returnValue.then(function(nextState) {\n            onActionSuccess(actionQueue, node, nextState);\n        }, function(error) {\n            return onActionError(actionQueue, node, error);\n        }), node.isTransition || console.error(\"An async function was passed to useActionState, but it was dispatched outside of an action context. This is likely not what you intended. Either pass the dispatch function to an `action` prop, or dispatch manually inside `startTransition`\")) : onActionSuccess(actionQueue, node, returnValue);\n    }\n    function onActionSuccess(actionQueue, actionNode, nextState) {\n        actionNode.status = \"fulfilled\";\n        actionNode.value = nextState;\n        notifyActionListeners(actionNode);\n        actionQueue.state = nextState;\n        actionNode = actionQueue.pending;\n        null !== actionNode && (nextState = actionNode.next, nextState === actionNode ? actionQueue.pending = null : (nextState = nextState.next, actionNode.next = nextState, runActionStateAction(actionQueue, nextState)));\n    }\n    function onActionError(actionQueue, actionNode, error) {\n        var last = actionQueue.pending;\n        actionQueue.pending = null;\n        if (null !== last) {\n            last = last.next;\n            do actionNode.status = \"rejected\", actionNode.reason = error, notifyActionListeners(actionNode), actionNode = actionNode.next;\n            while (actionNode !== last);\n        }\n        actionQueue.action = null;\n    }\n    function notifyActionListeners(actionNode) {\n        actionNode = actionNode.listeners;\n        for(var i = 0; i < actionNode.length; i++)(0, actionNode[i])();\n    }\n    function actionStateReducer(oldState, newState) {\n        return newState;\n    }\n    function mountActionState(action, initialStateProp) {\n        if (isHydrating) {\n            var ssrFormState = workInProgressRoot.formState;\n            if (null !== ssrFormState) {\n                a: {\n                    var isMatching = currentlyRenderingFiber$1;\n                    if (isHydrating) {\n                        if (nextHydratableInstance) {\n                            var markerInstance = canHydrateFormStateMarker(nextHydratableInstance, rootOrSingletonContext);\n                            if (markerInstance) {\n                                nextHydratableInstance = getNextHydratableSibling(markerInstance);\n                                isMatching = isFormStateMarkerMatching(markerInstance);\n                                break a;\n                            }\n                        }\n                        throwOnHydrationMismatch(isMatching);\n                    }\n                    isMatching = !1;\n                }\n                isMatching && (initialStateProp = ssrFormState[0]);\n            }\n        }\n        ssrFormState = mountWorkInProgressHook();\n        ssrFormState.memoizedState = ssrFormState.baseState = initialStateProp;\n        isMatching = {\n            pending: null,\n            lanes: 0,\n            dispatch: null,\n            lastRenderedReducer: actionStateReducer,\n            lastRenderedState: initialStateProp\n        };\n        ssrFormState.queue = isMatching;\n        ssrFormState = dispatchSetState.bind(null, currentlyRenderingFiber$1, isMatching);\n        isMatching.dispatch = ssrFormState;\n        isMatching = mountStateImpl(!1);\n        var setPendingState = dispatchOptimisticSetState.bind(null, currentlyRenderingFiber$1, !1, isMatching.queue);\n        isMatching = mountWorkInProgressHook();\n        markerInstance = {\n            state: initialStateProp,\n            dispatch: null,\n            action: action,\n            pending: null\n        };\n        isMatching.queue = markerInstance;\n        ssrFormState = dispatchActionState.bind(null, currentlyRenderingFiber$1, markerInstance, setPendingState, ssrFormState);\n        markerInstance.dispatch = ssrFormState;\n        isMatching.memoizedState = action;\n        return [\n            initialStateProp,\n            ssrFormState,\n            !1\n        ];\n    }\n    function updateActionState(action) {\n        var stateHook = updateWorkInProgressHook();\n        return updateActionStateImpl(stateHook, currentHook, action);\n    }\n    function updateActionStateImpl(stateHook, currentStateHook, action) {\n        currentStateHook = updateReducerImpl(stateHook, currentStateHook, actionStateReducer)[0];\n        stateHook = updateReducer(basicStateReducer)[0];\n        currentStateHook = \"object\" === typeof currentStateHook && null !== currentStateHook && \"function\" === typeof currentStateHook.then ? useThenable(currentStateHook) : currentStateHook;\n        var actionQueueHook = updateWorkInProgressHook(), actionQueue = actionQueueHook.queue, dispatch = actionQueue.dispatch;\n        action !== actionQueueHook.memoizedState && (currentlyRenderingFiber$1.flags |= 2048, pushEffect(HasEffect | Passive, actionStateActionEffect.bind(null, actionQueue, action), {\n            destroy: void 0\n        }, null));\n        return [\n            currentStateHook,\n            dispatch,\n            stateHook\n        ];\n    }\n    function actionStateActionEffect(actionQueue, action) {\n        actionQueue.action = action;\n    }\n    function rerenderActionState(action) {\n        var stateHook = updateWorkInProgressHook(), currentStateHook = currentHook;\n        if (null !== currentStateHook) return updateActionStateImpl(stateHook, currentStateHook, action);\n        updateWorkInProgressHook();\n        stateHook = stateHook.memoizedState;\n        currentStateHook = updateWorkInProgressHook();\n        var dispatch = currentStateHook.queue.dispatch;\n        currentStateHook.memoizedState = action;\n        return [\n            stateHook,\n            dispatch,\n            !1\n        ];\n    }\n    function pushEffect(tag, create, inst, deps) {\n        tag = {\n            tag: tag,\n            create: create,\n            inst: inst,\n            deps: deps,\n            next: null\n        };\n        create = currentlyRenderingFiber$1.updateQueue;\n        null === create && (create = createFunctionComponentUpdateQueue(), currentlyRenderingFiber$1.updateQueue = create);\n        inst = create.lastEffect;\n        null === inst ? create.lastEffect = tag.next = tag : (deps = inst.next, inst.next = tag, tag.next = deps, create.lastEffect = tag);\n        return tag;\n    }\n    function mountRef(initialValue) {\n        var hook = mountWorkInProgressHook();\n        initialValue = {\n            current: initialValue\n        };\n        return hook.memoizedState = initialValue;\n    }\n    function mountEffectImpl(fiberFlags, hookFlags, create, deps) {\n        var hook = mountWorkInProgressHook();\n        currentlyRenderingFiber$1.flags |= fiberFlags;\n        hook.memoizedState = pushEffect(HasEffect | hookFlags, create, {\n            destroy: void 0\n        }, void 0 === deps ? null : deps);\n    }\n    function updateEffectImpl(fiberFlags, hookFlags, create, deps) {\n        var hook = updateWorkInProgressHook();\n        deps = void 0 === deps ? null : deps;\n        var inst = hook.memoizedState.inst;\n        null !== currentHook && null !== deps && areHookInputsEqual(deps, currentHook.memoizedState.deps) ? hook.memoizedState = pushEffect(hookFlags, create, inst, deps) : (currentlyRenderingFiber$1.flags |= fiberFlags, hook.memoizedState = pushEffect(HasEffect | hookFlags, create, inst, deps));\n    }\n    function mountEffect(create, deps) {\n        (currentlyRenderingFiber$1.mode & 16) !== NoMode && (currentlyRenderingFiber$1.mode & 64) === NoMode ? mountEffectImpl(142608384, Passive, create, deps) : mountEffectImpl(8390656, Passive, create, deps);\n    }\n    function mountLayoutEffect(create, deps) {\n        var fiberFlags = 4194308;\n        (currentlyRenderingFiber$1.mode & 16) !== NoMode && (fiberFlags |= 67108864);\n        return mountEffectImpl(fiberFlags, Layout, create, deps);\n    }\n    function imperativeHandleEffect(create, ref) {\n        if (\"function\" === typeof ref) {\n            create = create();\n            var refCleanup = ref(create);\n            return function() {\n                \"function\" === typeof refCleanup ? refCleanup() : ref(null);\n            };\n        }\n        if (null !== ref && void 0 !== ref) return ref.hasOwnProperty(\"current\") || console.error(\"Expected useImperativeHandle() first argument to either be a ref callback or React.createRef() object. Instead received: %s.\", \"an object with keys {\" + Object.keys(ref).join(\", \") + \"}\"), create = create(), ref.current = create, function() {\n            ref.current = null;\n        };\n    }\n    function mountImperativeHandle(ref, create, deps) {\n        \"function\" !== typeof create && console.error(\"Expected useImperativeHandle() second argument to be a function that creates a handle. Instead received: %s.\", null !== create ? typeof create : \"null\");\n        deps = null !== deps && void 0 !== deps ? deps.concat([\n            ref\n        ]) : null;\n        var fiberFlags = 4194308;\n        (currentlyRenderingFiber$1.mode & 16) !== NoMode && (fiberFlags |= 67108864);\n        mountEffectImpl(fiberFlags, Layout, imperativeHandleEffect.bind(null, create, ref), deps);\n    }\n    function updateImperativeHandle(ref, create, deps) {\n        \"function\" !== typeof create && console.error(\"Expected useImperativeHandle() second argument to be a function that creates a handle. Instead received: %s.\", null !== create ? typeof create : \"null\");\n        deps = null !== deps && void 0 !== deps ? deps.concat([\n            ref\n        ]) : null;\n        updateEffectImpl(4, Layout, imperativeHandleEffect.bind(null, create, ref), deps);\n    }\n    function mountCallback(callback, deps) {\n        mountWorkInProgressHook().memoizedState = [\n            callback,\n            void 0 === deps ? null : deps\n        ];\n        return callback;\n    }\n    function updateCallback(callback, deps) {\n        var hook = updateWorkInProgressHook();\n        deps = void 0 === deps ? null : deps;\n        var prevState = hook.memoizedState;\n        if (null !== deps && areHookInputsEqual(deps, prevState[1])) return prevState[0];\n        hook.memoizedState = [\n            callback,\n            deps\n        ];\n        return callback;\n    }\n    function mountMemo(nextCreate, deps) {\n        var hook = mountWorkInProgressHook();\n        deps = void 0 === deps ? null : deps;\n        var nextValue = nextCreate();\n        if (shouldDoubleInvokeUserFnsInHooksDEV) {\n            setIsStrictModeForDevtools(!0);\n            try {\n                nextCreate();\n            } finally{\n                setIsStrictModeForDevtools(!1);\n            }\n        }\n        hook.memoizedState = [\n            nextValue,\n            deps\n        ];\n        return nextValue;\n    }\n    function updateMemo(nextCreate, deps) {\n        var hook = updateWorkInProgressHook();\n        deps = void 0 === deps ? null : deps;\n        var prevState = hook.memoizedState;\n        if (null !== deps && areHookInputsEqual(deps, prevState[1])) return prevState[0];\n        prevState = nextCreate();\n        if (shouldDoubleInvokeUserFnsInHooksDEV) {\n            setIsStrictModeForDevtools(!0);\n            try {\n                nextCreate();\n            } finally{\n                setIsStrictModeForDevtools(!1);\n            }\n        }\n        hook.memoizedState = [\n            prevState,\n            deps\n        ];\n        return prevState;\n    }\n    function mountDeferredValue(value, initialValue) {\n        var hook = mountWorkInProgressHook();\n        return mountDeferredValueImpl(hook, value, initialValue);\n    }\n    function updateDeferredValue(value, initialValue) {\n        var hook = updateWorkInProgressHook();\n        return updateDeferredValueImpl(hook, currentHook.memoizedState, value, initialValue);\n    }\n    function rerenderDeferredValue(value, initialValue) {\n        var hook = updateWorkInProgressHook();\n        return null === currentHook ? mountDeferredValueImpl(hook, value, initialValue) : updateDeferredValueImpl(hook, currentHook.memoizedState, value, initialValue);\n    }\n    function mountDeferredValueImpl(hook, value, initialValue) {\n        if (void 0 === initialValue || 0 !== (renderLanes & 1073741824)) return hook.memoizedState = value;\n        hook.memoizedState = initialValue;\n        hook = requestDeferredLane();\n        currentlyRenderingFiber$1.lanes |= hook;\n        workInProgressRootSkippedLanes |= hook;\n        return initialValue;\n    }\n    function updateDeferredValueImpl(hook, prevValue, value, initialValue) {\n        if (objectIs(value, prevValue)) return value;\n        if (null !== currentTreeHiddenStackCursor.current) return hook = mountDeferredValueImpl(hook, value, initialValue), objectIs(hook, prevValue) || (didReceiveUpdate = !0), hook;\n        if (0 === (renderLanes & 42)) return didReceiveUpdate = !0, hook.memoizedState = value;\n        hook = requestDeferredLane();\n        currentlyRenderingFiber$1.lanes |= hook;\n        workInProgressRootSkippedLanes |= hook;\n        return prevValue;\n    }\n    function startTransition(fiber, queue, pendingState, finishedState, callback) {\n        var previousPriority = getCurrentUpdatePriority();\n        setCurrentUpdatePriority(0 !== previousPriority && 8 > previousPriority ? previousPriority : 8);\n        var prevTransition = ReactSharedInternals.T, currentTransition = {};\n        ReactSharedInternals.T = currentTransition;\n        dispatchOptimisticSetState(fiber, !1, queue, pendingState);\n        currentTransition._updatedFibers = new Set();\n        try {\n            var returnValue = callback(), onStartTransitionFinish = ReactSharedInternals.S;\n            null !== onStartTransitionFinish && onStartTransitionFinish(currentTransition, returnValue);\n            if (null !== returnValue && \"object\" === typeof returnValue && \"function\" === typeof returnValue.then) {\n                var thenableForFinishedState = chainThenableValue(returnValue, finishedState);\n                dispatchSetStateInternal(fiber, queue, thenableForFinishedState, requestUpdateLane(fiber));\n            } else dispatchSetStateInternal(fiber, queue, finishedState, requestUpdateLane(fiber));\n        } catch (error) {\n            dispatchSetStateInternal(fiber, queue, {\n                then: function() {},\n                status: \"rejected\",\n                reason: error\n            }, requestUpdateLane(fiber));\n        } finally{\n            setCurrentUpdatePriority(previousPriority), ReactSharedInternals.T = prevTransition, null === prevTransition && currentTransition._updatedFibers && (fiber = currentTransition._updatedFibers.size, currentTransition._updatedFibers.clear(), 10 < fiber && console.warn(\"Detected a large number of updates inside startTransition. If this is due to a subscription please re-write it to use React provided hooks. Otherwise concurrent mode guarantees are off the table.\"));\n        }\n    }\n    function ensureFormComponentIsStateful(formFiber) {\n        var existingStateHook = formFiber.memoizedState;\n        if (null !== existingStateHook) return existingStateHook;\n        existingStateHook = {\n            memoizedState: NotPendingTransition,\n            baseState: NotPendingTransition,\n            baseQueue: null,\n            queue: {\n                pending: null,\n                lanes: 0,\n                dispatch: null,\n                lastRenderedReducer: basicStateReducer,\n                lastRenderedState: NotPendingTransition\n            },\n            next: null\n        };\n        var initialResetState = {};\n        existingStateHook.next = {\n            memoizedState: initialResetState,\n            baseState: initialResetState,\n            baseQueue: null,\n            queue: {\n                pending: null,\n                lanes: 0,\n                dispatch: null,\n                lastRenderedReducer: basicStateReducer,\n                lastRenderedState: initialResetState\n            },\n            next: null\n        };\n        formFiber.memoizedState = existingStateHook;\n        formFiber = formFiber.alternate;\n        null !== formFiber && (formFiber.memoizedState = existingStateHook);\n        return existingStateHook;\n    }\n    function mountTransition() {\n        var stateHook = mountStateImpl(!1);\n        stateHook = startTransition.bind(null, currentlyRenderingFiber$1, stateHook.queue, !0, !1);\n        mountWorkInProgressHook().memoizedState = stateHook;\n        return [\n            !1,\n            stateHook\n        ];\n    }\n    function updateTransition() {\n        var booleanOrThenable = updateReducer(basicStateReducer)[0], start = updateWorkInProgressHook().memoizedState;\n        return [\n            \"boolean\" === typeof booleanOrThenable ? booleanOrThenable : useThenable(booleanOrThenable),\n            start\n        ];\n    }\n    function rerenderTransition() {\n        var booleanOrThenable = rerenderReducer(basicStateReducer)[0], start = updateWorkInProgressHook().memoizedState;\n        return [\n            \"boolean\" === typeof booleanOrThenable ? booleanOrThenable : useThenable(booleanOrThenable),\n            start\n        ];\n    }\n    function useHostTransitionStatus() {\n        return readContext(HostTransitionContext);\n    }\n    function mountId() {\n        var hook = mountWorkInProgressHook(), identifierPrefix = workInProgressRoot.identifierPrefix;\n        if (isHydrating) {\n            var treeId = treeContextOverflow;\n            var idWithLeadingBit = treeContextId;\n            treeId = (idWithLeadingBit & ~(1 << 32 - clz32(idWithLeadingBit) - 1)).toString(32) + treeId;\n            identifierPrefix = \":\" + identifierPrefix + \"R\" + treeId;\n            treeId = localIdCounter++;\n            0 < treeId && (identifierPrefix += \"H\" + treeId.toString(32));\n            identifierPrefix += \":\";\n        } else treeId = globalClientIdCounter++, identifierPrefix = \":\" + identifierPrefix + \"r\" + treeId.toString(32) + \":\";\n        return hook.memoizedState = identifierPrefix;\n    }\n    function mountRefresh() {\n        return mountWorkInProgressHook().memoizedState = refreshCache.bind(null, currentlyRenderingFiber$1);\n    }\n    function refreshCache(fiber, seedKey) {\n        for(var provider = fiber.return; null !== provider;){\n            switch(provider.tag){\n                case 24:\n                case 3:\n                    var lane = requestUpdateLane(provider);\n                    fiber = createUpdate(lane);\n                    var root = enqueueUpdate(provider, fiber, lane);\n                    null !== root && (scheduleUpdateOnFiber(root, provider, lane), entangleTransitions(root, provider, lane));\n                    provider = createCache();\n                    null !== seedKey && void 0 !== seedKey && null !== root && console.error(\"The seed argument is not enabled outside experimental channels.\");\n                    fiber.payload = {\n                        cache: provider\n                    };\n                    return;\n            }\n            provider = provider.return;\n        }\n    }\n    function dispatchReducerAction(fiber, queue, action, JSCompiler_OptimizeArgumentsArray_p0) {\n        \"function\" === typeof JSCompiler_OptimizeArgumentsArray_p0 && console.error(\"State updates from the useState() and useReducer() Hooks don't support the second callback argument. To execute a side effect after rendering, declare it in the component body with useEffect().\");\n        JSCompiler_OptimizeArgumentsArray_p0 = requestUpdateLane(fiber);\n        action = {\n            lane: JSCompiler_OptimizeArgumentsArray_p0,\n            revertLane: 0,\n            action: action,\n            hasEagerState: !1,\n            eagerState: null,\n            next: null\n        };\n        isRenderPhaseUpdate(fiber) ? enqueueRenderPhaseUpdate(queue, action) : (action = enqueueConcurrentHookUpdate(fiber, queue, action, JSCompiler_OptimizeArgumentsArray_p0), null !== action && (scheduleUpdateOnFiber(action, fiber, JSCompiler_OptimizeArgumentsArray_p0), entangleTransitionUpdate(action, queue, JSCompiler_OptimizeArgumentsArray_p0)));\n        markStateUpdateScheduled(fiber, JSCompiler_OptimizeArgumentsArray_p0);\n    }\n    function dispatchSetState(fiber, queue, action, JSCompiler_OptimizeArgumentsArray_p1) {\n        \"function\" === typeof JSCompiler_OptimizeArgumentsArray_p1 && console.error(\"State updates from the useState() and useReducer() Hooks don't support the second callback argument. To execute a side effect after rendering, declare it in the component body with useEffect().\");\n        JSCompiler_OptimizeArgumentsArray_p1 = requestUpdateLane(fiber);\n        dispatchSetStateInternal(fiber, queue, action, JSCompiler_OptimizeArgumentsArray_p1);\n        markStateUpdateScheduled(fiber, JSCompiler_OptimizeArgumentsArray_p1);\n    }\n    function dispatchSetStateInternal(fiber, queue, action, lane) {\n        var update = {\n            lane: lane,\n            revertLane: 0,\n            action: action,\n            hasEagerState: !1,\n            eagerState: null,\n            next: null\n        };\n        if (isRenderPhaseUpdate(fiber)) enqueueRenderPhaseUpdate(queue, update);\n        else {\n            var alternate = fiber.alternate;\n            if (0 === fiber.lanes && (null === alternate || 0 === alternate.lanes) && (alternate = queue.lastRenderedReducer, null !== alternate)) {\n                var prevDispatcher = ReactSharedInternals.H;\n                ReactSharedInternals.H = InvalidNestedHooksDispatcherOnUpdateInDEV;\n                try {\n                    var currentState = queue.lastRenderedState, eagerState = alternate(currentState, action);\n                    update.hasEagerState = !0;\n                    update.eagerState = eagerState;\n                    if (objectIs(eagerState, currentState)) return enqueueUpdate$1(fiber, queue, update, 0), null === workInProgressRoot && finishQueueingConcurrentUpdates(), !1;\n                } catch (error) {} finally{\n                    ReactSharedInternals.H = prevDispatcher;\n                }\n            }\n            action = enqueueConcurrentHookUpdate(fiber, queue, update, lane);\n            if (null !== action) return scheduleUpdateOnFiber(action, fiber, lane), entangleTransitionUpdate(action, queue, lane), !0;\n        }\n        return !1;\n    }\n    function dispatchOptimisticSetState(fiber, throwIfDuringRender, queue, action) {\n        null === ReactSharedInternals.T && 0 === currentEntangledLane && console.error(\"An optimistic state update occurred outside a transition or action. To fix, move the update to an action, or wrap with startTransition.\");\n        action = {\n            lane: 2,\n            revertLane: requestTransitionLane(),\n            action: action,\n            hasEagerState: !1,\n            eagerState: null,\n            next: null\n        };\n        if (isRenderPhaseUpdate(fiber)) {\n            if (throwIfDuringRender) throw Error(\"Cannot update optimistic state while rendering.\");\n            console.error(\"Cannot call startTransition while rendering.\");\n        } else throwIfDuringRender = enqueueConcurrentHookUpdate(fiber, queue, action, 2), null !== throwIfDuringRender && scheduleUpdateOnFiber(throwIfDuringRender, fiber, 2);\n        markStateUpdateScheduled(fiber, 2);\n    }\n    function isRenderPhaseUpdate(fiber) {\n        var alternate = fiber.alternate;\n        return fiber === currentlyRenderingFiber$1 || null !== alternate && alternate === currentlyRenderingFiber$1;\n    }\n    function enqueueRenderPhaseUpdate(queue, update) {\n        didScheduleRenderPhaseUpdateDuringThisPass = didScheduleRenderPhaseUpdate = !0;\n        var pending = queue.pending;\n        null === pending ? update.next = update : (update.next = pending.next, pending.next = update);\n        queue.pending = update;\n    }\n    function entangleTransitionUpdate(root, queue, lane) {\n        if (0 !== (lane & 4194176)) {\n            var queueLanes = queue.lanes;\n            queueLanes &= root.pendingLanes;\n            lane |= queueLanes;\n            queue.lanes = lane;\n            markRootEntangled(root, lane);\n        }\n    }\n    function warnOnInvalidCallback(callback) {\n        if (null !== callback && \"function\" !== typeof callback) {\n            var key = String(callback);\n            didWarnOnInvalidCallback.has(key) || (didWarnOnInvalidCallback.add(key), console.error(\"Expected the last optional `callback` argument to be a function. Instead received: %s.\", callback));\n        }\n    }\n    function applyDerivedStateFromProps(workInProgress, ctor, getDerivedStateFromProps, nextProps) {\n        var prevState = workInProgress.memoizedState, partialState = getDerivedStateFromProps(nextProps, prevState);\n        if (workInProgress.mode & 8) {\n            setIsStrictModeForDevtools(!0);\n            try {\n                partialState = getDerivedStateFromProps(nextProps, prevState);\n            } finally{\n                setIsStrictModeForDevtools(!1);\n            }\n        }\n        void 0 === partialState && (ctor = getComponentNameFromType(ctor) || \"Component\", didWarnAboutUndefinedDerivedState.has(ctor) || (didWarnAboutUndefinedDerivedState.add(ctor), console.error(\"%s.getDerivedStateFromProps(): A valid state object (or null) must be returned. You have returned undefined.\", ctor)));\n        prevState = null === partialState || void 0 === partialState ? prevState : assign({}, prevState, partialState);\n        workInProgress.memoizedState = prevState;\n        0 === workInProgress.lanes && (workInProgress.updateQueue.baseState = prevState);\n    }\n    function checkShouldComponentUpdate(workInProgress, ctor, oldProps, newProps, oldState, newState, nextContext) {\n        var instance = workInProgress.stateNode;\n        if (\"function\" === typeof instance.shouldComponentUpdate) {\n            oldProps = instance.shouldComponentUpdate(newProps, newState, nextContext);\n            if (workInProgress.mode & 8) {\n                setIsStrictModeForDevtools(!0);\n                try {\n                    oldProps = instance.shouldComponentUpdate(newProps, newState, nextContext);\n                } finally{\n                    setIsStrictModeForDevtools(!1);\n                }\n            }\n            void 0 === oldProps && console.error(\"%s.shouldComponentUpdate(): Returned undefined instead of a boolean value. Make sure to return true or false.\", getComponentNameFromType(ctor) || \"Component\");\n            return oldProps;\n        }\n        return ctor.prototype && ctor.prototype.isPureReactComponent ? !shallowEqual(oldProps, newProps) || !shallowEqual(oldState, newState) : !0;\n    }\n    function callComponentWillReceiveProps(workInProgress, instance, newProps, nextContext) {\n        var oldState = instance.state;\n        \"function\" === typeof instance.componentWillReceiveProps && instance.componentWillReceiveProps(newProps, nextContext);\n        \"function\" === typeof instance.UNSAFE_componentWillReceiveProps && instance.UNSAFE_componentWillReceiveProps(newProps, nextContext);\n        instance.state !== oldState && (workInProgress = getComponentNameFromFiber(workInProgress) || \"Component\", didWarnAboutStateAssignmentForComponent.has(workInProgress) || (didWarnAboutStateAssignmentForComponent.add(workInProgress), console.error(\"%s.componentWillReceiveProps(): Assigning directly to this.state is deprecated (except inside a component's constructor). Use setState instead.\", workInProgress)), classComponentUpdater.enqueueReplaceState(instance, instance.state, null));\n    }\n    function resolveClassComponentProps(Component, baseProps) {\n        var newProps = baseProps;\n        if (\"ref\" in baseProps) {\n            newProps = {};\n            for(var propName in baseProps)\"ref\" !== propName && (newProps[propName] = baseProps[propName]);\n        }\n        if (Component = Component.defaultProps) {\n            newProps === baseProps && (newProps = assign({}, newProps));\n            for(var _propName in Component)void 0 === newProps[_propName] && (newProps[_propName] = Component[_propName]);\n        }\n        return newProps;\n    }\n    function logUncaughtError(root, errorInfo) {\n        try {\n            componentName = errorInfo.source ? getComponentNameFromFiber(errorInfo.source) : null;\n            errorBoundaryName = null;\n            var error = errorInfo.value;\n            if (null !== ReactSharedInternals.actQueue) ReactSharedInternals.thrownErrors.push(error);\n            else {\n                var onUncaughtError = root.onUncaughtError;\n                onUncaughtError(error, {\n                    componentStack: errorInfo.stack\n                });\n            }\n        } catch (e) {\n            setTimeout(function() {\n                throw e;\n            });\n        }\n    }\n    function logCaughtError(root, boundary, errorInfo) {\n        try {\n            componentName = errorInfo.source ? getComponentNameFromFiber(errorInfo.source) : null;\n            errorBoundaryName = getComponentNameFromFiber(boundary);\n            var onCaughtError = root.onCaughtError;\n            onCaughtError(errorInfo.value, {\n                componentStack: errorInfo.stack,\n                errorBoundary: 1 === boundary.tag ? boundary.stateNode : null\n            });\n        } catch (e) {\n            setTimeout(function() {\n                throw e;\n            });\n        }\n    }\n    function createRootErrorUpdate(root, errorInfo, lane) {\n        lane = createUpdate(lane);\n        lane.tag = CaptureUpdate;\n        lane.payload = {\n            element: null\n        };\n        lane.callback = function() {\n            runWithFiberInDEV(errorInfo.source, logUncaughtError, root, errorInfo);\n        };\n        return lane;\n    }\n    function createClassErrorUpdate(lane) {\n        lane = createUpdate(lane);\n        lane.tag = CaptureUpdate;\n        return lane;\n    }\n    function initializeClassErrorUpdate(update, root, fiber, errorInfo) {\n        var getDerivedStateFromError = fiber.type.getDerivedStateFromError;\n        if (\"function\" === typeof getDerivedStateFromError) {\n            var error = errorInfo.value;\n            update.payload = function() {\n                return getDerivedStateFromError(error);\n            };\n            update.callback = function() {\n                markFailedErrorBoundaryForHotReloading(fiber);\n                runWithFiberInDEV(errorInfo.source, logCaughtError, root, fiber, errorInfo);\n            };\n        }\n        var inst = fiber.stateNode;\n        null !== inst && \"function\" === typeof inst.componentDidCatch && (update.callback = function() {\n            markFailedErrorBoundaryForHotReloading(fiber);\n            runWithFiberInDEV(errorInfo.source, logCaughtError, root, fiber, errorInfo);\n            \"function\" !== typeof getDerivedStateFromError && (null === legacyErrorBoundariesThatAlreadyFailed ? legacyErrorBoundariesThatAlreadyFailed = new Set([\n                this\n            ]) : legacyErrorBoundariesThatAlreadyFailed.add(this));\n            callComponentDidCatchInDEV(this, errorInfo);\n            \"function\" === typeof getDerivedStateFromError || 0 === (fiber.lanes & 2) && console.error(\"%s: Error boundaries should implement getDerivedStateFromError(). In that method, return a state update to display an error message or fallback UI.\", getComponentNameFromFiber(fiber) || \"Unknown\");\n        });\n    }\n    function throwException(root, returnFiber, sourceFiber, value, rootRenderLanes) {\n        sourceFiber.flags |= 32768;\n        isDevToolsPresent && restorePendingUpdaters(root, rootRenderLanes);\n        if (null !== value && \"object\" === typeof value && \"function\" === typeof value.then) {\n            returnFiber = sourceFiber.alternate;\n            null !== returnFiber && propagateParentContextChanges(returnFiber, sourceFiber, rootRenderLanes, !0);\n            isHydrating && (didSuspendOrErrorDEV = !0);\n            sourceFiber = suspenseHandlerStackCursor.current;\n            if (null !== sourceFiber) {\n                switch(sourceFiber.tag){\n                    case 13:\n                        return null === shellBoundary ? renderDidSuspendDelayIfPossible() : null === sourceFiber.alternate && workInProgressRootExitStatus === RootInProgress && (workInProgressRootExitStatus = RootSuspended), sourceFiber.flags &= -257, sourceFiber.flags |= 65536, sourceFiber.lanes = rootRenderLanes, value === noopSuspenseyCommitThenable ? sourceFiber.flags |= 16384 : (returnFiber = sourceFiber.updateQueue, null === returnFiber ? sourceFiber.updateQueue = new Set([\n                            value\n                        ]) : returnFiber.add(value), attachPingListener(root, value, rootRenderLanes)), !1;\n                    case 22:\n                        return sourceFiber.flags |= 65536, value === noopSuspenseyCommitThenable ? sourceFiber.flags |= 16384 : (returnFiber = sourceFiber.updateQueue, null === returnFiber ? (returnFiber = {\n                            transitions: null,\n                            markerInstances: null,\n                            retryQueue: new Set([\n                                value\n                            ])\n                        }, sourceFiber.updateQueue = returnFiber) : (sourceFiber = returnFiber.retryQueue, null === sourceFiber ? returnFiber.retryQueue = new Set([\n                            value\n                        ]) : sourceFiber.add(value)), attachPingListener(root, value, rootRenderLanes)), !1;\n                }\n                throw Error(\"Unexpected Suspense handler tag (\" + sourceFiber.tag + \"). This is a bug in React.\");\n            }\n            attachPingListener(root, value, rootRenderLanes);\n            renderDidSuspendDelayIfPossible();\n            return !1;\n        }\n        if (isHydrating) return didSuspendOrErrorDEV = !0, returnFiber = suspenseHandlerStackCursor.current, null !== returnFiber ? (0 === (returnFiber.flags & 65536) && (returnFiber.flags |= 256), returnFiber.flags |= 65536, returnFiber.lanes = rootRenderLanes, value !== HydrationMismatchException && queueHydrationError(createCapturedValueAtFiber(Error(\"There was an error while hydrating but React was able to recover by instead client rendering from the nearest Suspense boundary.\", {\n            cause: value\n        }), sourceFiber))) : (value !== HydrationMismatchException && queueHydrationError(createCapturedValueAtFiber(Error(\"There was an error while hydrating but React was able to recover by instead client rendering the entire root.\", {\n            cause: value\n        }), sourceFiber)), root = root.current.alternate, root.flags |= 65536, rootRenderLanes &= -rootRenderLanes, root.lanes |= rootRenderLanes, value = createCapturedValueAtFiber(value, sourceFiber), rootRenderLanes = createRootErrorUpdate(root.stateNode, value, rootRenderLanes), enqueueCapturedUpdate(root, rootRenderLanes), workInProgressRootExitStatus !== RootSuspendedWithDelay && (workInProgressRootExitStatus = RootErrored)), !1;\n        var error = createCapturedValueAtFiber(Error(\"There was an error during concurrent rendering but React was able to recover by instead synchronously rendering the entire root.\", {\n            cause: value\n        }), sourceFiber);\n        null === workInProgressRootConcurrentErrors ? workInProgressRootConcurrentErrors = [\n            error\n        ] : workInProgressRootConcurrentErrors.push(error);\n        workInProgressRootExitStatus !== RootSuspendedWithDelay && (workInProgressRootExitStatus = RootErrored);\n        if (null === returnFiber) return !0;\n        value = createCapturedValueAtFiber(value, sourceFiber);\n        sourceFiber = returnFiber;\n        do {\n            switch(sourceFiber.tag){\n                case 3:\n                    return sourceFiber.flags |= 65536, root = rootRenderLanes & -rootRenderLanes, sourceFiber.lanes |= root, root = createRootErrorUpdate(sourceFiber.stateNode, value, root), enqueueCapturedUpdate(sourceFiber, root), !1;\n                case 1:\n                    if (returnFiber = sourceFiber.type, error = sourceFiber.stateNode, 0 === (sourceFiber.flags & 128) && (\"function\" === typeof returnFiber.getDerivedStateFromError || null !== error && \"function\" === typeof error.componentDidCatch && (null === legacyErrorBoundariesThatAlreadyFailed || !legacyErrorBoundariesThatAlreadyFailed.has(error)))) return sourceFiber.flags |= 65536, rootRenderLanes &= -rootRenderLanes, sourceFiber.lanes |= rootRenderLanes, rootRenderLanes = createClassErrorUpdate(rootRenderLanes), initializeClassErrorUpdate(rootRenderLanes, root, sourceFiber, value), enqueueCapturedUpdate(sourceFiber, rootRenderLanes), !1;\n            }\n            sourceFiber = sourceFiber.return;\n        }while (null !== sourceFiber);\n        return !1;\n    }\n    function reconcileChildren(current, workInProgress, nextChildren, renderLanes) {\n        workInProgress.child = null === current ? mountChildFibers(workInProgress, null, nextChildren, renderLanes) : reconcileChildFibers(workInProgress, current.child, nextChildren, renderLanes);\n    }\n    function updateForwardRef(current, workInProgress, Component, nextProps, renderLanes) {\n        Component = Component.render;\n        var ref = workInProgress.ref;\n        if (\"ref\" in nextProps) {\n            var propsWithoutRef = {};\n            for(var key in nextProps)\"ref\" !== key && (propsWithoutRef[key] = nextProps[key]);\n        } else propsWithoutRef = nextProps;\n        prepareToReadContext(workInProgress);\n        markComponentRenderStarted(workInProgress);\n        nextProps = renderWithHooks(current, workInProgress, Component, propsWithoutRef, ref, renderLanes);\n        key = checkDidRenderIdHook();\n        markComponentRenderStopped();\n        if (null !== current && !didReceiveUpdate) return bailoutHooks(current, workInProgress, renderLanes), bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);\n        isHydrating && key && pushMaterializedTreeId(workInProgress);\n        workInProgress.flags |= 1;\n        reconcileChildren(current, workInProgress, nextProps, renderLanes);\n        return workInProgress.child;\n    }\n    function updateMemoComponent(current, workInProgress, Component, nextProps, renderLanes) {\n        if (null === current) {\n            var type = Component.type;\n            if (\"function\" === typeof type && !shouldConstruct(type) && void 0 === type.defaultProps && null === Component.compare) return Component = resolveFunctionForHotReloading(type), workInProgress.tag = 15, workInProgress.type = Component, validateFunctionComponentInDev(workInProgress, type), updateSimpleMemoComponent(current, workInProgress, Component, nextProps, renderLanes);\n            current = createFiberFromTypeAndProps(Component.type, null, nextProps, workInProgress, workInProgress.mode, renderLanes);\n            current.ref = workInProgress.ref;\n            current.return = workInProgress;\n            return workInProgress.child = current;\n        }\n        type = current.child;\n        if (!checkScheduledUpdateOrContext(current, renderLanes)) {\n            var prevProps = type.memoizedProps;\n            Component = Component.compare;\n            Component = null !== Component ? Component : shallowEqual;\n            if (Component(prevProps, nextProps) && current.ref === workInProgress.ref) return bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);\n        }\n        workInProgress.flags |= 1;\n        current = createWorkInProgress(type, nextProps);\n        current.ref = workInProgress.ref;\n        current.return = workInProgress;\n        return workInProgress.child = current;\n    }\n    function updateSimpleMemoComponent(current, workInProgress, Component, nextProps, renderLanes) {\n        if (null !== current) {\n            var prevProps = current.memoizedProps;\n            if (shallowEqual(prevProps, nextProps) && current.ref === workInProgress.ref && workInProgress.type === current.type) if (didReceiveUpdate = !1, workInProgress.pendingProps = nextProps = prevProps, checkScheduledUpdateOrContext(current, renderLanes)) 0 !== (current.flags & 131072) && (didReceiveUpdate = !0);\n            else return workInProgress.lanes = current.lanes, bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);\n        }\n        return updateFunctionComponent(current, workInProgress, Component, nextProps, renderLanes);\n    }\n    function updateOffscreenComponent(current, workInProgress, renderLanes) {\n        var nextProps = workInProgress.pendingProps, nextChildren = nextProps.children, nextIsDetached = 0 !== (workInProgress.stateNode._pendingVisibility & 2), prevState = null !== current ? current.memoizedState : null;\n        markRef(current, workInProgress);\n        if (\"hidden\" === nextProps.mode || nextIsDetached) {\n            if (0 !== (workInProgress.flags & 128)) {\n                nextProps = null !== prevState ? prevState.baseLanes | renderLanes : renderLanes;\n                if (null !== current) {\n                    nextChildren = workInProgress.child = current.child;\n                    for(nextIsDetached = 0; null !== nextChildren;)nextIsDetached = nextIsDetached | nextChildren.lanes | nextChildren.childLanes, nextChildren = nextChildren.sibling;\n                    workInProgress.childLanes = nextIsDetached & ~nextProps;\n                } else workInProgress.childLanes = 0, workInProgress.child = null;\n                return deferHiddenOffscreenComponent(current, workInProgress, nextProps, renderLanes);\n            }\n            if (0 !== (renderLanes & 536870912)) workInProgress.memoizedState = {\n                baseLanes: 0,\n                cachePool: null\n            }, null !== current && pushTransition(workInProgress, null !== prevState ? prevState.cachePool : null), null !== prevState ? pushHiddenContext(workInProgress, prevState) : reuseHiddenContextOnStack(workInProgress), pushOffscreenSuspenseHandler(workInProgress);\n            else return workInProgress.lanes = workInProgress.childLanes = 536870912, deferHiddenOffscreenComponent(current, workInProgress, null !== prevState ? prevState.baseLanes | renderLanes : renderLanes, renderLanes);\n        } else null !== prevState ? (pushTransition(workInProgress, prevState.cachePool), pushHiddenContext(workInProgress, prevState), reuseSuspenseHandlerOnStack(workInProgress), workInProgress.memoizedState = null) : (null !== current && pushTransition(workInProgress, null), reuseHiddenContextOnStack(workInProgress), reuseSuspenseHandlerOnStack(workInProgress));\n        reconcileChildren(current, workInProgress, nextChildren, renderLanes);\n        return workInProgress.child;\n    }\n    function deferHiddenOffscreenComponent(current, workInProgress, nextBaseLanes, renderLanes) {\n        var JSCompiler_inline_result = peekCacheFromPool();\n        JSCompiler_inline_result = null === JSCompiler_inline_result ? null : {\n            parent: isPrimaryRenderer ? CacheContext._currentValue : CacheContext._currentValue2,\n            pool: JSCompiler_inline_result\n        };\n        workInProgress.memoizedState = {\n            baseLanes: nextBaseLanes,\n            cachePool: JSCompiler_inline_result\n        };\n        null !== current && pushTransition(workInProgress, null);\n        reuseHiddenContextOnStack(workInProgress);\n        pushOffscreenSuspenseHandler(workInProgress);\n        null !== current && propagateParentContextChanges(current, workInProgress, renderLanes, !0);\n        return null;\n    }\n    function markRef(current, workInProgress) {\n        var ref = workInProgress.ref;\n        if (null === ref) null !== current && null !== current.ref && (workInProgress.flags |= 2097664);\n        else {\n            if (\"function\" !== typeof ref && \"object\" !== typeof ref) throw Error(\"Expected ref to be a function, an object returned by React.createRef(), or undefined/null.\");\n            if (null === current || current.ref !== ref) workInProgress.flags |= 2097664;\n        }\n    }\n    function updateFunctionComponent(current, workInProgress, Component, nextProps, renderLanes) {\n        if (Component.prototype && \"function\" === typeof Component.prototype.render) {\n            var componentName = getComponentNameFromType(Component) || \"Unknown\";\n            didWarnAboutBadClass[componentName] || (console.error(\"The <%s /> component appears to have a render method, but doesn't extend React.Component. This is likely to cause errors. Change %s to extend React.Component instead.\", componentName, componentName), didWarnAboutBadClass[componentName] = !0);\n        }\n        workInProgress.mode & 8 && ReactStrictModeWarnings.recordLegacyContextWarning(workInProgress, null);\n        null === current && (validateFunctionComponentInDev(workInProgress, workInProgress.type), Component.contextTypes && (componentName = getComponentNameFromType(Component) || \"Unknown\", didWarnAboutContextTypes[componentName] || (didWarnAboutContextTypes[componentName] = !0, console.error(\"%s uses the legacy contextTypes API which was removed in React 19. Use React.createContext() with React.useContext() instead. (https://react.dev/link/legacy-context)\", componentName))));\n        prepareToReadContext(workInProgress);\n        markComponentRenderStarted(workInProgress);\n        Component = renderWithHooks(current, workInProgress, Component, nextProps, void 0, renderLanes);\n        nextProps = checkDidRenderIdHook();\n        markComponentRenderStopped();\n        if (null !== current && !didReceiveUpdate) return bailoutHooks(current, workInProgress, renderLanes), bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);\n        isHydrating && nextProps && pushMaterializedTreeId(workInProgress);\n        workInProgress.flags |= 1;\n        reconcileChildren(current, workInProgress, Component, renderLanes);\n        return workInProgress.child;\n    }\n    function replayFunctionComponent(current, workInProgress, nextProps, Component, secondArg, renderLanes) {\n        prepareToReadContext(workInProgress);\n        markComponentRenderStarted(workInProgress);\n        hookTypesUpdateIndexDev = -1;\n        ignorePreviousDependencies = null !== current && current.type !== workInProgress.type;\n        workInProgress.updateQueue = null;\n        nextProps = renderWithHooksAgain(workInProgress, Component, nextProps, secondArg);\n        finishRenderingHooks(current, workInProgress);\n        Component = checkDidRenderIdHook();\n        markComponentRenderStopped();\n        if (null !== current && !didReceiveUpdate) return bailoutHooks(current, workInProgress, renderLanes), bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);\n        isHydrating && Component && pushMaterializedTreeId(workInProgress);\n        workInProgress.flags |= 1;\n        reconcileChildren(current, workInProgress, nextProps, renderLanes);\n        return workInProgress.child;\n    }\n    function updateClassComponent(current$jscomp$0, workInProgress, Component, nextProps, renderLanes) {\n        switch(shouldErrorImpl(workInProgress)){\n            case !1:\n                var _instance = workInProgress.stateNode, state = new workInProgress.type(workInProgress.memoizedProps, _instance.context).state;\n                _instance.updater.enqueueSetState(_instance, state, null);\n                break;\n            case !0:\n                workInProgress.flags |= 128;\n                workInProgress.flags |= 65536;\n                _instance = Error(\"Simulated error coming from DevTools\");\n                var lane = renderLanes & -renderLanes;\n                workInProgress.lanes |= lane;\n                state = workInProgressRoot;\n                if (null === state) throw Error(\"Expected a work-in-progress root. This is a bug in React. Please file an issue.\");\n                lane = createClassErrorUpdate(lane);\n                initializeClassErrorUpdate(lane, state, workInProgress, createCapturedValueAtFiber(_instance, workInProgress));\n                enqueueCapturedUpdate(workInProgress, lane);\n        }\n        prepareToReadContext(workInProgress);\n        if (null === workInProgress.stateNode) {\n            state = emptyContextObject;\n            _instance = Component.contextType;\n            \"contextType\" in Component && null !== _instance && (void 0 === _instance || _instance.$$typeof !== REACT_CONTEXT_TYPE) && !didWarnAboutInvalidateContextType.has(Component) && (didWarnAboutInvalidateContextType.add(Component), lane = void 0 === _instance ? \" However, it is set to undefined. This can be caused by a typo or by mixing up named and default imports. This can also happen due to a circular dependency, so try moving the createContext() call to a separate file.\" : \"object\" !== typeof _instance ? \" However, it is set to a \" + typeof _instance + \".\" : _instance.$$typeof === REACT_CONSUMER_TYPE ? \" Did you accidentally pass the Context.Consumer instead?\" : \" However, it is set to an object with keys {\" + Object.keys(_instance).join(\", \") + \"}.\", console.error(\"%s defines an invalid contextType. contextType should point to the Context object returned by React.createContext().%s\", getComponentNameFromType(Component) || \"Component\", lane));\n            \"object\" === typeof _instance && null !== _instance && (state = readContext(_instance));\n            _instance = new Component(nextProps, state);\n            if (workInProgress.mode & 8) {\n                setIsStrictModeForDevtools(!0);\n                try {\n                    _instance = new Component(nextProps, state);\n                } finally{\n                    setIsStrictModeForDevtools(!1);\n                }\n            }\n            state = workInProgress.memoizedState = null !== _instance.state && void 0 !== _instance.state ? _instance.state : null;\n            _instance.updater = classComponentUpdater;\n            workInProgress.stateNode = _instance;\n            _instance._reactInternals = workInProgress;\n            _instance._reactInternalInstance = fakeInternalInstance;\n            \"function\" === typeof Component.getDerivedStateFromProps && null === state && (state = getComponentNameFromType(Component) || \"Component\", didWarnAboutUninitializedState.has(state) || (didWarnAboutUninitializedState.add(state), console.error(\"`%s` uses `getDerivedStateFromProps` but its initial state is %s. This is not recommended. Instead, define the initial state by assigning an object to `this.state` in the constructor of `%s`. This ensures that `getDerivedStateFromProps` arguments have a consistent shape.\", state, null === _instance.state ? \"null\" : \"undefined\", state)));\n            if (\"function\" === typeof Component.getDerivedStateFromProps || \"function\" === typeof _instance.getSnapshotBeforeUpdate) {\n                var foundWillUpdateName = lane = state = null;\n                \"function\" === typeof _instance.componentWillMount && !0 !== _instance.componentWillMount.__suppressDeprecationWarning ? state = \"componentWillMount\" : \"function\" === typeof _instance.UNSAFE_componentWillMount && (state = \"UNSAFE_componentWillMount\");\n                \"function\" === typeof _instance.componentWillReceiveProps && !0 !== _instance.componentWillReceiveProps.__suppressDeprecationWarning ? lane = \"componentWillReceiveProps\" : \"function\" === typeof _instance.UNSAFE_componentWillReceiveProps && (lane = \"UNSAFE_componentWillReceiveProps\");\n                \"function\" === typeof _instance.componentWillUpdate && !0 !== _instance.componentWillUpdate.__suppressDeprecationWarning ? foundWillUpdateName = \"componentWillUpdate\" : \"function\" === typeof _instance.UNSAFE_componentWillUpdate && (foundWillUpdateName = \"UNSAFE_componentWillUpdate\");\n                if (null !== state || null !== lane || null !== foundWillUpdateName) {\n                    _instance = getComponentNameFromType(Component) || \"Component\";\n                    var newApiName = \"function\" === typeof Component.getDerivedStateFromProps ? \"getDerivedStateFromProps()\" : \"getSnapshotBeforeUpdate()\";\n                    didWarnAboutLegacyLifecyclesAndDerivedState.has(_instance) || (didWarnAboutLegacyLifecyclesAndDerivedState.add(_instance), console.error(\"Unsafe legacy lifecycles will not be called for components using new component APIs.\\n\\n%s uses %s but also contains the following legacy lifecycles:%s%s%s\\n\\nThe above lifecycles should be removed. Learn more about this warning here:\\nhttps://react.dev/link/unsafe-component-lifecycles\", _instance, newApiName, null !== state ? \"\\n  \" + state : \"\", null !== lane ? \"\\n  \" + lane : \"\", null !== foundWillUpdateName ? \"\\n  \" + foundWillUpdateName : \"\"));\n                }\n            }\n            _instance = workInProgress.stateNode;\n            state = getComponentNameFromType(Component) || \"Component\";\n            _instance.render || (Component.prototype && \"function\" === typeof Component.prototype.render ? console.error(\"No `render` method found on the %s instance: did you accidentally return an object from the constructor?\", state) : console.error(\"No `render` method found on the %s instance: you may have forgotten to define `render`.\", state));\n            !_instance.getInitialState || _instance.getInitialState.isReactClassApproved || _instance.state || console.error(\"getInitialState was defined on %s, a plain JavaScript class. This is only supported for classes created using React.createClass. Did you mean to define a state property instead?\", state);\n            _instance.getDefaultProps && !_instance.getDefaultProps.isReactClassApproved && console.error(\"getDefaultProps was defined on %s, a plain JavaScript class. This is only supported for classes created using React.createClass. Use a static property to define defaultProps instead.\", state);\n            _instance.contextType && console.error(\"contextType was defined as an instance property on %s. Use a static property to define contextType instead.\", state);\n            Component.childContextTypes && !didWarnAboutChildContextTypes.has(Component) && (didWarnAboutChildContextTypes.add(Component), console.error(\"%s uses the legacy childContextTypes API which was removed in React 19. Use React.createContext() instead. (https://react.dev/link/legacy-context)\", state));\n            Component.contextTypes && !didWarnAboutContextTypes$1.has(Component) && (didWarnAboutContextTypes$1.add(Component), console.error(\"%s uses the legacy contextTypes API which was removed in React 19. Use React.createContext() with static contextType instead. (https://react.dev/link/legacy-context)\", state));\n            \"function\" === typeof _instance.componentShouldUpdate && console.error(\"%s has a method called componentShouldUpdate(). Did you mean shouldComponentUpdate()? The name is phrased as a question because the function is expected to return a value.\", state);\n            Component.prototype && Component.prototype.isPureReactComponent && \"undefined\" !== typeof _instance.shouldComponentUpdate && console.error(\"%s has a method called shouldComponentUpdate(). shouldComponentUpdate should not be used when extending React.PureComponent. Please extend React.Component if shouldComponentUpdate is used.\", getComponentNameFromType(Component) || \"A pure component\");\n            \"function\" === typeof _instance.componentDidUnmount && console.error(\"%s has a method called componentDidUnmount(). But there is no such lifecycle method. Did you mean componentWillUnmount()?\", state);\n            \"function\" === typeof _instance.componentDidReceiveProps && console.error(\"%s has a method called componentDidReceiveProps(). But there is no such lifecycle method. If you meant to update the state in response to changing props, use componentWillReceiveProps(). If you meant to fetch data or run side-effects or mutations after React has updated the UI, use componentDidUpdate().\", state);\n            \"function\" === typeof _instance.componentWillRecieveProps && console.error(\"%s has a method called componentWillRecieveProps(). Did you mean componentWillReceiveProps()?\", state);\n            \"function\" === typeof _instance.UNSAFE_componentWillRecieveProps && console.error(\"%s has a method called UNSAFE_componentWillRecieveProps(). Did you mean UNSAFE_componentWillReceiveProps()?\", state);\n            lane = _instance.props !== nextProps;\n            void 0 !== _instance.props && lane && console.error(\"When calling super() in `%s`, make sure to pass up the same props that your component's constructor was passed.\", state);\n            _instance.defaultProps && console.error(\"Setting defaultProps as an instance property on %s is not supported and will be ignored. Instead, define defaultProps as a static property on %s.\", state, state);\n            \"function\" !== typeof _instance.getSnapshotBeforeUpdate || \"function\" === typeof _instance.componentDidUpdate || didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate.has(Component) || (didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate.add(Component), console.error(\"%s: getSnapshotBeforeUpdate() should be used with componentDidUpdate(). This component defines getSnapshotBeforeUpdate() only.\", getComponentNameFromType(Component)));\n            \"function\" === typeof _instance.getDerivedStateFromProps && console.error(\"%s: getDerivedStateFromProps() is defined as an instance method and will be ignored. Instead, declare it as a static method.\", state);\n            \"function\" === typeof _instance.getDerivedStateFromError && console.error(\"%s: getDerivedStateFromError() is defined as an instance method and will be ignored. Instead, declare it as a static method.\", state);\n            \"function\" === typeof Component.getSnapshotBeforeUpdate && console.error(\"%s: getSnapshotBeforeUpdate() is defined as a static method and will be ignored. Instead, declare it as an instance method.\", state);\n            (lane = _instance.state) && (\"object\" !== typeof lane || isArrayImpl(lane)) && console.error(\"%s.state: must be set to an object or null\", state);\n            \"function\" === typeof _instance.getChildContext && \"object\" !== typeof Component.childContextTypes && console.error(\"%s.getChildContext(): childContextTypes must be defined in order to use getChildContext().\", state);\n            _instance = workInProgress.stateNode;\n            _instance.props = nextProps;\n            _instance.state = workInProgress.memoizedState;\n            _instance.refs = {};\n            initializeUpdateQueue(workInProgress);\n            state = Component.contextType;\n            _instance.context = \"object\" === typeof state && null !== state ? readContext(state) : emptyContextObject;\n            _instance.state === nextProps && (state = getComponentNameFromType(Component) || \"Component\", didWarnAboutDirectlyAssigningPropsToState.has(state) || (didWarnAboutDirectlyAssigningPropsToState.add(state), console.error(\"%s: It is not recommended to assign props directly to state because updates to props won't be reflected in state. In most cases, it is better to use props directly.\", state)));\n            workInProgress.mode & 8 && ReactStrictModeWarnings.recordLegacyContextWarning(workInProgress, _instance);\n            ReactStrictModeWarnings.recordUnsafeLifecycleWarnings(workInProgress, _instance);\n            _instance.state = workInProgress.memoizedState;\n            state = Component.getDerivedStateFromProps;\n            \"function\" === typeof state && (applyDerivedStateFromProps(workInProgress, Component, state, nextProps), _instance.state = workInProgress.memoizedState);\n            \"function\" === typeof Component.getDerivedStateFromProps || \"function\" === typeof _instance.getSnapshotBeforeUpdate || \"function\" !== typeof _instance.UNSAFE_componentWillMount && \"function\" !== typeof _instance.componentWillMount || (state = _instance.state, \"function\" === typeof _instance.componentWillMount && _instance.componentWillMount(), \"function\" === typeof _instance.UNSAFE_componentWillMount && _instance.UNSAFE_componentWillMount(), state !== _instance.state && (console.error(\"%s.componentWillMount(): Assigning directly to this.state is deprecated (except inside a component's constructor). Use setState instead.\", getComponentNameFromFiber(workInProgress) || \"Component\"), classComponentUpdater.enqueueReplaceState(_instance, _instance.state, null)), processUpdateQueue(workInProgress, nextProps, _instance, renderLanes), suspendIfUpdateReadFromEntangledAsyncAction(), _instance.state = workInProgress.memoizedState);\n            \"function\" === typeof _instance.componentDidMount && (workInProgress.flags |= 4194308);\n            (workInProgress.mode & 16) !== NoMode && (workInProgress.flags |= 67108864);\n            _instance = !0;\n        } else if (null === current$jscomp$0) {\n            _instance = workInProgress.stateNode;\n            var unresolvedOldProps = workInProgress.memoizedProps;\n            lane = resolveClassComponentProps(Component, unresolvedOldProps);\n            _instance.props = lane;\n            var oldContext = _instance.context;\n            foundWillUpdateName = Component.contextType;\n            state = emptyContextObject;\n            \"object\" === typeof foundWillUpdateName && null !== foundWillUpdateName && (state = readContext(foundWillUpdateName));\n            newApiName = Component.getDerivedStateFromProps;\n            foundWillUpdateName = \"function\" === typeof newApiName || \"function\" === typeof _instance.getSnapshotBeforeUpdate;\n            unresolvedOldProps = workInProgress.pendingProps !== unresolvedOldProps;\n            foundWillUpdateName || \"function\" !== typeof _instance.UNSAFE_componentWillReceiveProps && \"function\" !== typeof _instance.componentWillReceiveProps || (unresolvedOldProps || oldContext !== state) && callComponentWillReceiveProps(workInProgress, _instance, nextProps, state);\n            hasForceUpdate = !1;\n            var oldState = workInProgress.memoizedState;\n            _instance.state = oldState;\n            processUpdateQueue(workInProgress, nextProps, _instance, renderLanes);\n            suspendIfUpdateReadFromEntangledAsyncAction();\n            oldContext = workInProgress.memoizedState;\n            unresolvedOldProps || oldState !== oldContext || hasForceUpdate ? (\"function\" === typeof newApiName && (applyDerivedStateFromProps(workInProgress, Component, newApiName, nextProps), oldContext = workInProgress.memoizedState), (lane = hasForceUpdate || checkShouldComponentUpdate(workInProgress, Component, lane, nextProps, oldState, oldContext, state)) ? (foundWillUpdateName || \"function\" !== typeof _instance.UNSAFE_componentWillMount && \"function\" !== typeof _instance.componentWillMount || (\"function\" === typeof _instance.componentWillMount && _instance.componentWillMount(), \"function\" === typeof _instance.UNSAFE_componentWillMount && _instance.UNSAFE_componentWillMount()), \"function\" === typeof _instance.componentDidMount && (workInProgress.flags |= 4194308), (workInProgress.mode & 16) !== NoMode && (workInProgress.flags |= 67108864)) : (\"function\" === typeof _instance.componentDidMount && (workInProgress.flags |= 4194308), (workInProgress.mode & 16) !== NoMode && (workInProgress.flags |= 67108864), workInProgress.memoizedProps = nextProps, workInProgress.memoizedState = oldContext), _instance.props = nextProps, _instance.state = oldContext, _instance.context = state, _instance = lane) : (\"function\" === typeof _instance.componentDidMount && (workInProgress.flags |= 4194308), (workInProgress.mode & 16) !== NoMode && (workInProgress.flags |= 67108864), _instance = !1);\n        } else {\n            _instance = workInProgress.stateNode;\n            cloneUpdateQueue(current$jscomp$0, workInProgress);\n            state = workInProgress.memoizedProps;\n            foundWillUpdateName = resolveClassComponentProps(Component, state);\n            _instance.props = foundWillUpdateName;\n            newApiName = workInProgress.pendingProps;\n            oldState = _instance.context;\n            oldContext = Component.contextType;\n            lane = emptyContextObject;\n            \"object\" === typeof oldContext && null !== oldContext && (lane = readContext(oldContext));\n            unresolvedOldProps = Component.getDerivedStateFromProps;\n            (oldContext = \"function\" === typeof unresolvedOldProps || \"function\" === typeof _instance.getSnapshotBeforeUpdate) || \"function\" !== typeof _instance.UNSAFE_componentWillReceiveProps && \"function\" !== typeof _instance.componentWillReceiveProps || (state !== newApiName || oldState !== lane) && callComponentWillReceiveProps(workInProgress, _instance, nextProps, lane);\n            hasForceUpdate = !1;\n            oldState = workInProgress.memoizedState;\n            _instance.state = oldState;\n            processUpdateQueue(workInProgress, nextProps, _instance, renderLanes);\n            suspendIfUpdateReadFromEntangledAsyncAction();\n            var newState = workInProgress.memoizedState;\n            state !== newApiName || oldState !== newState || hasForceUpdate || null !== current$jscomp$0 && null !== current$jscomp$0.dependencies && checkIfContextChanged(current$jscomp$0.dependencies) ? (\"function\" === typeof unresolvedOldProps && (applyDerivedStateFromProps(workInProgress, Component, unresolvedOldProps, nextProps), newState = workInProgress.memoizedState), (foundWillUpdateName = hasForceUpdate || checkShouldComponentUpdate(workInProgress, Component, foundWillUpdateName, nextProps, oldState, newState, lane) || null !== current$jscomp$0 && null !== current$jscomp$0.dependencies && checkIfContextChanged(current$jscomp$0.dependencies)) ? (oldContext || \"function\" !== typeof _instance.UNSAFE_componentWillUpdate && \"function\" !== typeof _instance.componentWillUpdate || (\"function\" === typeof _instance.componentWillUpdate && _instance.componentWillUpdate(nextProps, newState, lane), \"function\" === typeof _instance.UNSAFE_componentWillUpdate && _instance.UNSAFE_componentWillUpdate(nextProps, newState, lane)), \"function\" === typeof _instance.componentDidUpdate && (workInProgress.flags |= 4), \"function\" === typeof _instance.getSnapshotBeforeUpdate && (workInProgress.flags |= 1024)) : (\"function\" !== typeof _instance.componentDidUpdate || state === current$jscomp$0.memoizedProps && oldState === current$jscomp$0.memoizedState || (workInProgress.flags |= 4), \"function\" !== typeof _instance.getSnapshotBeforeUpdate || state === current$jscomp$0.memoizedProps && oldState === current$jscomp$0.memoizedState || (workInProgress.flags |= 1024), workInProgress.memoizedProps = nextProps, workInProgress.memoizedState = newState), _instance.props = nextProps, _instance.state = newState, _instance.context = lane, _instance = foundWillUpdateName) : (\"function\" !== typeof _instance.componentDidUpdate || state === current$jscomp$0.memoizedProps && oldState === current$jscomp$0.memoizedState || (workInProgress.flags |= 4), \"function\" !== typeof _instance.getSnapshotBeforeUpdate || state === current$jscomp$0.memoizedProps && oldState === current$jscomp$0.memoizedState || (workInProgress.flags |= 1024), _instance = !1);\n        }\n        lane = _instance;\n        markRef(current$jscomp$0, workInProgress);\n        state = 0 !== (workInProgress.flags & 128);\n        if (lane || state) {\n            lane = workInProgress.stateNode;\n            ReactSharedInternals.getCurrentStack = null === workInProgress ? null : getCurrentFiberStackInDev;\n            isRendering = !1;\n            current = workInProgress;\n            if (state && \"function\" !== typeof Component.getDerivedStateFromError) Component = null, profilerStartTime = -1;\n            else {\n                markComponentRenderStarted(workInProgress);\n                Component = callRenderInDEV(lane);\n                if (workInProgress.mode & 8) {\n                    setIsStrictModeForDevtools(!0);\n                    try {\n                        callRenderInDEV(lane);\n                    } finally{\n                        setIsStrictModeForDevtools(!1);\n                    }\n                }\n                markComponentRenderStopped();\n            }\n            workInProgress.flags |= 1;\n            null !== current$jscomp$0 && state ? (workInProgress.child = reconcileChildFibers(workInProgress, current$jscomp$0.child, null, renderLanes), workInProgress.child = reconcileChildFibers(workInProgress, null, Component, renderLanes)) : reconcileChildren(current$jscomp$0, workInProgress, Component, renderLanes);\n            workInProgress.memoizedState = lane.state;\n            current$jscomp$0 = workInProgress.child;\n        } else current$jscomp$0 = bailoutOnAlreadyFinishedWork(current$jscomp$0, workInProgress, renderLanes);\n        renderLanes = workInProgress.stateNode;\n        _instance && renderLanes.props !== nextProps && (didWarnAboutReassigningProps || console.error(\"It looks like %s is reassigning its own `this.props` while rendering. This is not supported and can lead to confusing bugs.\", getComponentNameFromFiber(workInProgress) || \"a component\"), didWarnAboutReassigningProps = !0);\n        return current$jscomp$0;\n    }\n    function mountHostRootWithoutHydrating(current, workInProgress, nextChildren, renderLanes) {\n        resetHydrationState();\n        workInProgress.flags |= 256;\n        reconcileChildren(current, workInProgress, nextChildren, renderLanes);\n        return workInProgress.child;\n    }\n    function validateFunctionComponentInDev(workInProgress, Component) {\n        Component && Component.childContextTypes && console.error(\"childContextTypes cannot be defined on a function component.\\n  %s.childContextTypes = ...\", Component.displayName || Component.name || \"Component\");\n        \"function\" === typeof Component.getDerivedStateFromProps && (workInProgress = getComponentNameFromType(Component) || \"Unknown\", didWarnAboutGetDerivedStateOnFunctionComponent[workInProgress] || (console.error(\"%s: Function components do not support getDerivedStateFromProps.\", workInProgress), didWarnAboutGetDerivedStateOnFunctionComponent[workInProgress] = !0));\n        \"object\" === typeof Component.contextType && null !== Component.contextType && (Component = getComponentNameFromType(Component) || \"Unknown\", didWarnAboutContextTypeOnFunctionComponent[Component] || (console.error(\"%s: Function components do not support contextType.\", Component), didWarnAboutContextTypeOnFunctionComponent[Component] = !0));\n    }\n    function mountSuspenseOffscreenState(renderLanes) {\n        return {\n            baseLanes: renderLanes,\n            cachePool: getSuspendedCache()\n        };\n    }\n    function getRemainingWorkInPrimaryTree(current, primaryTreeDidDefer, renderLanes) {\n        current = null !== current ? current.childLanes & ~renderLanes : 0;\n        primaryTreeDidDefer && (current |= workInProgressDeferredLane);\n        return current;\n    }\n    function updateSuspenseComponent(current, workInProgress, renderLanes) {\n        var nextProps = workInProgress.pendingProps;\n        shouldSuspendImpl(workInProgress) && (workInProgress.flags |= 128);\n        var showFallback = !1, didSuspend = 0 !== (workInProgress.flags & 128), JSCompiler_temp;\n        (JSCompiler_temp = didSuspend) || (JSCompiler_temp = null !== current && null === current.memoizedState ? !1 : 0 !== (suspenseStackCursor.current & ForceSuspenseFallback));\n        JSCompiler_temp && (showFallback = !0, workInProgress.flags &= -129);\n        JSCompiler_temp = 0 !== (workInProgress.flags & 32);\n        workInProgress.flags &= -33;\n        if (null === current) {\n            if (isHydrating) {\n                showFallback ? pushPrimaryTreeSuspenseHandler(workInProgress) : reuseSuspenseHandlerOnStack(workInProgress);\n                if (isHydrating) {\n                    var nextInstance = nextHydratableInstance, JSCompiler_temp$jscomp$0;\n                    (JSCompiler_temp$jscomp$0 = !nextInstance) || (JSCompiler_temp$jscomp$0 = canHydrateSuspenseInstance(nextInstance, rootOrSingletonContext), null !== JSCompiler_temp$jscomp$0 ? (warnIfNotHydrating(), workInProgress.memoizedState = {\n                        dehydrated: JSCompiler_temp$jscomp$0,\n                        treeContext: null !== treeContextProvider ? {\n                            id: treeContextId,\n                            overflow: treeContextOverflow\n                        } : null,\n                        retryLane: 536870912\n                    }, didSuspend = createFiber(18, null, null, NoMode), didSuspend.stateNode = JSCompiler_temp$jscomp$0, didSuspend.return = workInProgress, workInProgress.child = didSuspend, hydrationParentFiber = workInProgress, nextHydratableInstance = null, JSCompiler_temp$jscomp$0 = !0) : JSCompiler_temp$jscomp$0 = !1, JSCompiler_temp$jscomp$0 = !JSCompiler_temp$jscomp$0);\n                    JSCompiler_temp$jscomp$0 && (warnNonHydratedInstance(workInProgress, nextInstance), throwOnHydrationMismatch(workInProgress));\n                }\n                nextInstance = workInProgress.memoizedState;\n                if (null !== nextInstance && (nextInstance = nextInstance.dehydrated, null !== nextInstance)) return isSuspenseInstanceFallback(nextInstance) ? workInProgress.lanes = 16 : workInProgress.lanes = 536870912, null;\n                popSuspenseHandler(workInProgress);\n            }\n            nextInstance = nextProps.children;\n            nextProps = nextProps.fallback;\n            if (showFallback) return reuseSuspenseHandlerOnStack(workInProgress), showFallback = workInProgress.mode, nextInstance = mountWorkInProgressOffscreenFiber({\n                mode: \"hidden\",\n                children: nextInstance\n            }, showFallback), nextProps = createFiberFromFragment(nextProps, showFallback, renderLanes, null), nextInstance.return = workInProgress, nextProps.return = workInProgress, nextInstance.sibling = nextProps, workInProgress.child = nextInstance, showFallback = workInProgress.child, showFallback.memoizedState = mountSuspenseOffscreenState(renderLanes), showFallback.childLanes = getRemainingWorkInPrimaryTree(current, JSCompiler_temp, renderLanes), workInProgress.memoizedState = SUSPENDED_MARKER, nextProps;\n            pushPrimaryTreeSuspenseHandler(workInProgress);\n            return mountSuspensePrimaryChildren(workInProgress, nextInstance);\n        }\n        JSCompiler_temp$jscomp$0 = current.memoizedState;\n        if (null !== JSCompiler_temp$jscomp$0 && (nextInstance = JSCompiler_temp$jscomp$0.dehydrated, null !== nextInstance)) {\n            if (didSuspend) workInProgress.flags & 256 ? (pushPrimaryTreeSuspenseHandler(workInProgress), workInProgress.flags &= -257, workInProgress = retrySuspenseComponentWithoutHydrating(current, workInProgress, renderLanes)) : null !== workInProgress.memoizedState ? (reuseSuspenseHandlerOnStack(workInProgress), workInProgress.child = current.child, workInProgress.flags |= 128, workInProgress = null) : (reuseSuspenseHandlerOnStack(workInProgress), showFallback = nextProps.fallback, nextInstance = workInProgress.mode, nextProps = mountWorkInProgressOffscreenFiber({\n                mode: \"visible\",\n                children: nextProps.children\n            }, nextInstance), showFallback = createFiberFromFragment(showFallback, nextInstance, renderLanes, null), showFallback.flags |= 2, nextProps.return = workInProgress, showFallback.return = workInProgress, nextProps.sibling = showFallback, workInProgress.child = nextProps, reconcileChildFibers(workInProgress, current.child, null, renderLanes), nextProps = workInProgress.child, nextProps.memoizedState = mountSuspenseOffscreenState(renderLanes), nextProps.childLanes = getRemainingWorkInPrimaryTree(current, JSCompiler_temp, renderLanes), workInProgress.memoizedState = SUSPENDED_MARKER, workInProgress = showFallback);\n            else if (pushPrimaryTreeSuspenseHandler(workInProgress), isHydrating && console.error(\"We should not be hydrating here. This is a bug in React. Please file a bug.\"), isSuspenseInstanceFallback(nextInstance)) nextInstance = getSuspenseInstanceFallbackErrorDetails(nextInstance), JSCompiler_temp = nextInstance.digest, showFallback = nextInstance.message, nextProps = nextInstance.stack, nextInstance = nextInstance.componentStack, showFallback = showFallback ? Error(showFallback) : Error(\"The server could not finish this Suspense boundary, likely due to an error during server rendering. Switched to client rendering.\"), showFallback.stack = nextProps || \"\", showFallback.digest = JSCompiler_temp, JSCompiler_temp = void 0 === nextInstance ? null : nextInstance, nextProps = {\n                value: showFallback,\n                source: null,\n                stack: JSCompiler_temp\n            }, \"string\" === typeof JSCompiler_temp && CapturedStacks.set(showFallback, nextProps), queueHydrationError(nextProps), workInProgress = retrySuspenseComponentWithoutHydrating(current, workInProgress, renderLanes);\n            else if (didReceiveUpdate || propagateParentContextChanges(current, workInProgress, renderLanes, !1), JSCompiler_temp = 0 !== (renderLanes & current.childLanes), didReceiveUpdate || JSCompiler_temp) {\n                JSCompiler_temp = workInProgressRoot;\n                if (null !== JSCompiler_temp) {\n                    nextProps = renderLanes & -renderLanes;\n                    if (0 !== (nextProps & 42)) nextProps = 1;\n                    else switch(nextProps){\n                        case 2:\n                            nextProps = 1;\n                            break;\n                        case 8:\n                            nextProps = 4;\n                            break;\n                        case 32:\n                            nextProps = 16;\n                            break;\n                        case 128:\n                        case 256:\n                        case 512:\n                        case 1024:\n                        case 2048:\n                        case 4096:\n                        case 8192:\n                        case 16384:\n                        case 32768:\n                        case 65536:\n                        case 131072:\n                        case 262144:\n                        case 524288:\n                        case 1048576:\n                        case 2097152:\n                        case 4194304:\n                        case 8388608:\n                        case 16777216:\n                        case 33554432:\n                            nextProps = 64;\n                            break;\n                        case 268435456:\n                            nextProps = 134217728;\n                            break;\n                        default:\n                            nextProps = 0;\n                    }\n                    nextProps = 0 !== (nextProps & (JSCompiler_temp.suspendedLanes | renderLanes)) ? 0 : nextProps;\n                    if (0 !== nextProps && nextProps !== JSCompiler_temp$jscomp$0.retryLane) throw JSCompiler_temp$jscomp$0.retryLane = nextProps, enqueueConcurrentRenderForLane(current, nextProps), scheduleUpdateOnFiber(JSCompiler_temp, current, nextProps), SelectiveHydrationException;\n                }\n                isSuspenseInstancePending(nextInstance) || renderDidSuspendDelayIfPossible();\n                workInProgress = retrySuspenseComponentWithoutHydrating(current, workInProgress, renderLanes);\n            } else isSuspenseInstancePending(nextInstance) ? (workInProgress.flags |= 128, workInProgress.child = current.child, workInProgress = retryDehydratedSuspenseBoundary.bind(null, current), registerSuspenseInstanceRetry(nextInstance, workInProgress), workInProgress = null) : (current = JSCompiler_temp$jscomp$0.treeContext, supportsHydration && (nextHydratableInstance = getFirstHydratableChildWithinSuspenseInstance(nextInstance), hydrationParentFiber = workInProgress, isHydrating = !0, hydrationErrors = null, didSuspendOrErrorDEV = !1, hydrationDiffRootDEV = null, rootOrSingletonContext = !1, null !== current && (warnIfNotHydrating(), idStack[idStackIndex++] = treeContextId, idStack[idStackIndex++] = treeContextOverflow, idStack[idStackIndex++] = treeContextProvider, treeContextId = current.id, treeContextOverflow = current.overflow, treeContextProvider = workInProgress)), workInProgress = mountSuspensePrimaryChildren(workInProgress, nextProps.children), workInProgress.flags |= 4096);\n            return workInProgress;\n        }\n        if (showFallback) return reuseSuspenseHandlerOnStack(workInProgress), showFallback = nextProps.fallback, nextInstance = workInProgress.mode, JSCompiler_temp$jscomp$0 = current.child, didSuspend = JSCompiler_temp$jscomp$0.sibling, nextProps = createWorkInProgress(JSCompiler_temp$jscomp$0, {\n            mode: \"hidden\",\n            children: nextProps.children\n        }), nextProps.subtreeFlags = JSCompiler_temp$jscomp$0.subtreeFlags & 31457280, null !== didSuspend ? showFallback = createWorkInProgress(didSuspend, showFallback) : (showFallback = createFiberFromFragment(showFallback, nextInstance, renderLanes, null), showFallback.flags |= 2), showFallback.return = workInProgress, nextProps.return = workInProgress, nextProps.sibling = showFallback, workInProgress.child = nextProps, nextProps = showFallback, showFallback = workInProgress.child, nextInstance = current.child.memoizedState, null === nextInstance ? nextInstance = mountSuspenseOffscreenState(renderLanes) : (JSCompiler_temp$jscomp$0 = nextInstance.cachePool, null !== JSCompiler_temp$jscomp$0 ? (didSuspend = isPrimaryRenderer ? CacheContext._currentValue : CacheContext._currentValue2, JSCompiler_temp$jscomp$0 = JSCompiler_temp$jscomp$0.parent !== didSuspend ? {\n            parent: didSuspend,\n            pool: didSuspend\n        } : JSCompiler_temp$jscomp$0) : JSCompiler_temp$jscomp$0 = getSuspendedCache(), nextInstance = {\n            baseLanes: nextInstance.baseLanes | renderLanes,\n            cachePool: JSCompiler_temp$jscomp$0\n        }), showFallback.memoizedState = nextInstance, showFallback.childLanes = getRemainingWorkInPrimaryTree(current, JSCompiler_temp, renderLanes), workInProgress.memoizedState = SUSPENDED_MARKER, nextProps;\n        pushPrimaryTreeSuspenseHandler(workInProgress);\n        renderLanes = current.child;\n        current = renderLanes.sibling;\n        renderLanes = createWorkInProgress(renderLanes, {\n            mode: \"visible\",\n            children: nextProps.children\n        });\n        renderLanes.return = workInProgress;\n        renderLanes.sibling = null;\n        null !== current && (JSCompiler_temp = workInProgress.deletions, null === JSCompiler_temp ? (workInProgress.deletions = [\n            current\n        ], workInProgress.flags |= 16) : JSCompiler_temp.push(current));\n        workInProgress.child = renderLanes;\n        workInProgress.memoizedState = null;\n        return renderLanes;\n    }\n    function mountSuspensePrimaryChildren(workInProgress, primaryChildren) {\n        primaryChildren = mountWorkInProgressOffscreenFiber({\n            mode: \"visible\",\n            children: primaryChildren\n        }, workInProgress.mode);\n        primaryChildren.return = workInProgress;\n        return workInProgress.child = primaryChildren;\n    }\n    function mountWorkInProgressOffscreenFiber(offscreenProps, mode) {\n        return createFiberFromOffscreen(offscreenProps, mode, 0, null);\n    }\n    function retrySuspenseComponentWithoutHydrating(current, workInProgress, renderLanes) {\n        reconcileChildFibers(workInProgress, current.child, null, renderLanes);\n        current = mountSuspensePrimaryChildren(workInProgress, workInProgress.pendingProps.children);\n        current.flags |= 2;\n        workInProgress.memoizedState = null;\n        return current;\n    }\n    function scheduleSuspenseWorkOnFiber(fiber, renderLanes, propagationRoot) {\n        fiber.lanes |= renderLanes;\n        var alternate = fiber.alternate;\n        null !== alternate && (alternate.lanes |= renderLanes);\n        scheduleContextWorkOnParentPath(fiber.return, renderLanes, propagationRoot);\n    }\n    function validateSuspenseListNestedChild(childSlot, index) {\n        var isAnArray = isArrayImpl(childSlot);\n        childSlot = !isAnArray && \"function\" === typeof getIteratorFn(childSlot);\n        return isAnArray || childSlot ? (isAnArray = isAnArray ? \"array\" : \"iterable\", console.error(\"A nested %s was passed to row #%s in <SuspenseList />. Wrap it in an additional SuspenseList to configure its revealOrder: <SuspenseList revealOrder=...> ... <SuspenseList revealOrder=...>{%s}</SuspenseList> ... </SuspenseList>\", isAnArray, index, isAnArray), !1) : !0;\n    }\n    function initSuspenseListRenderState(workInProgress, isBackwards, tail, lastContentRow, tailMode) {\n        var renderState = workInProgress.memoizedState;\n        null === renderState ? workInProgress.memoizedState = {\n            isBackwards: isBackwards,\n            rendering: null,\n            renderingStartTime: 0,\n            last: lastContentRow,\n            tail: tail,\n            tailMode: tailMode\n        } : (renderState.isBackwards = isBackwards, renderState.rendering = null, renderState.renderingStartTime = 0, renderState.last = lastContentRow, renderState.tail = tail, renderState.tailMode = tailMode);\n    }\n    function updateSuspenseListComponent(current, workInProgress, renderLanes) {\n        var nextProps = workInProgress.pendingProps, revealOrder = nextProps.revealOrder, tailMode = nextProps.tail;\n        nextProps = nextProps.children;\n        if (void 0 !== revealOrder && \"forwards\" !== revealOrder && \"backwards\" !== revealOrder && \"together\" !== revealOrder && !didWarnAboutRevealOrder[revealOrder]) if (didWarnAboutRevealOrder[revealOrder] = !0, \"string\" === typeof revealOrder) switch(revealOrder.toLowerCase()){\n            case \"together\":\n            case \"forwards\":\n            case \"backwards\":\n                console.error('\"%s\" is not a valid value for revealOrder on <SuspenseList />. Use lowercase \"%s\" instead.', revealOrder, revealOrder.toLowerCase());\n                break;\n            case \"forward\":\n            case \"backward\":\n                console.error('\"%s\" is not a valid value for revealOrder on <SuspenseList />. React uses the -s suffix in the spelling. Use \"%ss\" instead.', revealOrder, revealOrder.toLowerCase());\n                break;\n            default:\n                console.error('\"%s\" is not a supported revealOrder on <SuspenseList />. Did you mean \"together\", \"forwards\" or \"backwards\"?', revealOrder);\n        }\n        else console.error('%s is not a supported value for revealOrder on <SuspenseList />. Did you mean \"together\", \"forwards\" or \"backwards\"?', revealOrder);\n        void 0 === tailMode || didWarnAboutTailOptions[tailMode] || (\"collapsed\" !== tailMode && \"hidden\" !== tailMode ? (didWarnAboutTailOptions[tailMode] = !0, console.error('\"%s\" is not a supported value for tail on <SuspenseList />. Did you mean \"collapsed\" or \"hidden\"?', tailMode)) : \"forwards\" !== revealOrder && \"backwards\" !== revealOrder && (didWarnAboutTailOptions[tailMode] = !0, console.error('<SuspenseList tail=\"%s\" /> is only valid if revealOrder is \"forwards\" or \"backwards\". Did you mean to specify revealOrder=\"forwards\"?', tailMode)));\n        a: if ((\"forwards\" === revealOrder || \"backwards\" === revealOrder) && void 0 !== nextProps && null !== nextProps && !1 !== nextProps) if (isArrayImpl(nextProps)) for(var i = 0; i < nextProps.length; i++){\n            if (!validateSuspenseListNestedChild(nextProps[i], i)) break a;\n        }\n        else if (i = getIteratorFn(nextProps), \"function\" === typeof i) {\n            if (i = i.call(nextProps)) for(var step = i.next(), _i = 0; !step.done; step = i.next()){\n                if (!validateSuspenseListNestedChild(step.value, _i)) break a;\n                _i++;\n            }\n        } else console.error('A single row was passed to a <SuspenseList revealOrder=\"%s\" />. This is not useful since it needs multiple rows. Did you mean to pass multiple children or an array?', revealOrder);\n        reconcileChildren(current, workInProgress, nextProps, renderLanes);\n        nextProps = suspenseStackCursor.current;\n        if (0 !== (nextProps & ForceSuspenseFallback)) nextProps = nextProps & SubtreeSuspenseContextMask | ForceSuspenseFallback, workInProgress.flags |= 128;\n        else {\n            if (null !== current && 0 !== (current.flags & 128)) a: for(current = workInProgress.child; null !== current;){\n                if (13 === current.tag) null !== current.memoizedState && scheduleSuspenseWorkOnFiber(current, renderLanes, workInProgress);\n                else if (19 === current.tag) scheduleSuspenseWorkOnFiber(current, renderLanes, workInProgress);\n                else if (null !== current.child) {\n                    current.child.return = current;\n                    current = current.child;\n                    continue;\n                }\n                if (current === workInProgress) break a;\n                for(; null === current.sibling;){\n                    if (null === current.return || current.return === workInProgress) break a;\n                    current = current.return;\n                }\n                current.sibling.return = current.return;\n                current = current.sibling;\n            }\n            nextProps &= SubtreeSuspenseContextMask;\n        }\n        push(suspenseStackCursor, nextProps, workInProgress);\n        switch(revealOrder){\n            case \"forwards\":\n                renderLanes = workInProgress.child;\n                for(revealOrder = null; null !== renderLanes;)current = renderLanes.alternate, null !== current && null === findFirstSuspended(current) && (revealOrder = renderLanes), renderLanes = renderLanes.sibling;\n                renderLanes = revealOrder;\n                null === renderLanes ? (revealOrder = workInProgress.child, workInProgress.child = null) : (revealOrder = renderLanes.sibling, renderLanes.sibling = null);\n                initSuspenseListRenderState(workInProgress, !1, revealOrder, renderLanes, tailMode);\n                break;\n            case \"backwards\":\n                renderLanes = null;\n                revealOrder = workInProgress.child;\n                for(workInProgress.child = null; null !== revealOrder;){\n                    current = revealOrder.alternate;\n                    if (null !== current && null === findFirstSuspended(current)) {\n                        workInProgress.child = revealOrder;\n                        break;\n                    }\n                    current = revealOrder.sibling;\n                    revealOrder.sibling = renderLanes;\n                    renderLanes = revealOrder;\n                    revealOrder = current;\n                }\n                initSuspenseListRenderState(workInProgress, !0, renderLanes, null, tailMode);\n                break;\n            case \"together\":\n                initSuspenseListRenderState(workInProgress, !1, null, null, void 0);\n                break;\n            default:\n                workInProgress.memoizedState = null;\n        }\n        return workInProgress.child;\n    }\n    function bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes) {\n        null !== current && (workInProgress.dependencies = current.dependencies);\n        profilerStartTime = -1;\n        workInProgressRootSkippedLanes |= workInProgress.lanes;\n        if (0 === (renderLanes & workInProgress.childLanes)) if (null !== current) {\n            if (propagateParentContextChanges(current, workInProgress, renderLanes, !1), 0 === (renderLanes & workInProgress.childLanes)) return null;\n        } else return null;\n        if (null !== current && workInProgress.child !== current.child) throw Error(\"Resuming work not yet implemented.\");\n        if (null !== workInProgress.child) {\n            current = workInProgress.child;\n            renderLanes = createWorkInProgress(current, current.pendingProps);\n            workInProgress.child = renderLanes;\n            for(renderLanes.return = workInProgress; null !== current.sibling;)current = current.sibling, renderLanes = renderLanes.sibling = createWorkInProgress(current, current.pendingProps), renderLanes.return = workInProgress;\n            renderLanes.sibling = null;\n        }\n        return workInProgress.child;\n    }\n    function checkScheduledUpdateOrContext(current, renderLanes) {\n        if (0 !== (current.lanes & renderLanes)) return !0;\n        current = current.dependencies;\n        return null !== current && checkIfContextChanged(current) ? !0 : !1;\n    }\n    function attemptEarlyBailoutIfNoScheduledUpdate(current, workInProgress, renderLanes) {\n        switch(workInProgress.tag){\n            case 3:\n                pushHostContainer(workInProgress, workInProgress.stateNode.containerInfo);\n                pushProvider(workInProgress, CacheContext, current.memoizedState.cache);\n                resetHydrationState();\n                break;\n            case 27:\n            case 5:\n                pushHostContext(workInProgress);\n                break;\n            case 4:\n                pushHostContainer(workInProgress, workInProgress.stateNode.containerInfo);\n                break;\n            case 10:\n                pushProvider(workInProgress, workInProgress.type, workInProgress.memoizedProps.value);\n                break;\n            case 12:\n                0 !== (renderLanes & workInProgress.childLanes) && (workInProgress.flags |= 4);\n                workInProgress.flags |= 2048;\n                var stateNode = workInProgress.stateNode;\n                stateNode.effectDuration = -0;\n                stateNode.passiveEffectDuration = -0;\n                break;\n            case 13:\n                stateNode = workInProgress.memoizedState;\n                if (null !== stateNode) {\n                    if (null !== stateNode.dehydrated) return pushPrimaryTreeSuspenseHandler(workInProgress), workInProgress.flags |= 128, null;\n                    if (0 !== (renderLanes & workInProgress.child.childLanes)) return updateSuspenseComponent(current, workInProgress, renderLanes);\n                    pushPrimaryTreeSuspenseHandler(workInProgress);\n                    current = bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);\n                    return null !== current ? current.sibling : null;\n                }\n                pushPrimaryTreeSuspenseHandler(workInProgress);\n                break;\n            case 19:\n                var didSuspendBefore = 0 !== (current.flags & 128);\n                stateNode = 0 !== (renderLanes & workInProgress.childLanes);\n                stateNode || (propagateParentContextChanges(current, workInProgress, renderLanes, !1), stateNode = 0 !== (renderLanes & workInProgress.childLanes));\n                if (didSuspendBefore) {\n                    if (stateNode) return updateSuspenseListComponent(current, workInProgress, renderLanes);\n                    workInProgress.flags |= 128;\n                }\n                didSuspendBefore = workInProgress.memoizedState;\n                null !== didSuspendBefore && (didSuspendBefore.rendering = null, didSuspendBefore.tail = null, didSuspendBefore.lastEffect = null);\n                push(suspenseStackCursor, suspenseStackCursor.current, workInProgress);\n                if (stateNode) break;\n                else return null;\n            case 22:\n            case 23:\n                return workInProgress.lanes = 0, updateOffscreenComponent(current, workInProgress, renderLanes);\n            case 24:\n                pushProvider(workInProgress, CacheContext, current.memoizedState.cache);\n        }\n        return bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);\n    }\n    function beginWork(current, workInProgress, renderLanes) {\n        if (workInProgress._debugNeedsRemount && null !== current) {\n            renderLanes = createFiberFromTypeAndProps(workInProgress.type, workInProgress.key, workInProgress.pendingProps, workInProgress._debugOwner || null, workInProgress.mode, workInProgress.lanes);\n            var returnFiber = workInProgress.return;\n            if (null === returnFiber) throw Error(\"Cannot swap the root fiber.\");\n            current.alternate = null;\n            workInProgress.alternate = null;\n            renderLanes.index = workInProgress.index;\n            renderLanes.sibling = workInProgress.sibling;\n            renderLanes.return = workInProgress.return;\n            renderLanes.ref = workInProgress.ref;\n            renderLanes._debugInfo = workInProgress._debugInfo;\n            if (workInProgress === returnFiber.child) returnFiber.child = renderLanes;\n            else {\n                var prevSibling = returnFiber.child;\n                if (null === prevSibling) throw Error(\"Expected parent to have a child.\");\n                for(; prevSibling.sibling !== workInProgress;)if (prevSibling = prevSibling.sibling, null === prevSibling) throw Error(\"Expected to find the previous sibling.\");\n                prevSibling.sibling = renderLanes;\n            }\n            workInProgress = returnFiber.deletions;\n            null === workInProgress ? (returnFiber.deletions = [\n                current\n            ], returnFiber.flags |= 16) : workInProgress.push(current);\n            renderLanes.flags |= 2;\n            return renderLanes;\n        }\n        if (null !== current) if (current.memoizedProps !== workInProgress.pendingProps || workInProgress.type !== current.type) didReceiveUpdate = !0;\n        else {\n            if (!checkScheduledUpdateOrContext(current, renderLanes) && 0 === (workInProgress.flags & 128)) return didReceiveUpdate = !1, attemptEarlyBailoutIfNoScheduledUpdate(current, workInProgress, renderLanes);\n            didReceiveUpdate = 0 !== (current.flags & 131072) ? !0 : !1;\n        }\n        else {\n            didReceiveUpdate = !1;\n            if (returnFiber = isHydrating) warnIfNotHydrating(), returnFiber = 0 !== (workInProgress.flags & 1048576);\n            returnFiber && (returnFiber = workInProgress.index, warnIfNotHydrating(), pushTreeId(workInProgress, treeForkCount, returnFiber));\n        }\n        workInProgress.lanes = 0;\n        switch(workInProgress.tag){\n            case 16:\n                a: if (returnFiber = workInProgress.pendingProps, current = callLazyInitInDEV(workInProgress.elementType), workInProgress.type = current, \"function\" === typeof current) shouldConstruct(current) ? (returnFiber = resolveClassComponentProps(current, returnFiber), workInProgress.tag = 1, workInProgress.type = current = resolveFunctionForHotReloading(current), workInProgress = updateClassComponent(null, workInProgress, current, returnFiber, renderLanes)) : (workInProgress.tag = 0, validateFunctionComponentInDev(workInProgress, current), workInProgress.type = current = resolveFunctionForHotReloading(current), workInProgress = updateFunctionComponent(null, workInProgress, current, returnFiber, renderLanes));\n                else {\n                    if (void 0 !== current && null !== current) {\n                        if (prevSibling = current.$$typeof, prevSibling === REACT_FORWARD_REF_TYPE) {\n                            workInProgress.tag = 11;\n                            workInProgress.type = current = resolveForwardRefForHotReloading(current);\n                            workInProgress = updateForwardRef(null, workInProgress, current, returnFiber, renderLanes);\n                            break a;\n                        } else if (prevSibling === REACT_MEMO_TYPE) {\n                            workInProgress.tag = 14;\n                            workInProgress = updateMemoComponent(null, workInProgress, current, returnFiber, renderLanes);\n                            break a;\n                        }\n                    }\n                    workInProgress = \"\";\n                    null !== current && \"object\" === typeof current && current.$$typeof === REACT_LAZY_TYPE && (workInProgress = \" Did you wrap a component in React.lazy() more than once?\");\n                    current = getComponentNameFromType(current) || current;\n                    throw Error(\"Element type is invalid. Received a promise that resolves to: \" + current + \". Lazy element type must resolve to a class or function.\" + workInProgress);\n                }\n                return workInProgress;\n            case 0:\n                return updateFunctionComponent(current, workInProgress, workInProgress.type, workInProgress.pendingProps, renderLanes);\n            case 1:\n                return returnFiber = workInProgress.type, prevSibling = resolveClassComponentProps(returnFiber, workInProgress.pendingProps), updateClassComponent(current, workInProgress, returnFiber, prevSibling, renderLanes);\n            case 3:\n                a: {\n                    pushHostContainer(workInProgress, workInProgress.stateNode.containerInfo);\n                    if (null === current) throw Error(\"Should have a current fiber. This is a bug in React.\");\n                    var nextProps = workInProgress.pendingProps;\n                    prevSibling = workInProgress.memoizedState;\n                    returnFiber = prevSibling.element;\n                    cloneUpdateQueue(current, workInProgress);\n                    processUpdateQueue(workInProgress, nextProps, null, renderLanes);\n                    var nextState = workInProgress.memoizedState;\n                    nextProps = nextState.cache;\n                    pushProvider(workInProgress, CacheContext, nextProps);\n                    nextProps !== prevSibling.cache && propagateContextChanges(workInProgress, [\n                        CacheContext\n                    ], renderLanes, !0);\n                    suspendIfUpdateReadFromEntangledAsyncAction();\n                    nextProps = nextState.element;\n                    if (supportsHydration && prevSibling.isDehydrated) if (prevSibling = {\n                        element: nextProps,\n                        isDehydrated: !1,\n                        cache: nextState.cache\n                    }, workInProgress.updateQueue.baseState = prevSibling, workInProgress.memoizedState = prevSibling, workInProgress.flags & 256) {\n                        workInProgress = mountHostRootWithoutHydrating(current, workInProgress, nextProps, renderLanes);\n                        break a;\n                    } else if (nextProps !== returnFiber) {\n                        returnFiber = createCapturedValueAtFiber(Error(\"This root received an early update, before anything was able hydrate. Switched the entire root to client rendering.\"), workInProgress);\n                        queueHydrationError(returnFiber);\n                        workInProgress = mountHostRootWithoutHydrating(current, workInProgress, nextProps, renderLanes);\n                        break a;\n                    } else for(supportsHydration && (nextHydratableInstance = getFirstHydratableChildWithinContainer(workInProgress.stateNode.containerInfo), hydrationParentFiber = workInProgress, isHydrating = !0, hydrationErrors = null, didSuspendOrErrorDEV = !1, hydrationDiffRootDEV = null, rootOrSingletonContext = !0), current = mountChildFibers(workInProgress, null, nextProps, renderLanes), workInProgress.child = current; current;)current.flags = current.flags & -3 | 4096, current = current.sibling;\n                    else {\n                        resetHydrationState();\n                        if (nextProps === returnFiber) {\n                            workInProgress = bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);\n                            break a;\n                        }\n                        reconcileChildren(current, workInProgress, nextProps, renderLanes);\n                    }\n                    workInProgress = workInProgress.child;\n                }\n                return workInProgress;\n            case 26:\n                if (supportsResources) return markRef(current, workInProgress), null === current ? (current = getResource(workInProgress.type, null, workInProgress.pendingProps, null)) ? workInProgress.memoizedState = current : isHydrating || (workInProgress.stateNode = createHoistableInstance(workInProgress.type, workInProgress.pendingProps, requiredContext(rootInstanceStackCursor.current), workInProgress)) : workInProgress.memoizedState = getResource(workInProgress.type, current.memoizedProps, workInProgress.pendingProps, current.memoizedState), null;\n            case 27:\n                if (supportsSingletons) return pushHostContext(workInProgress), null === current && supportsSingletons && isHydrating && (prevSibling = requiredContext(rootInstanceStackCursor.current), returnFiber = getHostContext(), prevSibling = workInProgress.stateNode = resolveSingletonInstance(workInProgress.type, workInProgress.pendingProps, prevSibling, returnFiber, !1), didSuspendOrErrorDEV || (returnFiber = diffHydratedPropsForDevWarnings(prevSibling, workInProgress.type, workInProgress.pendingProps, returnFiber), null !== returnFiber && (buildHydrationDiffNode(workInProgress, 0).serverProps = returnFiber)), hydrationParentFiber = workInProgress, rootOrSingletonContext = !0, nextHydratableInstance = getFirstHydratableChild(prevSibling)), returnFiber = workInProgress.pendingProps.children, null !== current || isHydrating ? reconcileChildren(current, workInProgress, returnFiber, renderLanes) : workInProgress.child = reconcileChildFibers(workInProgress, null, returnFiber, renderLanes), markRef(current, workInProgress), workInProgress.child;\n            case 5:\n                return null === current && isHydrating && (nextProps = getHostContext(), returnFiber = validateHydratableInstance(workInProgress.type, workInProgress.pendingProps, nextProps), prevSibling = nextHydratableInstance, (nextState = !prevSibling) || (nextState = canHydrateInstance(prevSibling, workInProgress.type, workInProgress.pendingProps, rootOrSingletonContext), null !== nextState ? (workInProgress.stateNode = nextState, didSuspendOrErrorDEV || (nextProps = diffHydratedPropsForDevWarnings(nextState, workInProgress.type, workInProgress.pendingProps, nextProps), null !== nextProps && (buildHydrationDiffNode(workInProgress, 0).serverProps = nextProps)), hydrationParentFiber = workInProgress, nextHydratableInstance = getFirstHydratableChild(nextState), rootOrSingletonContext = !1, nextProps = !0) : nextProps = !1, nextState = !nextProps), nextState && (returnFiber && warnNonHydratedInstance(workInProgress, prevSibling), throwOnHydrationMismatch(workInProgress))), pushHostContext(workInProgress), prevSibling = workInProgress.type, nextProps = workInProgress.pendingProps, nextState = null !== current ? current.memoizedProps : null, returnFiber = nextProps.children, shouldSetTextContent(prevSibling, nextProps) ? returnFiber = null : null !== nextState && shouldSetTextContent(prevSibling, nextState) && (workInProgress.flags |= 32), null !== workInProgress.memoizedState && (prevSibling = renderWithHooks(current, workInProgress, TransitionAwareHostComponent, null, null, renderLanes), isPrimaryRenderer ? HostTransitionContext._currentValue = prevSibling : HostTransitionContext._currentValue2 = prevSibling), markRef(current, workInProgress), reconcileChildren(current, workInProgress, returnFiber, renderLanes), workInProgress.child;\n            case 6:\n                return null === current && isHydrating && (current = workInProgress.pendingProps, renderLanes = getHostContext(), current = validateHydratableTextInstance(current, renderLanes), renderLanes = nextHydratableInstance, (returnFiber = !renderLanes) || (returnFiber = canHydrateTextInstance(renderLanes, workInProgress.pendingProps, rootOrSingletonContext), null !== returnFiber ? (workInProgress.stateNode = returnFiber, hydrationParentFiber = workInProgress, nextHydratableInstance = null, returnFiber = !0) : returnFiber = !1, returnFiber = !returnFiber), returnFiber && (current && warnNonHydratedInstance(workInProgress, renderLanes), throwOnHydrationMismatch(workInProgress))), null;\n            case 13:\n                return updateSuspenseComponent(current, workInProgress, renderLanes);\n            case 4:\n                return pushHostContainer(workInProgress, workInProgress.stateNode.containerInfo), returnFiber = workInProgress.pendingProps, null === current ? workInProgress.child = reconcileChildFibers(workInProgress, null, returnFiber, renderLanes) : reconcileChildren(current, workInProgress, returnFiber, renderLanes), workInProgress.child;\n            case 11:\n                return updateForwardRef(current, workInProgress, workInProgress.type, workInProgress.pendingProps, renderLanes);\n            case 7:\n                return reconcileChildren(current, workInProgress, workInProgress.pendingProps, renderLanes), workInProgress.child;\n            case 8:\n                return reconcileChildren(current, workInProgress, workInProgress.pendingProps.children, renderLanes), workInProgress.child;\n            case 12:\n                return workInProgress.flags |= 4, workInProgress.flags |= 2048, returnFiber = workInProgress.stateNode, returnFiber.effectDuration = -0, returnFiber.passiveEffectDuration = -0, reconcileChildren(current, workInProgress, workInProgress.pendingProps.children, renderLanes), workInProgress.child;\n            case 10:\n                return returnFiber = workInProgress.type, prevSibling = workInProgress.pendingProps, nextProps = prevSibling.value, \"value\" in prevSibling || hasWarnedAboutUsingNoValuePropOnContextProvider || (hasWarnedAboutUsingNoValuePropOnContextProvider = !0, console.error(\"The `value` prop is required for the `<Context.Provider>`. Did you misspell it or forget to pass it?\")), pushProvider(workInProgress, returnFiber, nextProps), reconcileChildren(current, workInProgress, prevSibling.children, renderLanes), workInProgress.child;\n            case 9:\n                return prevSibling = workInProgress.type._context, returnFiber = workInProgress.pendingProps.children, \"function\" !== typeof returnFiber && console.error(\"A context consumer was rendered with multiple children, or a child that isn't a function. A context consumer expects a single child that is a function. If you did pass a function, make sure there is no trailing or leading whitespace around it.\"), prepareToReadContext(workInProgress), prevSibling = readContext(prevSibling), markComponentRenderStarted(workInProgress), returnFiber = callComponentInDEV(returnFiber, prevSibling, void 0), markComponentRenderStopped(), workInProgress.flags |= 1, reconcileChildren(current, workInProgress, returnFiber, renderLanes), workInProgress.child;\n            case 14:\n                return updateMemoComponent(current, workInProgress, workInProgress.type, workInProgress.pendingProps, renderLanes);\n            case 15:\n                return updateSimpleMemoComponent(current, workInProgress, workInProgress.type, workInProgress.pendingProps, renderLanes);\n            case 19:\n                return updateSuspenseListComponent(current, workInProgress, renderLanes);\n            case 22:\n                return updateOffscreenComponent(current, workInProgress, renderLanes);\n            case 24:\n                return prepareToReadContext(workInProgress), returnFiber = readContext(CacheContext), null === current ? (prevSibling = peekCacheFromPool(), null === prevSibling && (prevSibling = workInProgressRoot, nextProps = createCache(), prevSibling.pooledCache = nextProps, retainCache(nextProps), null !== nextProps && (prevSibling.pooledCacheLanes |= renderLanes), prevSibling = nextProps), workInProgress.memoizedState = {\n                    parent: returnFiber,\n                    cache: prevSibling\n                }, initializeUpdateQueue(workInProgress), pushProvider(workInProgress, CacheContext, prevSibling)) : (0 !== (current.lanes & renderLanes) && (cloneUpdateQueue(current, workInProgress), processUpdateQueue(workInProgress, null, null, renderLanes), suspendIfUpdateReadFromEntangledAsyncAction()), prevSibling = current.memoizedState, nextProps = workInProgress.memoizedState, prevSibling.parent !== returnFiber ? (prevSibling = {\n                    parent: returnFiber,\n                    cache: returnFiber\n                }, workInProgress.memoizedState = prevSibling, 0 === workInProgress.lanes && (workInProgress.memoizedState = workInProgress.updateQueue.baseState = prevSibling), pushProvider(workInProgress, CacheContext, returnFiber)) : (returnFiber = nextProps.cache, pushProvider(workInProgress, CacheContext, returnFiber), returnFiber !== prevSibling.cache && propagateContextChanges(workInProgress, [\n                    CacheContext\n                ], renderLanes, !0))), reconcileChildren(current, workInProgress, workInProgress.pendingProps.children, renderLanes), workInProgress.child;\n            case 29:\n                throw workInProgress.pendingProps;\n        }\n        throw Error(\"Unknown unit of work tag (\" + workInProgress.tag + \"). This error is likely caused by a bug in React. Please file an issue.\");\n    }\n    function resetContextDependencies() {\n        lastContextDependency = currentlyRenderingFiber = null;\n        isDisallowedContextReadInDEV = !1;\n    }\n    function pushProvider(providerFiber, context, nextValue) {\n        isPrimaryRenderer ? (push(valueCursor, context._currentValue, providerFiber), context._currentValue = nextValue, push(rendererCursorDEV, context._currentRenderer, providerFiber), void 0 !== context._currentRenderer && null !== context._currentRenderer && context._currentRenderer !== rendererSigil && console.error(\"Detected multiple renderers concurrently rendering the same context provider. This is currently unsupported.\"), context._currentRenderer = rendererSigil) : (push(valueCursor, context._currentValue2, providerFiber), context._currentValue2 = nextValue, push(renderer2CursorDEV, context._currentRenderer2, providerFiber), void 0 !== context._currentRenderer2 && null !== context._currentRenderer2 && context._currentRenderer2 !== rendererSigil && console.error(\"Detected multiple renderers concurrently rendering the same context provider. This is currently unsupported.\"), context._currentRenderer2 = rendererSigil);\n    }\n    function popProvider(context, providerFiber) {\n        var currentValue = valueCursor.current;\n        isPrimaryRenderer ? (context._currentValue = currentValue, currentValue = rendererCursorDEV.current, pop(rendererCursorDEV, providerFiber), context._currentRenderer = currentValue) : (context._currentValue2 = currentValue, currentValue = renderer2CursorDEV.current, pop(renderer2CursorDEV, providerFiber), context._currentRenderer2 = currentValue);\n        pop(valueCursor, providerFiber);\n    }\n    function scheduleContextWorkOnParentPath(parent, renderLanes, propagationRoot) {\n        for(; null !== parent;){\n            var alternate = parent.alternate;\n            (parent.childLanes & renderLanes) !== renderLanes ? (parent.childLanes |= renderLanes, null !== alternate && (alternate.childLanes |= renderLanes)) : null !== alternate && (alternate.childLanes & renderLanes) !== renderLanes && (alternate.childLanes |= renderLanes);\n            if (parent === propagationRoot) break;\n            parent = parent.return;\n        }\n        parent !== propagationRoot && console.error(\"Expected to find the propagation root when scheduling context work. This error is likely caused by a bug in React. Please file an issue.\");\n    }\n    function propagateContextChanges(workInProgress, contexts, renderLanes, forcePropagateEntireTree) {\n        var fiber = workInProgress.child;\n        null !== fiber && (fiber.return = workInProgress);\n        for(; null !== fiber;){\n            var list = fiber.dependencies;\n            if (null !== list) {\n                var nextFiber = fiber.child;\n                list = list.firstContext;\n                a: for(; null !== list;){\n                    var dependency = list;\n                    list = fiber;\n                    for(var i = 0; i < contexts.length; i++)if (dependency.context === contexts[i]) {\n                        list.lanes |= renderLanes;\n                        dependency = list.alternate;\n                        null !== dependency && (dependency.lanes |= renderLanes);\n                        scheduleContextWorkOnParentPath(list.return, renderLanes, workInProgress);\n                        forcePropagateEntireTree || (nextFiber = null);\n                        break a;\n                    }\n                    list = dependency.next;\n                }\n            } else if (18 === fiber.tag) {\n                nextFiber = fiber.return;\n                if (null === nextFiber) throw Error(\"We just came from a parent so we must have had a parent. This is a bug in React.\");\n                nextFiber.lanes |= renderLanes;\n                list = nextFiber.alternate;\n                null !== list && (list.lanes |= renderLanes);\n                scheduleContextWorkOnParentPath(nextFiber, renderLanes, workInProgress);\n                nextFiber = null;\n            } else nextFiber = fiber.child;\n            if (null !== nextFiber) nextFiber.return = fiber;\n            else for(nextFiber = fiber; null !== nextFiber;){\n                if (nextFiber === workInProgress) {\n                    nextFiber = null;\n                    break;\n                }\n                fiber = nextFiber.sibling;\n                if (null !== fiber) {\n                    fiber.return = nextFiber.return;\n                    nextFiber = fiber;\n                    break;\n                }\n                nextFiber = nextFiber.return;\n            }\n            fiber = nextFiber;\n        }\n    }\n    function propagateParentContextChanges(current, workInProgress, renderLanes, forcePropagateEntireTree) {\n        current = null;\n        for(var parent = workInProgress, isInsidePropagationBailout = !1; null !== parent;){\n            if (!isInsidePropagationBailout) {\n                if (0 !== (parent.flags & 524288)) isInsidePropagationBailout = !0;\n                else if (0 !== (parent.flags & 262144)) break;\n            }\n            if (10 === parent.tag) {\n                var currentParent = parent.alternate;\n                if (null === currentParent) throw Error(\"Should have a current fiber. This is a bug in React.\");\n                currentParent = currentParent.memoizedProps;\n                if (null !== currentParent) {\n                    var context = parent.type;\n                    objectIs(parent.pendingProps.value, currentParent.value) || (null !== current ? current.push(context) : current = [\n                        context\n                    ]);\n                }\n            } else if (parent === hostTransitionProviderCursor.current) {\n                currentParent = parent.alternate;\n                if (null === currentParent) throw Error(\"Should have a current fiber. This is a bug in React.\");\n                currentParent.memoizedState.memoizedState !== parent.memoizedState.memoizedState && (null !== current ? current.push(HostTransitionContext) : current = [\n                    HostTransitionContext\n                ]);\n            }\n            parent = parent.return;\n        }\n        null !== current && propagateContextChanges(workInProgress, current, renderLanes, forcePropagateEntireTree);\n        workInProgress.flags |= 262144;\n    }\n    function checkIfContextChanged(currentDependencies) {\n        for(currentDependencies = currentDependencies.firstContext; null !== currentDependencies;){\n            var context = currentDependencies.context;\n            if (!objectIs(isPrimaryRenderer ? context._currentValue : context._currentValue2, currentDependencies.memoizedValue)) return !0;\n            currentDependencies = currentDependencies.next;\n        }\n        return !1;\n    }\n    function prepareToReadContext(workInProgress) {\n        currentlyRenderingFiber = workInProgress;\n        lastContextDependency = null;\n        workInProgress = workInProgress.dependencies;\n        null !== workInProgress && (workInProgress.firstContext = null);\n    }\n    function readContext(context) {\n        isDisallowedContextReadInDEV && console.error(\"Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo().\");\n        return readContextForConsumer(currentlyRenderingFiber, context);\n    }\n    function readContextDuringReconciliation(consumer, context) {\n        null === currentlyRenderingFiber && prepareToReadContext(consumer);\n        return readContextForConsumer(consumer, context);\n    }\n    function readContextForConsumer(consumer, context) {\n        var value = isPrimaryRenderer ? context._currentValue : context._currentValue2;\n        context = {\n            context: context,\n            memoizedValue: value,\n            next: null\n        };\n        if (null === lastContextDependency) {\n            if (null === consumer) throw Error(\"Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo().\");\n            lastContextDependency = context;\n            consumer.dependencies = {\n                lanes: 0,\n                firstContext: context,\n                _debugThenableState: null\n            };\n            consumer.flags |= 524288;\n        } else lastContextDependency = lastContextDependency.next = context;\n        return value;\n    }\n    function createCache() {\n        return {\n            controller: new AbortControllerLocal(),\n            data: new Map(),\n            refCount: 0\n        };\n    }\n    function retainCache(cache) {\n        cache.controller.signal.aborted && console.warn(\"A cache instance was retained after it was already freed. This likely indicates a bug in React.\");\n        cache.refCount++;\n    }\n    function releaseCache(cache) {\n        cache.refCount--;\n        0 > cache.refCount && console.warn(\"A cache instance was released after it was already freed. This likely indicates a bug in React.\");\n        0 === cache.refCount && scheduleCallback$1(NormalPriority, function() {\n            cache.controller.abort();\n        });\n    }\n    function peekCacheFromPool() {\n        var cacheResumedFromPreviousRender = resumedCache.current;\n        return null !== cacheResumedFromPreviousRender ? cacheResumedFromPreviousRender : workInProgressRoot.pooledCache;\n    }\n    function pushTransition(offscreenWorkInProgress, prevCachePool) {\n        null === prevCachePool ? push(resumedCache, resumedCache.current, offscreenWorkInProgress) : push(resumedCache, prevCachePool.pool, offscreenWorkInProgress);\n    }\n    function getSuspendedCache() {\n        var cacheFromPool = peekCacheFromPool();\n        return null === cacheFromPool ? null : {\n            parent: isPrimaryRenderer ? CacheContext._currentValue : CacheContext._currentValue2,\n            pool: cacheFromPool\n        };\n    }\n    function markUpdate(workInProgress) {\n        workInProgress.flags |= 4;\n    }\n    function doesRequireClone(current, completedWork) {\n        if (null !== current && current.child === completedWork.child) return !1;\n        if (0 !== (completedWork.flags & 16)) return !0;\n        for(current = completedWork.child; null !== current;){\n            if (0 !== (current.flags & 13878) || 0 !== (current.subtreeFlags & 13878)) return !0;\n            current = current.sibling;\n        }\n        return !1;\n    }\n    function appendAllChildren(parent, workInProgress, needsVisibilityToggle, isHidden) {\n        if (supportsMutation) for(needsVisibilityToggle = workInProgress.child; null !== needsVisibilityToggle;){\n            if (5 === needsVisibilityToggle.tag || 6 === needsVisibilityToggle.tag) appendInitialChild(parent, needsVisibilityToggle.stateNode);\n            else if (!(4 === needsVisibilityToggle.tag || supportsSingletons && 27 === needsVisibilityToggle.tag) && null !== needsVisibilityToggle.child) {\n                needsVisibilityToggle.child.return = needsVisibilityToggle;\n                needsVisibilityToggle = needsVisibilityToggle.child;\n                continue;\n            }\n            if (needsVisibilityToggle === workInProgress) break;\n            for(; null === needsVisibilityToggle.sibling;){\n                if (null === needsVisibilityToggle.return || needsVisibilityToggle.return === workInProgress) return;\n                needsVisibilityToggle = needsVisibilityToggle.return;\n            }\n            needsVisibilityToggle.sibling.return = needsVisibilityToggle.return;\n            needsVisibilityToggle = needsVisibilityToggle.sibling;\n        }\n        else if (supportsPersistence) for(var _node = workInProgress.child; null !== _node;){\n            if (5 === _node.tag) {\n                var instance = _node.stateNode;\n                needsVisibilityToggle && isHidden && (instance = cloneHiddenInstance(instance, _node.type, _node.memoizedProps));\n                appendInitialChild(parent, instance);\n            } else if (6 === _node.tag) instance = _node.stateNode, needsVisibilityToggle && isHidden && (instance = cloneHiddenTextInstance(instance, _node.memoizedProps)), appendInitialChild(parent, instance);\n            else if (4 !== _node.tag) {\n                if (22 === _node.tag && null !== _node.memoizedState) instance = _node.child, null !== instance && (instance.return = _node), appendAllChildren(parent, _node, !0, !0);\n                else if (null !== _node.child) {\n                    _node.child.return = _node;\n                    _node = _node.child;\n                    continue;\n                }\n            }\n            if (_node === workInProgress) break;\n            for(; null === _node.sibling;){\n                if (null === _node.return || _node.return === workInProgress) return;\n                _node = _node.return;\n            }\n            _node.sibling.return = _node.return;\n            _node = _node.sibling;\n        }\n    }\n    function appendAllChildrenToContainer(containerChildSet, workInProgress, needsVisibilityToggle, isHidden) {\n        if (supportsPersistence) for(var node = workInProgress.child; null !== node;){\n            if (5 === node.tag) {\n                var instance = node.stateNode;\n                needsVisibilityToggle && isHidden && (instance = cloneHiddenInstance(instance, node.type, node.memoizedProps));\n                appendChildToContainerChildSet(containerChildSet, instance);\n            } else if (6 === node.tag) instance = node.stateNode, needsVisibilityToggle && isHidden && (instance = cloneHiddenTextInstance(instance, node.memoizedProps)), appendChildToContainerChildSet(containerChildSet, instance);\n            else if (4 !== node.tag) {\n                if (22 === node.tag && null !== node.memoizedState) instance = node.child, null !== instance && (instance.return = node), appendAllChildrenToContainer(containerChildSet, node, !(null !== node.memoizedProps && \"manual\" === node.memoizedProps.mode), !0);\n                else if (null !== node.child) {\n                    node.child.return = node;\n                    node = node.child;\n                    continue;\n                }\n            }\n            if (node === workInProgress) break;\n            for(; null === node.sibling;){\n                if (null === node.return || node.return === workInProgress) return;\n                node = node.return;\n            }\n            node.sibling.return = node.return;\n            node = node.sibling;\n        }\n    }\n    function updateHostContainer(current, workInProgress) {\n        if (supportsPersistence && doesRequireClone(current, workInProgress)) {\n            current = workInProgress.stateNode;\n            var container = current.containerInfo, newChildSet = createContainerChildSet();\n            appendAllChildrenToContainer(newChildSet, workInProgress, !1, !1);\n            current.pendingChildren = newChildSet;\n            markUpdate(workInProgress);\n            finalizeContainerChildren(container, newChildSet);\n        }\n    }\n    function updateHostComponent(current, workInProgress, type, newProps) {\n        if (supportsMutation) current.memoizedProps !== newProps && markUpdate(workInProgress);\n        else if (supportsPersistence) {\n            var currentInstance = current.stateNode, _oldProps = current.memoizedProps;\n            if ((current = doesRequireClone(current, workInProgress)) || _oldProps !== newProps) {\n                var currentHostContext = getHostContext();\n                _oldProps = cloneInstance(currentInstance, type, _oldProps, newProps, !current, null);\n                _oldProps === currentInstance ? workInProgress.stateNode = currentInstance : (finalizeInitialChildren(_oldProps, type, newProps, currentHostContext) && markUpdate(workInProgress), workInProgress.stateNode = _oldProps, current ? appendAllChildren(_oldProps, workInProgress, !1, !1) : markUpdate(workInProgress));\n            } else workInProgress.stateNode = currentInstance;\n        }\n    }\n    function preloadInstanceAndSuspendIfNeeded(workInProgress, type, props) {\n        if (maySuspendCommit(type, props)) {\n            if (workInProgress.flags |= 16777216, !preloadInstance(type, props)) if (shouldRemainOnPreviousScreen()) workInProgress.flags |= 8192;\n            else throw suspendedThenable = noopSuspenseyCommitThenable, SuspenseyCommitException;\n        } else workInProgress.flags &= -16777217;\n    }\n    function preloadResourceAndSuspendIfNeeded(workInProgress, resource) {\n        if (mayResourceSuspendCommit(resource)) {\n            if (workInProgress.flags |= 16777216, !preloadResource(resource)) if (shouldRemainOnPreviousScreen()) workInProgress.flags |= 8192;\n            else throw suspendedThenable = noopSuspenseyCommitThenable, SuspenseyCommitException;\n        } else workInProgress.flags &= -16777217;\n    }\n    function scheduleRetryEffect(workInProgress, retryQueue) {\n        null !== retryQueue && (workInProgress.flags |= 4);\n        workInProgress.flags & 16384 && (retryQueue = 22 !== workInProgress.tag ? claimNextRetryLane() : 536870912, workInProgress.lanes |= retryQueue, workInProgressSuspendedRetryLanes |= retryQueue);\n    }\n    function cutOffTailIfNeeded(renderState, hasRenderedATailFallback) {\n        if (!isHydrating) switch(renderState.tailMode){\n            case \"hidden\":\n                hasRenderedATailFallback = renderState.tail;\n                for(var lastTailNode = null; null !== hasRenderedATailFallback;)null !== hasRenderedATailFallback.alternate && (lastTailNode = hasRenderedATailFallback), hasRenderedATailFallback = hasRenderedATailFallback.sibling;\n                null === lastTailNode ? renderState.tail = null : lastTailNode.sibling = null;\n                break;\n            case \"collapsed\":\n                lastTailNode = renderState.tail;\n                for(var _lastTailNode = null; null !== lastTailNode;)null !== lastTailNode.alternate && (_lastTailNode = lastTailNode), lastTailNode = lastTailNode.sibling;\n                null === _lastTailNode ? hasRenderedATailFallback || null === renderState.tail ? renderState.tail = null : renderState.tail.sibling = null : _lastTailNode.sibling = null;\n        }\n    }\n    function bubbleProperties(completedWork) {\n        var didBailout = null !== completedWork.alternate && completedWork.alternate.child === completedWork.child, newChildLanes = 0, subtreeFlags = 0;\n        if (didBailout) if ((completedWork.mode & 2) !== NoMode) {\n            for(var _treeBaseDuration = completedWork.selfBaseDuration, _child2 = completedWork.child; null !== _child2;)newChildLanes |= _child2.lanes | _child2.childLanes, subtreeFlags |= _child2.subtreeFlags & 31457280, subtreeFlags |= _child2.flags & 31457280, _treeBaseDuration += _child2.treeBaseDuration, _child2 = _child2.sibling;\n            completedWork.treeBaseDuration = _treeBaseDuration;\n        } else for(_treeBaseDuration = completedWork.child; null !== _treeBaseDuration;)newChildLanes |= _treeBaseDuration.lanes | _treeBaseDuration.childLanes, subtreeFlags |= _treeBaseDuration.subtreeFlags & 31457280, subtreeFlags |= _treeBaseDuration.flags & 31457280, _treeBaseDuration.return = completedWork, _treeBaseDuration = _treeBaseDuration.sibling;\n        else if ((completedWork.mode & 2) !== NoMode) {\n            _treeBaseDuration = completedWork.actualDuration;\n            _child2 = completedWork.selfBaseDuration;\n            for(var child = completedWork.child; null !== child;)newChildLanes |= child.lanes | child.childLanes, subtreeFlags |= child.subtreeFlags, subtreeFlags |= child.flags, _treeBaseDuration += child.actualDuration, _child2 += child.treeBaseDuration, child = child.sibling;\n            completedWork.actualDuration = _treeBaseDuration;\n            completedWork.treeBaseDuration = _child2;\n        } else for(_treeBaseDuration = completedWork.child; null !== _treeBaseDuration;)newChildLanes |= _treeBaseDuration.lanes | _treeBaseDuration.childLanes, subtreeFlags |= _treeBaseDuration.subtreeFlags, subtreeFlags |= _treeBaseDuration.flags, _treeBaseDuration.return = completedWork, _treeBaseDuration = _treeBaseDuration.sibling;\n        completedWork.subtreeFlags |= subtreeFlags;\n        completedWork.childLanes = newChildLanes;\n        return didBailout;\n    }\n    function completeWork(current, workInProgress, renderLanes) {\n        var newProps = workInProgress.pendingProps;\n        popTreeContext(workInProgress);\n        switch(workInProgress.tag){\n            case 16:\n            case 15:\n            case 0:\n            case 11:\n            case 7:\n            case 8:\n            case 12:\n            case 9:\n            case 14:\n                return bubbleProperties(workInProgress), null;\n            case 1:\n                return bubbleProperties(workInProgress), null;\n            case 3:\n                renderLanes = workInProgress.stateNode;\n                newProps = null;\n                null !== current && (newProps = current.memoizedState.cache);\n                workInProgress.memoizedState.cache !== newProps && (workInProgress.flags |= 2048);\n                popProvider(CacheContext, workInProgress);\n                popHostContainer(workInProgress);\n                renderLanes.pendingContext && (renderLanes.context = renderLanes.pendingContext, renderLanes.pendingContext = null);\n                if (null === current || null === current.child) popHydrationState(workInProgress) ? (emitPendingHydrationWarnings(), markUpdate(workInProgress)) : null === current || current.memoizedState.isDehydrated && 0 === (workInProgress.flags & 256) || (workInProgress.flags |= 1024, null !== hydrationErrors && (queueRecoverableErrors(hydrationErrors), hydrationErrors = null));\n                updateHostContainer(current, workInProgress);\n                bubbleProperties(workInProgress);\n                return null;\n            case 26:\n                if (supportsResources) {\n                    renderLanes = workInProgress.type;\n                    var nextResource = workInProgress.memoizedState;\n                    null === current ? (markUpdate(workInProgress), null !== nextResource ? (bubbleProperties(workInProgress), preloadResourceAndSuspendIfNeeded(workInProgress, nextResource)) : (bubbleProperties(workInProgress), preloadInstanceAndSuspendIfNeeded(workInProgress, renderLanes, newProps))) : nextResource ? nextResource !== current.memoizedState ? (markUpdate(workInProgress), bubbleProperties(workInProgress), preloadResourceAndSuspendIfNeeded(workInProgress, nextResource)) : (bubbleProperties(workInProgress), workInProgress.flags &= -16777217) : (supportsMutation ? current.memoizedProps !== newProps && markUpdate(workInProgress) : updateHostComponent(current, workInProgress, renderLanes, newProps), bubbleProperties(workInProgress), preloadInstanceAndSuspendIfNeeded(workInProgress, renderLanes, newProps));\n                    return null;\n                }\n            case 27:\n                if (supportsSingletons) {\n                    popHostContext(workInProgress);\n                    renderLanes = requiredContext(rootInstanceStackCursor.current);\n                    nextResource = workInProgress.type;\n                    if (null !== current && null != workInProgress.stateNode) supportsMutation ? current.memoizedProps !== newProps && markUpdate(workInProgress) : updateHostComponent(current, workInProgress, nextResource, newProps);\n                    else {\n                        if (!newProps) {\n                            if (null === workInProgress.stateNode) throw Error(\"We must have new props for new mounts. This error is likely caused by a bug in React. Please file an issue.\");\n                            bubbleProperties(workInProgress);\n                            return null;\n                        }\n                        current = getHostContext();\n                        popHydrationState(workInProgress) ? prepareToHydrateHostInstance(workInProgress, current) : (current = resolveSingletonInstance(nextResource, newProps, renderLanes, current, !0), workInProgress.stateNode = current, markUpdate(workInProgress));\n                    }\n                    bubbleProperties(workInProgress);\n                    return null;\n                }\n            case 5:\n                popHostContext(workInProgress);\n                renderLanes = workInProgress.type;\n                if (null !== current && null != workInProgress.stateNode) updateHostComponent(current, workInProgress, renderLanes, newProps);\n                else {\n                    if (!newProps) {\n                        if (null === workInProgress.stateNode) throw Error(\"We must have new props for new mounts. This error is likely caused by a bug in React. Please file an issue.\");\n                        bubbleProperties(workInProgress);\n                        return null;\n                    }\n                    current = getHostContext();\n                    popHydrationState(workInProgress) ? prepareToHydrateHostInstance(workInProgress, current) : (nextResource = requiredContext(rootInstanceStackCursor.current), nextResource = createInstance(renderLanes, newProps, nextResource, current, workInProgress), appendAllChildren(nextResource, workInProgress, !1, !1), workInProgress.stateNode = nextResource, finalizeInitialChildren(nextResource, renderLanes, newProps, current) && markUpdate(workInProgress));\n                }\n                bubbleProperties(workInProgress);\n                preloadInstanceAndSuspendIfNeeded(workInProgress, workInProgress.type, workInProgress.pendingProps);\n                return null;\n            case 6:\n                if (current && null != workInProgress.stateNode) renderLanes = current.memoizedProps, supportsMutation ? renderLanes !== newProps && markUpdate(workInProgress) : supportsPersistence && (renderLanes !== newProps ? (current = requiredContext(rootInstanceStackCursor.current), renderLanes = getHostContext(), workInProgress.stateNode = createTextInstance(newProps, current, renderLanes, workInProgress), markUpdate(workInProgress)) : workInProgress.stateNode = current.stateNode);\n                else {\n                    if (\"string\" !== typeof newProps && null === workInProgress.stateNode) throw Error(\"We must have new props for new mounts. This error is likely caused by a bug in React. Please file an issue.\");\n                    current = requiredContext(rootInstanceStackCursor.current);\n                    renderLanes = getHostContext();\n                    if (popHydrationState(workInProgress)) {\n                        if (!supportsHydration) throw Error(\"Expected prepareToHydrateHostTextInstance() to never be called. This error is likely caused by a bug in React. Please file an issue.\");\n                        current = workInProgress.stateNode;\n                        renderLanes = workInProgress.memoizedProps;\n                        nextResource = !didSuspendOrErrorDEV;\n                        newProps = null;\n                        var returnFiber = hydrationParentFiber;\n                        if (null !== returnFiber) switch(returnFiber.tag){\n                            case 3:\n                                nextResource && (nextResource = diffHydratedTextForDevWarnings(current, renderLanes, newProps), null !== nextResource && (buildHydrationDiffNode(workInProgress, 0).serverProps = nextResource));\n                                break;\n                            case 27:\n                            case 5:\n                                newProps = returnFiber.memoizedProps, nextResource && (nextResource = diffHydratedTextForDevWarnings(current, renderLanes, newProps), null !== nextResource && (buildHydrationDiffNode(workInProgress, 0).serverProps = nextResource));\n                        }\n                        hydrateTextInstance(current, renderLanes, workInProgress, newProps) || throwOnHydrationMismatch(workInProgress);\n                    } else workInProgress.stateNode = createTextInstance(newProps, current, renderLanes, workInProgress);\n                }\n                bubbleProperties(workInProgress);\n                return null;\n            case 13:\n                newProps = workInProgress.memoizedState;\n                if (null === current || null !== current.memoizedState && null !== current.memoizedState.dehydrated) {\n                    nextResource = popHydrationState(workInProgress);\n                    if (null !== newProps && null !== newProps.dehydrated) {\n                        if (null === current) {\n                            if (!nextResource) throw Error(\"A dehydrated suspense component was completed without a hydrated node. This is probably a bug in React.\");\n                            if (!supportsHydration) throw Error(\"Expected prepareToHydrateHostSuspenseInstance() to never be called. This error is likely caused by a bug in React. Please file an issue.\");\n                            nextResource = workInProgress.memoizedState;\n                            nextResource = null !== nextResource ? nextResource.dehydrated : null;\n                            if (!nextResource) throw Error(\"Expected to have a hydrated suspense instance. This error is likely caused by a bug in React. Please file an issue.\");\n                            hydrateSuspenseInstance(nextResource, workInProgress);\n                            bubbleProperties(workInProgress);\n                            (workInProgress.mode & 2) !== NoMode && null !== newProps && (nextResource = workInProgress.child, null !== nextResource && (workInProgress.treeBaseDuration -= nextResource.treeBaseDuration));\n                        } else emitPendingHydrationWarnings(), resetHydrationState(), 0 === (workInProgress.flags & 128) && (workInProgress.memoizedState = null), workInProgress.flags |= 4, bubbleProperties(workInProgress), (workInProgress.mode & 2) !== NoMode && null !== newProps && (nextResource = workInProgress.child, null !== nextResource && (workInProgress.treeBaseDuration -= nextResource.treeBaseDuration));\n                        nextResource = !1;\n                    } else null !== hydrationErrors && (queueRecoverableErrors(hydrationErrors), hydrationErrors = null), nextResource = !0;\n                    if (!nextResource) {\n                        if (workInProgress.flags & 256) return popSuspenseHandler(workInProgress), workInProgress;\n                        popSuspenseHandler(workInProgress);\n                        return null;\n                    }\n                }\n                popSuspenseHandler(workInProgress);\n                if (0 !== (workInProgress.flags & 128)) return workInProgress.lanes = renderLanes, (workInProgress.mode & 2) !== NoMode && transferActualDuration(workInProgress), workInProgress;\n                renderLanes = null !== newProps;\n                current = null !== current && null !== current.memoizedState;\n                renderLanes && (newProps = workInProgress.child, nextResource = null, null !== newProps.alternate && null !== newProps.alternate.memoizedState && null !== newProps.alternate.memoizedState.cachePool && (nextResource = newProps.alternate.memoizedState.cachePool.pool), returnFiber = null, null !== newProps.memoizedState && null !== newProps.memoizedState.cachePool && (returnFiber = newProps.memoizedState.cachePool.pool), returnFiber !== nextResource && (newProps.flags |= 2048));\n                renderLanes !== current && renderLanes && (workInProgress.child.flags |= 8192);\n                scheduleRetryEffect(workInProgress, workInProgress.updateQueue);\n                bubbleProperties(workInProgress);\n                (workInProgress.mode & 2) !== NoMode && renderLanes && (current = workInProgress.child, null !== current && (workInProgress.treeBaseDuration -= current.treeBaseDuration));\n                return null;\n            case 4:\n                return popHostContainer(workInProgress), updateHostContainer(current, workInProgress), null === current && preparePortalMount(workInProgress.stateNode.containerInfo), bubbleProperties(workInProgress), null;\n            case 10:\n                return popProvider(workInProgress.type, workInProgress), bubbleProperties(workInProgress), null;\n            case 19:\n                pop(suspenseStackCursor, workInProgress);\n                nextResource = workInProgress.memoizedState;\n                if (null === nextResource) return bubbleProperties(workInProgress), null;\n                newProps = 0 !== (workInProgress.flags & 128);\n                returnFiber = nextResource.rendering;\n                if (null === returnFiber) if (newProps) cutOffTailIfNeeded(nextResource, !1);\n                else {\n                    if (workInProgressRootExitStatus !== RootInProgress || null !== current && 0 !== (current.flags & 128)) for(current = workInProgress.child; null !== current;){\n                        returnFiber = findFirstSuspended(current);\n                        if (null !== returnFiber) {\n                            workInProgress.flags |= 128;\n                            cutOffTailIfNeeded(nextResource, !1);\n                            current = returnFiber.updateQueue;\n                            workInProgress.updateQueue = current;\n                            scheduleRetryEffect(workInProgress, current);\n                            workInProgress.subtreeFlags = 0;\n                            current = renderLanes;\n                            for(renderLanes = workInProgress.child; null !== renderLanes;)resetWorkInProgress(renderLanes, current), renderLanes = renderLanes.sibling;\n                            push(suspenseStackCursor, suspenseStackCursor.current & SubtreeSuspenseContextMask | ForceSuspenseFallback, workInProgress);\n                            return workInProgress.child;\n                        }\n                        current = current.sibling;\n                    }\n                    null !== nextResource.tail && now$1() > workInProgressRootRenderTargetTime && (workInProgress.flags |= 128, newProps = !0, cutOffTailIfNeeded(nextResource, !1), workInProgress.lanes = 4194304);\n                }\n                else {\n                    if (!newProps) if (current = findFirstSuspended(returnFiber), null !== current) {\n                        if (workInProgress.flags |= 128, newProps = !0, current = current.updateQueue, workInProgress.updateQueue = current, scheduleRetryEffect(workInProgress, current), cutOffTailIfNeeded(nextResource, !0), null === nextResource.tail && \"hidden\" === nextResource.tailMode && !returnFiber.alternate && !isHydrating) return bubbleProperties(workInProgress), null;\n                    } else 2 * now$1() - nextResource.renderingStartTime > workInProgressRootRenderTargetTime && 536870912 !== renderLanes && (workInProgress.flags |= 128, newProps = !0, cutOffTailIfNeeded(nextResource, !1), workInProgress.lanes = 4194304);\n                    nextResource.isBackwards ? (returnFiber.sibling = workInProgress.child, workInProgress.child = returnFiber) : (current = nextResource.last, null !== current ? current.sibling = returnFiber : workInProgress.child = returnFiber, nextResource.last = returnFiber);\n                }\n                if (null !== nextResource.tail) return current = nextResource.tail, nextResource.rendering = current, nextResource.tail = current.sibling, nextResource.renderingStartTime = now$1(), current.sibling = null, renderLanes = suspenseStackCursor.current, renderLanes = newProps ? renderLanes & SubtreeSuspenseContextMask | ForceSuspenseFallback : renderLanes & SubtreeSuspenseContextMask, push(suspenseStackCursor, renderLanes, workInProgress), current;\n                bubbleProperties(workInProgress);\n                return null;\n            case 22:\n            case 23:\n                return popSuspenseHandler(workInProgress), popHiddenContext(workInProgress), newProps = null !== workInProgress.memoizedState, null !== current ? null !== current.memoizedState !== newProps && (workInProgress.flags |= 8192) : newProps && (workInProgress.flags |= 8192), newProps ? 0 !== (renderLanes & 536870912) && 0 === (workInProgress.flags & 128) && (bubbleProperties(workInProgress), workInProgress.subtreeFlags & 6 && (workInProgress.flags |= 8192)) : bubbleProperties(workInProgress), renderLanes = workInProgress.updateQueue, null !== renderLanes && scheduleRetryEffect(workInProgress, renderLanes.retryQueue), renderLanes = null, null !== current && null !== current.memoizedState && null !== current.memoizedState.cachePool && (renderLanes = current.memoizedState.cachePool.pool), newProps = null, null !== workInProgress.memoizedState && null !== workInProgress.memoizedState.cachePool && (newProps = workInProgress.memoizedState.cachePool.pool), newProps !== renderLanes && (workInProgress.flags |= 2048), null !== current && pop(resumedCache, workInProgress), null;\n            case 24:\n                return renderLanes = null, null !== current && (renderLanes = current.memoizedState.cache), workInProgress.memoizedState.cache !== renderLanes && (workInProgress.flags |= 2048), popProvider(CacheContext, workInProgress), bubbleProperties(workInProgress), null;\n            case 25:\n                return null;\n        }\n        throw Error(\"Unknown unit of work tag (\" + workInProgress.tag + \"). This error is likely caused by a bug in React. Please file an issue.\");\n    }\n    function unwindWork(current, workInProgress) {\n        popTreeContext(workInProgress);\n        switch(workInProgress.tag){\n            case 1:\n                return current = workInProgress.flags, current & 65536 ? (workInProgress.flags = current & -65537 | 128, (workInProgress.mode & 2) !== NoMode && transferActualDuration(workInProgress), workInProgress) : null;\n            case 3:\n                return popProvider(CacheContext, workInProgress), popHostContainer(workInProgress), current = workInProgress.flags, 0 !== (current & 65536) && 0 === (current & 128) ? (workInProgress.flags = current & -65537 | 128, workInProgress) : null;\n            case 26:\n            case 27:\n            case 5:\n                return popHostContext(workInProgress), null;\n            case 13:\n                popSuspenseHandler(workInProgress);\n                current = workInProgress.memoizedState;\n                if (null !== current && null !== current.dehydrated) {\n                    if (null === workInProgress.alternate) throw Error(\"Threw in newly mounted dehydrated component. This is likely a bug in React. Please file an issue.\");\n                    resetHydrationState();\n                }\n                current = workInProgress.flags;\n                return current & 65536 ? (workInProgress.flags = current & -65537 | 128, (workInProgress.mode & 2) !== NoMode && transferActualDuration(workInProgress), workInProgress) : null;\n            case 19:\n                return pop(suspenseStackCursor, workInProgress), null;\n            case 4:\n                return popHostContainer(workInProgress), null;\n            case 10:\n                return popProvider(workInProgress.type, workInProgress), null;\n            case 22:\n            case 23:\n                return popSuspenseHandler(workInProgress), popHiddenContext(workInProgress), null !== current && pop(resumedCache, workInProgress), current = workInProgress.flags, current & 65536 ? (workInProgress.flags = current & -65537 | 128, (workInProgress.mode & 2) !== NoMode && transferActualDuration(workInProgress), workInProgress) : null;\n            case 24:\n                return popProvider(CacheContext, workInProgress), null;\n            case 25:\n                return null;\n            default:\n                return null;\n        }\n    }\n    function unwindInterruptedWork(current, interruptedWork) {\n        popTreeContext(interruptedWork);\n        switch(interruptedWork.tag){\n            case 3:\n                popProvider(CacheContext, interruptedWork);\n                popHostContainer(interruptedWork);\n                break;\n            case 26:\n            case 27:\n            case 5:\n                popHostContext(interruptedWork);\n                break;\n            case 4:\n                popHostContainer(interruptedWork);\n                break;\n            case 13:\n                popSuspenseHandler(interruptedWork);\n                break;\n            case 19:\n                pop(suspenseStackCursor, interruptedWork);\n                break;\n            case 10:\n                popProvider(interruptedWork.type, interruptedWork);\n                break;\n            case 22:\n            case 23:\n                popSuspenseHandler(interruptedWork);\n                popHiddenContext(interruptedWork);\n                null !== current && pop(resumedCache, interruptedWork);\n                break;\n            case 24:\n                popProvider(CacheContext, interruptedWork);\n        }\n    }\n    function shouldProfile(current) {\n        return (current.mode & 2) !== NoMode;\n    }\n    function commitHookLayoutEffects(finishedWork, hookFlags) {\n        shouldProfile(finishedWork) ? (startEffectTimer(), commitHookEffectListMount(hookFlags, finishedWork), recordEffectDuration()) : commitHookEffectListMount(hookFlags, finishedWork);\n    }\n    function commitHookLayoutUnmountEffects(finishedWork, nearestMountedAncestor, hookFlags) {\n        shouldProfile(finishedWork) ? (startEffectTimer(), commitHookEffectListUnmount(hookFlags, finishedWork, nearestMountedAncestor), recordEffectDuration()) : commitHookEffectListUnmount(hookFlags, finishedWork, nearestMountedAncestor);\n    }\n    function commitHookEffectListMount(flags, finishedWork) {\n        try {\n            var updateQueue = finishedWork.updateQueue, lastEffect = null !== updateQueue ? updateQueue.lastEffect : null;\n            if (null !== lastEffect) {\n                var firstEffect = lastEffect.next;\n                updateQueue = firstEffect;\n                do {\n                    if ((updateQueue.tag & flags) === flags && ((flags & Passive) !== NoFlags ? null !== injectedProfilingHooks && \"function\" === typeof injectedProfilingHooks.markComponentPassiveEffectMountStarted && injectedProfilingHooks.markComponentPassiveEffectMountStarted(finishedWork) : (flags & Layout) !== NoFlags && null !== injectedProfilingHooks && \"function\" === typeof injectedProfilingHooks.markComponentLayoutEffectMountStarted && injectedProfilingHooks.markComponentLayoutEffectMountStarted(finishedWork), lastEffect = void 0, (flags & Insertion) !== NoFlags && (isRunningInsertionEffect = !0), lastEffect = runWithFiberInDEV(finishedWork, callCreateInDEV, updateQueue), (flags & Insertion) !== NoFlags && (isRunningInsertionEffect = !1), (flags & Passive) !== NoFlags ? null !== injectedProfilingHooks && \"function\" === typeof injectedProfilingHooks.markComponentPassiveEffectMountStopped && injectedProfilingHooks.markComponentPassiveEffectMountStopped() : (flags & Layout) !== NoFlags && null !== injectedProfilingHooks && \"function\" === typeof injectedProfilingHooks.markComponentLayoutEffectMountStopped && injectedProfilingHooks.markComponentLayoutEffectMountStopped(), void 0 !== lastEffect && \"function\" !== typeof lastEffect)) {\n                        var hookName = void 0;\n                        hookName = 0 !== (updateQueue.tag & Layout) ? \"useLayoutEffect\" : 0 !== (updateQueue.tag & Insertion) ? \"useInsertionEffect\" : \"useEffect\";\n                        var addendum = void 0;\n                        addendum = null === lastEffect ? \" You returned null. If your effect does not require clean up, return undefined (or nothing).\" : \"function\" === typeof lastEffect.then ? \"\\n\\nIt looks like you wrote \" + hookName + \"(async () => ...) or returned a Promise. Instead, write the async function inside your effect and call it immediately:\\n\\n\" + hookName + \"(() => {\\n  async function fetchData() {\\n    // You can await here\\n    const response = await MyAPI.getData(someId);\\n    // ...\\n  }\\n  fetchData();\\n}, [someId]); // Or [] if effect doesn't need props or state\\n\\nLearn more about data fetching with Hooks: https://react.dev/link/hooks-data-fetching\" : \" You returned: \" + lastEffect;\n                        runWithFiberInDEV(finishedWork, function(n, a) {\n                            console.error(\"%s must not return anything besides a function, which is used for clean-up.%s\", n, a);\n                        }, hookName, addendum);\n                    }\n                    updateQueue = updateQueue.next;\n                }while (updateQueue !== firstEffect);\n            }\n        } catch (error) {\n            captureCommitPhaseError(finishedWork, finishedWork.return, error);\n        }\n    }\n    function commitHookEffectListUnmount(flags, finishedWork, nearestMountedAncestor) {\n        try {\n            var updateQueue = finishedWork.updateQueue, lastEffect = null !== updateQueue ? updateQueue.lastEffect : null;\n            if (null !== lastEffect) {\n                var firstEffect = lastEffect.next;\n                updateQueue = firstEffect;\n                do {\n                    if ((updateQueue.tag & flags) === flags) {\n                        var inst = updateQueue.inst, destroy = inst.destroy;\n                        void 0 !== destroy && (inst.destroy = void 0, (flags & Passive) !== NoFlags ? null !== injectedProfilingHooks && \"function\" === typeof injectedProfilingHooks.markComponentPassiveEffectUnmountStarted && injectedProfilingHooks.markComponentPassiveEffectUnmountStarted(finishedWork) : (flags & Layout) !== NoFlags && null !== injectedProfilingHooks && \"function\" === typeof injectedProfilingHooks.markComponentLayoutEffectUnmountStarted && injectedProfilingHooks.markComponentLayoutEffectUnmountStarted(finishedWork), (flags & Insertion) !== NoFlags && (isRunningInsertionEffect = !0), runWithFiberInDEV(finishedWork, callDestroyInDEV, finishedWork, nearestMountedAncestor, destroy), (flags & Insertion) !== NoFlags && (isRunningInsertionEffect = !1), (flags & Passive) !== NoFlags ? null !== injectedProfilingHooks && \"function\" === typeof injectedProfilingHooks.markComponentPassiveEffectUnmountStopped && injectedProfilingHooks.markComponentPassiveEffectUnmountStopped() : (flags & Layout) !== NoFlags && null !== injectedProfilingHooks && \"function\" === typeof injectedProfilingHooks.markComponentLayoutEffectUnmountStopped && injectedProfilingHooks.markComponentLayoutEffectUnmountStopped());\n                    }\n                    updateQueue = updateQueue.next;\n                }while (updateQueue !== firstEffect);\n            }\n        } catch (error) {\n            captureCommitPhaseError(finishedWork, finishedWork.return, error);\n        }\n    }\n    function commitHookPassiveMountEffects(finishedWork, hookFlags) {\n        shouldProfile(finishedWork) ? (startEffectTimer(), commitHookEffectListMount(hookFlags, finishedWork), recordEffectDuration()) : commitHookEffectListMount(hookFlags, finishedWork);\n    }\n    function commitHookPassiveUnmountEffects(finishedWork, nearestMountedAncestor, hookFlags) {\n        shouldProfile(finishedWork) ? (startEffectTimer(), commitHookEffectListUnmount(hookFlags, finishedWork, nearestMountedAncestor), recordEffectDuration()) : commitHookEffectListUnmount(hookFlags, finishedWork, nearestMountedAncestor);\n    }\n    function commitClassCallbacks(finishedWork) {\n        var updateQueue = finishedWork.updateQueue;\n        if (null !== updateQueue) {\n            var instance = finishedWork.stateNode;\n            finishedWork.type.defaultProps || \"ref\" in finishedWork.memoizedProps || didWarnAboutReassigningProps || (instance.props !== finishedWork.memoizedProps && console.error(\"Expected %s props to match memoized props before processing the update queue. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.\", getComponentNameFromFiber(finishedWork) || \"instance\"), instance.state !== finishedWork.memoizedState && console.error(\"Expected %s state to match memoized state before processing the update queue. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.\", getComponentNameFromFiber(finishedWork) || \"instance\"));\n            try {\n                runWithFiberInDEV(finishedWork, commitCallbacks, updateQueue, instance);\n            } catch (error) {\n                captureCommitPhaseError(finishedWork, finishedWork.return, error);\n            }\n        }\n    }\n    function callGetSnapshotBeforeUpdates(instance, prevProps, prevState) {\n        return instance.getSnapshotBeforeUpdate(prevProps, prevState);\n    }\n    function commitClassSnapshot(finishedWork, current) {\n        var prevProps = current.memoizedProps, prevState = current.memoizedState;\n        current = finishedWork.stateNode;\n        finishedWork.type.defaultProps || \"ref\" in finishedWork.memoizedProps || didWarnAboutReassigningProps || (current.props !== finishedWork.memoizedProps && console.error(\"Expected %s props to match memoized props before getSnapshotBeforeUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.\", getComponentNameFromFiber(finishedWork) || \"instance\"), current.state !== finishedWork.memoizedState && console.error(\"Expected %s state to match memoized state before getSnapshotBeforeUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.\", getComponentNameFromFiber(finishedWork) || \"instance\"));\n        try {\n            var resolvedPrevProps = resolveClassComponentProps(finishedWork.type, prevProps, finishedWork.elementType === finishedWork.type);\n            var snapshot = runWithFiberInDEV(finishedWork, callGetSnapshotBeforeUpdates, current, resolvedPrevProps, prevState);\n            prevProps = didWarnAboutUndefinedSnapshotBeforeUpdate;\n            void 0 !== snapshot || prevProps.has(finishedWork.type) || (prevProps.add(finishedWork.type), runWithFiberInDEV(finishedWork, function() {\n                console.error(\"%s.getSnapshotBeforeUpdate(): A snapshot value (or null) must be returned. You have returned undefined.\", getComponentNameFromFiber(finishedWork));\n            }));\n            current.__reactInternalSnapshotBeforeUpdate = snapshot;\n        } catch (error) {\n            captureCommitPhaseError(finishedWork, finishedWork.return, error);\n        }\n    }\n    function safelyCallComponentWillUnmount(current, nearestMountedAncestor, instance) {\n        instance.props = resolveClassComponentProps(current.type, current.memoizedProps);\n        instance.state = current.memoizedState;\n        shouldProfile(current) ? (startEffectTimer(), runWithFiberInDEV(current, callComponentWillUnmountInDEV, current, nearestMountedAncestor, instance), recordEffectDuration()) : runWithFiberInDEV(current, callComponentWillUnmountInDEV, current, nearestMountedAncestor, instance);\n    }\n    function commitAttachRef(finishedWork) {\n        var ref = finishedWork.ref;\n        if (null !== ref) {\n            var instance = finishedWork.stateNode;\n            switch(finishedWork.tag){\n                case 26:\n                case 27:\n                case 5:\n                    instance = getPublicInstance(instance);\n            }\n            if (\"function\" === typeof ref) if (shouldProfile(finishedWork)) try {\n                startEffectTimer(), finishedWork.refCleanup = ref(instance);\n            } finally{\n                recordEffectDuration();\n            }\n            else finishedWork.refCleanup = ref(instance);\n            else \"string\" === typeof ref ? console.error(\"String refs are no longer supported.\") : ref.hasOwnProperty(\"current\") || console.error(\"Unexpected ref object provided for %s. Use either a ref-setter function or React.createRef().\", getComponentNameFromFiber(finishedWork)), ref.current = instance;\n        }\n    }\n    function safelyAttachRef(current, nearestMountedAncestor) {\n        try {\n            runWithFiberInDEV(current, commitAttachRef, current);\n        } catch (error) {\n            captureCommitPhaseError(current, nearestMountedAncestor, error);\n        }\n    }\n    function safelyDetachRef(current, nearestMountedAncestor) {\n        var ref = current.ref, refCleanup = current.refCleanup;\n        if (null !== ref) if (\"function\" === typeof refCleanup) try {\n            if (shouldProfile(current)) try {\n                startEffectTimer(), runWithFiberInDEV(current, refCleanup);\n            } finally{\n                recordEffectDuration(current);\n            }\n            else runWithFiberInDEV(current, refCleanup);\n        } catch (error) {\n            captureCommitPhaseError(current, nearestMountedAncestor, error);\n        } finally{\n            current.refCleanup = null, current = current.alternate, null != current && (current.refCleanup = null);\n        }\n        else if (\"function\" === typeof ref) try {\n            if (shouldProfile(current)) try {\n                startEffectTimer(), runWithFiberInDEV(current, ref, null);\n            } finally{\n                recordEffectDuration(current);\n            }\n            else runWithFiberInDEV(current, ref, null);\n        } catch (error$3) {\n            captureCommitPhaseError(current, nearestMountedAncestor, error$3);\n        }\n        else ref.current = null;\n    }\n    function commitProfiler(finishedWork, current, commitStartTime, effectDuration) {\n        var _finishedWork$memoize = finishedWork.memoizedProps, id = _finishedWork$memoize.id, onCommit = _finishedWork$memoize.onCommit;\n        _finishedWork$memoize = _finishedWork$memoize.onRender;\n        current = null === current ? \"mount\" : \"update\";\n        currentUpdateIsNested && (current = \"nested-update\");\n        \"function\" === typeof _finishedWork$memoize && _finishedWork$memoize(id, current, finishedWork.actualDuration, finishedWork.treeBaseDuration, finishedWork.actualStartTime, commitStartTime);\n        \"function\" === typeof onCommit && onCommit(finishedWork.memoizedProps.id, current, effectDuration, commitStartTime);\n    }\n    function commitProfilerPostCommitImpl(finishedWork, current, commitStartTime, passiveEffectDuration) {\n        var _finishedWork$memoize2 = finishedWork.memoizedProps;\n        finishedWork = _finishedWork$memoize2.id;\n        _finishedWork$memoize2 = _finishedWork$memoize2.onPostCommit;\n        current = null === current ? \"mount\" : \"update\";\n        currentUpdateIsNested && (current = \"nested-update\");\n        \"function\" === typeof _finishedWork$memoize2 && _finishedWork$memoize2(finishedWork, current, passiveEffectDuration, commitStartTime);\n    }\n    function commitHostMount(finishedWork) {\n        var type = finishedWork.type, props = finishedWork.memoizedProps, instance = finishedWork.stateNode;\n        try {\n            runWithFiberInDEV(finishedWork, commitMount, instance, type, props, finishedWork);\n        } catch (error) {\n            captureCommitPhaseError(finishedWork, finishedWork.return, error);\n        }\n    }\n    function commitHostUpdate(finishedWork, newProps, oldProps) {\n        try {\n            runWithFiberInDEV(finishedWork, commitUpdate, finishedWork.stateNode, finishedWork.type, oldProps, newProps, finishedWork);\n        } catch (error) {\n            captureCommitPhaseError(finishedWork, finishedWork.return, error);\n        }\n    }\n    function isHostParent(fiber) {\n        return 5 === fiber.tag || 3 === fiber.tag || (supportsResources ? 26 === fiber.tag : !1) || (supportsSingletons ? 27 === fiber.tag : !1) || 4 === fiber.tag;\n    }\n    function getHostSibling(fiber) {\n        a: for(;;){\n            for(; null === fiber.sibling;){\n                if (null === fiber.return || isHostParent(fiber.return)) return null;\n                fiber = fiber.return;\n            }\n            fiber.sibling.return = fiber.return;\n            for(fiber = fiber.sibling; 5 !== fiber.tag && 6 !== fiber.tag && (supportsSingletons ? 27 !== fiber.tag : 1) && 18 !== fiber.tag;){\n                if (fiber.flags & 2) continue a;\n                if (null === fiber.child || 4 === fiber.tag) continue a;\n                else fiber.child.return = fiber, fiber = fiber.child;\n            }\n            if (!(fiber.flags & 2)) return fiber.stateNode;\n        }\n    }\n    function insertOrAppendPlacementNodeIntoContainer(node, before, parent) {\n        var tag = node.tag;\n        if (5 === tag || 6 === tag) node = node.stateNode, before ? insertInContainerBefore(parent, node, before) : appendChildToContainer(parent, node);\n        else if (!(4 === tag || supportsSingletons && 27 === tag) && (node = node.child, null !== node)) for(insertOrAppendPlacementNodeIntoContainer(node, before, parent), node = node.sibling; null !== node;)insertOrAppendPlacementNodeIntoContainer(node, before, parent), node = node.sibling;\n    }\n    function insertOrAppendPlacementNode(node, before, parent) {\n        var tag = node.tag;\n        if (5 === tag || 6 === tag) node = node.stateNode, before ? insertBefore(parent, node, before) : appendChild(parent, node);\n        else if (!(4 === tag || supportsSingletons && 27 === tag) && (node = node.child, null !== node)) for(insertOrAppendPlacementNode(node, before, parent), node = node.sibling; null !== node;)insertOrAppendPlacementNode(node, before, parent), node = node.sibling;\n    }\n    function commitPlacement(finishedWork) {\n        if (supportsMutation && (!supportsSingletons || 27 !== finishedWork.tag)) {\n            a: {\n                for(var parent = finishedWork.return; null !== parent;){\n                    if (isHostParent(parent)) {\n                        var parentFiber = parent;\n                        break a;\n                    }\n                    parent = parent.return;\n                }\n                throw Error(\"Expected to find a host parent. This error is likely caused by a bug in React. Please file an issue.\");\n            }\n            switch(parentFiber.tag){\n                case 27:\n                    if (supportsSingletons) {\n                        parent = parentFiber.stateNode;\n                        parentFiber = getHostSibling(finishedWork);\n                        insertOrAppendPlacementNode(finishedWork, parentFiber, parent);\n                        break;\n                    }\n                case 5:\n                    parent = parentFiber.stateNode;\n                    parentFiber.flags & 32 && (resetTextContent(parent), parentFiber.flags &= -33);\n                    parentFiber = getHostSibling(finishedWork);\n                    insertOrAppendPlacementNode(finishedWork, parentFiber, parent);\n                    break;\n                case 3:\n                case 4:\n                    parent = parentFiber.stateNode.containerInfo;\n                    parentFiber = getHostSibling(finishedWork);\n                    insertOrAppendPlacementNodeIntoContainer(finishedWork, parentFiber, parent);\n                    break;\n                default:\n                    throw Error(\"Invalid host parent fiber. This error is likely caused by a bug in React. Please file an issue.\");\n            }\n        }\n    }\n    function commitHostPortalContainerChildren(portal, finishedWork, pendingChildren) {\n        portal = portal.containerInfo;\n        try {\n            runWithFiberInDEV(finishedWork, replaceContainerChildren, portal, pendingChildren);\n        } catch (error) {\n            captureCommitPhaseError(finishedWork, finishedWork.return, error);\n        }\n    }\n    function commitBeforeMutationEffects(root, firstChild) {\n        prepareForCommit(root.containerInfo);\n        for(nextEffect = firstChild; null !== nextEffect;)if (root = nextEffect, firstChild = root.child, 0 !== (root.subtreeFlags & 1028) && null !== firstChild) firstChild.return = root, nextEffect = firstChild;\n        else for(; null !== nextEffect;){\n            firstChild = root = nextEffect;\n            var current = firstChild.alternate, flags = firstChild.flags;\n            switch(firstChild.tag){\n                case 0:\n                    break;\n                case 11:\n                case 15:\n                    break;\n                case 1:\n                    0 !== (flags & 1024) && null !== current && commitClassSnapshot(firstChild, current);\n                    break;\n                case 3:\n                    0 !== (flags & 1024) && supportsMutation && clearContainer(firstChild.stateNode.containerInfo);\n                    break;\n                case 5:\n                case 26:\n                case 27:\n                case 6:\n                case 4:\n                case 17:\n                    break;\n                default:\n                    if (0 !== (flags & 1024)) throw Error(\"This unit of work tag should not have side-effects. This error is likely caused by a bug in React. Please file an issue.\");\n            }\n            firstChild = root.sibling;\n            if (null !== firstChild) {\n                firstChild.return = root.return;\n                nextEffect = firstChild;\n                break;\n            }\n            nextEffect = root.return;\n        }\n        root = shouldFireAfterActiveInstanceBlur;\n        shouldFireAfterActiveInstanceBlur = !1;\n        return root;\n    }\n    function commitLayoutEffectOnFiber(finishedRoot, current, finishedWork) {\n        var flags = finishedWork.flags;\n        switch(finishedWork.tag){\n            case 0:\n            case 11:\n            case 15:\n                recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);\n                flags & 4 && commitHookLayoutEffects(finishedWork, Layout | HasEffect);\n                break;\n            case 1:\n                recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);\n                if (flags & 4) if (finishedRoot = finishedWork.stateNode, null === current) finishedWork.type.defaultProps || \"ref\" in finishedWork.memoizedProps || didWarnAboutReassigningProps || (finishedRoot.props !== finishedWork.memoizedProps && console.error(\"Expected %s props to match memoized props before componentDidMount. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.\", getComponentNameFromFiber(finishedWork) || \"instance\"), finishedRoot.state !== finishedWork.memoizedState && console.error(\"Expected %s state to match memoized state before componentDidMount. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.\", getComponentNameFromFiber(finishedWork) || \"instance\")), shouldProfile(finishedWork) ? (startEffectTimer(), runWithFiberInDEV(finishedWork, callComponentDidMountInDEV, finishedWork, finishedRoot), recordEffectDuration()) : runWithFiberInDEV(finishedWork, callComponentDidMountInDEV, finishedWork, finishedRoot);\n                else {\n                    var prevProps = resolveClassComponentProps(finishedWork.type, current.memoizedProps);\n                    current = current.memoizedState;\n                    finishedWork.type.defaultProps || \"ref\" in finishedWork.memoizedProps || didWarnAboutReassigningProps || (finishedRoot.props !== finishedWork.memoizedProps && console.error(\"Expected %s props to match memoized props before componentDidUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.\", getComponentNameFromFiber(finishedWork) || \"instance\"), finishedRoot.state !== finishedWork.memoizedState && console.error(\"Expected %s state to match memoized state before componentDidUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.\", getComponentNameFromFiber(finishedWork) || \"instance\"));\n                    shouldProfile(finishedWork) ? (startEffectTimer(), runWithFiberInDEV(finishedWork, callComponentDidUpdateInDEV, finishedWork, finishedRoot, prevProps, current, finishedRoot.__reactInternalSnapshotBeforeUpdate), recordEffectDuration()) : runWithFiberInDEV(finishedWork, callComponentDidUpdateInDEV, finishedWork, finishedRoot, prevProps, current, finishedRoot.__reactInternalSnapshotBeforeUpdate);\n                }\n                flags & 64 && commitClassCallbacks(finishedWork);\n                flags & 512 && safelyAttachRef(finishedWork, finishedWork.return);\n                break;\n            case 3:\n                current = pushNestedEffectDurations();\n                recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);\n                if (flags & 64 && (flags = finishedWork.updateQueue, null !== flags)) {\n                    prevProps = null;\n                    if (null !== finishedWork.child) switch(finishedWork.child.tag){\n                        case 27:\n                        case 5:\n                            prevProps = getPublicInstance(finishedWork.child.stateNode);\n                            break;\n                        case 1:\n                            prevProps = finishedWork.child.stateNode;\n                    }\n                    try {\n                        runWithFiberInDEV(finishedWork, commitCallbacks, flags, prevProps);\n                    } catch (error) {\n                        captureCommitPhaseError(finishedWork, finishedWork.return, error);\n                    }\n                }\n                finishedRoot.effectDuration += popNestedEffectDurations(current);\n                break;\n            case 26:\n                if (supportsResources) {\n                    recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);\n                    flags & 512 && safelyAttachRef(finishedWork, finishedWork.return);\n                    break;\n                }\n            case 27:\n            case 5:\n                recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);\n                null === current && flags & 4 && commitHostMount(finishedWork);\n                flags & 512 && safelyAttachRef(finishedWork, finishedWork.return);\n                break;\n            case 12:\n                if (flags & 4) {\n                    flags = pushNestedEffectDurations();\n                    recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);\n                    finishedRoot = finishedWork.stateNode;\n                    finishedRoot.effectDuration += bubbleNestedEffectDurations(flags);\n                    try {\n                        runWithFiberInDEV(finishedWork, commitProfiler, finishedWork, current, commitStartTime, finishedRoot.effectDuration);\n                    } catch (error) {\n                        captureCommitPhaseError(finishedWork, finishedWork.return, error);\n                    }\n                } else recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);\n                break;\n            case 13:\n                recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);\n                flags & 4 && commitSuspenseHydrationCallbacks(finishedRoot, finishedWork);\n                break;\n            case 22:\n                prevProps = null !== finishedWork.memoizedState || offscreenSubtreeIsHidden;\n                if (!prevProps) {\n                    current = null !== current && null !== current.memoizedState || offscreenSubtreeWasHidden;\n                    var prevOffscreenSubtreeIsHidden = offscreenSubtreeIsHidden, prevOffscreenSubtreeWasHidden = offscreenSubtreeWasHidden;\n                    offscreenSubtreeIsHidden = prevProps;\n                    (offscreenSubtreeWasHidden = current) && !prevOffscreenSubtreeWasHidden ? recursivelyTraverseReappearLayoutEffects(finishedRoot, finishedWork, 0 !== (finishedWork.subtreeFlags & 8772)) : recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);\n                    offscreenSubtreeIsHidden = prevOffscreenSubtreeIsHidden;\n                    offscreenSubtreeWasHidden = prevOffscreenSubtreeWasHidden;\n                }\n                flags & 512 && (\"manual\" === finishedWork.memoizedProps.mode ? safelyAttachRef(finishedWork, finishedWork.return) : safelyDetachRef(finishedWork, finishedWork.return));\n                break;\n            default:\n                recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);\n        }\n    }\n    function detachFiberAfterEffects(fiber) {\n        var alternate = fiber.alternate;\n        null !== alternate && (fiber.alternate = null, detachFiberAfterEffects(alternate));\n        fiber.child = null;\n        fiber.deletions = null;\n        fiber.sibling = null;\n        5 === fiber.tag && (alternate = fiber.stateNode, null !== alternate && detachDeletedInstance(alternate));\n        fiber.stateNode = null;\n        fiber._debugOwner = null;\n        fiber.return = null;\n        fiber.dependencies = null;\n        fiber.memoizedProps = null;\n        fiber.memoizedState = null;\n        fiber.pendingProps = null;\n        fiber.stateNode = null;\n        fiber.updateQueue = null;\n    }\n    function recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, parent) {\n        for(parent = parent.child; null !== parent;)commitDeletionEffectsOnFiber(finishedRoot, nearestMountedAncestor, parent), parent = parent.sibling;\n    }\n    function commitDeletionEffectsOnFiber(finishedRoot, nearestMountedAncestor, deletedFiber) {\n        if (injectedHook && \"function\" === typeof injectedHook.onCommitFiberUnmount) try {\n            injectedHook.onCommitFiberUnmount(rendererID, deletedFiber);\n        } catch (err) {\n            hasLoggedError || (hasLoggedError = !0, console.error(\"React instrumentation encountered an error: %s\", err));\n        }\n        switch(deletedFiber.tag){\n            case 26:\n                if (supportsResources) {\n                    offscreenSubtreeWasHidden || safelyDetachRef(deletedFiber, nearestMountedAncestor);\n                    recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);\n                    deletedFiber.memoizedState ? releaseResource(deletedFiber.memoizedState) : deletedFiber.stateNode && unmountHoistable(deletedFiber.stateNode);\n                    break;\n                }\n            case 27:\n                if (supportsSingletons) {\n                    offscreenSubtreeWasHidden || safelyDetachRef(deletedFiber, nearestMountedAncestor);\n                    var prevHostParent = hostParent, prevHostParentIsContainer = hostParentIsContainer;\n                    hostParent = deletedFiber.stateNode;\n                    recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);\n                    releaseSingletonInstance(deletedFiber.stateNode);\n                    hostParent = prevHostParent;\n                    hostParentIsContainer = prevHostParentIsContainer;\n                    break;\n                }\n            case 5:\n                offscreenSubtreeWasHidden || safelyDetachRef(deletedFiber, nearestMountedAncestor);\n            case 6:\n                if (supportsMutation) {\n                    if (prevHostParent = hostParent, prevHostParentIsContainer = hostParentIsContainer, hostParent = null, recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber), hostParent = prevHostParent, hostParentIsContainer = prevHostParentIsContainer, null !== hostParent) if (hostParentIsContainer) try {\n                        runWithFiberInDEV(deletedFiber, removeChildFromContainer, hostParent, deletedFiber.stateNode);\n                    } catch (error) {\n                        captureCommitPhaseError(deletedFiber, nearestMountedAncestor, error);\n                    }\n                    else try {\n                        runWithFiberInDEV(deletedFiber, removeChild, hostParent, deletedFiber.stateNode);\n                    } catch (error) {\n                        captureCommitPhaseError(deletedFiber, nearestMountedAncestor, error);\n                    }\n                } else recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);\n                break;\n            case 18:\n                supportsMutation && null !== hostParent && (hostParentIsContainer ? clearSuspenseBoundaryFromContainer(hostParent, deletedFiber.stateNode) : clearSuspenseBoundary(hostParent, deletedFiber.stateNode));\n                break;\n            case 4:\n                supportsMutation ? (prevHostParent = hostParent, prevHostParentIsContainer = hostParentIsContainer, hostParent = deletedFiber.stateNode.containerInfo, hostParentIsContainer = !0, recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber), hostParent = prevHostParent, hostParentIsContainer = prevHostParentIsContainer) : (supportsPersistence && commitHostPortalContainerChildren(deletedFiber.stateNode, deletedFiber, createContainerChildSet()), recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber));\n                break;\n            case 0:\n            case 11:\n            case 14:\n            case 15:\n                offscreenSubtreeWasHidden || commitHookEffectListUnmount(Insertion, deletedFiber, nearestMountedAncestor);\n                offscreenSubtreeWasHidden || commitHookLayoutUnmountEffects(deletedFiber, nearestMountedAncestor, Layout);\n                recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);\n                break;\n            case 1:\n                offscreenSubtreeWasHidden || (safelyDetachRef(deletedFiber, nearestMountedAncestor), prevHostParent = deletedFiber.stateNode, \"function\" === typeof prevHostParent.componentWillUnmount && safelyCallComponentWillUnmount(deletedFiber, nearestMountedAncestor, prevHostParent));\n                recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);\n                break;\n            case 21:\n                recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);\n                break;\n            case 22:\n                offscreenSubtreeWasHidden || safelyDetachRef(deletedFiber, nearestMountedAncestor);\n                offscreenSubtreeWasHidden = (prevHostParent = offscreenSubtreeWasHidden) || null !== deletedFiber.memoizedState;\n                recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);\n                offscreenSubtreeWasHidden = prevHostParent;\n                break;\n            default:\n                recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);\n        }\n    }\n    function commitSuspenseHydrationCallbacks(finishedRoot, finishedWork) {\n        if (supportsHydration && null === finishedWork.memoizedState && (finishedRoot = finishedWork.alternate, null !== finishedRoot && (finishedRoot = finishedRoot.memoizedState, null !== finishedRoot && (finishedRoot = finishedRoot.dehydrated, null !== finishedRoot)))) try {\n            runWithFiberInDEV(finishedWork, commitHydratedSuspenseInstance, finishedRoot);\n        } catch (error) {\n            captureCommitPhaseError(finishedWork, finishedWork.return, error);\n        }\n    }\n    function getRetryCache(finishedWork) {\n        switch(finishedWork.tag){\n            case 13:\n            case 19:\n                var retryCache = finishedWork.stateNode;\n                null === retryCache && (retryCache = finishedWork.stateNode = new PossiblyWeakSet());\n                return retryCache;\n            case 22:\n                return finishedWork = finishedWork.stateNode, retryCache = finishedWork._retryCache, null === retryCache && (retryCache = finishedWork._retryCache = new PossiblyWeakSet()), retryCache;\n            default:\n                throw Error(\"Unexpected Suspense handler tag (\" + finishedWork.tag + \"). This is a bug in React.\");\n        }\n    }\n    function attachSuspenseRetryListeners(finishedWork, wakeables) {\n        var retryCache = getRetryCache(finishedWork);\n        wakeables.forEach(function(wakeable) {\n            var retry = resolveRetryWakeable.bind(null, finishedWork, wakeable);\n            if (!retryCache.has(wakeable)) {\n                retryCache.add(wakeable);\n                if (isDevToolsPresent) if (null !== inProgressLanes && null !== inProgressRoot) restorePendingUpdaters(inProgressRoot, inProgressLanes);\n                else throw Error(\"Expected finished root and lanes to be set. This is a bug in React.\");\n                wakeable.then(retry, retry);\n            }\n        });\n    }\n    function commitMutationEffects(root, finishedWork, committedLanes) {\n        inProgressLanes = committedLanes;\n        inProgressRoot = root;\n        commitMutationEffectsOnFiber(finishedWork, root);\n        inProgressRoot = inProgressLanes = null;\n    }\n    function recursivelyTraverseMutationEffects(root$jscomp$0, parentFiber) {\n        var deletions = parentFiber.deletions;\n        if (null !== deletions) for(var i = 0; i < deletions.length; i++){\n            var root = root$jscomp$0, returnFiber = parentFiber, deletedFiber = deletions[i];\n            if (supportsMutation) {\n                var parent = returnFiber;\n                a: for(; null !== parent;){\n                    switch(parent.tag){\n                        case 27:\n                        case 5:\n                            hostParent = parent.stateNode;\n                            hostParentIsContainer = !1;\n                            break a;\n                        case 3:\n                            hostParent = parent.stateNode.containerInfo;\n                            hostParentIsContainer = !0;\n                            break a;\n                        case 4:\n                            hostParent = parent.stateNode.containerInfo;\n                            hostParentIsContainer = !0;\n                            break a;\n                    }\n                    parent = parent.return;\n                }\n                if (null === hostParent) throw Error(\"Expected to find a host parent. This error is likely caused by a bug in React. Please file an issue.\");\n                commitDeletionEffectsOnFiber(root, returnFiber, deletedFiber);\n                hostParent = null;\n                hostParentIsContainer = !1;\n            } else commitDeletionEffectsOnFiber(root, returnFiber, deletedFiber);\n            root = deletedFiber;\n            returnFiber = root.alternate;\n            null !== returnFiber && (returnFiber.return = null);\n            root.return = null;\n        }\n        if (parentFiber.subtreeFlags & 13878) for(parentFiber = parentFiber.child; null !== parentFiber;)commitMutationEffectsOnFiber(parentFiber, root$jscomp$0), parentFiber = parentFiber.sibling;\n    }\n    function commitMutationEffectsOnFiber(finishedWork, root) {\n        var current = finishedWork.alternate, flags = finishedWork.flags;\n        switch(finishedWork.tag){\n            case 0:\n            case 11:\n            case 14:\n            case 15:\n                recursivelyTraverseMutationEffects(root, finishedWork);\n                commitReconciliationEffects(finishedWork);\n                flags & 4 && (commitHookEffectListUnmount(Insertion | HasEffect, finishedWork, finishedWork.return), commitHookEffectListMount(Insertion | HasEffect, finishedWork), commitHookLayoutUnmountEffects(finishedWork, finishedWork.return, Layout | HasEffect));\n                break;\n            case 1:\n                recursivelyTraverseMutationEffects(root, finishedWork);\n                commitReconciliationEffects(finishedWork);\n                flags & 512 && (offscreenSubtreeWasHidden || null === current || safelyDetachRef(current, current.return));\n                flags & 64 && offscreenSubtreeIsHidden && (finishedWork = finishedWork.updateQueue, null !== finishedWork && (flags = finishedWork.callbacks, null !== flags && (current = finishedWork.shared.hiddenCallbacks, finishedWork.shared.hiddenCallbacks = null === current ? flags : current.concat(flags))));\n                break;\n            case 26:\n                if (supportsResources) {\n                    var hoistableRoot = currentHoistableRoot;\n                    recursivelyTraverseMutationEffects(root, finishedWork);\n                    commitReconciliationEffects(finishedWork);\n                    flags & 512 && (offscreenSubtreeWasHidden || null === current || safelyDetachRef(current, current.return));\n                    flags & 4 && (flags = null !== current ? current.memoizedState : null, root = finishedWork.memoizedState, null === current ? null === root ? null === finishedWork.stateNode ? finishedWork.stateNode = hydrateHoistable(hoistableRoot, finishedWork.type, finishedWork.memoizedProps, finishedWork) : mountHoistable(hoistableRoot, finishedWork.type, finishedWork.stateNode) : finishedWork.stateNode = acquireResource(hoistableRoot, root, finishedWork.memoizedProps) : flags !== root ? (null === flags ? null !== current.stateNode && unmountHoistable(current.stateNode) : releaseResource(flags), null === root ? mountHoistable(hoistableRoot, finishedWork.type, finishedWork.stateNode) : acquireResource(hoistableRoot, root, finishedWork.memoizedProps)) : null === root && null !== finishedWork.stateNode && commitHostUpdate(finishedWork, finishedWork.memoizedProps, current.memoizedProps));\n                    break;\n                }\n            case 27:\n                if (supportsSingletons && flags & 4 && null === finishedWork.alternate) {\n                    hoistableRoot = finishedWork.stateNode;\n                    var props = finishedWork.memoizedProps;\n                    try {\n                        clearSingleton(hoistableRoot), runWithFiberInDEV(finishedWork, acquireSingletonInstance, finishedWork.type, props, hoistableRoot, finishedWork);\n                    } catch (error) {\n                        captureCommitPhaseError(finishedWork, finishedWork.return, error);\n                    }\n                }\n            case 5:\n                recursivelyTraverseMutationEffects(root, finishedWork);\n                commitReconciliationEffects(finishedWork);\n                flags & 512 && (offscreenSubtreeWasHidden || null === current || safelyDetachRef(current, current.return));\n                if (supportsMutation) {\n                    if (finishedWork.flags & 32) {\n                        root = finishedWork.stateNode;\n                        try {\n                            runWithFiberInDEV(finishedWork, resetTextContent, root);\n                        } catch (error) {\n                            captureCommitPhaseError(finishedWork, finishedWork.return, error);\n                        }\n                    }\n                    flags & 4 && null != finishedWork.stateNode && (root = finishedWork.memoizedProps, commitHostUpdate(finishedWork, root, null !== current ? current.memoizedProps : root));\n                    flags & 1024 && (needsFormReset = !0, \"form\" !== finishedWork.type && console.error(\"Unexpected host component type. Expected a form. This is a bug in React.\"));\n                }\n                break;\n            case 6:\n                recursivelyTraverseMutationEffects(root, finishedWork);\n                commitReconciliationEffects(finishedWork);\n                if (flags & 4 && supportsMutation) {\n                    if (null === finishedWork.stateNode) throw Error(\"This should have a text node initialized. This error is likely caused by a bug in React. Please file an issue.\");\n                    flags = finishedWork.memoizedProps;\n                    current = null !== current ? current.memoizedProps : flags;\n                    root = finishedWork.stateNode;\n                    try {\n                        runWithFiberInDEV(finishedWork, commitTextUpdate, root, current, flags);\n                    } catch (error) {\n                        captureCommitPhaseError(finishedWork, finishedWork.return, error);\n                    }\n                }\n                break;\n            case 3:\n                hoistableRoot = pushNestedEffectDurations();\n                supportsResources ? (prepareToCommitHoistables(), props = currentHoistableRoot, currentHoistableRoot = getHoistableRoot(root.containerInfo), recursivelyTraverseMutationEffects(root, finishedWork), currentHoistableRoot = props) : recursivelyTraverseMutationEffects(root, finishedWork);\n                commitReconciliationEffects(finishedWork);\n                if (flags & 4) {\n                    if (supportsMutation && supportsHydration && null !== current && current.memoizedState.isDehydrated) try {\n                        runWithFiberInDEV(finishedWork, commitHydratedContainer, root.containerInfo);\n                    } catch (error) {\n                        captureCommitPhaseError(finishedWork, finishedWork.return, error);\n                    }\n                    if (supportsPersistence) {\n                        flags = root.containerInfo;\n                        current = root.pendingChildren;\n                        try {\n                            runWithFiberInDEV(finishedWork, replaceContainerChildren, flags, current);\n                        } catch (error) {\n                            captureCommitPhaseError(finishedWork, finishedWork.return, error);\n                        }\n                    }\n                }\n                needsFormReset && (needsFormReset = !1, recursivelyResetForms(finishedWork));\n                root.effectDuration += popNestedEffectDurations(hoistableRoot);\n                break;\n            case 4:\n                supportsResources ? (current = currentHoistableRoot, currentHoistableRoot = getHoistableRoot(finishedWork.stateNode.containerInfo), recursivelyTraverseMutationEffects(root, finishedWork), commitReconciliationEffects(finishedWork), currentHoistableRoot = current) : (recursivelyTraverseMutationEffects(root, finishedWork), commitReconciliationEffects(finishedWork));\n                flags & 4 && supportsPersistence && commitHostPortalContainerChildren(finishedWork.stateNode, finishedWork, finishedWork.stateNode.pendingChildren);\n                break;\n            case 12:\n                flags = pushNestedEffectDurations();\n                recursivelyTraverseMutationEffects(root, finishedWork);\n                commitReconciliationEffects(finishedWork);\n                finishedWork.stateNode.effectDuration += bubbleNestedEffectDurations(flags);\n                break;\n            case 13:\n                recursivelyTraverseMutationEffects(root, finishedWork);\n                commitReconciliationEffects(finishedWork);\n                finishedWork.child.flags & 8192 && null !== finishedWork.memoizedState !== (null !== current && null !== current.memoizedState) && (globalMostRecentFallbackTime = now$1());\n                flags & 4 && (flags = finishedWork.updateQueue, null !== flags && (finishedWork.updateQueue = null, attachSuspenseRetryListeners(finishedWork, flags)));\n                break;\n            case 22:\n                flags & 512 && (offscreenSubtreeWasHidden || null === current || safelyDetachRef(current, current.return));\n                hoistableRoot = null !== finishedWork.memoizedState;\n                var wasHidden = null !== current && null !== current.memoizedState, prevOffscreenSubtreeIsHidden = offscreenSubtreeIsHidden, prevOffscreenSubtreeWasHidden = offscreenSubtreeWasHidden;\n                offscreenSubtreeIsHidden = prevOffscreenSubtreeIsHidden || hoistableRoot;\n                offscreenSubtreeWasHidden = prevOffscreenSubtreeWasHidden || wasHidden;\n                recursivelyTraverseMutationEffects(root, finishedWork);\n                offscreenSubtreeWasHidden = prevOffscreenSubtreeWasHidden;\n                offscreenSubtreeIsHidden = prevOffscreenSubtreeIsHidden;\n                commitReconciliationEffects(finishedWork);\n                root = finishedWork.stateNode;\n                root._current = finishedWork;\n                root._visibility &= -3;\n                root._visibility |= root._pendingVisibility & 2;\n                if (flags & 8192 && (root._visibility = hoistableRoot ? root._visibility & -2 : root._visibility | 1, hoistableRoot && (root = offscreenSubtreeIsHidden || offscreenSubtreeWasHidden, null === current || wasHidden || root || recursivelyTraverseDisappearLayoutEffects(finishedWork)), supportsMutation && (null === finishedWork.memoizedProps || \"manual\" !== finishedWork.memoizedProps.mode))) {\n                    a: if (current = null, supportsMutation) for(root = finishedWork;;){\n                        if (5 === root.tag || supportsResources && 26 === root.tag || supportsSingletons && 27 === root.tag) {\n                            if (null === current) {\n                                wasHidden = current = root;\n                                try {\n                                    props = wasHidden.stateNode, hoistableRoot ? runWithFiberInDEV(wasHidden, hideInstance, props) : runWithFiberInDEV(wasHidden, unhideInstance, wasHidden.stateNode, wasHidden.memoizedProps);\n                                } catch (error) {\n                                    captureCommitPhaseError(wasHidden, wasHidden.return, error);\n                                }\n                            }\n                        } else if (6 === root.tag) {\n                            if (null === current) {\n                                wasHidden = root;\n                                try {\n                                    var instance = wasHidden.stateNode;\n                                    hoistableRoot ? runWithFiberInDEV(wasHidden, hideTextInstance, instance) : runWithFiberInDEV(wasHidden, unhideTextInstance, instance, wasHidden.memoizedProps);\n                                } catch (error) {\n                                    captureCommitPhaseError(wasHidden, wasHidden.return, error);\n                                }\n                            }\n                        } else if ((22 !== root.tag && 23 !== root.tag || null === root.memoizedState || root === finishedWork) && null !== root.child) {\n                            root.child.return = root;\n                            root = root.child;\n                            continue;\n                        }\n                        if (root === finishedWork) break a;\n                        for(; null === root.sibling;){\n                            if (null === root.return || root.return === finishedWork) break a;\n                            current === root && (current = null);\n                            root = root.return;\n                        }\n                        current === root && (current = null);\n                        root.sibling.return = root.return;\n                        root = root.sibling;\n                    }\n                }\n                flags & 4 && (flags = finishedWork.updateQueue, null !== flags && (current = flags.retryQueue, null !== current && (flags.retryQueue = null, attachSuspenseRetryListeners(finishedWork, current))));\n                break;\n            case 19:\n                recursivelyTraverseMutationEffects(root, finishedWork);\n                commitReconciliationEffects(finishedWork);\n                flags & 4 && (flags = finishedWork.updateQueue, null !== flags && (finishedWork.updateQueue = null, attachSuspenseRetryListeners(finishedWork, flags)));\n                break;\n            case 21:\n                break;\n            default:\n                recursivelyTraverseMutationEffects(root, finishedWork), commitReconciliationEffects(finishedWork);\n        }\n    }\n    function commitReconciliationEffects(finishedWork) {\n        var flags = finishedWork.flags;\n        if (flags & 2) {\n            try {\n                runWithFiberInDEV(finishedWork, commitPlacement, finishedWork);\n            } catch (error) {\n                captureCommitPhaseError(finishedWork, finishedWork.return, error);\n            }\n            finishedWork.flags &= -3;\n        }\n        flags & 4096 && (finishedWork.flags &= -4097);\n    }\n    function recursivelyResetForms(parentFiber) {\n        if (parentFiber.subtreeFlags & 1024) for(parentFiber = parentFiber.child; null !== parentFiber;){\n            var fiber = parentFiber;\n            recursivelyResetForms(fiber);\n            5 === fiber.tag && fiber.flags & 1024 && resetFormInstance(fiber.stateNode);\n            parentFiber = parentFiber.sibling;\n        }\n    }\n    function commitLayoutEffects(finishedWork, root, committedLanes) {\n        inProgressLanes = committedLanes;\n        inProgressRoot = root;\n        commitLayoutEffectOnFiber(root, finishedWork.alternate, finishedWork);\n        inProgressRoot = inProgressLanes = null;\n    }\n    function recursivelyTraverseLayoutEffects(root, parentFiber) {\n        if (parentFiber.subtreeFlags & 8772) for(parentFiber = parentFiber.child; null !== parentFiber;)commitLayoutEffectOnFiber(root, parentFiber.alternate, parentFiber), parentFiber = parentFiber.sibling;\n    }\n    function disappearLayoutEffects(finishedWork) {\n        switch(finishedWork.tag){\n            case 0:\n            case 11:\n            case 14:\n            case 15:\n                commitHookLayoutUnmountEffects(finishedWork, finishedWork.return, Layout);\n                recursivelyTraverseDisappearLayoutEffects(finishedWork);\n                break;\n            case 1:\n                safelyDetachRef(finishedWork, finishedWork.return);\n                var instance = finishedWork.stateNode;\n                \"function\" === typeof instance.componentWillUnmount && safelyCallComponentWillUnmount(finishedWork, finishedWork.return, instance);\n                recursivelyTraverseDisappearLayoutEffects(finishedWork);\n                break;\n            case 26:\n            case 27:\n            case 5:\n                safelyDetachRef(finishedWork, finishedWork.return);\n                recursivelyTraverseDisappearLayoutEffects(finishedWork);\n                break;\n            case 22:\n                safelyDetachRef(finishedWork, finishedWork.return);\n                null === finishedWork.memoizedState && recursivelyTraverseDisappearLayoutEffects(finishedWork);\n                break;\n            default:\n                recursivelyTraverseDisappearLayoutEffects(finishedWork);\n        }\n    }\n    function recursivelyTraverseDisappearLayoutEffects(parentFiber) {\n        for(parentFiber = parentFiber.child; null !== parentFiber;)disappearLayoutEffects(parentFiber), parentFiber = parentFiber.sibling;\n    }\n    function reappearLayoutEffects(finishedRoot, current, finishedWork, includeWorkInProgressEffects) {\n        var flags = finishedWork.flags;\n        switch(finishedWork.tag){\n            case 0:\n            case 11:\n            case 15:\n                recursivelyTraverseReappearLayoutEffects(finishedRoot, finishedWork, includeWorkInProgressEffects);\n                commitHookLayoutEffects(finishedWork, Layout);\n                break;\n            case 1:\n                recursivelyTraverseReappearLayoutEffects(finishedRoot, finishedWork, includeWorkInProgressEffects);\n                current = finishedWork.stateNode;\n                \"function\" === typeof current.componentDidMount && runWithFiberInDEV(finishedWork, callComponentDidMountInDEV, finishedWork, current);\n                current = finishedWork.updateQueue;\n                if (null !== current) {\n                    finishedRoot = finishedWork.stateNode;\n                    try {\n                        runWithFiberInDEV(finishedWork, commitHiddenCallbacks, current, finishedRoot);\n                    } catch (error) {\n                        captureCommitPhaseError(finishedWork, finishedWork.return, error);\n                    }\n                }\n                includeWorkInProgressEffects && flags & 64 && commitClassCallbacks(finishedWork);\n                safelyAttachRef(finishedWork, finishedWork.return);\n                break;\n            case 26:\n            case 27:\n            case 5:\n                recursivelyTraverseReappearLayoutEffects(finishedRoot, finishedWork, includeWorkInProgressEffects);\n                includeWorkInProgressEffects && null === current && flags & 4 && commitHostMount(finishedWork);\n                safelyAttachRef(finishedWork, finishedWork.return);\n                break;\n            case 12:\n                if (includeWorkInProgressEffects && flags & 4) {\n                    flags = pushNestedEffectDurations();\n                    recursivelyTraverseReappearLayoutEffects(finishedRoot, finishedWork, includeWorkInProgressEffects);\n                    includeWorkInProgressEffects = finishedWork.stateNode;\n                    includeWorkInProgressEffects.effectDuration += bubbleNestedEffectDurations(flags);\n                    try {\n                        runWithFiberInDEV(finishedWork, commitProfiler, finishedWork, current, commitStartTime, includeWorkInProgressEffects.effectDuration);\n                    } catch (error) {\n                        captureCommitPhaseError(finishedWork, finishedWork.return, error);\n                    }\n                } else recursivelyTraverseReappearLayoutEffects(finishedRoot, finishedWork, includeWorkInProgressEffects);\n                break;\n            case 13:\n                recursivelyTraverseReappearLayoutEffects(finishedRoot, finishedWork, includeWorkInProgressEffects);\n                includeWorkInProgressEffects && flags & 4 && commitSuspenseHydrationCallbacks(finishedRoot, finishedWork);\n                break;\n            case 22:\n                null === finishedWork.memoizedState && recursivelyTraverseReappearLayoutEffects(finishedRoot, finishedWork, includeWorkInProgressEffects);\n                safelyAttachRef(finishedWork, finishedWork.return);\n                break;\n            default:\n                recursivelyTraverseReappearLayoutEffects(finishedRoot, finishedWork, includeWorkInProgressEffects);\n        }\n    }\n    function recursivelyTraverseReappearLayoutEffects(finishedRoot, parentFiber, includeWorkInProgressEffects) {\n        includeWorkInProgressEffects = includeWorkInProgressEffects && 0 !== (parentFiber.subtreeFlags & 8772);\n        for(parentFiber = parentFiber.child; null !== parentFiber;)reappearLayoutEffects(finishedRoot, parentFiber.alternate, parentFiber, includeWorkInProgressEffects), parentFiber = parentFiber.sibling;\n    }\n    function commitOffscreenPassiveMountEffects(current, finishedWork) {\n        var previousCache = null;\n        null !== current && null !== current.memoizedState && null !== current.memoizedState.cachePool && (previousCache = current.memoizedState.cachePool.pool);\n        current = null;\n        null !== finishedWork.memoizedState && null !== finishedWork.memoizedState.cachePool && (current = finishedWork.memoizedState.cachePool.pool);\n        current !== previousCache && (null != current && retainCache(current), null != previousCache && releaseCache(previousCache));\n    }\n    function commitCachePassiveMountEffect(current, finishedWork) {\n        current = null;\n        null !== finishedWork.alternate && (current = finishedWork.alternate.memoizedState.cache);\n        finishedWork = finishedWork.memoizedState.cache;\n        finishedWork !== current && (retainCache(finishedWork), null != current && releaseCache(current));\n    }\n    function recursivelyTraversePassiveMountEffects(root, parentFiber, committedLanes, committedTransitions) {\n        if (parentFiber.subtreeFlags & 10256) for(parentFiber = parentFiber.child; null !== parentFiber;)commitPassiveMountOnFiber(root, parentFiber, committedLanes, committedTransitions), parentFiber = parentFiber.sibling;\n    }\n    function commitPassiveMountOnFiber(finishedRoot, finishedWork, committedLanes, committedTransitions) {\n        var flags = finishedWork.flags;\n        switch(finishedWork.tag){\n            case 0:\n            case 11:\n            case 15:\n                recursivelyTraversePassiveMountEffects(finishedRoot, finishedWork, committedLanes, committedTransitions);\n                flags & 2048 && commitHookPassiveMountEffects(finishedWork, Passive | HasEffect);\n                break;\n            case 3:\n                var prevEffectDuration = pushNestedEffectDurations();\n                recursivelyTraversePassiveMountEffects(finishedRoot, finishedWork, committedLanes, committedTransitions);\n                flags & 2048 && (committedLanes = null, null !== finishedWork.alternate && (committedLanes = finishedWork.alternate.memoizedState.cache), finishedWork = finishedWork.memoizedState.cache, finishedWork !== committedLanes && (retainCache(finishedWork), null != committedLanes && releaseCache(committedLanes)));\n                finishedRoot.passiveEffectDuration += popNestedEffectDurations(prevEffectDuration);\n                break;\n            case 12:\n                if (flags & 2048) {\n                    prevEffectDuration = pushNestedEffectDurations();\n                    recursivelyTraversePassiveMountEffects(finishedRoot, finishedWork, committedLanes, committedTransitions);\n                    finishedRoot = finishedWork.stateNode;\n                    finishedRoot.passiveEffectDuration += bubbleNestedEffectDurations(prevEffectDuration);\n                    try {\n                        runWithFiberInDEV(finishedWork, commitProfilerPostCommitImpl, finishedWork, finishedWork.alternate, commitStartTime, finishedRoot.passiveEffectDuration);\n                    } catch (error) {\n                        captureCommitPhaseError(finishedWork, finishedWork.return, error);\n                    }\n                } else recursivelyTraversePassiveMountEffects(finishedRoot, finishedWork, committedLanes, committedTransitions);\n                break;\n            case 23:\n                break;\n            case 22:\n                prevEffectDuration = finishedWork.stateNode;\n                null !== finishedWork.memoizedState ? prevEffectDuration._visibility & 4 ? recursivelyTraversePassiveMountEffects(finishedRoot, finishedWork, committedLanes, committedTransitions) : recursivelyTraverseAtomicPassiveEffects(finishedRoot, finishedWork) : prevEffectDuration._visibility & 4 ? recursivelyTraversePassiveMountEffects(finishedRoot, finishedWork, committedLanes, committedTransitions) : (prevEffectDuration._visibility |= 4, recursivelyTraverseReconnectPassiveEffects(finishedRoot, finishedWork, committedLanes, committedTransitions, 0 !== (finishedWork.subtreeFlags & 10256)));\n                flags & 2048 && commitOffscreenPassiveMountEffects(finishedWork.alternate, finishedWork);\n                break;\n            case 24:\n                recursivelyTraversePassiveMountEffects(finishedRoot, finishedWork, committedLanes, committedTransitions);\n                flags & 2048 && commitCachePassiveMountEffect(finishedWork.alternate, finishedWork);\n                break;\n            default:\n                recursivelyTraversePassiveMountEffects(finishedRoot, finishedWork, committedLanes, committedTransitions);\n        }\n    }\n    function recursivelyTraverseReconnectPassiveEffects(finishedRoot, parentFiber, committedLanes, committedTransitions, includeWorkInProgressEffects) {\n        includeWorkInProgressEffects = includeWorkInProgressEffects && 0 !== (parentFiber.subtreeFlags & 10256);\n        for(parentFiber = parentFiber.child; null !== parentFiber;)reconnectPassiveEffects(finishedRoot, parentFiber, committedLanes, committedTransitions, includeWorkInProgressEffects), parentFiber = parentFiber.sibling;\n    }\n    function reconnectPassiveEffects(finishedRoot, finishedWork, committedLanes, committedTransitions, includeWorkInProgressEffects) {\n        var flags = finishedWork.flags;\n        switch(finishedWork.tag){\n            case 0:\n            case 11:\n            case 15:\n                recursivelyTraverseReconnectPassiveEffects(finishedRoot, finishedWork, committedLanes, committedTransitions, includeWorkInProgressEffects);\n                commitHookPassiveMountEffects(finishedWork, Passive);\n                break;\n            case 23:\n                break;\n            case 22:\n                var _instance2 = finishedWork.stateNode;\n                null !== finishedWork.memoizedState ? _instance2._visibility & 4 ? recursivelyTraverseReconnectPassiveEffects(finishedRoot, finishedWork, committedLanes, committedTransitions, includeWorkInProgressEffects) : recursivelyTraverseAtomicPassiveEffects(finishedRoot, finishedWork) : (_instance2._visibility |= 4, recursivelyTraverseReconnectPassiveEffects(finishedRoot, finishedWork, committedLanes, committedTransitions, includeWorkInProgressEffects));\n                includeWorkInProgressEffects && flags & 2048 && commitOffscreenPassiveMountEffects(finishedWork.alternate, finishedWork);\n                break;\n            case 24:\n                recursivelyTraverseReconnectPassiveEffects(finishedRoot, finishedWork, committedLanes, committedTransitions, includeWorkInProgressEffects);\n                includeWorkInProgressEffects && flags & 2048 && commitCachePassiveMountEffect(finishedWork.alternate, finishedWork);\n                break;\n            default:\n                recursivelyTraverseReconnectPassiveEffects(finishedRoot, finishedWork, committedLanes, committedTransitions, includeWorkInProgressEffects);\n        }\n    }\n    function recursivelyTraverseAtomicPassiveEffects(finishedRoot$jscomp$0, parentFiber) {\n        if (parentFiber.subtreeFlags & 10256) for(parentFiber = parentFiber.child; null !== parentFiber;){\n            var finishedRoot = finishedRoot$jscomp$0, finishedWork = parentFiber, flags = finishedWork.flags;\n            switch(finishedWork.tag){\n                case 22:\n                    recursivelyTraverseAtomicPassiveEffects(finishedRoot, finishedWork);\n                    flags & 2048 && commitOffscreenPassiveMountEffects(finishedWork.alternate, finishedWork);\n                    break;\n                case 24:\n                    recursivelyTraverseAtomicPassiveEffects(finishedRoot, finishedWork);\n                    flags & 2048 && commitCachePassiveMountEffect(finishedWork.alternate, finishedWork);\n                    break;\n                default:\n                    recursivelyTraverseAtomicPassiveEffects(finishedRoot, finishedWork);\n            }\n            parentFiber = parentFiber.sibling;\n        }\n    }\n    function recursivelyAccumulateSuspenseyCommit(parentFiber) {\n        if (parentFiber.subtreeFlags & suspenseyCommitFlag) for(parentFiber = parentFiber.child; null !== parentFiber;)accumulateSuspenseyCommitOnFiber(parentFiber), parentFiber = parentFiber.sibling;\n    }\n    function accumulateSuspenseyCommitOnFiber(fiber) {\n        switch(fiber.tag){\n            case 26:\n                recursivelyAccumulateSuspenseyCommit(fiber);\n                fiber.flags & suspenseyCommitFlag && (null !== fiber.memoizedState ? suspendResource(currentHoistableRoot, fiber.memoizedState, fiber.memoizedProps) : suspendInstance(fiber.type, fiber.memoizedProps));\n                break;\n            case 5:\n                recursivelyAccumulateSuspenseyCommit(fiber);\n                fiber.flags & suspenseyCommitFlag && suspendInstance(fiber.type, fiber.memoizedProps);\n                break;\n            case 3:\n            case 4:\n                if (supportsResources) {\n                    var previousHoistableRoot = currentHoistableRoot;\n                    currentHoistableRoot = getHoistableRoot(fiber.stateNode.containerInfo);\n                    recursivelyAccumulateSuspenseyCommit(fiber);\n                    currentHoistableRoot = previousHoistableRoot;\n                } else recursivelyAccumulateSuspenseyCommit(fiber);\n                break;\n            case 22:\n                null === fiber.memoizedState && (previousHoistableRoot = fiber.alternate, null !== previousHoistableRoot && null !== previousHoistableRoot.memoizedState ? (previousHoistableRoot = suspenseyCommitFlag, suspenseyCommitFlag = 16777216, recursivelyAccumulateSuspenseyCommit(fiber), suspenseyCommitFlag = previousHoistableRoot) : recursivelyAccumulateSuspenseyCommit(fiber));\n                break;\n            default:\n                recursivelyAccumulateSuspenseyCommit(fiber);\n        }\n    }\n    function detachAlternateSiblings(parentFiber) {\n        var previousFiber = parentFiber.alternate;\n        if (null !== previousFiber && (parentFiber = previousFiber.child, null !== parentFiber)) {\n            previousFiber.child = null;\n            do previousFiber = parentFiber.sibling, parentFiber.sibling = null, parentFiber = previousFiber;\n            while (null !== parentFiber);\n        }\n    }\n    function recursivelyTraversePassiveUnmountEffects(parentFiber) {\n        var deletions = parentFiber.deletions;\n        if (0 !== (parentFiber.flags & 16)) {\n            if (null !== deletions) for(var i = 0; i < deletions.length; i++){\n                var childToDelete = deletions[i];\n                nextEffect = childToDelete;\n                commitPassiveUnmountEffectsInsideOfDeletedTree_begin(childToDelete, parentFiber);\n            }\n            detachAlternateSiblings(parentFiber);\n        }\n        if (parentFiber.subtreeFlags & 10256) for(parentFiber = parentFiber.child; null !== parentFiber;)commitPassiveUnmountOnFiber(parentFiber), parentFiber = parentFiber.sibling;\n    }\n    function commitPassiveUnmountOnFiber(finishedWork) {\n        switch(finishedWork.tag){\n            case 0:\n            case 11:\n            case 15:\n                recursivelyTraversePassiveUnmountEffects(finishedWork);\n                finishedWork.flags & 2048 && commitHookPassiveUnmountEffects(finishedWork, finishedWork.return, Passive | HasEffect);\n                break;\n            case 3:\n                var prevEffectDuration = pushNestedEffectDurations();\n                recursivelyTraversePassiveUnmountEffects(finishedWork);\n                finishedWork.stateNode.passiveEffectDuration += popNestedEffectDurations(prevEffectDuration);\n                break;\n            case 12:\n                prevEffectDuration = pushNestedEffectDurations();\n                recursivelyTraversePassiveUnmountEffects(finishedWork);\n                finishedWork.stateNode.passiveEffectDuration += bubbleNestedEffectDurations(prevEffectDuration);\n                break;\n            case 22:\n                prevEffectDuration = finishedWork.stateNode;\n                null !== finishedWork.memoizedState && prevEffectDuration._visibility & 4 && (null === finishedWork.return || 13 !== finishedWork.return.tag) ? (prevEffectDuration._visibility &= -5, recursivelyTraverseDisconnectPassiveEffects(finishedWork)) : recursivelyTraversePassiveUnmountEffects(finishedWork);\n                break;\n            default:\n                recursivelyTraversePassiveUnmountEffects(finishedWork);\n        }\n    }\n    function recursivelyTraverseDisconnectPassiveEffects(parentFiber) {\n        var deletions = parentFiber.deletions;\n        if (0 !== (parentFiber.flags & 16)) {\n            if (null !== deletions) for(var i = 0; i < deletions.length; i++){\n                var childToDelete = deletions[i];\n                nextEffect = childToDelete;\n                commitPassiveUnmountEffectsInsideOfDeletedTree_begin(childToDelete, parentFiber);\n            }\n            detachAlternateSiblings(parentFiber);\n        }\n        for(parentFiber = parentFiber.child; null !== parentFiber;)disconnectPassiveEffect(parentFiber), parentFiber = parentFiber.sibling;\n    }\n    function disconnectPassiveEffect(finishedWork) {\n        switch(finishedWork.tag){\n            case 0:\n            case 11:\n            case 15:\n                commitHookPassiveUnmountEffects(finishedWork, finishedWork.return, Passive);\n                recursivelyTraverseDisconnectPassiveEffects(finishedWork);\n                break;\n            case 22:\n                var instance = finishedWork.stateNode;\n                instance._visibility & 4 && (instance._visibility &= -5, recursivelyTraverseDisconnectPassiveEffects(finishedWork));\n                break;\n            default:\n                recursivelyTraverseDisconnectPassiveEffects(finishedWork);\n        }\n    }\n    function commitPassiveUnmountEffectsInsideOfDeletedTree_begin(deletedSubtreeRoot, nearestMountedAncestor) {\n        for(; null !== nextEffect;){\n            var fiber = nextEffect, current = fiber;\n            switch(current.tag){\n                case 0:\n                case 11:\n                case 15:\n                    commitHookPassiveUnmountEffects(current, nearestMountedAncestor, Passive);\n                    break;\n                case 23:\n                case 22:\n                    null !== current.memoizedState && null !== current.memoizedState.cachePool && (current = current.memoizedState.cachePool.pool, null != current && retainCache(current));\n                    break;\n                case 24:\n                    releaseCache(current.memoizedState.cache);\n            }\n            current = fiber.child;\n            if (null !== current) current.return = fiber, nextEffect = current;\n            else a: for(fiber = deletedSubtreeRoot; null !== nextEffect;){\n                current = nextEffect;\n                var sibling = current.sibling, returnFiber = current.return;\n                detachFiberAfterEffects(current);\n                if (current === fiber) {\n                    nextEffect = null;\n                    break a;\n                }\n                if (null !== sibling) {\n                    sibling.return = returnFiber;\n                    nextEffect = sibling;\n                    break a;\n                }\n                nextEffect = returnFiber;\n            }\n        }\n    }\n    function findFiberRootForHostRoot(hostRoot) {\n        var maybeFiber = getInstanceFromNode(hostRoot);\n        if (null != maybeFiber) {\n            if (\"string\" !== typeof maybeFiber.memoizedProps[\"data-testname\"]) throw Error(\"Invalid host root specified. Should be either a React container or a node with a testname attribute.\");\n            return maybeFiber;\n        }\n        hostRoot = findFiberRoot(hostRoot);\n        if (null === hostRoot) throw Error(\"Could not find React container within specified host subtree.\");\n        return hostRoot.stateNode.current;\n    }\n    function matchSelector(fiber$jscomp$0, selector) {\n        var tag = fiber$jscomp$0.tag;\n        switch(selector.$$typeof){\n            case COMPONENT_TYPE:\n                if (fiber$jscomp$0.type === selector.value) return !0;\n                break;\n            case HAS_PSEUDO_CLASS_TYPE:\n                a: {\n                    selector = selector.value;\n                    fiber$jscomp$0 = [\n                        fiber$jscomp$0,\n                        0\n                    ];\n                    for(tag = 0; tag < fiber$jscomp$0.length;){\n                        var fiber = fiber$jscomp$0[tag++], tag$jscomp$0 = fiber.tag, selectorIndex = fiber$jscomp$0[tag++], selector$jscomp$0 = selector[selectorIndex];\n                        if (5 !== tag$jscomp$0 && 26 !== tag$jscomp$0 && 27 !== tag$jscomp$0 || !isHiddenSubtree(fiber)) {\n                            for(; null != selector$jscomp$0 && matchSelector(fiber, selector$jscomp$0);)selectorIndex++, selector$jscomp$0 = selector[selectorIndex];\n                            if (selectorIndex === selector.length) {\n                                selector = !0;\n                                break a;\n                            } else for(fiber = fiber.child; null !== fiber;)fiber$jscomp$0.push(fiber, selectorIndex), fiber = fiber.sibling;\n                        }\n                    }\n                    selector = !1;\n                }\n                return selector;\n            case ROLE_TYPE:\n                if ((5 === tag || 26 === tag || 27 === tag) && matchAccessibilityRole(fiber$jscomp$0.stateNode, selector.value)) return !0;\n                break;\n            case TEXT_TYPE:\n                if (5 === tag || 6 === tag || 26 === tag || 27 === tag) {\n                    if (fiber$jscomp$0 = getTextContent(fiber$jscomp$0), null !== fiber$jscomp$0 && 0 <= fiber$jscomp$0.indexOf(selector.value)) return !0;\n                }\n                break;\n            case TEST_NAME_TYPE:\n                if (5 === tag || 26 === tag || 27 === tag) {\n                    if (fiber$jscomp$0 = fiber$jscomp$0.memoizedProps[\"data-testname\"], \"string\" === typeof fiber$jscomp$0 && fiber$jscomp$0.toLowerCase() === selector.value.toLowerCase()) return !0;\n                }\n                break;\n            default:\n                throw Error(\"Invalid selector type specified.\");\n        }\n        return !1;\n    }\n    function selectorToString(selector) {\n        switch(selector.$$typeof){\n            case COMPONENT_TYPE:\n                return \"<\" + (getComponentNameFromType(selector.value) || \"Unknown\") + \">\";\n            case HAS_PSEUDO_CLASS_TYPE:\n                return \":has(\" + (selectorToString(selector) || \"\") + \")\";\n            case ROLE_TYPE:\n                return '[role=\"' + selector.value + '\"]';\n            case TEXT_TYPE:\n                return '\"' + selector.value + '\"';\n            case TEST_NAME_TYPE:\n                return '[data-testname=\"' + selector.value + '\"]';\n            default:\n                throw Error(\"Invalid selector type specified.\");\n        }\n    }\n    function findPaths(root, selectors) {\n        var matchingFibers = [];\n        root = [\n            root,\n            0\n        ];\n        for(var index = 0; index < root.length;){\n            var fiber = root[index++], tag = fiber.tag, selectorIndex = root[index++], selector = selectors[selectorIndex];\n            if (5 !== tag && 26 !== tag && 27 !== tag || !isHiddenSubtree(fiber)) {\n                for(; null != selector && matchSelector(fiber, selector);)selectorIndex++, selector = selectors[selectorIndex];\n                if (selectorIndex === selectors.length) matchingFibers.push(fiber);\n                else for(fiber = fiber.child; null !== fiber;)root.push(fiber, selectorIndex), fiber = fiber.sibling;\n            }\n        }\n        return matchingFibers;\n    }\n    function findAllNodes(hostRoot, selectors) {\n        if (!supportsTestSelectors) throw Error(\"Test selector API is not supported by this renderer.\");\n        hostRoot = findFiberRootForHostRoot(hostRoot);\n        hostRoot = findPaths(hostRoot, selectors);\n        selectors = [];\n        hostRoot = Array.from(hostRoot);\n        for(var index = 0; index < hostRoot.length;){\n            var node = hostRoot[index++], tag = node.tag;\n            if (5 === tag || 26 === tag || 27 === tag) isHiddenSubtree(node) || selectors.push(node.stateNode);\n            else for(node = node.child; null !== node;)hostRoot.push(node), node = node.sibling;\n        }\n        return selectors;\n    }\n    function onCommitRoot() {\n        supportsTestSelectors && commitHooks.forEach(function(commitHook) {\n            return commitHook();\n        });\n    }\n    function isConcurrentActEnvironment() {\n        var isReactActEnvironmentGlobal = \"undefined\" !== typeof IS_REACT_ACT_ENVIRONMENT ? IS_REACT_ACT_ENVIRONMENT : void 0;\n        isReactActEnvironmentGlobal || null === ReactSharedInternals.actQueue || console.error(\"The current testing environment is not configured to support act(...)\");\n        return isReactActEnvironmentGlobal;\n    }\n    function requestUpdateLane(fiber) {\n        if ((executionContext & RenderContext) !== NoContext && 0 !== workInProgressRootRenderLanes) return workInProgressRootRenderLanes & -workInProgressRootRenderLanes;\n        var transition = ReactSharedInternals.T;\n        return null !== transition ? (transition._updatedFibers || (transition._updatedFibers = new Set()), transition._updatedFibers.add(fiber), fiber = currentEntangledLane, 0 !== fiber ? fiber : requestTransitionLane()) : resolveUpdatePriority();\n    }\n    function requestDeferredLane() {\n        0 === workInProgressDeferredLane && (workInProgressDeferredLane = 0 === (workInProgressRootRenderLanes & 536870912) || isHydrating ? claimNextTransitionLane() : 536870912);\n        var suspenseHandler = suspenseHandlerStackCursor.current;\n        null !== suspenseHandler && (suspenseHandler.flags |= 32);\n        return workInProgressDeferredLane;\n    }\n    function scheduleUpdateOnFiber(root, fiber, lane) {\n        isRunningInsertionEffect && console.error(\"useInsertionEffect must not schedule updates.\");\n        isFlushingPassiveEffects && (didScheduleUpdateDuringPassiveEffects = !0);\n        if (root === workInProgressRoot && workInProgressSuspendedReason === SuspendedOnData || null !== root.cancelPendingCommit) prepareFreshStack(root, 0), markRootSuspended(root, workInProgressRootRenderLanes, workInProgressDeferredLane, !1);\n        markRootUpdated$1(root, lane);\n        if (0 !== (executionContext & RenderContext) && root === workInProgressRoot) {\n            if (isRendering) switch(fiber.tag){\n                case 0:\n                case 11:\n                case 15:\n                    root = workInProgress && getComponentNameFromFiber(workInProgress) || \"Unknown\";\n                    didWarnAboutUpdateInRenderForAnotherComponent.has(root) || (didWarnAboutUpdateInRenderForAnotherComponent.add(root), fiber = getComponentNameFromFiber(fiber) || \"Unknown\", console.error(\"Cannot update a component (`%s`) while rendering a different component (`%s`). To locate the bad setState() call inside `%s`, follow the stack trace as described in https://react.dev/link/setstate-in-render\", fiber, root, root));\n                    break;\n                case 1:\n                    didWarnAboutUpdateInRender || (console.error(\"Cannot update during an existing state transition (such as within `render`). Render methods should be a pure function of props and state.\"), didWarnAboutUpdateInRender = !0);\n            }\n        } else isDevToolsPresent && addFiberToLanesMap(root, fiber, lane), warnIfUpdatesNotWrappedWithActDEV(fiber), root === workInProgressRoot && ((executionContext & RenderContext) === NoContext && (workInProgressRootInterleavedUpdatedLanes |= lane), workInProgressRootExitStatus === RootSuspendedWithDelay && markRootSuspended(root, workInProgressRootRenderLanes, workInProgressDeferredLane, !1)), ensureRootIsScheduled(root);\n    }\n    function performWorkOnRoot(root, lanes, forceSync) {\n        if ((executionContext & (RenderContext | CommitContext)) !== NoContext) throw Error(\"Should not already be working.\");\n        var shouldTimeSlice = !forceSync && 0 === (lanes & 60) && 0 === (lanes & root.expiredLanes) || checkIfRootIsPrerendering(root, lanes), exitStatus = shouldTimeSlice ? renderRootConcurrent(root, lanes) : renderRootSync(root, lanes, !0), renderWasConcurrent = shouldTimeSlice;\n        do {\n            if (exitStatus === RootInProgress) {\n                workInProgressRootIsPrerendering && !shouldTimeSlice && markRootSuspended(root, lanes, 0, !1);\n                break;\n            } else if (exitStatus === RootDidNotComplete) markRootSuspended(root, lanes, 0, !workInProgressRootDidSkipSuspendedSiblings);\n            else {\n                forceSync = root.current.alternate;\n                if (renderWasConcurrent && !isRenderConsistentWithExternalStores(forceSync)) {\n                    exitStatus = renderRootSync(root, lanes, !1);\n                    renderWasConcurrent = !1;\n                    continue;\n                }\n                if (exitStatus === RootErrored) {\n                    renderWasConcurrent = lanes;\n                    if (root.errorRecoveryDisabledLanes & renderWasConcurrent) var errorRetryLanes = 0;\n                    else errorRetryLanes = root.pendingLanes & -536870913, errorRetryLanes = 0 !== errorRetryLanes ? errorRetryLanes : errorRetryLanes & 536870912 ? 536870912 : 0;\n                    if (0 !== errorRetryLanes) {\n                        lanes = errorRetryLanes;\n                        a: {\n                            exitStatus = root;\n                            var errorRetryLanes$jscomp$0 = errorRetryLanes;\n                            errorRetryLanes = workInProgressRootConcurrentErrors;\n                            var wasRootDehydrated = supportsHydration && exitStatus.current.memoizedState.isDehydrated;\n                            wasRootDehydrated && (prepareFreshStack(exitStatus, errorRetryLanes$jscomp$0).flags |= 256);\n                            errorRetryLanes$jscomp$0 = renderRootSync(exitStatus, errorRetryLanes$jscomp$0, !1);\n                            if (errorRetryLanes$jscomp$0 !== RootErrored) {\n                                if (workInProgressRootDidAttachPingListener && !wasRootDehydrated) {\n                                    exitStatus.errorRecoveryDisabledLanes |= renderWasConcurrent;\n                                    workInProgressRootInterleavedUpdatedLanes |= renderWasConcurrent;\n                                    exitStatus = RootSuspendedWithDelay;\n                                    break a;\n                                }\n                                exitStatus = workInProgressRootRecoverableErrors;\n                                workInProgressRootRecoverableErrors = errorRetryLanes;\n                                null !== exitStatus && queueRecoverableErrors(exitStatus);\n                            }\n                            exitStatus = errorRetryLanes$jscomp$0;\n                        }\n                        renderWasConcurrent = !1;\n                        if (exitStatus !== RootErrored) continue;\n                    }\n                }\n                if (exitStatus === RootFatalErrored) {\n                    prepareFreshStack(root, 0);\n                    markRootSuspended(root, lanes, 0, !0);\n                    break;\n                }\n                a: {\n                    shouldTimeSlice = root;\n                    switch(exitStatus){\n                        case RootInProgress:\n                        case RootFatalErrored:\n                            throw Error(\"Root did not complete. This is a bug in React.\");\n                        case RootSuspendedWithDelay:\n                            if ((lanes & 4194176) === lanes) {\n                                markRootSuspended(shouldTimeSlice, lanes, workInProgressDeferredLane, !workInProgressRootDidSkipSuspendedSiblings);\n                                break a;\n                            }\n                            break;\n                        case RootErrored:\n                            workInProgressRootRecoverableErrors = null;\n                            break;\n                        case RootSuspended:\n                        case RootCompleted:\n                            break;\n                        default:\n                            throw Error(\"Unknown root exit status.\");\n                    }\n                    shouldTimeSlice.finishedWork = forceSync;\n                    shouldTimeSlice.finishedLanes = lanes;\n                    if (null !== ReactSharedInternals.actQueue) commitRoot(shouldTimeSlice, workInProgressRootRecoverableErrors, workInProgressTransitions, workInProgressRootDidIncludeRecursiveRenderUpdate, workInProgressDeferredLane, workInProgressRootInterleavedUpdatedLanes, workInProgressSuspendedRetryLanes, IMMEDIATE_COMMIT, -0, 0);\n                    else {\n                        if ((lanes & 62914560) === lanes && (exitStatus = globalMostRecentFallbackTime + FALLBACK_THROTTLE_MS - now$1(), 10 < exitStatus)) {\n                            markRootSuspended(shouldTimeSlice, lanes, workInProgressDeferredLane, !workInProgressRootDidSkipSuspendedSiblings);\n                            if (0 !== getNextLanes(shouldTimeSlice, 0)) break a;\n                            shouldTimeSlice.timeoutHandle = scheduleTimeout(commitRootWhenReady.bind(null, shouldTimeSlice, forceSync, workInProgressRootRecoverableErrors, workInProgressTransitions, workInProgressRootDidIncludeRecursiveRenderUpdate, lanes, workInProgressDeferredLane, workInProgressRootInterleavedUpdatedLanes, workInProgressSuspendedRetryLanes, workInProgressRootDidSkipSuspendedSiblings, THROTTLED_COMMIT, -0, 0), exitStatus);\n                            break a;\n                        }\n                        commitRootWhenReady(shouldTimeSlice, forceSync, workInProgressRootRecoverableErrors, workInProgressTransitions, workInProgressRootDidIncludeRecursiveRenderUpdate, lanes, workInProgressDeferredLane, workInProgressRootInterleavedUpdatedLanes, workInProgressSuspendedRetryLanes, workInProgressRootDidSkipSuspendedSiblings, IMMEDIATE_COMMIT, -0, 0);\n                    }\n                }\n            }\n            break;\n        }while (1);\n        ensureRootIsScheduled(root);\n    }\n    function queueRecoverableErrors(errors) {\n        null === workInProgressRootRecoverableErrors ? workInProgressRootRecoverableErrors = errors : workInProgressRootRecoverableErrors.push.apply(workInProgressRootRecoverableErrors, errors);\n    }\n    function commitRootWhenReady(root, finishedWork, recoverableErrors, transitions, didIncludeRenderPhaseUpdate, lanes, spawnedLane, updatedLanes, suspendedRetryLanes, didSkipSuspendedSiblings, suspendedCommitReason, completedRenderStartTime, completedRenderEndTime) {\n        var subtreeFlags = finishedWork.subtreeFlags;\n        if (subtreeFlags & 8192 || 16785408 === (subtreeFlags & 16785408)) {\n            if (startSuspendingCommit(), accumulateSuspenseyCommitOnFiber(finishedWork), finishedWork = waitForCommitToBeReady(), null !== finishedWork) {\n                root.cancelPendingCommit = finishedWork(commitRoot.bind(null, root, recoverableErrors, transitions, didIncludeRenderPhaseUpdate, spawnedLane, updatedLanes, suspendedRetryLanes, SUSPENDED_COMMIT, completedRenderStartTime, completedRenderEndTime));\n                markRootSuspended(root, lanes, spawnedLane, !didSkipSuspendedSiblings);\n                return;\n            }\n        }\n        commitRoot(root, recoverableErrors, transitions, didIncludeRenderPhaseUpdate, spawnedLane, updatedLanes, suspendedRetryLanes, suspendedCommitReason, completedRenderStartTime, completedRenderEndTime);\n    }\n    function isRenderConsistentWithExternalStores(finishedWork) {\n        for(var node = finishedWork;;){\n            var tag = node.tag;\n            if ((0 === tag || 11 === tag || 15 === tag) && node.flags & 16384 && (tag = node.updateQueue, null !== tag && (tag = tag.stores, null !== tag))) for(var i = 0; i < tag.length; i++){\n                var check = tag[i], getSnapshot = check.getSnapshot;\n                check = check.value;\n                try {\n                    if (!objectIs(getSnapshot(), check)) return !1;\n                } catch (error) {\n                    return !1;\n                }\n            }\n            tag = node.child;\n            if (node.subtreeFlags & 16384 && null !== tag) tag.return = node, node = tag;\n            else {\n                if (node === finishedWork) break;\n                for(; null === node.sibling;){\n                    if (null === node.return || node.return === finishedWork) return !0;\n                    node = node.return;\n                }\n                node.sibling.return = node.return;\n                node = node.sibling;\n            }\n        }\n        return !0;\n    }\n    function markRootSuspended(root, suspendedLanes, spawnedLane, didAttemptEntireTree) {\n        suspendedLanes &= ~workInProgressRootPingedLanes;\n        suspendedLanes &= ~workInProgressRootInterleavedUpdatedLanes;\n        root.suspendedLanes |= suspendedLanes;\n        root.pingedLanes &= ~suspendedLanes;\n        didAttemptEntireTree && (root.warmLanes |= suspendedLanes);\n        didAttemptEntireTree = root.expirationTimes;\n        for(var lanes = suspendedLanes; 0 < lanes;){\n            var index = 31 - clz32(lanes), lane = 1 << index;\n            didAttemptEntireTree[index] = -1;\n            lanes &= ~lane;\n        }\n        0 !== spawnedLane && markSpawnedDeferredLane(root, spawnedLane, suspendedLanes);\n    }\n    function flushSyncWork() {\n        return (executionContext & (RenderContext | CommitContext)) === NoContext ? (flushSyncWorkAcrossRoots_impl(0, !1), !1) : !0;\n    }\n    function resetWorkInProgressStack() {\n        if (null !== workInProgress) {\n            if (workInProgressSuspendedReason === NotSuspended) var interruptedWork = workInProgress.return;\n            else interruptedWork = workInProgress, resetContextDependencies(), resetHooksOnUnwind(interruptedWork), thenableState$1 = null, thenableIndexCounter$1 = 0, interruptedWork = workInProgress;\n            for(; null !== interruptedWork;)unwindInterruptedWork(interruptedWork.alternate, interruptedWork), interruptedWork = interruptedWork.return;\n            workInProgress = null;\n        }\n    }\n    function prepareFreshStack(root, lanes) {\n        root.finishedWork = null;\n        root.finishedLanes = 0;\n        var timeoutHandle = root.timeoutHandle;\n        timeoutHandle !== noTimeout && (root.timeoutHandle = noTimeout, cancelTimeout(timeoutHandle));\n        timeoutHandle = root.cancelPendingCommit;\n        null !== timeoutHandle && (root.cancelPendingCommit = null, timeoutHandle());\n        resetWorkInProgressStack();\n        workInProgressRoot = root;\n        workInProgress = timeoutHandle = createWorkInProgress(root.current, null);\n        workInProgressRootRenderLanes = lanes;\n        workInProgressSuspendedReason = NotSuspended;\n        workInProgressThrownValue = null;\n        workInProgressRootDidSkipSuspendedSiblings = !1;\n        workInProgressRootIsPrerendering = checkIfRootIsPrerendering(root, lanes);\n        workInProgressRootDidAttachPingListener = !1;\n        workInProgressRootExitStatus = RootInProgress;\n        workInProgressSuspendedRetryLanes = workInProgressDeferredLane = workInProgressRootPingedLanes = workInProgressRootInterleavedUpdatedLanes = workInProgressRootSkippedLanes = 0;\n        workInProgressRootRecoverableErrors = workInProgressRootConcurrentErrors = null;\n        workInProgressRootDidIncludeRecursiveRenderUpdate = !1;\n        0 !== (lanes & 8) && (lanes |= lanes & 32);\n        var allEntangledLanes = root.entangledLanes;\n        if (0 !== allEntangledLanes) for(root = root.entanglements, allEntangledLanes &= lanes; 0 < allEntangledLanes;){\n            var index = 31 - clz32(allEntangledLanes), lane = 1 << index;\n            lanes |= root[index];\n            allEntangledLanes &= ~lane;\n        }\n        entangledRenderLanes = lanes;\n        finishQueueingConcurrentUpdates();\n        ReactStrictModeWarnings.discardPendingWarnings();\n        return timeoutHandle;\n    }\n    function handleThrow(root, thrownValue) {\n        currentlyRenderingFiber$1 = null;\n        ReactSharedInternals.H = ContextOnlyDispatcher;\n        ReactSharedInternals.getCurrentStack = null;\n        isRendering = !1;\n        current = null;\n        thrownValue === SuspenseException ? (thrownValue = getSuspendedThenable(), workInProgressSuspendedReason = SuspendedOnImmediate) : thrownValue === SuspenseyCommitException ? (thrownValue = getSuspendedThenable(), workInProgressSuspendedReason = SuspendedOnInstance) : workInProgressSuspendedReason = thrownValue === SelectiveHydrationException ? SuspendedOnHydration : null !== thrownValue && \"object\" === typeof thrownValue && \"function\" === typeof thrownValue.then ? SuspendedOnDeprecatedThrowPromise : SuspendedOnError;\n        workInProgressThrownValue = thrownValue;\n        var erroredWork = workInProgress;\n        if (null === erroredWork) workInProgressRootExitStatus = RootFatalErrored, logUncaughtError(root, createCapturedValueAtFiber(thrownValue, root.current));\n        else switch(erroredWork.mode & 2 && stopProfilerTimerIfRunningAndRecordDuration(erroredWork), markComponentRenderStopped(), workInProgressSuspendedReason){\n            case SuspendedOnError:\n                null !== injectedProfilingHooks && \"function\" === typeof injectedProfilingHooks.markComponentErrored && injectedProfilingHooks.markComponentErrored(erroredWork, thrownValue, workInProgressRootRenderLanes);\n                break;\n            case SuspendedOnData:\n            case SuspendedOnImmediate:\n            case SuspendedOnDeprecatedThrowPromise:\n            case SuspendedAndReadyToContinue:\n                null !== injectedProfilingHooks && \"function\" === typeof injectedProfilingHooks.markComponentSuspended && injectedProfilingHooks.markComponentSuspended(erroredWork, thrownValue, workInProgressRootRenderLanes);\n        }\n    }\n    function shouldRemainOnPreviousScreen() {\n        var handler = suspenseHandlerStackCursor.current;\n        return null === handler ? !0 : (workInProgressRootRenderLanes & 4194176) === workInProgressRootRenderLanes ? null === shellBoundary ? !0 : !1 : (workInProgressRootRenderLanes & 62914560) === workInProgressRootRenderLanes || 0 !== (workInProgressRootRenderLanes & 536870912) ? handler === shellBoundary : !1;\n    }\n    function pushDispatcher() {\n        var prevDispatcher = ReactSharedInternals.H;\n        ReactSharedInternals.H = ContextOnlyDispatcher;\n        return null === prevDispatcher ? ContextOnlyDispatcher : prevDispatcher;\n    }\n    function pushAsyncDispatcher() {\n        var prevAsyncDispatcher = ReactSharedInternals.A;\n        ReactSharedInternals.A = DefaultAsyncDispatcher;\n        return prevAsyncDispatcher;\n    }\n    function renderDidSuspendDelayIfPossible() {\n        workInProgressRootExitStatus = RootSuspendedWithDelay;\n        workInProgressRootDidSkipSuspendedSiblings || (workInProgressRootRenderLanes & 4194176) !== workInProgressRootRenderLanes && null !== suspenseHandlerStackCursor.current || (workInProgressRootIsPrerendering = !0);\n        0 === (workInProgressRootSkippedLanes & 134217727) && 0 === (workInProgressRootInterleavedUpdatedLanes & 134217727) || null === workInProgressRoot || markRootSuspended(workInProgressRoot, workInProgressRootRenderLanes, workInProgressDeferredLane, !1);\n    }\n    function renderRootSync(root, lanes, shouldYieldForPrerendering) {\n        var prevExecutionContext = executionContext;\n        executionContext |= RenderContext;\n        var prevDispatcher = pushDispatcher(), prevAsyncDispatcher = pushAsyncDispatcher();\n        if (workInProgressRoot !== root || workInProgressRootRenderLanes !== lanes) {\n            if (isDevToolsPresent) {\n                var memoizedUpdaters = root.memoizedUpdaters;\n                0 < memoizedUpdaters.size && (restorePendingUpdaters(root, workInProgressRootRenderLanes), memoizedUpdaters.clear());\n                movePendingFibersToMemoized(root, lanes);\n            }\n            workInProgressTransitions = null;\n            prepareFreshStack(root, lanes);\n        }\n        markRenderStarted(lanes);\n        lanes = !1;\n        memoizedUpdaters = workInProgressRootExitStatus;\n        a: do try {\n            if (workInProgressSuspendedReason !== NotSuspended && null !== workInProgress) {\n                var unitOfWork = workInProgress, thrownValue = workInProgressThrownValue;\n                switch(workInProgressSuspendedReason){\n                    case SuspendedOnHydration:\n                        resetWorkInProgressStack();\n                        memoizedUpdaters = RootDidNotComplete;\n                        break a;\n                    case SuspendedOnImmediate:\n                    case SuspendedOnData:\n                    case SuspendedOnDeprecatedThrowPromise:\n                        null === suspenseHandlerStackCursor.current && (lanes = !0);\n                        var reason = workInProgressSuspendedReason;\n                        workInProgressSuspendedReason = NotSuspended;\n                        workInProgressThrownValue = null;\n                        throwAndUnwindWorkLoop(root, unitOfWork, thrownValue, reason);\n                        if (shouldYieldForPrerendering && workInProgressRootIsPrerendering) {\n                            memoizedUpdaters = RootInProgress;\n                            break a;\n                        }\n                        break;\n                    default:\n                        reason = workInProgressSuspendedReason, workInProgressSuspendedReason = NotSuspended, workInProgressThrownValue = null, throwAndUnwindWorkLoop(root, unitOfWork, thrownValue, reason);\n                }\n            }\n            workLoopSync();\n            memoizedUpdaters = workInProgressRootExitStatus;\n            break;\n        } catch (thrownValue$4) {\n            handleThrow(root, thrownValue$4);\n        }\n        while (1);\n        lanes && root.shellSuspendCounter++;\n        resetContextDependencies();\n        executionContext = prevExecutionContext;\n        ReactSharedInternals.H = prevDispatcher;\n        ReactSharedInternals.A = prevAsyncDispatcher;\n        markRenderStopped();\n        null === workInProgress && (workInProgressRoot = null, workInProgressRootRenderLanes = 0, finishQueueingConcurrentUpdates());\n        return memoizedUpdaters;\n    }\n    function workLoopSync() {\n        for(; null !== workInProgress;)performUnitOfWork(workInProgress);\n    }\n    function renderRootConcurrent(root, lanes) {\n        var prevExecutionContext = executionContext;\n        executionContext |= RenderContext;\n        var prevDispatcher = pushDispatcher(), prevAsyncDispatcher = pushAsyncDispatcher();\n        if (workInProgressRoot !== root || workInProgressRootRenderLanes !== lanes) {\n            if (isDevToolsPresent) {\n                var memoizedUpdaters = root.memoizedUpdaters;\n                0 < memoizedUpdaters.size && (restorePendingUpdaters(root, workInProgressRootRenderLanes), memoizedUpdaters.clear());\n                movePendingFibersToMemoized(root, lanes);\n            }\n            workInProgressTransitions = null;\n            workInProgressRootRenderTargetTime = now$1() + RENDER_TIMEOUT_MS;\n            prepareFreshStack(root, lanes);\n        } else workInProgressRootIsPrerendering = checkIfRootIsPrerendering(root, lanes);\n        markRenderStarted(lanes);\n        a: do try {\n            if (workInProgressSuspendedReason !== NotSuspended && null !== workInProgress) b: switch(lanes = workInProgress, memoizedUpdaters = workInProgressThrownValue, workInProgressSuspendedReason){\n                case SuspendedOnError:\n                    workInProgressSuspendedReason = NotSuspended;\n                    workInProgressThrownValue = null;\n                    throwAndUnwindWorkLoop(root, lanes, memoizedUpdaters, SuspendedOnError);\n                    break;\n                case SuspendedOnData:\n                    if (isThenableResolved(memoizedUpdaters)) {\n                        workInProgressSuspendedReason = NotSuspended;\n                        workInProgressThrownValue = null;\n                        replaySuspendedUnitOfWork(lanes);\n                        break;\n                    }\n                    lanes = function() {\n                        workInProgressSuspendedReason === SuspendedOnData && workInProgressRoot === root && (workInProgressSuspendedReason = SuspendedAndReadyToContinue);\n                        ensureRootIsScheduled(root);\n                    };\n                    memoizedUpdaters.then(lanes, lanes);\n                    break a;\n                case SuspendedOnImmediate:\n                    workInProgressSuspendedReason = SuspendedAndReadyToContinue;\n                    break a;\n                case SuspendedOnInstance:\n                    workInProgressSuspendedReason = SuspendedOnInstanceAndReadyToContinue;\n                    break a;\n                case SuspendedAndReadyToContinue:\n                    isThenableResolved(memoizedUpdaters) ? (workInProgressSuspendedReason = NotSuspended, workInProgressThrownValue = null, replaySuspendedUnitOfWork(lanes)) : (workInProgressSuspendedReason = NotSuspended, workInProgressThrownValue = null, throwAndUnwindWorkLoop(root, lanes, memoizedUpdaters, SuspendedAndReadyToContinue));\n                    break;\n                case SuspendedOnInstanceAndReadyToContinue:\n                    var resource = null;\n                    switch(workInProgress.tag){\n                        case 26:\n                            resource = workInProgress.memoizedState;\n                        case 5:\n                        case 27:\n                            var hostFiber = workInProgress, type = hostFiber.type, props = hostFiber.pendingProps;\n                            if (resource ? preloadResource(resource) : preloadInstance(type, props)) {\n                                workInProgressSuspendedReason = NotSuspended;\n                                workInProgressThrownValue = null;\n                                var sibling = hostFiber.sibling;\n                                if (null !== sibling) workInProgress = sibling;\n                                else {\n                                    var returnFiber = hostFiber.return;\n                                    null !== returnFiber ? (workInProgress = returnFiber, completeUnitOfWork(returnFiber)) : workInProgress = null;\n                                }\n                                break b;\n                            }\n                            break;\n                        default:\n                            console.error(\"Unexpected type of fiber triggered a suspensey commit. This is a bug in React.\");\n                    }\n                    workInProgressSuspendedReason = NotSuspended;\n                    workInProgressThrownValue = null;\n                    throwAndUnwindWorkLoop(root, lanes, memoizedUpdaters, SuspendedOnInstanceAndReadyToContinue);\n                    break;\n                case SuspendedOnDeprecatedThrowPromise:\n                    workInProgressSuspendedReason = NotSuspended;\n                    workInProgressThrownValue = null;\n                    throwAndUnwindWorkLoop(root, lanes, memoizedUpdaters, SuspendedOnDeprecatedThrowPromise);\n                    break;\n                case SuspendedOnHydration:\n                    resetWorkInProgressStack();\n                    workInProgressRootExitStatus = RootDidNotComplete;\n                    break a;\n                default:\n                    throw Error(\"Unexpected SuspendedReason. This is a bug in React.\");\n            }\n            null !== ReactSharedInternals.actQueue ? workLoopSync() : workLoopConcurrent();\n            break;\n        } catch (thrownValue$5) {\n            handleThrow(root, thrownValue$5);\n        }\n        while (1);\n        resetContextDependencies();\n        ReactSharedInternals.H = prevDispatcher;\n        ReactSharedInternals.A = prevAsyncDispatcher;\n        executionContext = prevExecutionContext;\n        if (null !== workInProgress) return null !== injectedProfilingHooks && \"function\" === typeof injectedProfilingHooks.markRenderYielded && injectedProfilingHooks.markRenderYielded(), RootInProgress;\n        markRenderStopped();\n        workInProgressRoot = null;\n        workInProgressRootRenderLanes = 0;\n        finishQueueingConcurrentUpdates();\n        return workInProgressRootExitStatus;\n    }\n    function workLoopConcurrent() {\n        for(; null !== workInProgress && !shouldYield();)performUnitOfWork(workInProgress);\n    }\n    function performUnitOfWork(unitOfWork) {\n        var current = unitOfWork.alternate;\n        (unitOfWork.mode & 2) !== NoMode ? (startProfilerTimer(unitOfWork), current = runWithFiberInDEV(unitOfWork, beginWork, current, unitOfWork, entangledRenderLanes), stopProfilerTimerIfRunningAndRecordDuration(unitOfWork)) : current = runWithFiberInDEV(unitOfWork, beginWork, current, unitOfWork, entangledRenderLanes);\n        unitOfWork.memoizedProps = unitOfWork.pendingProps;\n        null === current ? completeUnitOfWork(unitOfWork) : workInProgress = current;\n    }\n    function replaySuspendedUnitOfWork(unitOfWork) {\n        var next = runWithFiberInDEV(unitOfWork, replayBeginWork, unitOfWork);\n        unitOfWork.memoizedProps = unitOfWork.pendingProps;\n        null === next ? completeUnitOfWork(unitOfWork) : workInProgress = next;\n    }\n    function replayBeginWork(unitOfWork) {\n        var current = unitOfWork.alternate, isProfilingMode = (unitOfWork.mode & 2) !== NoMode;\n        isProfilingMode && startProfilerTimer(unitOfWork);\n        switch(unitOfWork.tag){\n            case 15:\n            case 0:\n                current = replayFunctionComponent(current, unitOfWork, unitOfWork.pendingProps, unitOfWork.type, void 0, workInProgressRootRenderLanes);\n                break;\n            case 11:\n                current = replayFunctionComponent(current, unitOfWork, unitOfWork.pendingProps, unitOfWork.type.render, unitOfWork.ref, workInProgressRootRenderLanes);\n                break;\n            case 5:\n                resetHooksOnUnwind(unitOfWork);\n            default:\n                unwindInterruptedWork(current, unitOfWork), unitOfWork = workInProgress = resetWorkInProgress(unitOfWork, entangledRenderLanes), current = beginWork(current, unitOfWork, entangledRenderLanes);\n        }\n        isProfilingMode && stopProfilerTimerIfRunningAndRecordDuration(unitOfWork);\n        return current;\n    }\n    function throwAndUnwindWorkLoop(root, unitOfWork, thrownValue, suspendedReason) {\n        resetContextDependencies();\n        resetHooksOnUnwind(unitOfWork);\n        thenableState$1 = null;\n        thenableIndexCounter$1 = 0;\n        var returnFiber = unitOfWork.return;\n        try {\n            if (throwException(root, returnFiber, unitOfWork, thrownValue, workInProgressRootRenderLanes)) {\n                workInProgressRootExitStatus = RootFatalErrored;\n                logUncaughtError(root, createCapturedValueAtFiber(thrownValue, root.current));\n                workInProgress = null;\n                return;\n            }\n        } catch (error) {\n            if (null !== returnFiber) throw workInProgress = returnFiber, error;\n            workInProgressRootExitStatus = RootFatalErrored;\n            logUncaughtError(root, createCapturedValueAtFiber(thrownValue, root.current));\n            workInProgress = null;\n            return;\n        }\n        if (unitOfWork.flags & 32768) {\n            if (isHydrating || suspendedReason === SuspendedOnError) root = !0;\n            else if (workInProgressRootIsPrerendering || 0 !== (workInProgressRootRenderLanes & 536870912)) root = !1;\n            else if (workInProgressRootDidSkipSuspendedSiblings = root = !0, suspendedReason === SuspendedOnData || suspendedReason === SuspendedOnImmediate || suspendedReason === SuspendedOnDeprecatedThrowPromise) suspendedReason = suspenseHandlerStackCursor.current, null !== suspendedReason && 13 === suspendedReason.tag && (suspendedReason.flags |= 16384);\n            unwindUnitOfWork(unitOfWork, root);\n        } else completeUnitOfWork(unitOfWork);\n    }\n    function completeUnitOfWork(unitOfWork) {\n        var completedWork = unitOfWork;\n        do {\n            if (0 !== (completedWork.flags & 32768)) {\n                unwindUnitOfWork(completedWork, workInProgressRootDidSkipSuspendedSiblings);\n                return;\n            }\n            var current = completedWork.alternate;\n            unitOfWork = completedWork.return;\n            startProfilerTimer(completedWork);\n            current = runWithFiberInDEV(completedWork, completeWork, current, completedWork, entangledRenderLanes);\n            (completedWork.mode & 2) !== NoMode && stopProfilerTimerIfRunningAndRecordIncompleteDuration(completedWork);\n            if (null !== current) {\n                workInProgress = current;\n                return;\n            }\n            completedWork = completedWork.sibling;\n            if (null !== completedWork) {\n                workInProgress = completedWork;\n                return;\n            }\n            workInProgress = completedWork = unitOfWork;\n        }while (null !== completedWork);\n        workInProgressRootExitStatus === RootInProgress && (workInProgressRootExitStatus = RootCompleted);\n    }\n    function unwindUnitOfWork(unitOfWork, skipSiblings) {\n        do {\n            var next = unwindWork(unitOfWork.alternate, unitOfWork);\n            if (null !== next) {\n                next.flags &= 32767;\n                workInProgress = next;\n                return;\n            }\n            if ((unitOfWork.mode & 2) !== NoMode) {\n                stopProfilerTimerIfRunningAndRecordIncompleteDuration(unitOfWork);\n                next = unitOfWork.actualDuration;\n                for(var child = unitOfWork.child; null !== child;)next += child.actualDuration, child = child.sibling;\n                unitOfWork.actualDuration = next;\n            }\n            next = unitOfWork.return;\n            null !== next && (next.flags |= 32768, next.subtreeFlags = 0, next.deletions = null);\n            if (!skipSiblings && (unitOfWork = unitOfWork.sibling, null !== unitOfWork)) {\n                workInProgress = unitOfWork;\n                return;\n            }\n            workInProgress = unitOfWork = next;\n        }while (null !== unitOfWork);\n        workInProgressRootExitStatus = RootDidNotComplete;\n        workInProgress = null;\n    }\n    function commitRoot(root, recoverableErrors, transitions, didIncludeRenderPhaseUpdate, spawnedLane, updatedLanes, suspendedRetryLanes, suspendedCommitReason, completedRenderStartTime, completedRenderEndTime) {\n        var prevTransition = ReactSharedInternals.T, previousUpdateLanePriority = getCurrentUpdatePriority();\n        try {\n            setCurrentUpdatePriority(2), ReactSharedInternals.T = null, commitRootImpl(root, recoverableErrors, transitions, didIncludeRenderPhaseUpdate, previousUpdateLanePriority, spawnedLane, updatedLanes, suspendedRetryLanes, suspendedCommitReason, completedRenderStartTime, completedRenderEndTime);\n        } finally{\n            ReactSharedInternals.T = prevTransition, setCurrentUpdatePriority(previousUpdateLanePriority);\n        }\n    }\n    function commitRootImpl(root, recoverableErrors, transitions, didIncludeRenderPhaseUpdate, renderPriorityLevel, spawnedLane, updatedLanes, suspendedRetryLanes) {\n        do flushPassiveEffects();\n        while (null !== rootWithPendingPassiveEffects);\n        ReactStrictModeWarnings.flushLegacyContextWarning();\n        ReactStrictModeWarnings.flushPendingUnsafeLifecycleWarnings();\n        if ((executionContext & (RenderContext | CommitContext)) !== NoContext) throw Error(\"Should not already be working.\");\n        var finishedWork = root.finishedWork;\n        didIncludeRenderPhaseUpdate = root.finishedLanes;\n        null !== injectedProfilingHooks && \"function\" === typeof injectedProfilingHooks.markCommitStarted && injectedProfilingHooks.markCommitStarted(didIncludeRenderPhaseUpdate);\n        if (null === finishedWork) return markCommitStopped(), null;\n        0 === didIncludeRenderPhaseUpdate && console.error(\"root.finishedLanes should not be empty during a commit. This is a bug in React.\");\n        root.finishedWork = null;\n        root.finishedLanes = 0;\n        if (finishedWork === root.current) throw Error(\"Cannot commit the same tree as before. This error is likely caused by a bug in React. Please file an issue.\");\n        root.callbackNode = null;\n        root.callbackPriority = 0;\n        root.cancelPendingCommit = null;\n        var remainingLanes = finishedWork.lanes | finishedWork.childLanes;\n        remainingLanes |= concurrentlyUpdatedLanes;\n        markRootFinished(root, didIncludeRenderPhaseUpdate, remainingLanes, spawnedLane, updatedLanes, suspendedRetryLanes);\n        root === workInProgressRoot && (workInProgress = workInProgressRoot = null, workInProgressRootRenderLanes = 0);\n        0 === (finishedWork.subtreeFlags & 10256) && 0 === (finishedWork.flags & 10256) || rootDoesHavePassiveEffects || (rootDoesHavePassiveEffects = !0, pendingPassiveEffectsRemainingLanes = remainingLanes, pendingPassiveTransitions = transitions, scheduleCallback(NormalPriority$1, function() {\n            flushPassiveEffects(!0);\n            return null;\n        }));\n        commitStartTime = now();\n        transitions = 0 !== (finishedWork.flags & 15990);\n        0 !== (finishedWork.subtreeFlags & 15990) || transitions ? (transitions = ReactSharedInternals.T, ReactSharedInternals.T = null, spawnedLane = getCurrentUpdatePriority(), setCurrentUpdatePriority(2), updatedLanes = executionContext, executionContext |= CommitContext, commitBeforeMutationEffects(root, finishedWork), commitMutationEffects(root, finishedWork, didIncludeRenderPhaseUpdate), resetAfterCommit(root.containerInfo), root.current = finishedWork, null !== injectedProfilingHooks && \"function\" === typeof injectedProfilingHooks.markLayoutEffectsStarted && injectedProfilingHooks.markLayoutEffectsStarted(didIncludeRenderPhaseUpdate), commitLayoutEffects(finishedWork, root, didIncludeRenderPhaseUpdate), null !== injectedProfilingHooks && \"function\" === typeof injectedProfilingHooks.markLayoutEffectsStopped && injectedProfilingHooks.markLayoutEffectsStopped(), requestPaint(), executionContext = updatedLanes, setCurrentUpdatePriority(spawnedLane), ReactSharedInternals.T = transitions) : root.current = finishedWork;\n        (transitions = rootDoesHavePassiveEffects) ? (rootDoesHavePassiveEffects = !1, rootWithPendingPassiveEffects = root, pendingPassiveEffectsLanes = didIncludeRenderPhaseUpdate) : (releaseRootPooledCache(root, remainingLanes), nestedPassiveUpdateCount = 0, rootWithPassiveNestedUpdates = null);\n        remainingLanes = root.pendingLanes;\n        0 === remainingLanes && (legacyErrorBoundariesThatAlreadyFailed = null);\n        transitions || commitDoubleInvokeEffectsInDEV(root);\n        onCommitRoot$1(finishedWork.stateNode, renderPriorityLevel);\n        isDevToolsPresent && root.memoizedUpdaters.clear();\n        onCommitRoot();\n        ensureRootIsScheduled(root);\n        if (null !== recoverableErrors) for(renderPriorityLevel = root.onRecoverableError, finishedWork = 0; finishedWork < recoverableErrors.length; finishedWork++)remainingLanes = recoverableErrors[finishedWork], transitions = makeErrorInfo(remainingLanes.stack), runWithFiberInDEV(remainingLanes.source, renderPriorityLevel, remainingLanes.value, transitions);\n        0 !== (pendingPassiveEffectsLanes & 3) && flushPassiveEffects();\n        remainingLanes = root.pendingLanes;\n        0 !== (didIncludeRenderPhaseUpdate & 4194218) && 0 !== (remainingLanes & 42) ? (nestedUpdateScheduled = !0, root === rootWithNestedUpdates ? nestedUpdateCount++ : (nestedUpdateCount = 0, rootWithNestedUpdates = root)) : nestedUpdateCount = 0;\n        flushSyncWorkAcrossRoots_impl(0, !1);\n        markCommitStopped();\n        return null;\n    }\n    function makeErrorInfo(componentStack) {\n        componentStack = {\n            componentStack: componentStack\n        };\n        Object.defineProperty(componentStack, \"digest\", {\n            get: function() {\n                console.error('You are accessing \"digest\" from the errorInfo object passed to onRecoverableError. This property is no longer provided as part of errorInfo but can be accessed as a property of the Error instance itself.');\n            }\n        });\n        return componentStack;\n    }\n    function releaseRootPooledCache(root, remainingLanes) {\n        0 === (root.pooledCacheLanes &= remainingLanes) && (remainingLanes = root.pooledCache, null != remainingLanes && (root.pooledCache = null, releaseCache(remainingLanes)));\n    }\n    function flushPassiveEffects() {\n        if (null !== rootWithPendingPassiveEffects) {\n            var root = rootWithPendingPassiveEffects, remainingLanes = pendingPassiveEffectsRemainingLanes;\n            pendingPassiveEffectsRemainingLanes = 0;\n            var renderPriority = lanesToEventPriority(pendingPassiveEffectsLanes), priority = 32 > renderPriority ? 32 : renderPriority;\n            renderPriority = ReactSharedInternals.T;\n            var previousPriority = getCurrentUpdatePriority();\n            try {\n                setCurrentUpdatePriority(priority);\n                ReactSharedInternals.T = null;\n                if (null === rootWithPendingPassiveEffects) var JSCompiler_inline_result = !1;\n                else {\n                    priority = pendingPassiveTransitions;\n                    pendingPassiveTransitions = null;\n                    var root$jscomp$0 = rootWithPendingPassiveEffects, lanes = pendingPassiveEffectsLanes;\n                    rootWithPendingPassiveEffects = null;\n                    pendingPassiveEffectsLanes = 0;\n                    if ((executionContext & (RenderContext | CommitContext)) !== NoContext) throw Error(\"Cannot flush passive effects while already rendering.\");\n                    isFlushingPassiveEffects = !0;\n                    didScheduleUpdateDuringPassiveEffects = !1;\n                    null !== injectedProfilingHooks && \"function\" === typeof injectedProfilingHooks.markPassiveEffectsStarted && injectedProfilingHooks.markPassiveEffectsStarted(lanes);\n                    var prevExecutionContext = executionContext;\n                    executionContext |= CommitContext;\n                    commitPassiveUnmountOnFiber(root$jscomp$0.current);\n                    commitPassiveMountOnFiber(root$jscomp$0, root$jscomp$0.current, lanes, priority);\n                    null !== injectedProfilingHooks && \"function\" === typeof injectedProfilingHooks.markPassiveEffectsStopped && injectedProfilingHooks.markPassiveEffectsStopped();\n                    commitDoubleInvokeEffectsInDEV(root$jscomp$0);\n                    executionContext = prevExecutionContext;\n                    flushSyncWorkAcrossRoots_impl(0, !1);\n                    didScheduleUpdateDuringPassiveEffects ? root$jscomp$0 === rootWithPassiveNestedUpdates ? nestedPassiveUpdateCount++ : (nestedPassiveUpdateCount = 0, rootWithPassiveNestedUpdates = root$jscomp$0) : nestedPassiveUpdateCount = 0;\n                    didScheduleUpdateDuringPassiveEffects = isFlushingPassiveEffects = !1;\n                    if (injectedHook && \"function\" === typeof injectedHook.onPostCommitFiberRoot) try {\n                        injectedHook.onPostCommitFiberRoot(rendererID, root$jscomp$0);\n                    } catch (err) {\n                        hasLoggedError || (hasLoggedError = !0, console.error(\"React instrumentation encountered an error: %s\", err));\n                    }\n                    var stateNode = root$jscomp$0.current.stateNode;\n                    stateNode.effectDuration = 0;\n                    stateNode.passiveEffectDuration = 0;\n                    JSCompiler_inline_result = !0;\n                }\n                return JSCompiler_inline_result;\n            } finally{\n                setCurrentUpdatePriority(previousPriority), ReactSharedInternals.T = renderPriority, releaseRootPooledCache(root, remainingLanes);\n            }\n        }\n        return !1;\n    }\n    function captureCommitPhaseErrorOnRoot(rootFiber, sourceFiber, error) {\n        sourceFiber = createCapturedValueAtFiber(error, sourceFiber);\n        sourceFiber = createRootErrorUpdate(rootFiber.stateNode, sourceFiber, 2);\n        rootFiber = enqueueUpdate(rootFiber, sourceFiber, 2);\n        null !== rootFiber && (markRootUpdated$1(rootFiber, 2), ensureRootIsScheduled(rootFiber));\n    }\n    function captureCommitPhaseError(sourceFiber, nearestMountedAncestor, error) {\n        isRunningInsertionEffect = !1;\n        if (3 === sourceFiber.tag) captureCommitPhaseErrorOnRoot(sourceFiber, sourceFiber, error);\n        else {\n            for(; null !== nearestMountedAncestor;){\n                if (3 === nearestMountedAncestor.tag) {\n                    captureCommitPhaseErrorOnRoot(nearestMountedAncestor, sourceFiber, error);\n                    return;\n                }\n                if (1 === nearestMountedAncestor.tag) {\n                    var instance = nearestMountedAncestor.stateNode;\n                    if (\"function\" === typeof nearestMountedAncestor.type.getDerivedStateFromError || \"function\" === typeof instance.componentDidCatch && (null === legacyErrorBoundariesThatAlreadyFailed || !legacyErrorBoundariesThatAlreadyFailed.has(instance))) {\n                        sourceFiber = createCapturedValueAtFiber(error, sourceFiber);\n                        error = createClassErrorUpdate(2);\n                        instance = enqueueUpdate(nearestMountedAncestor, error, 2);\n                        null !== instance && (initializeClassErrorUpdate(error, instance, nearestMountedAncestor, sourceFiber), markRootUpdated$1(instance, 2), ensureRootIsScheduled(instance));\n                        return;\n                    }\n                }\n                nearestMountedAncestor = nearestMountedAncestor.return;\n            }\n            console.error(\"Internal React error: Attempted to capture a commit phase error inside a detached tree. This indicates a bug in React. Potential causes include deleting the same fiber more than once, committing an already-finished tree, or an inconsistent return pointer.\\n\\nError message:\\n\\n%s\", error);\n        }\n    }\n    function attachPingListener(root, wakeable, lanes) {\n        var pingCache = root.pingCache;\n        if (null === pingCache) {\n            pingCache = root.pingCache = new PossiblyWeakMap();\n            var threadIDs = new Set();\n            pingCache.set(wakeable, threadIDs);\n        } else threadIDs = pingCache.get(wakeable), void 0 === threadIDs && (threadIDs = new Set(), pingCache.set(wakeable, threadIDs));\n        threadIDs.has(lanes) || (workInProgressRootDidAttachPingListener = !0, threadIDs.add(lanes), pingCache = pingSuspendedRoot.bind(null, root, wakeable, lanes), isDevToolsPresent && restorePendingUpdaters(root, lanes), wakeable.then(pingCache, pingCache));\n    }\n    function pingSuspendedRoot(root, wakeable, pingedLanes) {\n        var pingCache = root.pingCache;\n        null !== pingCache && pingCache.delete(wakeable);\n        root.pingedLanes |= root.suspendedLanes & pingedLanes;\n        root.warmLanes &= ~pingedLanes;\n        isConcurrentActEnvironment() && null === ReactSharedInternals.actQueue && console.error(\"A suspended resource finished loading inside a test, but the event was not wrapped in act(...).\\n\\nWhen testing, code that resolves suspended data should be wrapped into act(...):\\n\\nact(() => {\\n  /* finish loading suspended data */\\n});\\n/* assert on the output */\\n\\nThis ensures that you're testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act\");\n        workInProgressRoot === root && (workInProgressRootRenderLanes & pingedLanes) === pingedLanes && (workInProgressRootExitStatus === RootSuspendedWithDelay || workInProgressRootExitStatus === RootSuspended && (workInProgressRootRenderLanes & 62914560) === workInProgressRootRenderLanes && now$1() - globalMostRecentFallbackTime < FALLBACK_THROTTLE_MS ? (executionContext & RenderContext) === NoContext && prepareFreshStack(root, 0) : workInProgressRootPingedLanes |= pingedLanes, workInProgressSuspendedRetryLanes === workInProgressRootRenderLanes && (workInProgressSuspendedRetryLanes = 0));\n        ensureRootIsScheduled(root);\n    }\n    function retryTimedOutBoundary(boundaryFiber, retryLane) {\n        0 === retryLane && (retryLane = claimNextRetryLane());\n        boundaryFiber = enqueueConcurrentRenderForLane(boundaryFiber, retryLane);\n        null !== boundaryFiber && (markRootUpdated$1(boundaryFiber, retryLane), ensureRootIsScheduled(boundaryFiber));\n    }\n    function retryDehydratedSuspenseBoundary(boundaryFiber) {\n        var suspenseState = boundaryFiber.memoizedState, retryLane = 0;\n        null !== suspenseState && (retryLane = suspenseState.retryLane);\n        retryTimedOutBoundary(boundaryFiber, retryLane);\n    }\n    function resolveRetryWakeable(boundaryFiber, wakeable) {\n        var retryLane = 0;\n        switch(boundaryFiber.tag){\n            case 13:\n                var retryCache = boundaryFiber.stateNode;\n                var suspenseState = boundaryFiber.memoizedState;\n                null !== suspenseState && (retryLane = suspenseState.retryLane);\n                break;\n            case 19:\n                retryCache = boundaryFiber.stateNode;\n                break;\n            case 22:\n                retryCache = boundaryFiber.stateNode._retryCache;\n                break;\n            default:\n                throw Error(\"Pinged unknown suspense boundary type. This is probably a bug in React.\");\n        }\n        null !== retryCache && retryCache.delete(wakeable);\n        retryTimedOutBoundary(boundaryFiber, retryLane);\n    }\n    function recursivelyTraverseAndDoubleInvokeEffectsInDEV(root$jscomp$0, parentFiber, isInStrictMode) {\n        if (0 !== (parentFiber.subtreeFlags & 33562624)) for(parentFiber = parentFiber.child; null !== parentFiber;){\n            var root = root$jscomp$0, fiber = parentFiber, isStrictModeFiber = fiber.type === REACT_STRICT_MODE_TYPE;\n            isStrictModeFiber = isInStrictMode || isStrictModeFiber;\n            22 !== fiber.tag ? fiber.flags & 33554432 ? isStrictModeFiber && runWithFiberInDEV(fiber, doubleInvokeEffectsOnFiber, root, fiber, (fiber.mode & 64) === NoMode) : recursivelyTraverseAndDoubleInvokeEffectsInDEV(root, fiber, isStrictModeFiber) : null === fiber.memoizedState && (isStrictModeFiber && fiber.flags & 8192 ? runWithFiberInDEV(fiber, doubleInvokeEffectsOnFiber, root, fiber) : fiber.subtreeFlags & 33554432 && runWithFiberInDEV(fiber, recursivelyTraverseAndDoubleInvokeEffectsInDEV, root, fiber, isStrictModeFiber));\n            parentFiber = parentFiber.sibling;\n        }\n    }\n    function doubleInvokeEffectsOnFiber(root, fiber) {\n        var shouldDoubleInvokePassiveEffects = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : !0;\n        setIsStrictModeForDevtools(!0);\n        try {\n            disappearLayoutEffects(fiber), shouldDoubleInvokePassiveEffects && disconnectPassiveEffect(fiber), reappearLayoutEffects(root, fiber.alternate, fiber, !1), shouldDoubleInvokePassiveEffects && reconnectPassiveEffects(root, fiber, 0, null, !1);\n        } finally{\n            setIsStrictModeForDevtools(!1);\n        }\n    }\n    function commitDoubleInvokeEffectsInDEV(root) {\n        var doubleInvokeEffects = !0;\n        root.current.mode & 24 || (doubleInvokeEffects = !1);\n        recursivelyTraverseAndDoubleInvokeEffectsInDEV(root, root.current, doubleInvokeEffects);\n    }\n    function warnAboutUpdateOnNotYetMountedFiberInDEV(fiber) {\n        if ((executionContext & RenderContext) === NoContext) {\n            var tag = fiber.tag;\n            if (3 === tag || 1 === tag || 0 === tag || 11 === tag || 14 === tag || 15 === tag) {\n                tag = getComponentNameFromFiber(fiber) || \"ReactComponent\";\n                if (null !== didWarnStateUpdateForNotYetMountedComponent) {\n                    if (didWarnStateUpdateForNotYetMountedComponent.has(tag)) return;\n                    didWarnStateUpdateForNotYetMountedComponent.add(tag);\n                } else didWarnStateUpdateForNotYetMountedComponent = new Set([\n                    tag\n                ]);\n                runWithFiberInDEV(fiber, function() {\n                    console.error(\"Can't perform a React state update on a component that hasn't mounted yet. This indicates that you have a side-effect in your render function that asynchronously later calls tries to update the component. Move this work to useEffect instead.\");\n                });\n            }\n        }\n    }\n    function restorePendingUpdaters(root, lanes) {\n        isDevToolsPresent && root.memoizedUpdaters.forEach(function(schedulingFiber) {\n            addFiberToLanesMap(root, schedulingFiber, lanes);\n        });\n    }\n    function scheduleCallback(priorityLevel, callback) {\n        var actQueue = ReactSharedInternals.actQueue;\n        return null !== actQueue ? (actQueue.push(callback), fakeActCallbackNode) : scheduleCallback$3(priorityLevel, callback);\n    }\n    function warnIfUpdatesNotWrappedWithActDEV(fiber) {\n        isConcurrentActEnvironment() && null === ReactSharedInternals.actQueue && runWithFiberInDEV(fiber, function() {\n            console.error(\"An update to %s inside a test was not wrapped in act(...).\\n\\nWhen testing, code that causes React state updates should be wrapped into act(...):\\n\\nact(() => {\\n  /* fire events that update state */\\n});\\n/* assert on the output */\\n\\nThis ensures that you're testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act\", getComponentNameFromFiber(fiber));\n        });\n    }\n    function resolveFunctionForHotReloading(type) {\n        if (null === resolveFamily) return type;\n        var family = resolveFamily(type);\n        return void 0 === family ? type : family.current;\n    }\n    function resolveForwardRefForHotReloading(type) {\n        if (null === resolveFamily) return type;\n        var family = resolveFamily(type);\n        return void 0 === family ? null !== type && void 0 !== type && \"function\" === typeof type.render && (family = resolveFunctionForHotReloading(type.render), type.render !== family) ? (family = {\n            $$typeof: REACT_FORWARD_REF_TYPE,\n            render: family\n        }, void 0 !== type.displayName && (family.displayName = type.displayName), family) : type : family.current;\n    }\n    function isCompatibleFamilyForHotReloading(fiber, element) {\n        if (null === resolveFamily) return !1;\n        var prevType = fiber.elementType;\n        element = element.type;\n        var needsCompareFamilies = !1, $$typeofNextType = \"object\" === typeof element && null !== element ? element.$$typeof : null;\n        switch(fiber.tag){\n            case 1:\n                \"function\" === typeof element && (needsCompareFamilies = !0);\n                break;\n            case 0:\n                \"function\" === typeof element ? needsCompareFamilies = !0 : $$typeofNextType === REACT_LAZY_TYPE && (needsCompareFamilies = !0);\n                break;\n            case 11:\n                $$typeofNextType === REACT_FORWARD_REF_TYPE ? needsCompareFamilies = !0 : $$typeofNextType === REACT_LAZY_TYPE && (needsCompareFamilies = !0);\n                break;\n            case 14:\n            case 15:\n                $$typeofNextType === REACT_MEMO_TYPE ? needsCompareFamilies = !0 : $$typeofNextType === REACT_LAZY_TYPE && (needsCompareFamilies = !0);\n                break;\n            default:\n                return !1;\n        }\n        return needsCompareFamilies && (fiber = resolveFamily(prevType), void 0 !== fiber && fiber === resolveFamily(element)) ? !0 : !1;\n    }\n    function markFailedErrorBoundaryForHotReloading(fiber) {\n        null !== resolveFamily && \"function\" === typeof WeakSet && (null === failedBoundaries && (failedBoundaries = new WeakSet()), failedBoundaries.add(fiber));\n    }\n    function scheduleFibersWithFamiliesRecursively(fiber, updatedFamilies, staleFamilies) {\n        var alternate = fiber.alternate, child = fiber.child, sibling = fiber.sibling, tag = fiber.tag, type = fiber.type, candidateType = null;\n        switch(tag){\n            case 0:\n            case 15:\n            case 1:\n                candidateType = type;\n                break;\n            case 11:\n                candidateType = type.render;\n        }\n        if (null === resolveFamily) throw Error(\"Expected resolveFamily to be set during hot reload.\");\n        var needsRender = !1;\n        type = !1;\n        null !== candidateType && (candidateType = resolveFamily(candidateType), void 0 !== candidateType && (staleFamilies.has(candidateType) ? type = !0 : updatedFamilies.has(candidateType) && (1 === tag ? type = !0 : needsRender = !0)));\n        null !== failedBoundaries && (failedBoundaries.has(fiber) || null !== alternate && failedBoundaries.has(alternate)) && (type = !0);\n        type && (fiber._debugNeedsRemount = !0);\n        if (type || needsRender) alternate = enqueueConcurrentRenderForLane(fiber, 2), null !== alternate && scheduleUpdateOnFiber(alternate, fiber, 2);\n        null === child || type || scheduleFibersWithFamiliesRecursively(child, updatedFamilies, staleFamilies);\n        null !== sibling && scheduleFibersWithFamiliesRecursively(sibling, updatedFamilies, staleFamilies);\n    }\n    function FiberNode(tag, pendingProps, key, mode) {\n        this.tag = tag;\n        this.key = key;\n        this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null;\n        this.index = 0;\n        this.refCleanup = this.ref = null;\n        this.pendingProps = pendingProps;\n        this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null;\n        this.mode = mode;\n        this.subtreeFlags = this.flags = 0;\n        this.deletions = null;\n        this.childLanes = this.lanes = 0;\n        this.alternate = null;\n        this.actualDuration = -0;\n        this.actualStartTime = -1.1;\n        this.treeBaseDuration = this.selfBaseDuration = -0;\n        this._debugOwner = this._debugInfo = null;\n        this._debugNeedsRemount = !1;\n        this._debugHookTypes = null;\n        hasBadMapPolyfill || \"function\" !== typeof Object.preventExtensions || Object.preventExtensions(this);\n    }\n    function shouldConstruct(Component) {\n        Component = Component.prototype;\n        return !(!Component || !Component.isReactComponent);\n    }\n    function createWorkInProgress(current, pendingProps) {\n        var workInProgress = current.alternate;\n        null === workInProgress ? (workInProgress = createFiber(current.tag, pendingProps, current.key, current.mode), workInProgress.elementType = current.elementType, workInProgress.type = current.type, workInProgress.stateNode = current.stateNode, workInProgress._debugOwner = current._debugOwner, workInProgress._debugHookTypes = current._debugHookTypes, workInProgress.alternate = current, current.alternate = workInProgress) : (workInProgress.pendingProps = pendingProps, workInProgress.type = current.type, workInProgress.flags = 0, workInProgress.subtreeFlags = 0, workInProgress.deletions = null, workInProgress.actualDuration = -0, workInProgress.actualStartTime = -1.1);\n        workInProgress.flags = current.flags & 31457280;\n        workInProgress.childLanes = current.childLanes;\n        workInProgress.lanes = current.lanes;\n        workInProgress.child = current.child;\n        workInProgress.memoizedProps = current.memoizedProps;\n        workInProgress.memoizedState = current.memoizedState;\n        workInProgress.updateQueue = current.updateQueue;\n        pendingProps = current.dependencies;\n        workInProgress.dependencies = null === pendingProps ? null : {\n            lanes: pendingProps.lanes,\n            firstContext: pendingProps.firstContext,\n            _debugThenableState: pendingProps._debugThenableState\n        };\n        workInProgress.sibling = current.sibling;\n        workInProgress.index = current.index;\n        workInProgress.ref = current.ref;\n        workInProgress.refCleanup = current.refCleanup;\n        workInProgress.selfBaseDuration = current.selfBaseDuration;\n        workInProgress.treeBaseDuration = current.treeBaseDuration;\n        workInProgress._debugInfo = current._debugInfo;\n        workInProgress._debugNeedsRemount = current._debugNeedsRemount;\n        switch(workInProgress.tag){\n            case 0:\n            case 15:\n                workInProgress.type = resolveFunctionForHotReloading(current.type);\n                break;\n            case 1:\n                workInProgress.type = resolveFunctionForHotReloading(current.type);\n                break;\n            case 11:\n                workInProgress.type = resolveForwardRefForHotReloading(current.type);\n        }\n        return workInProgress;\n    }\n    function resetWorkInProgress(workInProgress, renderLanes) {\n        workInProgress.flags &= 31457282;\n        var current = workInProgress.alternate;\n        null === current ? (workInProgress.childLanes = 0, workInProgress.lanes = renderLanes, workInProgress.child = null, workInProgress.subtreeFlags = 0, workInProgress.memoizedProps = null, workInProgress.memoizedState = null, workInProgress.updateQueue = null, workInProgress.dependencies = null, workInProgress.stateNode = null, workInProgress.selfBaseDuration = 0, workInProgress.treeBaseDuration = 0) : (workInProgress.childLanes = current.childLanes, workInProgress.lanes = current.lanes, workInProgress.child = current.child, workInProgress.subtreeFlags = 0, workInProgress.deletions = null, workInProgress.memoizedProps = current.memoizedProps, workInProgress.memoizedState = current.memoizedState, workInProgress.updateQueue = current.updateQueue, workInProgress.type = current.type, renderLanes = current.dependencies, workInProgress.dependencies = null === renderLanes ? null : {\n            lanes: renderLanes.lanes,\n            firstContext: renderLanes.firstContext,\n            _debugThenableState: renderLanes._debugThenableState\n        }, workInProgress.selfBaseDuration = current.selfBaseDuration, workInProgress.treeBaseDuration = current.treeBaseDuration);\n        return workInProgress;\n    }\n    function createFiberFromTypeAndProps(type, key, pendingProps, owner, mode, lanes) {\n        var fiberTag = 0, resolvedType = type;\n        if (\"function\" === typeof type) shouldConstruct(type) && (fiberTag = 1), resolvedType = resolveFunctionForHotReloading(resolvedType);\n        else if (\"string\" === typeof type) supportsResources && supportsSingletons ? (fiberTag = getHostContext(), fiberTag = isHostHoistableType(type, pendingProps, fiberTag) ? 26 : isHostSingletonType(type) ? 27 : 5) : supportsResources ? (fiberTag = getHostContext(), fiberTag = isHostHoistableType(type, pendingProps, fiberTag) ? 26 : 5) : fiberTag = supportsSingletons ? isHostSingletonType(type) ? 27 : 5 : 5;\n        else a: switch(type){\n            case REACT_FRAGMENT_TYPE:\n                return createFiberFromFragment(pendingProps.children, mode, lanes, key);\n            case REACT_STRICT_MODE_TYPE:\n                fiberTag = 8;\n                mode |= 24;\n                break;\n            case REACT_PROFILER_TYPE:\n                return type = pendingProps, owner = mode, \"string\" !== typeof type.id && console.error('Profiler must specify an \"id\" of type `string` as a prop. Received the type `%s` instead.', typeof type.id), key = createFiber(12, type, key, owner | 2), key.elementType = REACT_PROFILER_TYPE, key.lanes = lanes, key.stateNode = {\n                    effectDuration: 0,\n                    passiveEffectDuration: 0\n                }, key;\n            case REACT_SUSPENSE_TYPE:\n                return key = createFiber(13, pendingProps, key, mode), key.elementType = REACT_SUSPENSE_TYPE, key.lanes = lanes, key;\n            case REACT_SUSPENSE_LIST_TYPE:\n                return key = createFiber(19, pendingProps, key, mode), key.elementType = REACT_SUSPENSE_LIST_TYPE, key.lanes = lanes, key;\n            case REACT_OFFSCREEN_TYPE:\n                return createFiberFromOffscreen(pendingProps, mode, lanes, key);\n            default:\n                if (\"object\" === typeof type && null !== type) switch(type.$$typeof){\n                    case REACT_PROVIDER_TYPE:\n                    case REACT_CONTEXT_TYPE:\n                        fiberTag = 10;\n                        break a;\n                    case REACT_CONSUMER_TYPE:\n                        fiberTag = 9;\n                        break a;\n                    case REACT_FORWARD_REF_TYPE:\n                        fiberTag = 11;\n                        resolvedType = resolveForwardRefForHotReloading(resolvedType);\n                        break a;\n                    case REACT_MEMO_TYPE:\n                        fiberTag = 14;\n                        break a;\n                    case REACT_LAZY_TYPE:\n                        fiberTag = 16;\n                        resolvedType = null;\n                        break a;\n                }\n                resolvedType = \"\";\n                if (void 0 === type || \"object\" === typeof type && null !== type && 0 === Object.keys(type).length) resolvedType += \" You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.\";\n                null === type ? pendingProps = \"null\" : isArrayImpl(type) ? pendingProps = \"array\" : void 0 !== type && type.$$typeof === REACT_ELEMENT_TYPE ? (pendingProps = \"<\" + (getComponentNameFromType(type.type) || \"Unknown\") + \" />\", resolvedType = \" Did you accidentally export a JSX literal instead of a component?\") : pendingProps = typeof type;\n                fiberTag = owner ? \"number\" === typeof owner.tag ? getComponentNameFromFiber(owner) : \"string\" === typeof owner.name ? owner.name : null : null;\n                fiberTag && (resolvedType += \"\\n\\nCheck the render method of `\" + fiberTag + \"`.\");\n                fiberTag = 29;\n                pendingProps = Error(\"Element type is invalid: expected a string (for built-in components) or a class/function (for composite components) but got: \" + (pendingProps + \".\" + resolvedType));\n                resolvedType = null;\n        }\n        key = createFiber(fiberTag, pendingProps, key, mode);\n        key.elementType = type;\n        key.type = resolvedType;\n        key.lanes = lanes;\n        key._debugOwner = owner;\n        return key;\n    }\n    function createFiberFromElement(element, mode, lanes) {\n        mode = createFiberFromTypeAndProps(element.type, element.key, element.props, element._owner, mode, lanes);\n        mode._debugOwner = element._owner;\n        return mode;\n    }\n    function createFiberFromFragment(elements, mode, lanes, key) {\n        elements = createFiber(7, elements, key, mode);\n        elements.lanes = lanes;\n        return elements;\n    }\n    function createFiberFromOffscreen(pendingProps, mode, lanes, key) {\n        pendingProps = createFiber(22, pendingProps, key, mode);\n        pendingProps.elementType = REACT_OFFSCREEN_TYPE;\n        pendingProps.lanes = lanes;\n        var primaryChildInstance = {\n            _visibility: 1,\n            _pendingVisibility: 1,\n            _pendingMarkers: null,\n            _retryCache: null,\n            _transitions: null,\n            _current: null,\n            detach: function() {\n                var instance = primaryChildInstance, fiber = instance._current;\n                if (null === fiber) throw Error(\"Calling Offscreen.detach before instance handle has been set.\");\n                if (0 === (instance._pendingVisibility & 2)) {\n                    var root = enqueueConcurrentRenderForLane(fiber, 2);\n                    null !== root && (instance._pendingVisibility |= 2, scheduleUpdateOnFiber(root, fiber, 2));\n                }\n            },\n            attach: function() {\n                var instance = primaryChildInstance, fiber = instance._current;\n                if (null === fiber) throw Error(\"Calling Offscreen.detach before instance handle has been set.\");\n                if (0 !== (instance._pendingVisibility & 2)) {\n                    var root = enqueueConcurrentRenderForLane(fiber, 2);\n                    null !== root && (instance._pendingVisibility &= -3, scheduleUpdateOnFiber(root, fiber, 2));\n                }\n            }\n        };\n        pendingProps.stateNode = primaryChildInstance;\n        return pendingProps;\n    }\n    function createFiberFromText(content, mode, lanes) {\n        content = createFiber(6, content, null, mode);\n        content.lanes = lanes;\n        return content;\n    }\n    function createFiberFromPortal(portal, mode, lanes) {\n        mode = createFiber(4, null !== portal.children ? portal.children : [], portal.key, mode);\n        mode.lanes = lanes;\n        mode.stateNode = {\n            containerInfo: portal.containerInfo,\n            pendingChildren: null,\n            implementation: portal.implementation\n        };\n        return mode;\n    }\n    function FiberRootNode(containerInfo, tag, hydrate, identifierPrefix, onUncaughtError, onCaughtError, onRecoverableError, formState) {\n        this.tag = 1;\n        this.containerInfo = containerInfo;\n        this.finishedWork = this.pingCache = this.current = this.pendingChildren = null;\n        this.timeoutHandle = noTimeout;\n        this.callbackNode = this.next = this.pendingContext = this.context = this.cancelPendingCommit = null;\n        this.callbackPriority = 0;\n        this.expirationTimes = createLaneMap(-1);\n        this.entangledLanes = this.shellSuspendCounter = this.errorRecoveryDisabledLanes = this.finishedLanes = this.expiredLanes = this.warmLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0;\n        this.entanglements = createLaneMap(0);\n        this.hiddenUpdates = createLaneMap(null);\n        this.identifierPrefix = identifierPrefix;\n        this.onUncaughtError = onUncaughtError;\n        this.onCaughtError = onCaughtError;\n        this.onRecoverableError = onRecoverableError;\n        this.pooledCache = null;\n        this.pooledCacheLanes = 0;\n        this.formState = formState;\n        this.incompleteTransitions = new Map();\n        this.passiveEffectDuration = this.effectDuration = -0;\n        this.memoizedUpdaters = new Set();\n        containerInfo = this.pendingUpdatersLaneMap = [];\n        for(tag = 0; 31 > tag; tag++)containerInfo.push(new Set());\n        this._debugRootType = hydrate ? \"hydrateRoot()\" : \"createRoot()\";\n    }\n    function createFiberRoot(containerInfo, tag, hydrate, initialChildren, hydrationCallbacks, isStrictMode, identifierPrefix, onUncaughtError, onCaughtError, onRecoverableError, transitionCallbacks, formState) {\n        containerInfo = new FiberRootNode(containerInfo, tag, hydrate, identifierPrefix, onUncaughtError, onCaughtError, onRecoverableError, formState);\n        tag = 1;\n        !0 === isStrictMode && (tag |= 24);\n        isDevToolsPresent && (tag |= 2);\n        isStrictMode = createFiber(3, null, null, tag);\n        containerInfo.current = isStrictMode;\n        isStrictMode.stateNode = containerInfo;\n        tag = createCache();\n        retainCache(tag);\n        containerInfo.pooledCache = tag;\n        retainCache(tag);\n        isStrictMode.memoizedState = {\n            element: initialChildren,\n            isDehydrated: hydrate,\n            cache: tag\n        };\n        initializeUpdateQueue(isStrictMode);\n        return containerInfo;\n    }\n    function testStringCoercion(value) {\n        return \"\" + value;\n    }\n    function getContextForSubtree(parentComponent) {\n        if (!parentComponent) return emptyContextObject;\n        parentComponent = emptyContextObject;\n        return parentComponent;\n    }\n    function updateContainerSync(element, container, parentComponent, callback) {\n        0 === container.tag && flushPassiveEffects();\n        updateContainerImpl(container.current, 2, element, container, parentComponent, callback);\n        return 2;\n    }\n    function updateContainerImpl(rootFiber, lane, element, container, parentComponent, callback) {\n        if (injectedHook && \"function\" === typeof injectedHook.onScheduleFiberRoot) try {\n            injectedHook.onScheduleFiberRoot(rendererID, container, element);\n        } catch (err) {\n            hasLoggedError || (hasLoggedError = !0, console.error(\"React instrumentation encountered an error: %s\", err));\n        }\n        null !== injectedProfilingHooks && \"function\" === typeof injectedProfilingHooks.markRenderScheduled && injectedProfilingHooks.markRenderScheduled(lane);\n        parentComponent = getContextForSubtree(parentComponent);\n        null === container.context ? container.context = parentComponent : container.pendingContext = parentComponent;\n        isRendering && null !== current && !didWarnAboutNestedUpdates && (didWarnAboutNestedUpdates = !0, console.error(\"Render methods should be a pure function of props and state; triggering nested component updates from render is not allowed. If necessary, trigger nested updates in componentDidUpdate.\\n\\nCheck the render method of %s.\", getComponentNameFromFiber(current) || \"Unknown\"));\n        container = createUpdate(lane);\n        container.payload = {\n            element: element\n        };\n        callback = void 0 === callback ? null : callback;\n        null !== callback && (\"function\" !== typeof callback && console.error(\"Expected the last optional `callback` argument to be a function. Instead received: %s.\", callback), container.callback = callback);\n        element = enqueueUpdate(rootFiber, container, lane);\n        null !== element && (scheduleUpdateOnFiber(element, rootFiber, lane), entangleTransitions(element, rootFiber, lane));\n    }\n    function markRetryLaneImpl(fiber, retryLane) {\n        fiber = fiber.memoizedState;\n        if (null !== fiber && null !== fiber.dehydrated) {\n            var a = fiber.retryLane;\n            fiber.retryLane = 0 !== a && a < retryLane ? a : retryLane;\n        }\n    }\n    function markRetryLaneIfNotHydrated(fiber, retryLane) {\n        markRetryLaneImpl(fiber, retryLane);\n        (fiber = fiber.alternate) && markRetryLaneImpl(fiber, retryLane);\n    }\n    function getCurrentFiberForDevTools() {\n        return current;\n    }\n    function getLaneLabelMap() {\n        for(var map = new Map(), lane = 1, index = 0; 31 > index; index++){\n            var label = getLabelForLane(lane);\n            map.set(lane, label);\n            lane *= 2;\n        }\n        return map;\n    }\n    var exports = {};\n    \"use strict\";\n    var React = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react.js\"), Scheduler = __webpack_require__(/*! scheduler */ \"(ssr)/./node_modules/react-reconciler/node_modules/scheduler/index.js\"), assign = Object.assign, REACT_LEGACY_ELEMENT_TYPE = Symbol.for(\"react.element\"), REACT_ELEMENT_TYPE = Symbol.for(\"react.transitional.element\"), REACT_PORTAL_TYPE = Symbol.for(\"react.portal\"), REACT_FRAGMENT_TYPE = Symbol.for(\"react.fragment\"), REACT_STRICT_MODE_TYPE = Symbol.for(\"react.strict_mode\"), REACT_PROFILER_TYPE = Symbol.for(\"react.profiler\"), REACT_PROVIDER_TYPE = Symbol.for(\"react.provider\"), REACT_CONSUMER_TYPE = Symbol.for(\"react.consumer\"), REACT_CONTEXT_TYPE = Symbol.for(\"react.context\"), REACT_FORWARD_REF_TYPE = Symbol.for(\"react.forward_ref\"), REACT_SUSPENSE_TYPE = Symbol.for(\"react.suspense\"), REACT_SUSPENSE_LIST_TYPE = Symbol.for(\"react.suspense_list\"), REACT_MEMO_TYPE = Symbol.for(\"react.memo\"), REACT_LAZY_TYPE = Symbol.for(\"react.lazy\");\n    Symbol.for(\"react.scope\");\n    Symbol.for(\"react.debug_trace_mode\");\n    var REACT_OFFSCREEN_TYPE = Symbol.for(\"react.offscreen\");\n    Symbol.for(\"react.legacy_hidden\");\n    Symbol.for(\"react.tracing_marker\");\n    var REACT_MEMO_CACHE_SENTINEL = Symbol.for(\"react.memo_cache_sentinel\"), MAYBE_ITERATOR_SYMBOL = Symbol.iterator, REACT_CLIENT_REFERENCE = Symbol.for(\"react.client.reference\"), ReactSharedInternals = React.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE, disabledDepth = 0, prevLog, prevInfo, prevWarn, prevError, prevGroup, prevGroupCollapsed, prevGroupEnd;\n    disabledLog.__reactDisabledLog = !0;\n    var prefix, suffix, reentry = !1;\n    var componentFrameCache = new (\"function\" === typeof WeakMap ? WeakMap : Map)();\n    var current = null, isRendering = !1, isArrayImpl = Array.isArray, rendererVersion = $$$config.rendererVersion, rendererPackageName = $$$config.rendererPackageName, extraDevToolsConfig = $$$config.extraDevToolsConfig, getPublicInstance = $$$config.getPublicInstance, getRootHostContext = $$$config.getRootHostContext, getChildHostContext = $$$config.getChildHostContext, prepareForCommit = $$$config.prepareForCommit, resetAfterCommit = $$$config.resetAfterCommit, createInstance = $$$config.createInstance, appendInitialChild = $$$config.appendInitialChild, finalizeInitialChildren = $$$config.finalizeInitialChildren, shouldSetTextContent = $$$config.shouldSetTextContent, createTextInstance = $$$config.createTextInstance, scheduleTimeout = $$$config.scheduleTimeout, cancelTimeout = $$$config.cancelTimeout, noTimeout = $$$config.noTimeout, isPrimaryRenderer = $$$config.isPrimaryRenderer;\n    $$$config.warnsIfNotActing;\n    var supportsMutation = $$$config.supportsMutation, supportsPersistence = $$$config.supportsPersistence, supportsHydration = $$$config.supportsHydration, getInstanceFromNode = $$$config.getInstanceFromNode;\n    $$$config.beforeActiveInstanceBlur;\n    $$$config.afterActiveInstanceBlur;\n    var preparePortalMount = $$$config.preparePortalMount;\n    $$$config.prepareScopeUpdate;\n    $$$config.getInstanceFromScope;\n    var setCurrentUpdatePriority = $$$config.setCurrentUpdatePriority, getCurrentUpdatePriority = $$$config.getCurrentUpdatePriority, resolveUpdatePriority = $$$config.resolveUpdatePriority;\n    $$$config.resolveEventType;\n    $$$config.resolveEventTimeStamp;\n    var shouldAttemptEagerTransition = $$$config.shouldAttemptEagerTransition, detachDeletedInstance = $$$config.detachDeletedInstance;\n    $$$config.requestPostPaintCallback;\n    var maySuspendCommit = $$$config.maySuspendCommit, preloadInstance = $$$config.preloadInstance, startSuspendingCommit = $$$config.startSuspendingCommit, suspendInstance = $$$config.suspendInstance, waitForCommitToBeReady = $$$config.waitForCommitToBeReady, NotPendingTransition = $$$config.NotPendingTransition, HostTransitionContext = $$$config.HostTransitionContext, resetFormInstance = $$$config.resetFormInstance, bindToConsole = $$$config.bindToConsole, supportsMicrotasks = $$$config.supportsMicrotasks, scheduleMicrotask = $$$config.scheduleMicrotask, supportsTestSelectors = $$$config.supportsTestSelectors, findFiberRoot = $$$config.findFiberRoot, getBoundingRect = $$$config.getBoundingRect, getTextContent = $$$config.getTextContent, isHiddenSubtree = $$$config.isHiddenSubtree, matchAccessibilityRole = $$$config.matchAccessibilityRole, setFocusIfFocusable = $$$config.setFocusIfFocusable, setupIntersectionObserver = $$$config.setupIntersectionObserver, appendChild = $$$config.appendChild, appendChildToContainer = $$$config.appendChildToContainer, commitTextUpdate = $$$config.commitTextUpdate, commitMount = $$$config.commitMount, commitUpdate = $$$config.commitUpdate, insertBefore = $$$config.insertBefore, insertInContainerBefore = $$$config.insertInContainerBefore, removeChild = $$$config.removeChild, removeChildFromContainer = $$$config.removeChildFromContainer, resetTextContent = $$$config.resetTextContent, hideInstance = $$$config.hideInstance, hideTextInstance = $$$config.hideTextInstance, unhideInstance = $$$config.unhideInstance, unhideTextInstance = $$$config.unhideTextInstance, clearContainer = $$$config.clearContainer, cloneInstance = $$$config.cloneInstance, createContainerChildSet = $$$config.createContainerChildSet, appendChildToContainerChildSet = $$$config.appendChildToContainerChildSet, finalizeContainerChildren = $$$config.finalizeContainerChildren, replaceContainerChildren = $$$config.replaceContainerChildren, cloneHiddenInstance = $$$config.cloneHiddenInstance, cloneHiddenTextInstance = $$$config.cloneHiddenTextInstance, isSuspenseInstancePending = $$$config.isSuspenseInstancePending, isSuspenseInstanceFallback = $$$config.isSuspenseInstanceFallback, getSuspenseInstanceFallbackErrorDetails = $$$config.getSuspenseInstanceFallbackErrorDetails, registerSuspenseInstanceRetry = $$$config.registerSuspenseInstanceRetry, canHydrateFormStateMarker = $$$config.canHydrateFormStateMarker, isFormStateMarkerMatching = $$$config.isFormStateMarkerMatching, getNextHydratableSibling = $$$config.getNextHydratableSibling, getFirstHydratableChild = $$$config.getFirstHydratableChild, getFirstHydratableChildWithinContainer = $$$config.getFirstHydratableChildWithinContainer, getFirstHydratableChildWithinSuspenseInstance = $$$config.getFirstHydratableChildWithinSuspenseInstance, canHydrateInstance = $$$config.canHydrateInstance, canHydrateTextInstance = $$$config.canHydrateTextInstance, canHydrateSuspenseInstance = $$$config.canHydrateSuspenseInstance, hydrateInstance = $$$config.hydrateInstance, hydrateTextInstance = $$$config.hydrateTextInstance, hydrateSuspenseInstance = $$$config.hydrateSuspenseInstance, getNextHydratableInstanceAfterSuspenseInstance = $$$config.getNextHydratableInstanceAfterSuspenseInstance, commitHydratedContainer = $$$config.commitHydratedContainer, commitHydratedSuspenseInstance = $$$config.commitHydratedSuspenseInstance, clearSuspenseBoundary = $$$config.clearSuspenseBoundary, clearSuspenseBoundaryFromContainer = $$$config.clearSuspenseBoundaryFromContainer, shouldDeleteUnhydratedTailInstances = $$$config.shouldDeleteUnhydratedTailInstances, diffHydratedPropsForDevWarnings = $$$config.diffHydratedPropsForDevWarnings, diffHydratedTextForDevWarnings = $$$config.diffHydratedTextForDevWarnings, describeHydratableInstanceForDevWarnings = $$$config.describeHydratableInstanceForDevWarnings, validateHydratableInstance = $$$config.validateHydratableInstance, validateHydratableTextInstance = $$$config.validateHydratableTextInstance, supportsResources = $$$config.supportsResources, isHostHoistableType = $$$config.isHostHoistableType, getHoistableRoot = $$$config.getHoistableRoot, getResource = $$$config.getResource, acquireResource = $$$config.acquireResource, releaseResource = $$$config.releaseResource, hydrateHoistable = $$$config.hydrateHoistable, mountHoistable = $$$config.mountHoistable, unmountHoistable = $$$config.unmountHoistable, createHoistableInstance = $$$config.createHoistableInstance, prepareToCommitHoistables = $$$config.prepareToCommitHoistables, mayResourceSuspendCommit = $$$config.mayResourceSuspendCommit, preloadResource = $$$config.preloadResource, suspendResource = $$$config.suspendResource, supportsSingletons = $$$config.supportsSingletons, resolveSingletonInstance = $$$config.resolveSingletonInstance, clearSingleton = $$$config.clearSingleton, acquireSingletonInstance = $$$config.acquireSingletonInstance, releaseSingletonInstance = $$$config.releaseSingletonInstance, isHostSingletonType = $$$config.isHostSingletonType, valueStack = [];\n    var fiberStack = [];\n    var index$jscomp$0 = -1, emptyContextObject = {};\n    Object.freeze(emptyContextObject);\n    var clz32 = Math.clz32 ? Math.clz32 : clz32Fallback, log$1 = Math.log, LN2 = Math.LN2, nextTransitionLane = 128, nextRetryLane = 4194304, scheduleCallback$3 = Scheduler.unstable_scheduleCallback, cancelCallback$1 = Scheduler.unstable_cancelCallback, shouldYield = Scheduler.unstable_shouldYield, requestPaint = Scheduler.unstable_requestPaint, now$1 = Scheduler.unstable_now, ImmediatePriority = Scheduler.unstable_ImmediatePriority, UserBlockingPriority = Scheduler.unstable_UserBlockingPriority, NormalPriority$1 = Scheduler.unstable_NormalPriority, IdlePriority = Scheduler.unstable_IdlePriority, log = Scheduler.log, unstable_setDisableYieldValue = Scheduler.unstable_setDisableYieldValue, rendererID = null, injectedHook = null, injectedProfilingHooks = null, hasLoggedError = !1, isDevToolsPresent = \"undefined\" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__, objectIs = \"function\" === typeof Object.is ? Object.is : is, CapturedStacks = new WeakMap(), forkStack = [], forkStackIndex = 0, treeForkProvider = null, treeForkCount = 0, idStack = [], idStackIndex = 0, treeContextProvider = null, treeContextId = 1, treeContextOverflow = \"\", contextStackCursor = createCursor(null), contextFiberStackCursor = createCursor(null), rootInstanceStackCursor = createCursor(null), hostTransitionProviderCursor = createCursor(null), needsEscaping = /[\"'&<>\\n\\t]|^\\s|\\s$/, hydrationParentFiber = null, nextHydratableInstance = null, isHydrating = !1, didSuspendOrErrorDEV = !1, hydrationDiffRootDEV = null, hydrationErrors = null, rootOrSingletonContext = !1, HydrationMismatchException = Error(\"Hydration Mismatch Exception: This is not a real error, and should not leak into userspace. If you're seeing this, it's likely a bug in React.\"), NoMode = 0, concurrentQueues = [], concurrentQueuesIndex = 0, concurrentlyUpdatedLanes = 0, now = Scheduler.unstable_now, commitStartTime = -0, profilerStartTime = -1.1, profilerEffectDuration = -0, currentUpdateIsNested = !1, nestedUpdateScheduled = !1, firstScheduledRoot = null, lastScheduledRoot = null, didScheduleMicrotask = !1, didScheduleMicrotask_act = !1, mightHavePendingSyncWork = !1, isFlushingWork = !1, currentEventTransitionLane = 0, fakeActCallbackNode$1 = {}, currentEntangledListeners = null, currentEntangledPendingCount = 0, currentEntangledLane = 0, currentEntangledActionThenable = null, UpdateState = 0, ReplaceState = 1, ForceUpdate = 2, CaptureUpdate = 3, hasForceUpdate = !1;\n    var didWarnUpdateInsideUpdate = !1;\n    var currentlyProcessingQueue = null;\n    var didReadFromEntangledAsyncAction = !1, hasOwnProperty = Object.prototype.hasOwnProperty, ReactStrictModeWarnings = {\n        recordUnsafeLifecycleWarnings: function() {},\n        flushPendingUnsafeLifecycleWarnings: function() {},\n        recordLegacyContextWarning: function() {},\n        flushLegacyContextWarning: function() {},\n        discardPendingWarnings: function() {}\n    }, pendingComponentWillMountWarnings = [], pendingUNSAFE_ComponentWillMountWarnings = [], pendingComponentWillReceivePropsWarnings = [], pendingUNSAFE_ComponentWillReceivePropsWarnings = [], pendingComponentWillUpdateWarnings = [], pendingUNSAFE_ComponentWillUpdateWarnings = [], didWarnAboutUnsafeLifecycles = new Set();\n    ReactStrictModeWarnings.recordUnsafeLifecycleWarnings = function(fiber, instance) {\n        didWarnAboutUnsafeLifecycles.has(fiber.type) || (\"function\" === typeof instance.componentWillMount && !0 !== instance.componentWillMount.__suppressDeprecationWarning && pendingComponentWillMountWarnings.push(fiber), fiber.mode & 8 && \"function\" === typeof instance.UNSAFE_componentWillMount && pendingUNSAFE_ComponentWillMountWarnings.push(fiber), \"function\" === typeof instance.componentWillReceiveProps && !0 !== instance.componentWillReceiveProps.__suppressDeprecationWarning && pendingComponentWillReceivePropsWarnings.push(fiber), fiber.mode & 8 && \"function\" === typeof instance.UNSAFE_componentWillReceiveProps && pendingUNSAFE_ComponentWillReceivePropsWarnings.push(fiber), \"function\" === typeof instance.componentWillUpdate && !0 !== instance.componentWillUpdate.__suppressDeprecationWarning && pendingComponentWillUpdateWarnings.push(fiber), fiber.mode & 8 && \"function\" === typeof instance.UNSAFE_componentWillUpdate && pendingUNSAFE_ComponentWillUpdateWarnings.push(fiber));\n    };\n    ReactStrictModeWarnings.flushPendingUnsafeLifecycleWarnings = function() {\n        var componentWillMountUniqueNames = new Set();\n        0 < pendingComponentWillMountWarnings.length && (pendingComponentWillMountWarnings.forEach(function(fiber) {\n            componentWillMountUniqueNames.add(getComponentNameFromFiber(fiber) || \"Component\");\n            didWarnAboutUnsafeLifecycles.add(fiber.type);\n        }), pendingComponentWillMountWarnings = []);\n        var UNSAFE_componentWillMountUniqueNames = new Set();\n        0 < pendingUNSAFE_ComponentWillMountWarnings.length && (pendingUNSAFE_ComponentWillMountWarnings.forEach(function(fiber) {\n            UNSAFE_componentWillMountUniqueNames.add(getComponentNameFromFiber(fiber) || \"Component\");\n            didWarnAboutUnsafeLifecycles.add(fiber.type);\n        }), pendingUNSAFE_ComponentWillMountWarnings = []);\n        var componentWillReceivePropsUniqueNames = new Set();\n        0 < pendingComponentWillReceivePropsWarnings.length && (pendingComponentWillReceivePropsWarnings.forEach(function(fiber) {\n            componentWillReceivePropsUniqueNames.add(getComponentNameFromFiber(fiber) || \"Component\");\n            didWarnAboutUnsafeLifecycles.add(fiber.type);\n        }), pendingComponentWillReceivePropsWarnings = []);\n        var UNSAFE_componentWillReceivePropsUniqueNames = new Set();\n        0 < pendingUNSAFE_ComponentWillReceivePropsWarnings.length && (pendingUNSAFE_ComponentWillReceivePropsWarnings.forEach(function(fiber) {\n            UNSAFE_componentWillReceivePropsUniqueNames.add(getComponentNameFromFiber(fiber) || \"Component\");\n            didWarnAboutUnsafeLifecycles.add(fiber.type);\n        }), pendingUNSAFE_ComponentWillReceivePropsWarnings = []);\n        var componentWillUpdateUniqueNames = new Set();\n        0 < pendingComponentWillUpdateWarnings.length && (pendingComponentWillUpdateWarnings.forEach(function(fiber) {\n            componentWillUpdateUniqueNames.add(getComponentNameFromFiber(fiber) || \"Component\");\n            didWarnAboutUnsafeLifecycles.add(fiber.type);\n        }), pendingComponentWillUpdateWarnings = []);\n        var UNSAFE_componentWillUpdateUniqueNames = new Set();\n        0 < pendingUNSAFE_ComponentWillUpdateWarnings.length && (pendingUNSAFE_ComponentWillUpdateWarnings.forEach(function(fiber) {\n            UNSAFE_componentWillUpdateUniqueNames.add(getComponentNameFromFiber(fiber) || \"Component\");\n            didWarnAboutUnsafeLifecycles.add(fiber.type);\n        }), pendingUNSAFE_ComponentWillUpdateWarnings = []);\n        if (0 < UNSAFE_componentWillMountUniqueNames.size) {\n            var sortedNames = setToSortedString(UNSAFE_componentWillMountUniqueNames);\n            console.error(\"Using UNSAFE_componentWillMount in strict mode is not recommended and may indicate bugs in your code. See https://react.dev/link/unsafe-component-lifecycles for details.\\n\\n* Move code with side effects to componentDidMount, and set initial state in the constructor.\\n\\nPlease update the following components: %s\", sortedNames);\n        }\n        0 < UNSAFE_componentWillReceivePropsUniqueNames.size && (sortedNames = setToSortedString(UNSAFE_componentWillReceivePropsUniqueNames), console.error(\"Using UNSAFE_componentWillReceiveProps in strict mode is not recommended and may indicate bugs in your code. See https://react.dev/link/unsafe-component-lifecycles for details.\\n\\n* Move data fetching code or side effects to componentDidUpdate.\\n* If you're updating state whenever props change, refactor your code to use memoization techniques or move it to static getDerivedStateFromProps. Learn more at: https://react.dev/link/derived-state\\n\\nPlease update the following components: %s\", sortedNames));\n        0 < UNSAFE_componentWillUpdateUniqueNames.size && (sortedNames = setToSortedString(UNSAFE_componentWillUpdateUniqueNames), console.error(\"Using UNSAFE_componentWillUpdate in strict mode is not recommended and may indicate bugs in your code. See https://react.dev/link/unsafe-component-lifecycles for details.\\n\\n* Move data fetching code or side effects to componentDidUpdate.\\n\\nPlease update the following components: %s\", sortedNames));\n        0 < componentWillMountUniqueNames.size && (sortedNames = setToSortedString(componentWillMountUniqueNames), console.warn(\"componentWillMount has been renamed, and is not recommended for use. See https://react.dev/link/unsafe-component-lifecycles for details.\\n\\n* Move code with side effects to componentDidMount, and set initial state in the constructor.\\n* Rename componentWillMount to UNSAFE_componentWillMount to suppress this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. To rename all deprecated lifecycles to their new names, you can run `npx react-codemod rename-unsafe-lifecycles` in your project source folder.\\n\\nPlease update the following components: %s\", sortedNames));\n        0 < componentWillReceivePropsUniqueNames.size && (sortedNames = setToSortedString(componentWillReceivePropsUniqueNames), console.warn(\"componentWillReceiveProps has been renamed, and is not recommended for use. See https://react.dev/link/unsafe-component-lifecycles for details.\\n\\n* Move data fetching code or side effects to componentDidUpdate.\\n* If you're updating state whenever props change, refactor your code to use memoization techniques or move it to static getDerivedStateFromProps. Learn more at: https://react.dev/link/derived-state\\n* Rename componentWillReceiveProps to UNSAFE_componentWillReceiveProps to suppress this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. To rename all deprecated lifecycles to their new names, you can run `npx react-codemod rename-unsafe-lifecycles` in your project source folder.\\n\\nPlease update the following components: %s\", sortedNames));\n        0 < componentWillUpdateUniqueNames.size && (sortedNames = setToSortedString(componentWillUpdateUniqueNames), console.warn(\"componentWillUpdate has been renamed, and is not recommended for use. See https://react.dev/link/unsafe-component-lifecycles for details.\\n\\n* Move data fetching code or side effects to componentDidUpdate.\\n* Rename componentWillUpdate to UNSAFE_componentWillUpdate to suppress this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. To rename all deprecated lifecycles to their new names, you can run `npx react-codemod rename-unsafe-lifecycles` in your project source folder.\\n\\nPlease update the following components: %s\", sortedNames));\n    };\n    var pendingLegacyContextWarning = new Map(), didWarnAboutLegacyContext = new Set();\n    ReactStrictModeWarnings.recordLegacyContextWarning = function(fiber, instance) {\n        var strictRoot = null;\n        for(var node = fiber; null !== node;)node.mode & 8 && (strictRoot = node), node = node.return;\n        null === strictRoot ? console.error(\"Expected to find a StrictMode component in a strict mode tree. This error is likely caused by a bug in React. Please file an issue.\") : !didWarnAboutLegacyContext.has(fiber.type) && (node = pendingLegacyContextWarning.get(strictRoot), null != fiber.type.contextTypes || null != fiber.type.childContextTypes || null !== instance && \"function\" === typeof instance.getChildContext) && (void 0 === node && (node = [], pendingLegacyContextWarning.set(strictRoot, node)), node.push(fiber));\n    };\n    ReactStrictModeWarnings.flushLegacyContextWarning = function() {\n        pendingLegacyContextWarning.forEach(function(fiberArray) {\n            if (0 !== fiberArray.length) {\n                var firstFiber = fiberArray[0], uniqueNames = new Set();\n                fiberArray.forEach(function(fiber) {\n                    uniqueNames.add(getComponentNameFromFiber(fiber) || \"Component\");\n                    didWarnAboutLegacyContext.add(fiber.type);\n                });\n                var sortedNames = setToSortedString(uniqueNames);\n                runWithFiberInDEV(firstFiber, function() {\n                    console.error(\"Legacy context API has been detected within a strict-mode tree.\\n\\nThe old API will be supported in all 16.x releases, but applications using it should migrate to the new version.\\n\\nPlease update the following components: %s\\n\\nLearn more about this warning here: https://react.dev/link/legacy-context\", sortedNames);\n                });\n            }\n        });\n    };\n    ReactStrictModeWarnings.discardPendingWarnings = function() {\n        pendingComponentWillMountWarnings = [];\n        pendingUNSAFE_ComponentWillMountWarnings = [];\n        pendingComponentWillReceivePropsWarnings = [];\n        pendingUNSAFE_ComponentWillReceivePropsWarnings = [];\n        pendingComponentWillUpdateWarnings = [];\n        pendingUNSAFE_ComponentWillUpdateWarnings = [];\n        pendingLegacyContextWarning = new Map();\n    };\n    var SuspenseException = Error(\"Suspense Exception: This is not a real error! It's an implementation detail of `use` to interrupt the current render. You must either rethrow it immediately, or move the `use` call outside of the `try/catch` block. Capturing without rethrowing will lead to unexpected behavior.\\n\\nTo handle async errors, wrap your component in an error boundary, or call the promise's `.catch` method and pass the result to `use`\"), SuspenseyCommitException = Error(\"Suspense Exception: This is not a real error, and should not leak into userspace. If you're seeing this, it's likely a bug in React.\"), noopSuspenseyCommitThenable = {\n        then: function() {\n            console.error('Internal React error: A listener was unexpectedly attached to a \"noop\" thenable. This is a bug in React. Please file an issue.');\n        }\n    }, suspendedThenable = null, needsToResetSuspendedThenableDEV = !1, callComponent = {\n        \"react-stack-bottom-frame\": function(Component, props, secondArg) {\n            var wasRendering = isRendering;\n            isRendering = !0;\n            try {\n                return Component(props, secondArg);\n            } finally{\n                isRendering = wasRendering;\n            }\n        }\n    }, callComponentInDEV = callComponent[\"react-stack-bottom-frame\"].bind(callComponent), callRender = {\n        \"react-stack-bottom-frame\": function(instance) {\n            var wasRendering = isRendering;\n            isRendering = !0;\n            try {\n                return instance.render();\n            } finally{\n                isRendering = wasRendering;\n            }\n        }\n    }, callRenderInDEV = callRender[\"react-stack-bottom-frame\"].bind(callRender), callComponentDidMount = {\n        \"react-stack-bottom-frame\": function(finishedWork, instance) {\n            try {\n                instance.componentDidMount();\n            } catch (error) {\n                captureCommitPhaseError(finishedWork, finishedWork.return, error);\n            }\n        }\n    }, callComponentDidMountInDEV = callComponentDidMount[\"react-stack-bottom-frame\"].bind(callComponentDidMount), callComponentDidUpdate = {\n        \"react-stack-bottom-frame\": function(finishedWork, instance, prevProps, prevState, snapshot) {\n            try {\n                instance.componentDidUpdate(prevProps, prevState, snapshot);\n            } catch (error) {\n                captureCommitPhaseError(finishedWork, finishedWork.return, error);\n            }\n        }\n    }, callComponentDidUpdateInDEV = callComponentDidUpdate[\"react-stack-bottom-frame\"].bind(callComponentDidUpdate), callComponentDidCatch = {\n        \"react-stack-bottom-frame\": function(instance, errorInfo) {\n            var stack = errorInfo.stack;\n            instance.componentDidCatch(errorInfo.value, {\n                componentStack: null !== stack ? stack : \"\"\n            });\n        }\n    }, callComponentDidCatchInDEV = callComponentDidCatch[\"react-stack-bottom-frame\"].bind(callComponentDidCatch), callComponentWillUnmount = {\n        \"react-stack-bottom-frame\": function(current, nearestMountedAncestor, instance) {\n            try {\n                instance.componentWillUnmount();\n            } catch (error) {\n                captureCommitPhaseError(current, nearestMountedAncestor, error);\n            }\n        }\n    }, callComponentWillUnmountInDEV = callComponentWillUnmount[\"react-stack-bottom-frame\"].bind(callComponentWillUnmount), callCreate = {\n        \"react-stack-bottom-frame\": function(effect) {\n            var create = effect.create;\n            effect = effect.inst;\n            create = create();\n            return effect.destroy = create;\n        }\n    }, callCreateInDEV = callCreate[\"react-stack-bottom-frame\"].bind(callCreate), callDestroy = {\n        \"react-stack-bottom-frame\": function(current, nearestMountedAncestor, destroy) {\n            try {\n                destroy();\n            } catch (error) {\n                captureCommitPhaseError(current, nearestMountedAncestor, error);\n            }\n        }\n    }, callDestroyInDEV = callDestroy[\"react-stack-bottom-frame\"].bind(callDestroy), callLazyInit = {\n        \"react-stack-bottom-frame\": function(lazy) {\n            var init = lazy._init;\n            return init(lazy._payload);\n        }\n    }, callLazyInitInDEV = callLazyInit[\"react-stack-bottom-frame\"].bind(callLazyInit), thenableState$1 = null, thenableIndexCounter$1 = 0, currentDebugInfo = null, didWarnAboutMaps;\n    var didWarnAboutGenerators = didWarnAboutMaps = !1;\n    var ownerHasKeyUseWarning = {};\n    var ownerHasFunctionTypeWarning = {};\n    var ownerHasSymbolTypeWarning = {};\n    warnForMissingKey = function(returnFiber, workInProgress, child) {\n        if (null !== child && \"object\" === typeof child && child._store && (!child._store.validated && null == child.key || 2 === child._store.validated)) {\n            if (\"object\" !== typeof child._store) throw Error(\"React Component in warnForMissingKey should have a _store. This error is likely caused by a bug in React. Please file an issue.\");\n            child._store.validated = 1;\n            var componentName = getComponentNameFromFiber(returnFiber), componentKey = componentName || \"null\";\n            if (!ownerHasKeyUseWarning[componentKey]) {\n                ownerHasKeyUseWarning[componentKey] = !0;\n                child = child._owner;\n                returnFiber = returnFiber._debugOwner;\n                var currentComponentErrorInfo = \"\";\n                returnFiber && \"number\" === typeof returnFiber.tag && (componentKey = getComponentNameFromFiber(returnFiber)) && (currentComponentErrorInfo = \"\\n\\nCheck the render method of `\" + componentKey + \"`.\");\n                currentComponentErrorInfo || componentName && (currentComponentErrorInfo = \"\\n\\nCheck the top-level render call using <\" + componentName + \">.\");\n                var childOwnerAppendix = \"\";\n                null != child && returnFiber !== child && (componentName = null, \"number\" === typeof child.tag ? componentName = getComponentNameFromFiber(child) : \"string\" === typeof child.name && (componentName = child.name), componentName && (childOwnerAppendix = \" It was passed a child from \" + componentName + \".\"));\n                runWithFiberInDEV(workInProgress, function() {\n                    console.error('Each child in a list should have a unique \"key\" prop.%s%s See https://react.dev/link/warning-keys for more information.', currentComponentErrorInfo, childOwnerAppendix);\n                });\n            }\n        }\n    };\n    var reconcileChildFibers = createChildReconciler(!0), mountChildFibers = createChildReconciler(!1), currentTreeHiddenStackCursor = createCursor(null), prevEntangledRenderLanesCursor = createCursor(0), suspenseHandlerStackCursor = createCursor(null), shellBoundary = null, SubtreeSuspenseContextMask = 1, ForceSuspenseFallback = 2, suspenseStackCursor = createCursor(0), NoFlags = 0, HasEffect = 1, Insertion = 2, Layout = 4, Passive = 8, didWarnUncachedGetSnapshot;\n    var didWarnAboutMismatchedHooksForComponent = new Set();\n    var didWarnAboutUseWrappedInTryCatch = new Set();\n    var didWarnAboutAsyncClientComponent = new Set();\n    var didWarnAboutUseFormState = new Set();\n    var renderLanes = 0, currentlyRenderingFiber$1 = null, currentHook = null, workInProgressHook = null, didScheduleRenderPhaseUpdate = !1, didScheduleRenderPhaseUpdateDuringThisPass = !1, shouldDoubleInvokeUserFnsInHooksDEV = !1, localIdCounter = 0, thenableIndexCounter = 0, thenableState = null, globalClientIdCounter = 0, RE_RENDER_LIMIT = 25, currentHookNameInDev = null, hookTypesDev = null, hookTypesUpdateIndexDev = -1, ignorePreviousDependencies = !1;\n    var createFunctionComponentUpdateQueue = function() {\n        return {\n            lastEffect: null,\n            events: null,\n            stores: null,\n            memoCache: null\n        };\n    };\n    var ContextOnlyDispatcher = {\n        readContext: readContext,\n        use: use,\n        useCallback: throwInvalidHookError,\n        useContext: throwInvalidHookError,\n        useEffect: throwInvalidHookError,\n        useImperativeHandle: throwInvalidHookError,\n        useLayoutEffect: throwInvalidHookError,\n        useInsertionEffect: throwInvalidHookError,\n        useMemo: throwInvalidHookError,\n        useReducer: throwInvalidHookError,\n        useRef: throwInvalidHookError,\n        useState: throwInvalidHookError,\n        useDebugValue: throwInvalidHookError,\n        useDeferredValue: throwInvalidHookError,\n        useTransition: throwInvalidHookError,\n        useSyncExternalStore: throwInvalidHookError,\n        useId: throwInvalidHookError\n    };\n    ContextOnlyDispatcher.useCacheRefresh = throwInvalidHookError;\n    ContextOnlyDispatcher.useMemoCache = throwInvalidHookError;\n    ContextOnlyDispatcher.useHostTransitionStatus = throwInvalidHookError;\n    ContextOnlyDispatcher.useFormState = throwInvalidHookError;\n    ContextOnlyDispatcher.useActionState = throwInvalidHookError;\n    ContextOnlyDispatcher.useOptimistic = throwInvalidHookError;\n    var HooksDispatcherOnMountInDEV = null, HooksDispatcherOnMountWithHookTypesInDEV = null, HooksDispatcherOnUpdateInDEV = null, HooksDispatcherOnRerenderInDEV = null, InvalidNestedHooksDispatcherOnMountInDEV = null, InvalidNestedHooksDispatcherOnUpdateInDEV = null, InvalidNestedHooksDispatcherOnRerenderInDEV = null;\n    HooksDispatcherOnMountInDEV = {\n        readContext: function(context) {\n            return readContext(context);\n        },\n        use: use,\n        useCallback: function(callback, deps) {\n            currentHookNameInDev = \"useCallback\";\n            mountHookTypesDev();\n            checkDepsAreArrayDev(deps);\n            return mountCallback(callback, deps);\n        },\n        useContext: function(context) {\n            currentHookNameInDev = \"useContext\";\n            mountHookTypesDev();\n            return readContext(context);\n        },\n        useEffect: function(create, deps) {\n            currentHookNameInDev = \"useEffect\";\n            mountHookTypesDev();\n            checkDepsAreArrayDev(deps);\n            return mountEffect(create, deps);\n        },\n        useImperativeHandle: function(ref, create, deps) {\n            currentHookNameInDev = \"useImperativeHandle\";\n            mountHookTypesDev();\n            checkDepsAreArrayDev(deps);\n            return mountImperativeHandle(ref, create, deps);\n        },\n        useInsertionEffect: function(create, deps) {\n            currentHookNameInDev = \"useInsertionEffect\";\n            mountHookTypesDev();\n            checkDepsAreArrayDev(deps);\n            mountEffectImpl(4, Insertion, create, deps);\n        },\n        useLayoutEffect: function(create, deps) {\n            currentHookNameInDev = \"useLayoutEffect\";\n            mountHookTypesDev();\n            checkDepsAreArrayDev(deps);\n            return mountLayoutEffect(create, deps);\n        },\n        useMemo: function(create, deps) {\n            currentHookNameInDev = \"useMemo\";\n            mountHookTypesDev();\n            checkDepsAreArrayDev(deps);\n            var prevDispatcher = ReactSharedInternals.H;\n            ReactSharedInternals.H = InvalidNestedHooksDispatcherOnMountInDEV;\n            try {\n                return mountMemo(create, deps);\n            } finally{\n                ReactSharedInternals.H = prevDispatcher;\n            }\n        },\n        useReducer: function(reducer, initialArg, init) {\n            currentHookNameInDev = \"useReducer\";\n            mountHookTypesDev();\n            var prevDispatcher = ReactSharedInternals.H;\n            ReactSharedInternals.H = InvalidNestedHooksDispatcherOnMountInDEV;\n            try {\n                return mountReducer(reducer, initialArg, init);\n            } finally{\n                ReactSharedInternals.H = prevDispatcher;\n            }\n        },\n        useRef: function(initialValue) {\n            currentHookNameInDev = \"useRef\";\n            mountHookTypesDev();\n            return mountRef(initialValue);\n        },\n        useState: function(initialState) {\n            currentHookNameInDev = \"useState\";\n            mountHookTypesDev();\n            var prevDispatcher = ReactSharedInternals.H;\n            ReactSharedInternals.H = InvalidNestedHooksDispatcherOnMountInDEV;\n            try {\n                return mountState(initialState);\n            } finally{\n                ReactSharedInternals.H = prevDispatcher;\n            }\n        },\n        useDebugValue: function() {\n            currentHookNameInDev = \"useDebugValue\";\n            mountHookTypesDev();\n        },\n        useDeferredValue: function(value, initialValue) {\n            currentHookNameInDev = \"useDeferredValue\";\n            mountHookTypesDev();\n            return mountDeferredValue(value, initialValue);\n        },\n        useTransition: function() {\n            currentHookNameInDev = \"useTransition\";\n            mountHookTypesDev();\n            return mountTransition();\n        },\n        useSyncExternalStore: function(subscribe, getSnapshot, getServerSnapshot) {\n            currentHookNameInDev = \"useSyncExternalStore\";\n            mountHookTypesDev();\n            return mountSyncExternalStore(subscribe, getSnapshot, getServerSnapshot);\n        },\n        useId: function() {\n            currentHookNameInDev = \"useId\";\n            mountHookTypesDev();\n            return mountId();\n        },\n        useCacheRefresh: function() {\n            currentHookNameInDev = \"useCacheRefresh\";\n            mountHookTypesDev();\n            return mountRefresh();\n        }\n    };\n    HooksDispatcherOnMountInDEV.useMemoCache = useMemoCache;\n    HooksDispatcherOnMountInDEV.useHostTransitionStatus = useHostTransitionStatus;\n    HooksDispatcherOnMountInDEV.useFormState = function(action, initialState) {\n        currentHookNameInDev = \"useFormState\";\n        mountHookTypesDev();\n        warnOnUseFormStateInDev();\n        return mountActionState(action, initialState);\n    };\n    HooksDispatcherOnMountInDEV.useActionState = function(action, initialState) {\n        currentHookNameInDev = \"useActionState\";\n        mountHookTypesDev();\n        return mountActionState(action, initialState);\n    };\n    HooksDispatcherOnMountInDEV.useOptimistic = function(passthrough) {\n        currentHookNameInDev = \"useOptimistic\";\n        mountHookTypesDev();\n        return mountOptimistic(passthrough);\n    };\n    HooksDispatcherOnMountWithHookTypesInDEV = {\n        readContext: function(context) {\n            return readContext(context);\n        },\n        use: use,\n        useCallback: function(callback, deps) {\n            currentHookNameInDev = \"useCallback\";\n            updateHookTypesDev();\n            return mountCallback(callback, deps);\n        },\n        useContext: function(context) {\n            currentHookNameInDev = \"useContext\";\n            updateHookTypesDev();\n            return readContext(context);\n        },\n        useEffect: function(create, deps) {\n            currentHookNameInDev = \"useEffect\";\n            updateHookTypesDev();\n            return mountEffect(create, deps);\n        },\n        useImperativeHandle: function(ref, create, deps) {\n            currentHookNameInDev = \"useImperativeHandle\";\n            updateHookTypesDev();\n            return mountImperativeHandle(ref, create, deps);\n        },\n        useInsertionEffect: function(create, deps) {\n            currentHookNameInDev = \"useInsertionEffect\";\n            updateHookTypesDev();\n            mountEffectImpl(4, Insertion, create, deps);\n        },\n        useLayoutEffect: function(create, deps) {\n            currentHookNameInDev = \"useLayoutEffect\";\n            updateHookTypesDev();\n            return mountLayoutEffect(create, deps);\n        },\n        useMemo: function(create, deps) {\n            currentHookNameInDev = \"useMemo\";\n            updateHookTypesDev();\n            var prevDispatcher = ReactSharedInternals.H;\n            ReactSharedInternals.H = InvalidNestedHooksDispatcherOnMountInDEV;\n            try {\n                return mountMemo(create, deps);\n            } finally{\n                ReactSharedInternals.H = prevDispatcher;\n            }\n        },\n        useReducer: function(reducer, initialArg, init) {\n            currentHookNameInDev = \"useReducer\";\n            updateHookTypesDev();\n            var prevDispatcher = ReactSharedInternals.H;\n            ReactSharedInternals.H = InvalidNestedHooksDispatcherOnMountInDEV;\n            try {\n                return mountReducer(reducer, initialArg, init);\n            } finally{\n                ReactSharedInternals.H = prevDispatcher;\n            }\n        },\n        useRef: function(initialValue) {\n            currentHookNameInDev = \"useRef\";\n            updateHookTypesDev();\n            return mountRef(initialValue);\n        },\n        useState: function(initialState) {\n            currentHookNameInDev = \"useState\";\n            updateHookTypesDev();\n            var prevDispatcher = ReactSharedInternals.H;\n            ReactSharedInternals.H = InvalidNestedHooksDispatcherOnMountInDEV;\n            try {\n                return mountState(initialState);\n            } finally{\n                ReactSharedInternals.H = prevDispatcher;\n            }\n        },\n        useDebugValue: function() {\n            currentHookNameInDev = \"useDebugValue\";\n            updateHookTypesDev();\n        },\n        useDeferredValue: function(value, initialValue) {\n            currentHookNameInDev = \"useDeferredValue\";\n            updateHookTypesDev();\n            return mountDeferredValue(value, initialValue);\n        },\n        useTransition: function() {\n            currentHookNameInDev = \"useTransition\";\n            updateHookTypesDev();\n            return mountTransition();\n        },\n        useSyncExternalStore: function(subscribe, getSnapshot, getServerSnapshot) {\n            currentHookNameInDev = \"useSyncExternalStore\";\n            updateHookTypesDev();\n            return mountSyncExternalStore(subscribe, getSnapshot, getServerSnapshot);\n        },\n        useId: function() {\n            currentHookNameInDev = \"useId\";\n            updateHookTypesDev();\n            return mountId();\n        },\n        useCacheRefresh: function() {\n            currentHookNameInDev = \"useCacheRefresh\";\n            updateHookTypesDev();\n            return mountRefresh();\n        }\n    };\n    HooksDispatcherOnMountWithHookTypesInDEV.useMemoCache = useMemoCache;\n    HooksDispatcherOnMountWithHookTypesInDEV.useHostTransitionStatus = useHostTransitionStatus;\n    HooksDispatcherOnMountWithHookTypesInDEV.useFormState = function(action, initialState) {\n        currentHookNameInDev = \"useFormState\";\n        updateHookTypesDev();\n        warnOnUseFormStateInDev();\n        return mountActionState(action, initialState);\n    };\n    HooksDispatcherOnMountWithHookTypesInDEV.useActionState = function(action, initialState) {\n        currentHookNameInDev = \"useActionState\";\n        updateHookTypesDev();\n        return mountActionState(action, initialState);\n    };\n    HooksDispatcherOnMountWithHookTypesInDEV.useOptimistic = function(passthrough) {\n        currentHookNameInDev = \"useOptimistic\";\n        updateHookTypesDev();\n        return mountOptimistic(passthrough);\n    };\n    HooksDispatcherOnUpdateInDEV = {\n        readContext: function(context) {\n            return readContext(context);\n        },\n        use: use,\n        useCallback: function(callback, deps) {\n            currentHookNameInDev = \"useCallback\";\n            updateHookTypesDev();\n            return updateCallback(callback, deps);\n        },\n        useContext: function(context) {\n            currentHookNameInDev = \"useContext\";\n            updateHookTypesDev();\n            return readContext(context);\n        },\n        useEffect: function(create, deps) {\n            currentHookNameInDev = \"useEffect\";\n            updateHookTypesDev();\n            updateEffectImpl(2048, Passive, create, deps);\n        },\n        useImperativeHandle: function(ref, create, deps) {\n            currentHookNameInDev = \"useImperativeHandle\";\n            updateHookTypesDev();\n            return updateImperativeHandle(ref, create, deps);\n        },\n        useInsertionEffect: function(create, deps) {\n            currentHookNameInDev = \"useInsertionEffect\";\n            updateHookTypesDev();\n            return updateEffectImpl(4, Insertion, create, deps);\n        },\n        useLayoutEffect: function(create, deps) {\n            currentHookNameInDev = \"useLayoutEffect\";\n            updateHookTypesDev();\n            return updateEffectImpl(4, Layout, create, deps);\n        },\n        useMemo: function(create, deps) {\n            currentHookNameInDev = \"useMemo\";\n            updateHookTypesDev();\n            var prevDispatcher = ReactSharedInternals.H;\n            ReactSharedInternals.H = InvalidNestedHooksDispatcherOnUpdateInDEV;\n            try {\n                return updateMemo(create, deps);\n            } finally{\n                ReactSharedInternals.H = prevDispatcher;\n            }\n        },\n        useReducer: function(reducer, initialArg, init) {\n            currentHookNameInDev = \"useReducer\";\n            updateHookTypesDev();\n            var prevDispatcher = ReactSharedInternals.H;\n            ReactSharedInternals.H = InvalidNestedHooksDispatcherOnUpdateInDEV;\n            try {\n                return updateReducer(reducer, initialArg, init);\n            } finally{\n                ReactSharedInternals.H = prevDispatcher;\n            }\n        },\n        useRef: function() {\n            currentHookNameInDev = \"useRef\";\n            updateHookTypesDev();\n            return updateWorkInProgressHook().memoizedState;\n        },\n        useState: function() {\n            currentHookNameInDev = \"useState\";\n            updateHookTypesDev();\n            var prevDispatcher = ReactSharedInternals.H;\n            ReactSharedInternals.H = InvalidNestedHooksDispatcherOnUpdateInDEV;\n            try {\n                return updateReducer(basicStateReducer);\n            } finally{\n                ReactSharedInternals.H = prevDispatcher;\n            }\n        },\n        useDebugValue: function() {\n            currentHookNameInDev = \"useDebugValue\";\n            updateHookTypesDev();\n        },\n        useDeferredValue: function(value, initialValue) {\n            currentHookNameInDev = \"useDeferredValue\";\n            updateHookTypesDev();\n            return updateDeferredValue(value, initialValue);\n        },\n        useTransition: function() {\n            currentHookNameInDev = \"useTransition\";\n            updateHookTypesDev();\n            return updateTransition();\n        },\n        useSyncExternalStore: function(subscribe, getSnapshot, getServerSnapshot) {\n            currentHookNameInDev = \"useSyncExternalStore\";\n            updateHookTypesDev();\n            return updateSyncExternalStore(subscribe, getSnapshot, getServerSnapshot);\n        },\n        useId: function() {\n            currentHookNameInDev = \"useId\";\n            updateHookTypesDev();\n            return updateWorkInProgressHook().memoizedState;\n        },\n        useCacheRefresh: function() {\n            currentHookNameInDev = \"useCacheRefresh\";\n            updateHookTypesDev();\n            return updateWorkInProgressHook().memoizedState;\n        }\n    };\n    HooksDispatcherOnUpdateInDEV.useMemoCache = useMemoCache;\n    HooksDispatcherOnUpdateInDEV.useHostTransitionStatus = useHostTransitionStatus;\n    HooksDispatcherOnUpdateInDEV.useFormState = function(action) {\n        currentHookNameInDev = \"useFormState\";\n        updateHookTypesDev();\n        warnOnUseFormStateInDev();\n        return updateActionState(action);\n    };\n    HooksDispatcherOnUpdateInDEV.useActionState = function(action) {\n        currentHookNameInDev = \"useActionState\";\n        updateHookTypesDev();\n        return updateActionState(action);\n    };\n    HooksDispatcherOnUpdateInDEV.useOptimistic = function(passthrough, reducer) {\n        currentHookNameInDev = \"useOptimistic\";\n        updateHookTypesDev();\n        return updateOptimistic(passthrough, reducer);\n    };\n    HooksDispatcherOnRerenderInDEV = {\n        readContext: function(context) {\n            return readContext(context);\n        },\n        use: use,\n        useCallback: function(callback, deps) {\n            currentHookNameInDev = \"useCallback\";\n            updateHookTypesDev();\n            return updateCallback(callback, deps);\n        },\n        useContext: function(context) {\n            currentHookNameInDev = \"useContext\";\n            updateHookTypesDev();\n            return readContext(context);\n        },\n        useEffect: function(create, deps) {\n            currentHookNameInDev = \"useEffect\";\n            updateHookTypesDev();\n            updateEffectImpl(2048, Passive, create, deps);\n        },\n        useImperativeHandle: function(ref, create, deps) {\n            currentHookNameInDev = \"useImperativeHandle\";\n            updateHookTypesDev();\n            return updateImperativeHandle(ref, create, deps);\n        },\n        useInsertionEffect: function(create, deps) {\n            currentHookNameInDev = \"useInsertionEffect\";\n            updateHookTypesDev();\n            return updateEffectImpl(4, Insertion, create, deps);\n        },\n        useLayoutEffect: function(create, deps) {\n            currentHookNameInDev = \"useLayoutEffect\";\n            updateHookTypesDev();\n            return updateEffectImpl(4, Layout, create, deps);\n        },\n        useMemo: function(create, deps) {\n            currentHookNameInDev = \"useMemo\";\n            updateHookTypesDev();\n            var prevDispatcher = ReactSharedInternals.H;\n            ReactSharedInternals.H = InvalidNestedHooksDispatcherOnRerenderInDEV;\n            try {\n                return updateMemo(create, deps);\n            } finally{\n                ReactSharedInternals.H = prevDispatcher;\n            }\n        },\n        useReducer: function(reducer, initialArg, init) {\n            currentHookNameInDev = \"useReducer\";\n            updateHookTypesDev();\n            var prevDispatcher = ReactSharedInternals.H;\n            ReactSharedInternals.H = InvalidNestedHooksDispatcherOnRerenderInDEV;\n            try {\n                return rerenderReducer(reducer, initialArg, init);\n            } finally{\n                ReactSharedInternals.H = prevDispatcher;\n            }\n        },\n        useRef: function() {\n            currentHookNameInDev = \"useRef\";\n            updateHookTypesDev();\n            return updateWorkInProgressHook().memoizedState;\n        },\n        useState: function() {\n            currentHookNameInDev = \"useState\";\n            updateHookTypesDev();\n            var prevDispatcher = ReactSharedInternals.H;\n            ReactSharedInternals.H = InvalidNestedHooksDispatcherOnRerenderInDEV;\n            try {\n                return rerenderReducer(basicStateReducer);\n            } finally{\n                ReactSharedInternals.H = prevDispatcher;\n            }\n        },\n        useDebugValue: function() {\n            currentHookNameInDev = \"useDebugValue\";\n            updateHookTypesDev();\n        },\n        useDeferredValue: function(value, initialValue) {\n            currentHookNameInDev = \"useDeferredValue\";\n            updateHookTypesDev();\n            return rerenderDeferredValue(value, initialValue);\n        },\n        useTransition: function() {\n            currentHookNameInDev = \"useTransition\";\n            updateHookTypesDev();\n            return rerenderTransition();\n        },\n        useSyncExternalStore: function(subscribe, getSnapshot, getServerSnapshot) {\n            currentHookNameInDev = \"useSyncExternalStore\";\n            updateHookTypesDev();\n            return updateSyncExternalStore(subscribe, getSnapshot, getServerSnapshot);\n        },\n        useId: function() {\n            currentHookNameInDev = \"useId\";\n            updateHookTypesDev();\n            return updateWorkInProgressHook().memoizedState;\n        },\n        useCacheRefresh: function() {\n            currentHookNameInDev = \"useCacheRefresh\";\n            updateHookTypesDev();\n            return updateWorkInProgressHook().memoizedState;\n        }\n    };\n    HooksDispatcherOnRerenderInDEV.useMemoCache = useMemoCache;\n    HooksDispatcherOnRerenderInDEV.useHostTransitionStatus = useHostTransitionStatus;\n    HooksDispatcherOnRerenderInDEV.useFormState = function(action) {\n        currentHookNameInDev = \"useFormState\";\n        updateHookTypesDev();\n        warnOnUseFormStateInDev();\n        return rerenderActionState(action);\n    };\n    HooksDispatcherOnRerenderInDEV.useActionState = function(action) {\n        currentHookNameInDev = \"useActionState\";\n        updateHookTypesDev();\n        return rerenderActionState(action);\n    };\n    HooksDispatcherOnRerenderInDEV.useOptimistic = function(passthrough, reducer) {\n        currentHookNameInDev = \"useOptimistic\";\n        updateHookTypesDev();\n        return rerenderOptimistic(passthrough, reducer);\n    };\n    InvalidNestedHooksDispatcherOnMountInDEV = {\n        readContext: function(context) {\n            warnInvalidContextAccess();\n            return readContext(context);\n        },\n        use: function(usable) {\n            warnInvalidHookAccess();\n            return use(usable);\n        },\n        useCallback: function(callback, deps) {\n            currentHookNameInDev = \"useCallback\";\n            warnInvalidHookAccess();\n            mountHookTypesDev();\n            return mountCallback(callback, deps);\n        },\n        useContext: function(context) {\n            currentHookNameInDev = \"useContext\";\n            warnInvalidHookAccess();\n            mountHookTypesDev();\n            return readContext(context);\n        },\n        useEffect: function(create, deps) {\n            currentHookNameInDev = \"useEffect\";\n            warnInvalidHookAccess();\n            mountHookTypesDev();\n            return mountEffect(create, deps);\n        },\n        useImperativeHandle: function(ref, create, deps) {\n            currentHookNameInDev = \"useImperativeHandle\";\n            warnInvalidHookAccess();\n            mountHookTypesDev();\n            return mountImperativeHandle(ref, create, deps);\n        },\n        useInsertionEffect: function(create, deps) {\n            currentHookNameInDev = \"useInsertionEffect\";\n            warnInvalidHookAccess();\n            mountHookTypesDev();\n            mountEffectImpl(4, Insertion, create, deps);\n        },\n        useLayoutEffect: function(create, deps) {\n            currentHookNameInDev = \"useLayoutEffect\";\n            warnInvalidHookAccess();\n            mountHookTypesDev();\n            return mountLayoutEffect(create, deps);\n        },\n        useMemo: function(create, deps) {\n            currentHookNameInDev = \"useMemo\";\n            warnInvalidHookAccess();\n            mountHookTypesDev();\n            var prevDispatcher = ReactSharedInternals.H;\n            ReactSharedInternals.H = InvalidNestedHooksDispatcherOnMountInDEV;\n            try {\n                return mountMemo(create, deps);\n            } finally{\n                ReactSharedInternals.H = prevDispatcher;\n            }\n        },\n        useReducer: function(reducer, initialArg, init) {\n            currentHookNameInDev = \"useReducer\";\n            warnInvalidHookAccess();\n            mountHookTypesDev();\n            var prevDispatcher = ReactSharedInternals.H;\n            ReactSharedInternals.H = InvalidNestedHooksDispatcherOnMountInDEV;\n            try {\n                return mountReducer(reducer, initialArg, init);\n            } finally{\n                ReactSharedInternals.H = prevDispatcher;\n            }\n        },\n        useRef: function(initialValue) {\n            currentHookNameInDev = \"useRef\";\n            warnInvalidHookAccess();\n            mountHookTypesDev();\n            return mountRef(initialValue);\n        },\n        useState: function(initialState) {\n            currentHookNameInDev = \"useState\";\n            warnInvalidHookAccess();\n            mountHookTypesDev();\n            var prevDispatcher = ReactSharedInternals.H;\n            ReactSharedInternals.H = InvalidNestedHooksDispatcherOnMountInDEV;\n            try {\n                return mountState(initialState);\n            } finally{\n                ReactSharedInternals.H = prevDispatcher;\n            }\n        },\n        useDebugValue: function() {\n            currentHookNameInDev = \"useDebugValue\";\n            warnInvalidHookAccess();\n            mountHookTypesDev();\n        },\n        useDeferredValue: function(value, initialValue) {\n            currentHookNameInDev = \"useDeferredValue\";\n            warnInvalidHookAccess();\n            mountHookTypesDev();\n            return mountDeferredValue(value, initialValue);\n        },\n        useTransition: function() {\n            currentHookNameInDev = \"useTransition\";\n            warnInvalidHookAccess();\n            mountHookTypesDev();\n            return mountTransition();\n        },\n        useSyncExternalStore: function(subscribe, getSnapshot, getServerSnapshot) {\n            currentHookNameInDev = \"useSyncExternalStore\";\n            warnInvalidHookAccess();\n            mountHookTypesDev();\n            return mountSyncExternalStore(subscribe, getSnapshot, getServerSnapshot);\n        },\n        useId: function() {\n            currentHookNameInDev = \"useId\";\n            warnInvalidHookAccess();\n            mountHookTypesDev();\n            return mountId();\n        },\n        useCacheRefresh: function() {\n            currentHookNameInDev = \"useCacheRefresh\";\n            mountHookTypesDev();\n            return mountRefresh();\n        },\n        useMemoCache: function(size) {\n            warnInvalidHookAccess();\n            return useMemoCache(size);\n        }\n    };\n    InvalidNestedHooksDispatcherOnMountInDEV.useHostTransitionStatus = useHostTransitionStatus;\n    InvalidNestedHooksDispatcherOnMountInDEV.useFormState = function(action, initialState) {\n        currentHookNameInDev = \"useFormState\";\n        warnInvalidHookAccess();\n        mountHookTypesDev();\n        return mountActionState(action, initialState);\n    };\n    InvalidNestedHooksDispatcherOnMountInDEV.useActionState = function(action, initialState) {\n        currentHookNameInDev = \"useActionState\";\n        warnInvalidHookAccess();\n        mountHookTypesDev();\n        return mountActionState(action, initialState);\n    };\n    InvalidNestedHooksDispatcherOnMountInDEV.useOptimistic = function(passthrough) {\n        currentHookNameInDev = \"useOptimistic\";\n        warnInvalidHookAccess();\n        mountHookTypesDev();\n        return mountOptimistic(passthrough);\n    };\n    InvalidNestedHooksDispatcherOnUpdateInDEV = {\n        readContext: function(context) {\n            warnInvalidContextAccess();\n            return readContext(context);\n        },\n        use: function(usable) {\n            warnInvalidHookAccess();\n            return use(usable);\n        },\n        useCallback: function(callback, deps) {\n            currentHookNameInDev = \"useCallback\";\n            warnInvalidHookAccess();\n            updateHookTypesDev();\n            return updateCallback(callback, deps);\n        },\n        useContext: function(context) {\n            currentHookNameInDev = \"useContext\";\n            warnInvalidHookAccess();\n            updateHookTypesDev();\n            return readContext(context);\n        },\n        useEffect: function(create, deps) {\n            currentHookNameInDev = \"useEffect\";\n            warnInvalidHookAccess();\n            updateHookTypesDev();\n            updateEffectImpl(2048, Passive, create, deps);\n        },\n        useImperativeHandle: function(ref, create, deps) {\n            currentHookNameInDev = \"useImperativeHandle\";\n            warnInvalidHookAccess();\n            updateHookTypesDev();\n            return updateImperativeHandle(ref, create, deps);\n        },\n        useInsertionEffect: function(create, deps) {\n            currentHookNameInDev = \"useInsertionEffect\";\n            warnInvalidHookAccess();\n            updateHookTypesDev();\n            return updateEffectImpl(4, Insertion, create, deps);\n        },\n        useLayoutEffect: function(create, deps) {\n            currentHookNameInDev = \"useLayoutEffect\";\n            warnInvalidHookAccess();\n            updateHookTypesDev();\n            return updateEffectImpl(4, Layout, create, deps);\n        },\n        useMemo: function(create, deps) {\n            currentHookNameInDev = \"useMemo\";\n            warnInvalidHookAccess();\n            updateHookTypesDev();\n            var prevDispatcher = ReactSharedInternals.H;\n            ReactSharedInternals.H = InvalidNestedHooksDispatcherOnUpdateInDEV;\n            try {\n                return updateMemo(create, deps);\n            } finally{\n                ReactSharedInternals.H = prevDispatcher;\n            }\n        },\n        useReducer: function(reducer, initialArg, init) {\n            currentHookNameInDev = \"useReducer\";\n            warnInvalidHookAccess();\n            updateHookTypesDev();\n            var prevDispatcher = ReactSharedInternals.H;\n            ReactSharedInternals.H = InvalidNestedHooksDispatcherOnUpdateInDEV;\n            try {\n                return updateReducer(reducer, initialArg, init);\n            } finally{\n                ReactSharedInternals.H = prevDispatcher;\n            }\n        },\n        useRef: function() {\n            currentHookNameInDev = \"useRef\";\n            warnInvalidHookAccess();\n            updateHookTypesDev();\n            return updateWorkInProgressHook().memoizedState;\n        },\n        useState: function() {\n            currentHookNameInDev = \"useState\";\n            warnInvalidHookAccess();\n            updateHookTypesDev();\n            var prevDispatcher = ReactSharedInternals.H;\n            ReactSharedInternals.H = InvalidNestedHooksDispatcherOnUpdateInDEV;\n            try {\n                return updateReducer(basicStateReducer);\n            } finally{\n                ReactSharedInternals.H = prevDispatcher;\n            }\n        },\n        useDebugValue: function() {\n            currentHookNameInDev = \"useDebugValue\";\n            warnInvalidHookAccess();\n            updateHookTypesDev();\n        },\n        useDeferredValue: function(value, initialValue) {\n            currentHookNameInDev = \"useDeferredValue\";\n            warnInvalidHookAccess();\n            updateHookTypesDev();\n            return updateDeferredValue(value, initialValue);\n        },\n        useTransition: function() {\n            currentHookNameInDev = \"useTransition\";\n            warnInvalidHookAccess();\n            updateHookTypesDev();\n            return updateTransition();\n        },\n        useSyncExternalStore: function(subscribe, getSnapshot, getServerSnapshot) {\n            currentHookNameInDev = \"useSyncExternalStore\";\n            warnInvalidHookAccess();\n            updateHookTypesDev();\n            return updateSyncExternalStore(subscribe, getSnapshot, getServerSnapshot);\n        },\n        useId: function() {\n            currentHookNameInDev = \"useId\";\n            warnInvalidHookAccess();\n            updateHookTypesDev();\n            return updateWorkInProgressHook().memoizedState;\n        },\n        useCacheRefresh: function() {\n            currentHookNameInDev = \"useCacheRefresh\";\n            updateHookTypesDev();\n            return updateWorkInProgressHook().memoizedState;\n        },\n        useMemoCache: function(size) {\n            warnInvalidHookAccess();\n            return useMemoCache(size);\n        }\n    };\n    InvalidNestedHooksDispatcherOnUpdateInDEV.useHostTransitionStatus = useHostTransitionStatus;\n    InvalidNestedHooksDispatcherOnUpdateInDEV.useFormState = function(action) {\n        currentHookNameInDev = \"useFormState\";\n        warnInvalidHookAccess();\n        updateHookTypesDev();\n        return updateActionState(action);\n    };\n    InvalidNestedHooksDispatcherOnUpdateInDEV.useActionState = function(action) {\n        currentHookNameInDev = \"useActionState\";\n        warnInvalidHookAccess();\n        updateHookTypesDev();\n        return updateActionState(action);\n    };\n    InvalidNestedHooksDispatcherOnUpdateInDEV.useOptimistic = function(passthrough, reducer) {\n        currentHookNameInDev = \"useOptimistic\";\n        warnInvalidHookAccess();\n        updateHookTypesDev();\n        return updateOptimistic(passthrough, reducer);\n    };\n    InvalidNestedHooksDispatcherOnRerenderInDEV = {\n        readContext: function(context) {\n            warnInvalidContextAccess();\n            return readContext(context);\n        },\n        use: function(usable) {\n            warnInvalidHookAccess();\n            return use(usable);\n        },\n        useCallback: function(callback, deps) {\n            currentHookNameInDev = \"useCallback\";\n            warnInvalidHookAccess();\n            updateHookTypesDev();\n            return updateCallback(callback, deps);\n        },\n        useContext: function(context) {\n            currentHookNameInDev = \"useContext\";\n            warnInvalidHookAccess();\n            updateHookTypesDev();\n            return readContext(context);\n        },\n        useEffect: function(create, deps) {\n            currentHookNameInDev = \"useEffect\";\n            warnInvalidHookAccess();\n            updateHookTypesDev();\n            updateEffectImpl(2048, Passive, create, deps);\n        },\n        useImperativeHandle: function(ref, create, deps) {\n            currentHookNameInDev = \"useImperativeHandle\";\n            warnInvalidHookAccess();\n            updateHookTypesDev();\n            return updateImperativeHandle(ref, create, deps);\n        },\n        useInsertionEffect: function(create, deps) {\n            currentHookNameInDev = \"useInsertionEffect\";\n            warnInvalidHookAccess();\n            updateHookTypesDev();\n            return updateEffectImpl(4, Insertion, create, deps);\n        },\n        useLayoutEffect: function(create, deps) {\n            currentHookNameInDev = \"useLayoutEffect\";\n            warnInvalidHookAccess();\n            updateHookTypesDev();\n            return updateEffectImpl(4, Layout, create, deps);\n        },\n        useMemo: function(create, deps) {\n            currentHookNameInDev = \"useMemo\";\n            warnInvalidHookAccess();\n            updateHookTypesDev();\n            var prevDispatcher = ReactSharedInternals.H;\n            ReactSharedInternals.H = InvalidNestedHooksDispatcherOnUpdateInDEV;\n            try {\n                return updateMemo(create, deps);\n            } finally{\n                ReactSharedInternals.H = prevDispatcher;\n            }\n        },\n        useReducer: function(reducer, initialArg, init) {\n            currentHookNameInDev = \"useReducer\";\n            warnInvalidHookAccess();\n            updateHookTypesDev();\n            var prevDispatcher = ReactSharedInternals.H;\n            ReactSharedInternals.H = InvalidNestedHooksDispatcherOnUpdateInDEV;\n            try {\n                return rerenderReducer(reducer, initialArg, init);\n            } finally{\n                ReactSharedInternals.H = prevDispatcher;\n            }\n        },\n        useRef: function() {\n            currentHookNameInDev = \"useRef\";\n            warnInvalidHookAccess();\n            updateHookTypesDev();\n            return updateWorkInProgressHook().memoizedState;\n        },\n        useState: function() {\n            currentHookNameInDev = \"useState\";\n            warnInvalidHookAccess();\n            updateHookTypesDev();\n            var prevDispatcher = ReactSharedInternals.H;\n            ReactSharedInternals.H = InvalidNestedHooksDispatcherOnUpdateInDEV;\n            try {\n                return rerenderReducer(basicStateReducer);\n            } finally{\n                ReactSharedInternals.H = prevDispatcher;\n            }\n        },\n        useDebugValue: function() {\n            currentHookNameInDev = \"useDebugValue\";\n            warnInvalidHookAccess();\n            updateHookTypesDev();\n        },\n        useDeferredValue: function(value, initialValue) {\n            currentHookNameInDev = \"useDeferredValue\";\n            warnInvalidHookAccess();\n            updateHookTypesDev();\n            return rerenderDeferredValue(value, initialValue);\n        },\n        useTransition: function() {\n            currentHookNameInDev = \"useTransition\";\n            warnInvalidHookAccess();\n            updateHookTypesDev();\n            return rerenderTransition();\n        },\n        useSyncExternalStore: function(subscribe, getSnapshot, getServerSnapshot) {\n            currentHookNameInDev = \"useSyncExternalStore\";\n            warnInvalidHookAccess();\n            updateHookTypesDev();\n            return updateSyncExternalStore(subscribe, getSnapshot, getServerSnapshot);\n        },\n        useId: function() {\n            currentHookNameInDev = \"useId\";\n            warnInvalidHookAccess();\n            updateHookTypesDev();\n            return updateWorkInProgressHook().memoizedState;\n        },\n        useCacheRefresh: function() {\n            currentHookNameInDev = \"useCacheRefresh\";\n            updateHookTypesDev();\n            return updateWorkInProgressHook().memoizedState;\n        },\n        useMemoCache: function(size) {\n            warnInvalidHookAccess();\n            return useMemoCache(size);\n        }\n    };\n    InvalidNestedHooksDispatcherOnRerenderInDEV.useHostTransitionStatus = useHostTransitionStatus;\n    InvalidNestedHooksDispatcherOnRerenderInDEV.useFormState = function(action) {\n        currentHookNameInDev = \"useFormState\";\n        warnInvalidHookAccess();\n        updateHookTypesDev();\n        return rerenderActionState(action);\n    };\n    InvalidNestedHooksDispatcherOnRerenderInDEV.useActionState = function(action) {\n        currentHookNameInDev = \"useActionState\";\n        warnInvalidHookAccess();\n        updateHookTypesDev();\n        return rerenderActionState(action);\n    };\n    InvalidNestedHooksDispatcherOnRerenderInDEV.useOptimistic = function(passthrough, reducer) {\n        currentHookNameInDev = \"useOptimistic\";\n        warnInvalidHookAccess();\n        updateHookTypesDev();\n        return rerenderOptimistic(passthrough, reducer);\n    };\n    var fakeInternalInstance = {};\n    var didWarnAboutStateAssignmentForComponent = new Set();\n    var didWarnAboutUninitializedState = new Set();\n    var didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate = new Set();\n    var didWarnAboutLegacyLifecyclesAndDerivedState = new Set();\n    var didWarnAboutDirectlyAssigningPropsToState = new Set();\n    var didWarnAboutUndefinedDerivedState = new Set();\n    var didWarnAboutContextTypes$1 = new Set();\n    var didWarnAboutChildContextTypes = new Set();\n    var didWarnAboutInvalidateContextType = new Set();\n    var didWarnOnInvalidCallback = new Set();\n    Object.freeze(fakeInternalInstance);\n    var classComponentUpdater = {\n        isMounted: function(component) {\n            var owner = current;\n            if (null !== owner && isRendering && 1 === owner.tag) {\n                var instance = owner.stateNode;\n                instance._warnedAboutRefsInRender || console.error(\"%s is accessing isMounted inside its render() function. render() should be a pure function of props and state. It should never access something that requires stale data from the previous render, such as refs. Move this logic to componentDidMount and componentDidUpdate instead.\", getComponentNameFromFiber(owner) || \"A component\");\n                instance._warnedAboutRefsInRender = !0;\n            }\n            return (component = component._reactInternals) ? getNearestMountedFiber(component) === component : !1;\n        },\n        enqueueSetState: function(inst, payload, callback) {\n            inst = inst._reactInternals;\n            var lane = requestUpdateLane(inst), update = createUpdate(lane);\n            update.payload = payload;\n            void 0 !== callback && null !== callback && (warnOnInvalidCallback(callback), update.callback = callback);\n            payload = enqueueUpdate(inst, update, lane);\n            null !== payload && (scheduleUpdateOnFiber(payload, inst, lane), entangleTransitions(payload, inst, lane));\n            markStateUpdateScheduled(inst, lane);\n        },\n        enqueueReplaceState: function(inst, payload, callback) {\n            inst = inst._reactInternals;\n            var lane = requestUpdateLane(inst), update = createUpdate(lane);\n            update.tag = ReplaceState;\n            update.payload = payload;\n            void 0 !== callback && null !== callback && (warnOnInvalidCallback(callback), update.callback = callback);\n            payload = enqueueUpdate(inst, update, lane);\n            null !== payload && (scheduleUpdateOnFiber(payload, inst, lane), entangleTransitions(payload, inst, lane));\n            markStateUpdateScheduled(inst, lane);\n        },\n        enqueueForceUpdate: function(inst, callback) {\n            inst = inst._reactInternals;\n            var lane = requestUpdateLane(inst), update = createUpdate(lane);\n            update.tag = ForceUpdate;\n            void 0 !== callback && null !== callback && (warnOnInvalidCallback(callback), update.callback = callback);\n            callback = enqueueUpdate(inst, update, lane);\n            null !== callback && (scheduleUpdateOnFiber(callback, inst, lane), entangleTransitions(callback, inst, lane));\n            null !== injectedProfilingHooks && \"function\" === typeof injectedProfilingHooks.markForceUpdateScheduled && injectedProfilingHooks.markForceUpdateScheduled(inst, lane);\n        }\n    }, reportGlobalError = \"function\" === typeof reportError ? reportError : function(error) {\n        if (false) { var event; } else if (\"object\" === typeof process && \"function\" === typeof process.emit) {\n            process.emit(\"uncaughtException\", error);\n            return;\n        }\n        console.error(error);\n    }, componentName = null, errorBoundaryName = null, SelectiveHydrationException = Error(\"This is not a real error. It's an implementation detail of React's selective hydration feature. If this leaks into userspace, it's a bug in React. Please file an issue.\"), didReceiveUpdate = !1;\n    var didWarnAboutBadClass = {};\n    var didWarnAboutContextTypeOnFunctionComponent = {};\n    var didWarnAboutContextTypes = {};\n    var didWarnAboutGetDerivedStateOnFunctionComponent = {};\n    var didWarnAboutReassigningProps = !1;\n    var didWarnAboutRevealOrder = {};\n    var didWarnAboutTailOptions = {};\n    var SUSPENDED_MARKER = {\n        dehydrated: null,\n        treeContext: null,\n        retryLane: 0\n    }, hasWarnedAboutUsingNoValuePropOnContextProvider = !1, valueCursor = createCursor(null);\n    var rendererCursorDEV = createCursor(null);\n    var renderer2CursorDEV = createCursor(null);\n    var rendererSigil = {};\n    var currentlyRenderingFiber = null, lastContextDependency = null, isDisallowedContextReadInDEV = !1, AbortControllerLocal = \"undefined\" !== typeof AbortController ? AbortController : function() {\n        var listeners = [], signal = this.signal = {\n            aborted: !1,\n            addEventListener: function(type, listener) {\n                listeners.push(listener);\n            }\n        };\n        this.abort = function() {\n            signal.aborted = !0;\n            listeners.forEach(function(listener) {\n                return listener();\n            });\n        };\n    }, scheduleCallback$1 = Scheduler.unstable_scheduleCallback, NormalPriority = Scheduler.unstable_NormalPriority, CacheContext = {\n        $$typeof: REACT_CONTEXT_TYPE,\n        Consumer: null,\n        Provider: null,\n        _currentValue: null,\n        _currentValue2: null,\n        _threadCount: 0,\n        _currentRenderer: null,\n        _currentRenderer2: null\n    }, prevOnStartTransitionFinish = ReactSharedInternals.S;\n    ReactSharedInternals.S = function(transition, returnValue) {\n        \"object\" === typeof returnValue && null !== returnValue && \"function\" === typeof returnValue.then && entangleAsyncAction(transition, returnValue);\n        null !== prevOnStartTransitionFinish && prevOnStartTransitionFinish(transition, returnValue);\n    };\n    var resumedCache = createCursor(null), didWarnAboutUndefinedSnapshotBeforeUpdate = null;\n    didWarnAboutUndefinedSnapshotBeforeUpdate = new Set();\n    var offscreenSubtreeIsHidden = !1, offscreenSubtreeWasHidden = !1, needsFormReset = !1, PossiblyWeakSet = \"function\" === typeof WeakSet ? WeakSet : Set, nextEffect = null, inProgressLanes = null, inProgressRoot = null, shouldFireAfterActiveInstanceBlur = !1, hostParent = null, hostParentIsContainer = !1, currentHoistableRoot = null, suspenseyCommitFlag = 8192, DefaultAsyncDispatcher = {\n        getCacheForType: function(resourceType) {\n            var cache = readContext(CacheContext), cacheForType = cache.data.get(resourceType);\n            void 0 === cacheForType && (cacheForType = resourceType(), cache.data.set(resourceType, cacheForType));\n            return cacheForType;\n        },\n        getOwner: function() {\n            return current;\n        }\n    }, COMPONENT_TYPE = 0, HAS_PSEUDO_CLASS_TYPE = 1, ROLE_TYPE = 2, TEST_NAME_TYPE = 3, TEXT_TYPE = 4;\n    if (\"function\" === typeof Symbol && Symbol.for) {\n        var symbolFor = Symbol.for;\n        COMPONENT_TYPE = symbolFor(\"selector.component\");\n        HAS_PSEUDO_CLASS_TYPE = symbolFor(\"selector.has_pseudo_class\");\n        ROLE_TYPE = symbolFor(\"selector.role\");\n        TEST_NAME_TYPE = symbolFor(\"selector.test_id\");\n        TEXT_TYPE = symbolFor(\"selector.text\");\n    }\n    var commitHooks = [], PossiblyWeakMap = \"function\" === typeof WeakMap ? WeakMap : Map, NoContext = 0, RenderContext = 2, CommitContext = 4, RootInProgress = 0, RootFatalErrored = 1, RootErrored = 2, RootSuspended = 3, RootSuspendedWithDelay = 4, RootCompleted = 5, RootDidNotComplete = 6, executionContext = NoContext, workInProgressRoot = null, workInProgress = null, workInProgressRootRenderLanes = 0, NotSuspended = 0, SuspendedOnError = 1, SuspendedOnData = 2, SuspendedOnImmediate = 3, SuspendedOnInstance = 4, SuspendedOnInstanceAndReadyToContinue = 5, SuspendedOnDeprecatedThrowPromise = 6, SuspendedAndReadyToContinue = 7, SuspendedOnHydration = 8, workInProgressSuspendedReason = NotSuspended, workInProgressThrownValue = null, workInProgressRootDidSkipSuspendedSiblings = !1, workInProgressRootIsPrerendering = !1, workInProgressRootDidAttachPingListener = !1, entangledRenderLanes = 0, workInProgressRootExitStatus = RootInProgress, workInProgressRootSkippedLanes = 0, workInProgressRootInterleavedUpdatedLanes = 0, workInProgressRootPingedLanes = 0, workInProgressDeferredLane = 0, workInProgressSuspendedRetryLanes = 0, workInProgressRootConcurrentErrors = null, workInProgressRootRecoverableErrors = null, workInProgressRootDidIncludeRecursiveRenderUpdate = !1, globalMostRecentFallbackTime = 0, FALLBACK_THROTTLE_MS = 300, workInProgressRootRenderTargetTime = Infinity, RENDER_TIMEOUT_MS = 500, workInProgressTransitions = null, legacyErrorBoundariesThatAlreadyFailed = null, rootDoesHavePassiveEffects = !1, rootWithPendingPassiveEffects = null, pendingPassiveEffectsLanes = 0, pendingPassiveEffectsRemainingLanes = 0, pendingPassiveTransitions = null, NESTED_UPDATE_LIMIT = 50, nestedUpdateCount = 0, rootWithNestedUpdates = null, isFlushingPassiveEffects = !1, didScheduleUpdateDuringPassiveEffects = !1, NESTED_PASSIVE_UPDATE_LIMIT = 50, nestedPassiveUpdateCount = 0, rootWithPassiveNestedUpdates = null, isRunningInsertionEffect = !1, IMMEDIATE_COMMIT = 0, SUSPENDED_COMMIT = 1, THROTTLED_COMMIT = 2, didWarnStateUpdateForNotYetMountedComponent = null, didWarnAboutUpdateInRender = !1;\n    var didWarnAboutUpdateInRenderForAnotherComponent = new Set();\n    var fakeActCallbackNode = {}, resolveFamily = null, failedBoundaries = null;\n    var hasBadMapPolyfill = !1;\n    try {\n        var nonExtensibleObject = Object.preventExtensions({});\n        new Map([\n            [\n                nonExtensibleObject,\n                null\n            ]\n        ]);\n        new Set([\n            nonExtensibleObject\n        ]);\n    } catch (e) {\n        hasBadMapPolyfill = !0;\n    }\n    var didWarnAboutNestedUpdates = !1;\n    var didWarnAboutFindNodeInStrictMode = {};\n    var overrideHookState = null, overrideHookStateDeletePath = null, overrideHookStateRenamePath = null, overrideProps = null, overridePropsDeletePath = null, overridePropsRenamePath = null, scheduleUpdate = null, setErrorHandler = null, setSuspenseHandler = null;\n    overrideHookState = function(fiber, id, path, value) {\n        id = findHook(fiber, id);\n        null !== id && (path = copyWithSetImpl(id.memoizedState, path, 0, value), id.memoizedState = path, id.baseState = path, fiber.memoizedProps = assign({}, fiber.memoizedProps), path = enqueueConcurrentRenderForLane(fiber, 2), null !== path && scheduleUpdateOnFiber(path, fiber, 2));\n    };\n    overrideHookStateDeletePath = function(fiber, id, path) {\n        id = findHook(fiber, id);\n        null !== id && (path = copyWithDeleteImpl(id.memoizedState, path, 0), id.memoizedState = path, id.baseState = path, fiber.memoizedProps = assign({}, fiber.memoizedProps), path = enqueueConcurrentRenderForLane(fiber, 2), null !== path && scheduleUpdateOnFiber(path, fiber, 2));\n    };\n    overrideHookStateRenamePath = function(fiber, id, oldPath, newPath) {\n        id = findHook(fiber, id);\n        null !== id && (oldPath = copyWithRename(id.memoizedState, oldPath, newPath), id.memoizedState = oldPath, id.baseState = oldPath, fiber.memoizedProps = assign({}, fiber.memoizedProps), oldPath = enqueueConcurrentRenderForLane(fiber, 2), null !== oldPath && scheduleUpdateOnFiber(oldPath, fiber, 2));\n    };\n    overrideProps = function(fiber, path, value) {\n        fiber.pendingProps = copyWithSetImpl(fiber.memoizedProps, path, 0, value);\n        fiber.alternate && (fiber.alternate.pendingProps = fiber.pendingProps);\n        path = enqueueConcurrentRenderForLane(fiber, 2);\n        null !== path && scheduleUpdateOnFiber(path, fiber, 2);\n    };\n    overridePropsDeletePath = function(fiber, path) {\n        fiber.pendingProps = copyWithDeleteImpl(fiber.memoizedProps, path, 0);\n        fiber.alternate && (fiber.alternate.pendingProps = fiber.pendingProps);\n        path = enqueueConcurrentRenderForLane(fiber, 2);\n        null !== path && scheduleUpdateOnFiber(path, fiber, 2);\n    };\n    overridePropsRenamePath = function(fiber, oldPath, newPath) {\n        fiber.pendingProps = copyWithRename(fiber.memoizedProps, oldPath, newPath);\n        fiber.alternate && (fiber.alternate.pendingProps = fiber.pendingProps);\n        oldPath = enqueueConcurrentRenderForLane(fiber, 2);\n        null !== oldPath && scheduleUpdateOnFiber(oldPath, fiber, 2);\n    };\n    scheduleUpdate = function(fiber) {\n        var root = enqueueConcurrentRenderForLane(fiber, 2);\n        null !== root && scheduleUpdateOnFiber(root, fiber, 2);\n    };\n    setErrorHandler = function(newShouldErrorImpl) {\n        shouldErrorImpl = newShouldErrorImpl;\n    };\n    setSuspenseHandler = function(newShouldSuspendImpl) {\n        shouldSuspendImpl = newShouldSuspendImpl;\n    };\n    exports.attemptContinuousHydration = function(fiber) {\n        if (13 === fiber.tag) {\n            var root = enqueueConcurrentRenderForLane(fiber, 67108864);\n            null !== root && scheduleUpdateOnFiber(root, fiber, 67108864);\n            markRetryLaneIfNotHydrated(fiber, 67108864);\n        }\n    };\n    exports.attemptHydrationAtCurrentPriority = function(fiber) {\n        if (13 === fiber.tag) {\n            var lane = requestUpdateLane(fiber), root = enqueueConcurrentRenderForLane(fiber, lane);\n            null !== root && scheduleUpdateOnFiber(root, fiber, lane);\n            markRetryLaneIfNotHydrated(fiber, lane);\n        }\n    };\n    exports.attemptSynchronousHydration = function(fiber) {\n        switch(fiber.tag){\n            case 3:\n                fiber = fiber.stateNode;\n                if (fiber.current.memoizedState.isDehydrated) {\n                    var lanes = getHighestPriorityLanes(fiber.pendingLanes);\n                    if (0 !== lanes) {\n                        fiber.pendingLanes |= 2;\n                        for(fiber.entangledLanes |= 2; lanes;){\n                            var lane = 1 << 31 - clz32(lanes);\n                            fiber.entanglements[1] |= lane;\n                            lanes &= ~lane;\n                        }\n                        ensureRootIsScheduled(fiber);\n                        (executionContext & (RenderContext | CommitContext)) === NoContext && (workInProgressRootRenderTargetTime = now$1() + RENDER_TIMEOUT_MS, flushSyncWorkAcrossRoots_impl(0, !1));\n                    }\n                }\n                break;\n            case 13:\n                lanes = enqueueConcurrentRenderForLane(fiber, 2), null !== lanes && scheduleUpdateOnFiber(lanes, fiber, 2), flushSyncWork(), markRetryLaneIfNotHydrated(fiber, 2);\n        }\n    };\n    exports.batchedUpdates = function(fn, a) {\n        return fn(a);\n    };\n    exports.createComponentSelector = function(component) {\n        return {\n            $$typeof: COMPONENT_TYPE,\n            value: component\n        };\n    };\n    exports.createContainer = function(containerInfo, tag, hydrationCallbacks, isStrictMode, concurrentUpdatesByDefaultOverride, identifierPrefix, onUncaughtError, onCaughtError, onRecoverableError, transitionCallbacks) {\n        return createFiberRoot(containerInfo, tag, !1, null, hydrationCallbacks, isStrictMode, identifierPrefix, onUncaughtError, onCaughtError, onRecoverableError, transitionCallbacks, null);\n    };\n    exports.createHasPseudoClassSelector = function(selectors) {\n        return {\n            $$typeof: HAS_PSEUDO_CLASS_TYPE,\n            value: selectors\n        };\n    };\n    exports.createHydrationContainer = function(initialChildren, callback, containerInfo, tag, hydrationCallbacks, isStrictMode, concurrentUpdatesByDefaultOverride, identifierPrefix, onUncaughtError, onCaughtError, onRecoverableError, transitionCallbacks, formState) {\n        initialChildren = createFiberRoot(containerInfo, tag, !0, initialChildren, hydrationCallbacks, isStrictMode, identifierPrefix, onUncaughtError, onCaughtError, onRecoverableError, transitionCallbacks, formState);\n        initialChildren.context = getContextForSubtree(null);\n        containerInfo = initialChildren.current;\n        tag = requestUpdateLane(containerInfo);\n        hydrationCallbacks = createUpdate(tag);\n        hydrationCallbacks.callback = void 0 !== callback && null !== callback ? callback : null;\n        enqueueUpdate(containerInfo, hydrationCallbacks, tag);\n        initialChildren.current.lanes = tag;\n        markRootUpdated$1(initialChildren, tag);\n        ensureRootIsScheduled(initialChildren);\n        return initialChildren;\n    };\n    exports.createPortal = function(children, containerInfo, implementation) {\n        var key = 3 < arguments.length && void 0 !== arguments[3] ? arguments[3] : null;\n        try {\n            testStringCoercion(key);\n            var JSCompiler_inline_result = !1;\n        } catch (e$6) {\n            JSCompiler_inline_result = !0;\n        }\n        JSCompiler_inline_result && (console.error(\"The provided key is an unsupported type %s. This value must be coerced to a string before using it here.\", \"function\" === typeof Symbol && Symbol.toStringTag && key[Symbol.toStringTag] || key.constructor.name || \"Object\"), testStringCoercion(key));\n        return {\n            $$typeof: REACT_PORTAL_TYPE,\n            key: null == key ? null : \"\" + key,\n            children: children,\n            containerInfo: containerInfo,\n            implementation: implementation\n        };\n    };\n    exports.createRoleSelector = function(role) {\n        return {\n            $$typeof: ROLE_TYPE,\n            value: role\n        };\n    };\n    exports.createTestNameSelector = function(id) {\n        return {\n            $$typeof: TEST_NAME_TYPE,\n            value: id\n        };\n    };\n    exports.createTextSelector = function(text) {\n        return {\n            $$typeof: TEXT_TYPE,\n            value: text\n        };\n    };\n    exports.defaultOnCaughtError = function(error, errorInfo) {\n        var componentNameMessage = componentName ? \"The above error occurred in the <\" + componentName + \"> component.\" : \"The above error occurred in one of your React components.\", recreateMessage = \"React will try to recreate this component tree from scratch using the error boundary you provided, \" + ((errorBoundaryName || \"Anonymous\") + \".\"), prevGetCurrentStack = ReactSharedInternals.getCurrentStack, componentStack = null != errorInfo.componentStack ? errorInfo.componentStack : \"\";\n        ReactSharedInternals.getCurrentStack = function() {\n            return componentStack;\n        };\n        try {\n            \"object\" === typeof error && null !== error && \"string\" === typeof error.environmentName ? bindToConsole(\"error\", [\n                \"%o\\n\\n%s\\n\\n%s\\n\",\n                error,\n                componentNameMessage,\n                recreateMessage\n            ], error.environmentName)() : console.error(\"%o\\n\\n%s\\n\\n%s\\n\", error, componentNameMessage, recreateMessage);\n        } finally{\n            ReactSharedInternals.getCurrentStack = prevGetCurrentStack;\n        }\n    };\n    exports.defaultOnRecoverableError = function(error) {\n        reportGlobalError(error);\n    };\n    exports.defaultOnUncaughtError = function(error, errorInfo) {\n        reportGlobalError(error);\n        error = componentName ? \"An error occurred in the <\" + componentName + \"> component.\" : \"An error occurred in one of your React components.\";\n        var prevGetCurrentStack = ReactSharedInternals.getCurrentStack, componentStack = null != errorInfo.componentStack ? errorInfo.componentStack : \"\";\n        ReactSharedInternals.getCurrentStack = function() {\n            return componentStack;\n        };\n        try {\n            console.warn(\"%s\\n\\n%s\\n\", error, \"Consider adding an error boundary to your tree to customize error handling behavior.\\nVisit https://react.dev/link/error-boundaries to learn more about error boundaries.\");\n        } finally{\n            ReactSharedInternals.getCurrentStack = prevGetCurrentStack;\n        }\n    };\n    exports.deferredUpdates = function(fn) {\n        var prevTransition = ReactSharedInternals.T, previousPriority = getCurrentUpdatePriority();\n        try {\n            return setCurrentUpdatePriority(32), ReactSharedInternals.T = null, fn();\n        } finally{\n            setCurrentUpdatePriority(previousPriority), ReactSharedInternals.T = prevTransition;\n        }\n    };\n    exports.discreteUpdates = function(fn, a, b, c, d) {\n        var prevTransition = ReactSharedInternals.T, previousPriority = getCurrentUpdatePriority();\n        try {\n            return setCurrentUpdatePriority(2), ReactSharedInternals.T = null, fn(a, b, c, d);\n        } finally{\n            setCurrentUpdatePriority(previousPriority), ReactSharedInternals.T = prevTransition, executionContext === NoContext && (workInProgressRootRenderTargetTime = now$1() + RENDER_TIMEOUT_MS);\n        }\n    };\n    exports.findAllNodes = findAllNodes;\n    exports.findBoundingRects = function(hostRoot, selectors) {\n        if (!supportsTestSelectors) throw Error(\"Test selector API is not supported by this renderer.\");\n        selectors = findAllNodes(hostRoot, selectors);\n        hostRoot = [];\n        for(var i = 0; i < selectors.length; i++)hostRoot.push(getBoundingRect(selectors[i]));\n        for(selectors = hostRoot.length - 1; 0 < selectors; selectors--){\n            i = hostRoot[selectors];\n            for(var targetLeft = i.x, targetRight = targetLeft + i.width, targetTop = i.y, targetBottom = targetTop + i.height, j = selectors - 1; 0 <= j; j--)if (selectors !== j) {\n                var otherRect = hostRoot[j], otherLeft = otherRect.x, otherRight = otherLeft + otherRect.width, otherTop = otherRect.y, otherBottom = otherTop + otherRect.height;\n                if (targetLeft >= otherLeft && targetTop >= otherTop && targetRight <= otherRight && targetBottom <= otherBottom) {\n                    hostRoot.splice(selectors, 1);\n                    break;\n                } else if (!(targetLeft !== otherLeft || i.width !== otherRect.width || otherBottom < targetTop || otherTop > targetBottom)) {\n                    otherTop > targetTop && (otherRect.height += otherTop - targetTop, otherRect.y = targetTop);\n                    otherBottom < targetBottom && (otherRect.height = targetBottom - otherTop);\n                    hostRoot.splice(selectors, 1);\n                    break;\n                } else if (!(targetTop !== otherTop || i.height !== otherRect.height || otherRight < targetLeft || otherLeft > targetRight)) {\n                    otherLeft > targetLeft && (otherRect.width += otherLeft - targetLeft, otherRect.x = targetLeft);\n                    otherRight < targetRight && (otherRect.width = targetRight - otherLeft);\n                    hostRoot.splice(selectors, 1);\n                    break;\n                }\n            }\n        }\n        return hostRoot;\n    };\n    exports.findHostInstance = function(component) {\n        var fiber = component._reactInternals;\n        if (void 0 === fiber) {\n            if (\"function\" === typeof component.render) throw Error(\"Unable to find node on an unmounted component.\");\n            component = Object.keys(component).join(\",\");\n            throw Error(\"Argument appears to not be a ReactComponent. Keys: \" + component);\n        }\n        component = findCurrentHostFiber(fiber);\n        return null === component ? null : getPublicInstance(component.stateNode);\n    };\n    exports.findHostInstanceWithNoPortals = function(fiber) {\n        fiber = findCurrentFiberUsingSlowPath(fiber);\n        fiber = null !== fiber ? findCurrentHostFiberWithNoPortalsImpl(fiber) : null;\n        return null === fiber ? null : getPublicInstance(fiber.stateNode);\n    };\n    exports.findHostInstanceWithWarning = function(component, methodName) {\n        var fiber = component._reactInternals;\n        if (void 0 === fiber) {\n            if (\"function\" === typeof component.render) throw Error(\"Unable to find node on an unmounted component.\");\n            component = Object.keys(component).join(\",\");\n            throw Error(\"Argument appears to not be a ReactComponent. Keys: \" + component);\n        }\n        component = findCurrentHostFiber(fiber);\n        if (null === component) return null;\n        if (component.mode & 8) {\n            var componentName = getComponentNameFromFiber(fiber) || \"Component\";\n            didWarnAboutFindNodeInStrictMode[componentName] || (didWarnAboutFindNodeInStrictMode[componentName] = !0, runWithFiberInDEV(component, function() {\n                fiber.mode & 8 ? console.error(\"%s is deprecated in StrictMode. %s was passed an instance of %s which is inside StrictMode. Instead, add a ref directly to the element you want to reference. Learn more about using refs safely here: https://react.dev/link/strict-mode-find-node\", methodName, methodName, componentName) : console.error(\"%s is deprecated in StrictMode. %s was passed an instance of %s which renders StrictMode children. Instead, add a ref directly to the element you want to reference. Learn more about using refs safely here: https://react.dev/link/strict-mode-find-node\", methodName, methodName, componentName);\n            }));\n        }\n        return getPublicInstance(component.stateNode);\n    };\n    exports.flushPassiveEffects = flushPassiveEffects;\n    exports.flushSyncFromReconciler = function(fn) {\n        var prevExecutionContext = executionContext;\n        executionContext |= 1;\n        var prevTransition = ReactSharedInternals.T, previousPriority = getCurrentUpdatePriority();\n        try {\n            if (setCurrentUpdatePriority(2), ReactSharedInternals.T = null, fn) return fn();\n        } finally{\n            setCurrentUpdatePriority(previousPriority), ReactSharedInternals.T = prevTransition, executionContext = prevExecutionContext, (executionContext & (RenderContext | CommitContext)) === NoContext && flushSyncWorkAcrossRoots_impl(0, !1);\n        }\n    };\n    exports.flushSyncWork = flushSyncWork;\n    exports.focusWithin = function(hostRoot, selectors) {\n        if (!supportsTestSelectors) throw Error(\"Test selector API is not supported by this renderer.\");\n        hostRoot = findFiberRootForHostRoot(hostRoot);\n        selectors = findPaths(hostRoot, selectors);\n        selectors = Array.from(selectors);\n        for(hostRoot = 0; hostRoot < selectors.length;){\n            var fiber = selectors[hostRoot++], tag = fiber.tag;\n            if (!isHiddenSubtree(fiber)) {\n                if ((5 === tag || 26 === tag || 27 === tag) && setFocusIfFocusable(fiber.stateNode)) return !0;\n                for(fiber = fiber.child; null !== fiber;)selectors.push(fiber), fiber = fiber.sibling;\n            }\n        }\n        return !1;\n    };\n    exports.getFindAllNodesFailureDescription = function(hostRoot, selectors) {\n        if (!supportsTestSelectors) throw Error(\"Test selector API is not supported by this renderer.\");\n        var maxSelectorIndex = 0, matchedNames = [];\n        hostRoot = [\n            findFiberRootForHostRoot(hostRoot),\n            0\n        ];\n        for(var index = 0; index < hostRoot.length;){\n            var fiber = hostRoot[index++], tag = fiber.tag, selectorIndex = hostRoot[index++], selector = selectors[selectorIndex];\n            if (5 !== tag && 26 !== tag && 27 !== tag || !isHiddenSubtree(fiber)) {\n                if (matchSelector(fiber, selector) && (matchedNames.push(selectorToString(selector)), selectorIndex++, selectorIndex > maxSelectorIndex && (maxSelectorIndex = selectorIndex)), selectorIndex < selectors.length) for(fiber = fiber.child; null !== fiber;)hostRoot.push(fiber, selectorIndex), fiber = fiber.sibling;\n            }\n        }\n        if (maxSelectorIndex < selectors.length) {\n            for(hostRoot = []; maxSelectorIndex < selectors.length; maxSelectorIndex++)hostRoot.push(selectorToString(selectors[maxSelectorIndex]));\n            return \"findAllNodes was able to match part of the selector:\\n  \" + (matchedNames.join(\" > \") + \"\\n\\nNo matching component was found for:\\n  \") + hostRoot.join(\" > \");\n        }\n        return null;\n    };\n    exports.getPublicRootInstance = function(container) {\n        container = container.current;\n        if (!container.child) return null;\n        switch(container.child.tag){\n            case 27:\n            case 5:\n                return getPublicInstance(container.child.stateNode);\n            default:\n                return container.child.stateNode;\n        }\n    };\n    exports.injectIntoDevTools = function() {\n        var internals = {\n            bundleType: 1,\n            version: rendererVersion,\n            rendererPackageName: rendererPackageName,\n            currentDispatcherRef: ReactSharedInternals,\n            findFiberByHostInstance: getInstanceFromNode,\n            reconcilerVersion: \"19.0.0\"\n        };\n        null !== extraDevToolsConfig && (internals.rendererConfig = extraDevToolsConfig);\n        internals.overrideHookState = overrideHookState;\n        internals.overrideHookStateDeletePath = overrideHookStateDeletePath;\n        internals.overrideHookStateRenamePath = overrideHookStateRenamePath;\n        internals.overrideProps = overrideProps;\n        internals.overridePropsDeletePath = overridePropsDeletePath;\n        internals.overridePropsRenamePath = overridePropsRenamePath;\n        internals.scheduleUpdate = scheduleUpdate;\n        internals.setErrorHandler = setErrorHandler;\n        internals.setSuspenseHandler = setSuspenseHandler;\n        internals.scheduleRefresh = scheduleRefresh;\n        internals.scheduleRoot = scheduleRoot;\n        internals.setRefreshHandler = setRefreshHandler;\n        internals.getCurrentFiber = getCurrentFiberForDevTools;\n        internals.getLaneLabelMap = getLaneLabelMap;\n        internals.injectProfilingHooks = injectProfilingHooks;\n        return injectInternals(internals);\n    };\n    exports.isAlreadyRendering = function() {\n        return (executionContext & (RenderContext | CommitContext)) !== NoContext;\n    };\n    exports.observeVisibleRects = function(hostRoot, selectors, callback, options) {\n        function commitHook() {\n            var nextInstanceRoots = findAllNodes(hostRoot, selectors);\n            instanceRoots.forEach(function(target) {\n                0 > nextInstanceRoots.indexOf(target) && unobserve(target);\n            });\n            nextInstanceRoots.forEach(function(target) {\n                0 > instanceRoots.indexOf(target) && observe(target);\n            });\n        }\n        if (!supportsTestSelectors) throw Error(\"Test selector API is not supported by this renderer.\");\n        var instanceRoots = findAllNodes(hostRoot, selectors);\n        callback = setupIntersectionObserver(instanceRoots, callback, options);\n        var disconnect = callback.disconnect, observe = callback.observe, unobserve = callback.unobserve;\n        commitHooks.push(commitHook);\n        return {\n            disconnect: function() {\n                var index = commitHooks.indexOf(commitHook);\n                0 <= index && commitHooks.splice(index, 1);\n                disconnect();\n            }\n        };\n    };\n    exports.shouldError = function(fiber) {\n        return shouldErrorImpl(fiber);\n    };\n    exports.shouldSuspend = function(fiber) {\n        return shouldSuspendImpl(fiber);\n    };\n    exports.startHostTransition = function(formFiber, pendingState, action, formData) {\n        if (5 !== formFiber.tag) throw Error(\"Expected the form instance to be a HostComponent. This is a bug in React.\");\n        var queue = ensureFormComponentIsStateful(formFiber).queue;\n        startTransition(formFiber, queue, pendingState, NotPendingTransition, null === action ? noop : function() {\n            null === ReactSharedInternals.T && console.error(\"requestFormReset was called outside a transition or action. To fix, move to an action, or wrap with startTransition.\");\n            var resetStateQueue = ensureFormComponentIsStateful(formFiber).next.queue;\n            dispatchSetStateInternal(formFiber, resetStateQueue, {}, requestUpdateLane(formFiber));\n            return action(formData);\n        });\n    };\n    exports.updateContainer = function(element, container, parentComponent, callback) {\n        var current = container.current, lane = requestUpdateLane(current);\n        updateContainerImpl(current, lane, element, container, parentComponent, callback);\n        return lane;\n    };\n    exports.updateContainerSync = updateContainerSync;\n    return exports;\n}, module.exports[\"default\"] = module.exports, Object.defineProperty(module.exports, \"__esModule\", {\n    value: !0\n}));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmVhY3QtcmVjb25jaWxlci9janMvcmVhY3QtcmVjb25jaWxlci5kZXZlbG9wbWVudC5qcyIsIm1hcHBpbmdzIjoiQUFBQTs7Ozs7Ozs7Q0FRQyxHQUVZO0FBQ2IsS0FVK0MsSUFUNUMsUUFBUUMsT0FBTyxHQUFHLFNBQVVDLFNBQVM7SUFDcEMsU0FBU0MsU0FBU0MsS0FBSyxFQUFFQyxFQUFFO1FBQ3pCLElBQUtELFFBQVFBLE1BQU1FLGFBQWEsRUFBRSxTQUFTRixTQUFTLElBQUlDLElBQ3RELFFBQVNELE1BQU1HLElBQUksRUFBR0Y7UUFDeEIsT0FBT0Q7SUFDVDtJQUNBLFNBQVNJLGdCQUFnQkMsR0FBRyxFQUFFQyxJQUFJLEVBQUVDLEtBQUssRUFBRUMsS0FBSztRQUM5QyxJQUFJRCxTQUFTRCxLQUFLRyxNQUFNLEVBQUUsT0FBT0Q7UUFDakMsSUFBSUUsTUFBTUosSUFBSSxDQUFDQyxNQUFNLEVBQ25CSSxVQUFVQyxZQUFZUCxPQUFPQSxJQUFJUSxLQUFLLEtBQUtDLE9BQU8sQ0FBQyxHQUFHVDtRQUN4RE0sT0FBTyxDQUFDRCxJQUFJLEdBQUdOLGdCQUFnQkMsR0FBRyxDQUFDSyxJQUFJLEVBQUVKLE1BQU1DLFFBQVEsR0FBR0M7UUFDMUQsT0FBT0c7SUFDVDtJQUNBLFNBQVNJLGVBQWVWLEdBQUcsRUFBRVcsT0FBTyxFQUFFQyxPQUFPO1FBQzNDLElBQUlELFFBQVFQLE1BQU0sS0FBS1EsUUFBUVIsTUFBTSxFQUNuQ1MsUUFBUUMsSUFBSSxDQUFDO2FBQ1Y7WUFDSCxJQUFLLElBQUlDLElBQUksR0FBR0EsSUFBSUgsUUFBUVIsTUFBTSxHQUFHLEdBQUdXLElBQ3RDLElBQUlKLE9BQU8sQ0FBQ0ksRUFBRSxLQUFLSCxPQUFPLENBQUNHLEVBQUUsRUFBRTtnQkFDN0JGLFFBQVFDLElBQUksQ0FDVjtnQkFFRjtZQUNGO1lBQ0YsT0FBT0UsbUJBQW1CaEIsS0FBS1csU0FBU0MsU0FBUztRQUNuRDtJQUNGO0lBQ0EsU0FB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QkFBcUJ1dEIsQ0FBQyxJQUM3QnQwQixRQUFRZ0MsS0FBSyxDQUNYO1lBRUosSUFBSXl3RCxrQkFDRm42Qiw4QkFBOEJDLFdBQVd0NUIsSUFBSSxDQUFDcWIsS0FBSztZQUNyRDhkLHlCQUNFRyxXQUNBazZCLGlCQUNBLENBQUMsR0FDRHA2QixrQkFBa0JFO1lBRXBCLE9BQU9qSSxPQUFPa2lDO1FBQ2hCO0lBRVI7SUFDQTd6RCxRQUFRK3pELGVBQWUsR0FBRyxTQUN4QjF4RCxPQUFPLEVBQ1AycEMsU0FBUyxFQUNUc2EsZUFBZSxFQUNmOTdDLFFBQVE7UUFFUixJQUFJdkgsVUFBVStvQyxVQUFVL29DLE9BQU8sRUFDN0IrSixPQUFPMHNCLGtCQUFrQnoyQjtRQUMzQnNqRCxvQkFDRXRqRCxTQUNBK0osTUFDQTNLLFNBQ0EycEMsV0FDQXNhLGlCQUNBOTdDO1FBRUYsT0FBT3dDO0lBQ1Q7SUFDQWhOLFFBQVF3QyxtQkFBbUIsR0FBR0E7SUFDOUIsT0FBT3hDO0FBQ1QsR0FDQ0QseUJBQXNCLEdBQUdBLE9BQU9DLE9BQU8sRUFDeENnSCxPQUFPeUIsY0FBYyxDQUFDMUksT0FBT0MsT0FBTyxFQUFFLGNBQWM7SUFBRVcsT0FBTyxDQUFDO0FBQUUsRUFBQyIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxSYXZpc2ggU2luZ2hcXEVDT0ZcXGVjb1xcZWNvLWN5Y2xlXFxub2RlX21vZHVsZXNcXHJlYWN0LXJlY29uY2lsZXJcXGNqc1xccmVhY3QtcmVjb25jaWxlci5kZXZlbG9wbWVudC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBsaWNlbnNlIFJlYWN0XG4gKiByZWFjdC1yZWNvbmNpbGVyLmRldmVsb3BtZW50LmpzXG4gKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG5cInVzZSBzdHJpY3RcIjtcblwicHJvZHVjdGlvblwiICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOViAmJlxuICAoKG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKCQkJGNvbmZpZykge1xuICAgIGZ1bmN0aW9uIGZpbmRIb29rKGZpYmVyLCBpZCkge1xuICAgICAgZm9yIChmaWJlciA9IGZpYmVyLm1lbW9pemVkU3RhdGU7IG51bGwgIT09IGZpYmVyICYmIDAgPCBpZDsgKVxuICAgICAgICAoZmliZXIgPSBmaWJlci5uZXh0KSwgaWQtLTtcbiAgICAgIHJldHVybiBmaWJlcjtcbiAgICB9XG4gICAgZnVuY3Rpb24gY29weVdpdGhTZXRJbXBsKG9iaiwgcGF0aCwgaW5kZXgsIHZhbHVlKSB7XG4gICAgICBpZiAoaW5kZXggPj0gcGF0aC5sZW5ndGgpIHJldHVybiB2YWx1ZTtcbiAgICAgIHZhciBrZXkgPSBwYXRoW2luZGV4XSxcbiAgICAgICAgdXBkYXRlZCA9IGlzQXJyYXlJbXBsKG9iaikgPyBvYmouc2xpY2UoKSA6IGFzc2lnbih7fSwgb2JqKTtcbiAgICAgIHVwZGF0ZWRba2V5XSA9IGNvcHlXaXRoU2V0SW1wbChvYmpba2V5XSwgcGF0aCwgaW5kZXggKyAxLCB2YWx1ZSk7XG4gICAgICByZXR1cm4gdXBkYXRlZDtcbiAgICB9XG4gICAgZnVuY3Rpb24gY29weVdpdGhSZW5hbWUob2JqLCBvbGRQYXRoLCBuZXdQYXRoKSB7XG4gICAgICBpZiAob2xkUGF0aC5sZW5ndGggIT09IG5ld1BhdGgubGVuZ3RoKVxuICAgICAgICBjb25zb2xlLndhcm4oXCJjb3B5V2l0aFJlbmFtZSgpIGV4cGVjdHMgcGF0aHMgb2YgdGhlIHNhbWUgbGVuZ3RoXCIpO1xuICAgICAgZWxzZSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbmV3UGF0aC5sZW5ndGggLSAxOyBpKyspXG4gICAgICAgICAgaWYgKG9sZFBhdGhbaV0gIT09IG5ld1BhdGhbaV0pIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgICAgICAgXCJjb3B5V2l0aFJlbmFtZSgpIGV4cGVjdHMgcGF0aHMgdG8gYmUgdGhlIHNhbWUgZXhjZXB0IGZvciB0aGUgZGVlcGVzdCBrZXlcIlxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgIHJldHVybiBjb3B5V2l0aFJlbmFtZUltcGwob2JqLCBvbGRQYXRoLCBuZXdQYXRoLCAwKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gY29weVdpdGhSZW5hbWVJbXBsKG9iaiwgb2xkUGF0aCwgbmV3UGF0aCwgaW5kZXgpIHtcbiAgICAgIHZhciBvbGRLZXkgPSBvbGRQYXRoW2luZGV4XSxcbiAgICAgICAgdXBkYXRlZCA9IGlzQXJyYXlJbXBsKG9iaikgPyBvYmouc2xpY2UoKSA6IGFzc2lnbih7fSwgb2JqKTtcbiAgICAgIGluZGV4ICsgMSA9PT0gb2xkUGF0aC5sZW5ndGhcbiAgICAgICAgPyAoKHVwZGF0ZWRbbmV3UGF0aFtpbmRleF1dID0gdXBkYXRlZFtvbGRLZXldKSxcbiAgICAgICAgICBpc0FycmF5SW1wbCh1cGRhdGVkKVxuICAgICAgICAgICAgPyB1cGRhdGVkLnNwbGljZShvbGRLZXksIDEpXG4gICAgICAgICAgICA6IGRlbGV0ZSB1cGRhdGVkW29sZEtleV0pXG4gICAgICAgIDogKHVwZGF0ZWRbb2xkS2V5XSA9IGNvcHlXaXRoUmVuYW1lSW1wbChcbiAgICAgICAgICAgIG9ialtvbGRLZXldLFxuICAgICAgICAgICAgb2xkUGF0aCxcbiAgICAgICAgICAgIG5ld1BhdGgsXG4gICAgICAgICAgICBpbmRleCArIDFcbiAgICAgICAgICApKTtcbiAgICAgIHJldHVybiB1cGRhdGVkO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjb3B5V2l0aERlbGV0ZUltcGwob2JqLCBwYXRoLCBpbmRleCkge1xuICAgICAgdmFyIGtleSA9IHBhdGhbaW5kZXhdLFxuICAgICAgICB1cGRhdGVkID0gaXNBcnJheUltcGwob2JqKSA/IG9iai5zbGljZSgpIDogYXNzaWduKHt9LCBvYmopO1xuICAgICAgaWYgKGluZGV4ICsgMSA9PT0gcGF0aC5sZW5ndGgpXG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgaXNBcnJheUltcGwodXBkYXRlZCkgPyB1cGRhdGVkLnNwbGljZShrZXksIDEpIDogZGVsZXRlIHVwZGF0ZWRba2V5XSxcbiAgICAgICAgICB1cGRhdGVkXG4gICAgICAgICk7XG4gICAgICB1cGRhdGVkW2tleV0gPSBjb3B5V2l0aERlbGV0ZUltcGwob2JqW2tleV0sIHBhdGgsIGluZGV4ICsgMSk7XG4gICAgICByZXR1cm4gdXBkYXRlZDtcbiAgICB9XG4gICAgZnVuY3Rpb24gc2hvdWxkU3VzcGVuZEltcGwoKSB7XG4gICAgICByZXR1cm4gITE7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHNob3VsZEVycm9ySW1wbCgpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjcmVhdGVGaWJlcih0YWcsIHBlbmRpbmdQcm9wcywga2V5LCBtb2RlKSB7XG4gICAgICByZXR1cm4gbmV3IEZpYmVyTm9kZSh0YWcsIHBlbmRpbmdQcm9wcywga2V5LCBtb2RlKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gc2NoZWR1bGVSb290KHJvb3QsIGVsZW1lbnQpIHtcbiAgICAgIHJvb3QuY29udGV4dCA9PT0gZW1wdHlDb250ZXh0T2JqZWN0ICYmXG4gICAgICAgICh1cGRhdGVDb250YWluZXJTeW5jKGVsZW1lbnQsIHJvb3QsIG51bGwsIG51bGwpLCBmbHVzaFN5bmNXb3JrKCkpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBzY2hlZHVsZVJlZnJlc2gocm9vdCwgdXBkYXRlKSB7XG4gICAgICBpZiAobnVsbCAhPT0gcmVzb2x2ZUZhbWlseSkge1xuICAgICAgICB2YXIgc3RhbGVGYW1pbGllcyA9IHVwZGF0ZS5zdGFsZUZhbWlsaWVzO1xuICAgICAgICB1cGRhdGUgPSB1cGRhdGUudXBkYXRlZEZhbWlsaWVzO1xuICAgICAgICBmbHVzaFBhc3NpdmVFZmZlY3RzKCk7XG4gICAgICAgIHNjaGVkdWxlRmliZXJzV2l0aEZhbWlsaWVzUmVjdXJzaXZlbHkoXG4gICAgICAgICAgcm9vdC5jdXJyZW50LFxuICAgICAgICAgIHVwZGF0ZSxcbiAgICAgICAgICBzdGFsZUZhbWlsaWVzXG4gICAgICAgICk7XG4gICAgICAgIGZsdXNoU3luY1dvcmsoKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gc2V0UmVmcmVzaEhhbmRsZXIoaGFuZGxlcikge1xuICAgICAgcmVzb2x2ZUZhbWlseSA9IGhhbmRsZXI7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHdhcm5JbnZhbGlkSG9va0FjY2VzcygpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgIFwiRG8gbm90IGNhbGwgSG9va3MgaW5zaWRlIHVzZUVmZmVjdCguLi4pLCB1c2VNZW1vKC4uLiksIG9yIG90aGVyIGJ1aWx0LWluIEhvb2tzLiBZb3UgY2FuIG9ubHkgY2FsbCBIb29rcyBhdCB0aGUgdG9wIGxldmVsIG9mIHlvdXIgUmVhY3QgZnVuY3Rpb24uIEZvciBtb3JlIGluZm9ybWF0aW9uLCBzZWUgaHR0cHM6Ly9yZWFjdC5kZXYvbGluay9ydWxlcy1vZi1ob29rc1wiXG4gICAgICApO1xuICAgIH1cbiAgICBmdW5jdGlvbiB3YXJuSW52YWxpZENvbnRleHRBY2Nlc3MoKSB7XG4gICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICBcIkNvbnRleHQgY2FuIG9ubHkgYmUgcmVhZCB3aGlsZSBSZWFjdCBpcyByZW5kZXJpbmcuIEluIGNsYXNzZXMsIHlvdSBjYW4gcmVhZCBpdCBpbiB0aGUgcmVuZGVyIG1ldGhvZCBvciBnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMuIEluIGZ1bmN0aW9uIGNvbXBvbmVudHMsIHlvdSBjYW4gcmVhZCBpdCBkaXJlY3RseSBpbiB0aGUgZnVuY3Rpb24gYm9keSwgYnV0IG5vdCBpbnNpZGUgSG9va3MgbGlrZSB1c2VSZWR1Y2VyKCkgb3IgdXNlTWVtbygpLlwiXG4gICAgICApO1xuICAgIH1cbiAgICBmdW5jdGlvbiBub29wKCkge31cbiAgICBmdW5jdGlvbiB3YXJuRm9yTWlzc2luZ0tleSgpIHt9XG4gICAgZnVuY3Rpb24gc2V0VG9Tb3J0ZWRTdHJpbmcoc2V0KSB7XG4gICAgICB2YXIgYXJyYXkgPSBbXTtcbiAgICAgIHNldC5mb3JFYWNoKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICBhcnJheS5wdXNoKHZhbHVlKTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIGFycmF5LnNvcnQoKS5qb2luKFwiLCBcIik7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGdldEl0ZXJhdG9yRm4obWF5YmVJdGVyYWJsZSkge1xuICAgICAgaWYgKG51bGwgPT09IG1heWJlSXRlcmFibGUgfHwgXCJvYmplY3RcIiAhPT0gdHlwZW9mIG1heWJlSXRlcmFibGUpXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgbWF5YmVJdGVyYWJsZSA9XG4gICAgICAgIChNQVlCRV9JVEVSQVRPUl9TWU1CT0wgJiYgbWF5YmVJdGVyYWJsZVtNQVlCRV9JVEVSQVRPUl9TWU1CT0xdKSB8fFxuICAgICAgICBtYXliZUl0ZXJhYmxlW1wiQEBpdGVyYXRvclwiXTtcbiAgICAgIHJldHVybiBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBtYXliZUl0ZXJhYmxlID8gbWF5YmVJdGVyYWJsZSA6IG51bGw7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSh0eXBlKSB7XG4gICAgICBpZiAobnVsbCA9PSB0eXBlKSByZXR1cm4gbnVsbDtcbiAgICAgIGlmIChcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiB0eXBlKVxuICAgICAgICByZXR1cm4gdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfQ0xJRU5UX1JFRkVSRU5DRVxuICAgICAgICAgID8gbnVsbFxuICAgICAgICAgIDogdHlwZS5kaXNwbGF5TmFtZSB8fCB0eXBlLm5hbWUgfHwgbnVsbDtcbiAgICAgIGlmIChcInN0cmluZ1wiID09PSB0eXBlb2YgdHlwZSkgcmV0dXJuIHR5cGU7XG4gICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgY2FzZSBSRUFDVF9GUkFHTUVOVF9UWVBFOlxuICAgICAgICAgIHJldHVybiBcIkZyYWdtZW50XCI7XG4gICAgICAgIGNhc2UgUkVBQ1RfUE9SVEFMX1RZUEU6XG4gICAgICAgICAgcmV0dXJuIFwiUG9ydGFsXCI7XG4gICAgICAgIGNhc2UgUkVBQ1RfUFJPRklMRVJfVFlQRTpcbiAgICAgICAgICByZXR1cm4gXCJQcm9maWxlclwiO1xuICAgICAgICBjYXNlIFJFQUNUX1NUUklDVF9NT0RFX1RZUEU6XG4gICAgICAgICAgcmV0dXJuIFwiU3RyaWN0TW9kZVwiO1xuICAgICAgICBjYXNlIFJFQUNUX1NVU1BFTlNFX1RZUEU6XG4gICAgICAgICAgcmV0dXJuIFwiU3VzcGVuc2VcIjtcbiAgICAgICAgY2FzZSBSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEU6XG4gICAgICAgICAgcmV0dXJuIFwiU3VzcGVuc2VMaXN0XCI7XG4gICAgICB9XG4gICAgICBpZiAoXCJvYmplY3RcIiA9PT0gdHlwZW9mIHR5cGUpXG4gICAgICAgIHN3aXRjaCAoXG4gICAgICAgICAgKFwibnVtYmVyXCIgPT09IHR5cGVvZiB0eXBlLnRhZyAmJlxuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgXCJSZWNlaXZlZCBhbiB1bmV4cGVjdGVkIG9iamVjdCBpbiBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoKS4gVGhpcyBpcyBsaWtlbHkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLlwiXG4gICAgICAgICAgICApLFxuICAgICAgICAgIHR5cGUuJCR0eXBlb2YpXG4gICAgICAgICkge1xuICAgICAgICAgIGNhc2UgUkVBQ1RfQ09OVEVYVF9UWVBFOlxuICAgICAgICAgICAgcmV0dXJuICh0eXBlLmRpc3BsYXlOYW1lIHx8IFwiQ29udGV4dFwiKSArIFwiLlByb3ZpZGVyXCI7XG4gICAgICAgICAgY2FzZSBSRUFDVF9DT05TVU1FUl9UWVBFOlxuICAgICAgICAgICAgcmV0dXJuICh0eXBlLl9jb250ZXh0LmRpc3BsYXlOYW1lIHx8IFwiQ29udGV4dFwiKSArIFwiLkNvbnN1bWVyXCI7XG4gICAgICAgICAgY2FzZSBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFOlxuICAgICAgICAgICAgdmFyIGlubmVyVHlwZSA9IHR5cGUucmVuZGVyO1xuICAgICAgICAgICAgdHlwZSA9IHR5cGUuZGlzcGxheU5hbWU7XG4gICAgICAgICAgICB0eXBlIHx8XG4gICAgICAgICAgICAgICgodHlwZSA9IGlubmVyVHlwZS5kaXNwbGF5TmFtZSB8fCBpbm5lclR5cGUubmFtZSB8fCBcIlwiKSxcbiAgICAgICAgICAgICAgKHR5cGUgPSBcIlwiICE9PSB0eXBlID8gXCJGb3J3YXJkUmVmKFwiICsgdHlwZSArIFwiKVwiIDogXCJGb3J3YXJkUmVmXCIpKTtcbiAgICAgICAgICAgIHJldHVybiB0eXBlO1xuICAgICAgICAgIGNhc2UgUkVBQ1RfTUVNT19UWVBFOlxuICAgICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICAgKGlubmVyVHlwZSA9IHR5cGUuZGlzcGxheU5hbWUgfHwgbnVsbCksXG4gICAgICAgICAgICAgIG51bGwgIT09IGlubmVyVHlwZVxuICAgICAgICAgICAgICAgID8gaW5uZXJUeXBlXG4gICAgICAgICAgICAgICAgOiBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUodHlwZS50eXBlKSB8fCBcIk1lbW9cIlxuICAgICAgICAgICAgKTtcbiAgICAgICAgICBjYXNlIFJFQUNUX0xBWllfVFlQRTpcbiAgICAgICAgICAgIGlubmVyVHlwZSA9IHR5cGUuX3BheWxvYWQ7XG4gICAgICAgICAgICB0eXBlID0gdHlwZS5faW5pdDtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIHJldHVybiBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUodHlwZShpbm5lclR5cGUpKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKHgpIHt9XG4gICAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBmdW5jdGlvbiBnZXRDb21wb25lbnROYW1lRnJvbUZpYmVyKGZpYmVyKSB7XG4gICAgICB2YXIgdHlwZSA9IGZpYmVyLnR5cGU7XG4gICAgICBzd2l0Y2ggKGZpYmVyLnRhZykge1xuICAgICAgICBjYXNlIDI0OlxuICAgICAgICAgIHJldHVybiBcIkNhY2hlXCI7XG4gICAgICAgIGNhc2UgOTpcbiAgICAgICAgICByZXR1cm4gKHR5cGUuX2NvbnRleHQuZGlzcGxheU5hbWUgfHwgXCJDb250ZXh0XCIpICsgXCIuQ29uc3VtZXJcIjtcbiAgICAgICAgY2FzZSAxMDpcbiAgICAgICAgICByZXR1cm4gKHR5cGUuZGlzcGxheU5hbWUgfHwgXCJDb250ZXh0XCIpICsgXCIuUHJvdmlkZXJcIjtcbiAgICAgICAgY2FzZSAxODpcbiAgICAgICAgICByZXR1cm4gXCJEZWh5ZHJhdGVkRnJhZ21lbnRcIjtcbiAgICAgICAgY2FzZSAxMTpcbiAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgKGZpYmVyID0gdHlwZS5yZW5kZXIpLFxuICAgICAgICAgICAgKGZpYmVyID0gZmliZXIuZGlzcGxheU5hbWUgfHwgZmliZXIubmFtZSB8fCBcIlwiKSxcbiAgICAgICAgICAgIHR5cGUuZGlzcGxheU5hbWUgfHxcbiAgICAgICAgICAgICAgKFwiXCIgIT09IGZpYmVyID8gXCJGb3J3YXJkUmVmKFwiICsgZmliZXIgKyBcIilcIiA6IFwiRm9yd2FyZFJlZlwiKVxuICAgICAgICAgICk7XG4gICAgICAgIGNhc2UgNzpcbiAgICAgICAgICByZXR1cm4gXCJGcmFnbWVudFwiO1xuICAgICAgICBjYXNlIDI2OlxuICAgICAgICBjYXNlIDI3OlxuICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgcmV0dXJuIHR5cGU7XG4gICAgICAgIGNhc2UgNDpcbiAgICAgICAgICByZXR1cm4gXCJQb3J0YWxcIjtcbiAgICAgICAgY2FzZSAzOlxuICAgICAgICAgIHJldHVybiBcIlJvb3RcIjtcbiAgICAgICAgY2FzZSA2OlxuICAgICAgICAgIHJldHVybiBcIlRleHRcIjtcbiAgICAgICAgY2FzZSAxNjpcbiAgICAgICAgICByZXR1cm4gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUpO1xuICAgICAgICBjYXNlIDg6XG4gICAgICAgICAgcmV0dXJuIHR5cGUgPT09IFJFQUNUX1NUUklDVF9NT0RFX1RZUEUgPyBcIlN0cmljdE1vZGVcIiA6IFwiTW9kZVwiO1xuICAgICAgICBjYXNlIDIyOlxuICAgICAgICAgIHJldHVybiBcIk9mZnNjcmVlblwiO1xuICAgICAgICBjYXNlIDEyOlxuICAgICAgICAgIHJldHVybiBcIlByb2ZpbGVyXCI7XG4gICAgICAgIGNhc2UgMjE6XG4gICAgICAgICAgcmV0dXJuIFwiU2NvcGVcIjtcbiAgICAgICAgY2FzZSAxMzpcbiAgICAgICAgICByZXR1cm4gXCJTdXNwZW5zZVwiO1xuICAgICAgICBjYXNlIDE5OlxuICAgICAgICAgIHJldHVybiBcIlN1c3BlbnNlTGlzdFwiO1xuICAgICAgICBjYXNlIDI1OlxuICAgICAgICAgIHJldHVybiBcIlRyYWNpbmdNYXJrZXJcIjtcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICBjYXNlIDA6XG4gICAgICAgIGNhc2UgMTQ6XG4gICAgICAgIGNhc2UgMTU6XG4gICAgICAgICAgaWYgKFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIHR5cGUpXG4gICAgICAgICAgICByZXR1cm4gdHlwZS5kaXNwbGF5TmFtZSB8fCB0eXBlLm5hbWUgfHwgbnVsbDtcbiAgICAgICAgICBpZiAoXCJzdHJpbmdcIiA9PT0gdHlwZW9mIHR5cGUpIHJldHVybiB0eXBlO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDI5OlxuICAgICAgICAgIHR5cGUgPSBmaWJlci5fZGVidWdJbmZvO1xuICAgICAgICAgIGlmIChudWxsICE9IHR5cGUpXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gdHlwZS5sZW5ndGggLSAxOyAwIDw9IGk7IGktLSlcbiAgICAgICAgICAgICAgaWYgKFwic3RyaW5nXCIgPT09IHR5cGVvZiB0eXBlW2ldLm5hbWUpIHJldHVybiB0eXBlW2ldLm5hbWU7XG4gICAgICAgICAgaWYgKG51bGwgIT09IGZpYmVyLnJldHVybilcbiAgICAgICAgICAgIHJldHVybiBnZXRDb21wb25lbnROYW1lRnJvbUZpYmVyKGZpYmVyLnJldHVybik7XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgZnVuY3Rpb24gZGlzYWJsZWRMb2coKSB7fVxuICAgIGZ1bmN0aW9uIGRpc2FibGVMb2dzKCkge1xuICAgICAgaWYgKDAgPT09IGRpc2FibGVkRGVwdGgpIHtcbiAgICAgICAgcHJldkxvZyA9IGNvbnNvbGUubG9nO1xuICAgICAgICBwcmV2SW5mbyA9IGNvbnNvbGUuaW5mbztcbiAgICAgICAgcHJldldhcm4gPSBjb25zb2xlLndhcm47XG4gICAgICAgIHByZXZFcnJvciA9IGNvbnNvbGUuZXJyb3I7XG4gICAgICAgIHByZXZHcm91cCA9IGNvbnNvbGUuZ3JvdXA7XG4gICAgICAgIHByZXZHcm91cENvbGxhcHNlZCA9IGNvbnNvbGUuZ3JvdXBDb2xsYXBzZWQ7XG4gICAgICAgIHByZXZHcm91cEVuZCA9IGNvbnNvbGUuZ3JvdXBFbmQ7XG4gICAgICAgIHZhciBwcm9wcyA9IHtcbiAgICAgICAgICBjb25maWd1cmFibGU6ICEwLFxuICAgICAgICAgIGVudW1lcmFibGU6ICEwLFxuICAgICAgICAgIHZhbHVlOiBkaXNhYmxlZExvZyxcbiAgICAgICAgICB3cml0YWJsZTogITBcbiAgICAgICAgfTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoY29uc29sZSwge1xuICAgICAgICAgIGluZm86IHByb3BzLFxuICAgICAgICAgIGxvZzogcHJvcHMsXG4gICAgICAgICAgd2FybjogcHJvcHMsXG4gICAgICAgICAgZXJyb3I6IHByb3BzLFxuICAgICAgICAgIGdyb3VwOiBwcm9wcyxcbiAgICAgICAgICBncm91cENvbGxhcHNlZDogcHJvcHMsXG4gICAgICAgICAgZ3JvdXBFbmQ6IHByb3BzXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgZGlzYWJsZWREZXB0aCsrO1xuICAgIH1cbiAgICBmdW5jdGlvbiByZWVuYWJsZUxvZ3MoKSB7XG4gICAgICBkaXNhYmxlZERlcHRoLS07XG4gICAgICBpZiAoMCA9PT0gZGlzYWJsZWREZXB0aCkge1xuICAgICAgICB2YXIgcHJvcHMgPSB7IGNvbmZpZ3VyYWJsZTogITAsIGVudW1lcmFibGU6ICEwLCB3cml0YWJsZTogITAgfTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoY29uc29sZSwge1xuICAgICAgICAgIGxvZzogYXNzaWduKHt9LCBwcm9wcywgeyB2YWx1ZTogcHJldkxvZyB9KSxcbiAgICAgICAgICBpbmZvOiBhc3NpZ24oe30sIHByb3BzLCB7IHZhbHVlOiBwcmV2SW5mbyB9KSxcbiAgICAgICAgICB3YXJuOiBhc3NpZ24oe30sIHByb3BzLCB7IHZhbHVlOiBwcmV2V2FybiB9KSxcbiAgICAgICAgICBlcnJvcjogYXNzaWduKHt9LCBwcm9wcywgeyB2YWx1ZTogcHJldkVycm9yIH0pLFxuICAgICAgICAgIGdyb3VwOiBhc3NpZ24oe30sIHByb3BzLCB7IHZhbHVlOiBwcmV2R3JvdXAgfSksXG4gICAgICAgICAgZ3JvdXBDb2xsYXBzZWQ6IGFzc2lnbih7fSwgcHJvcHMsIHsgdmFsdWU6IHByZXZHcm91cENvbGxhcHNlZCB9KSxcbiAgICAgICAgICBncm91cEVuZDogYXNzaWduKHt9LCBwcm9wcywgeyB2YWx1ZTogcHJldkdyb3VwRW5kIH0pXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgMCA+IGRpc2FibGVkRGVwdGggJiZcbiAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICBcImRpc2FibGVkRGVwdGggZmVsbCBiZWxvdyB6ZXJvLiBUaGlzIGlzIGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS5cIlxuICAgICAgICApO1xuICAgIH1cbiAgICBmdW5jdGlvbiBkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZShuYW1lKSB7XG4gICAgICBpZiAodm9pZCAwID09PSBwcmVmaXgpXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgdGhyb3cgRXJyb3IoKTtcbiAgICAgICAgfSBjYXRjaCAoeCkge1xuICAgICAgICAgIHZhciBtYXRjaCA9IHguc3RhY2sudHJpbSgpLm1hdGNoKC9cXG4oICooYXQgKT8pLyk7XG4gICAgICAgICAgcHJlZml4ID0gKG1hdGNoICYmIG1hdGNoWzFdKSB8fCBcIlwiO1xuICAgICAgICAgIHN1ZmZpeCA9XG4gICAgICAgICAgICAtMSA8IHguc3RhY2suaW5kZXhPZihcIlxcbiAgICBhdFwiKVxuICAgICAgICAgICAgICA/IFwiICg8YW5vbnltb3VzPilcIlxuICAgICAgICAgICAgICA6IC0xIDwgeC5zdGFjay5pbmRleE9mKFwiQFwiKVxuICAgICAgICAgICAgICAgID8gXCJAdW5rbm93bjowOjBcIlxuICAgICAgICAgICAgICAgIDogXCJcIjtcbiAgICAgICAgfVxuICAgICAgcmV0dXJuIFwiXFxuXCIgKyBwcmVmaXggKyBuYW1lICsgc3VmZml4O1xuICAgIH1cbiAgICBmdW5jdGlvbiBkZXNjcmliZU5hdGl2ZUNvbXBvbmVudEZyYW1lKGZuLCBjb25zdHJ1Y3QpIHtcbiAgICAgIGlmICghZm4gfHwgcmVlbnRyeSkgcmV0dXJuIFwiXCI7XG4gICAgICB2YXIgZnJhbWUgPSBjb21wb25lbnRGcmFtZUNhY2hlLmdldChmbik7XG4gICAgICBpZiAodm9pZCAwICE9PSBmcmFtZSkgcmV0dXJuIGZyYW1lO1xuICAgICAgcmVlbnRyeSA9ICEwO1xuICAgICAgZnJhbWUgPSBFcnJvci5wcmVwYXJlU3RhY2tUcmFjZTtcbiAgICAgIEVycm9yLnByZXBhcmVTdGFja1RyYWNlID0gdm9pZCAwO1xuICAgICAgdmFyIHByZXZpb3VzRGlzcGF0Y2hlciA9IG51bGw7XG4gICAgICBwcmV2aW91c0Rpc3BhdGNoZXIgPSBSZWFjdFNoYXJlZEludGVybmFscy5IO1xuICAgICAgUmVhY3RTaGFyZWRJbnRlcm5hbHMuSCA9IG51bGw7XG4gICAgICBkaXNhYmxlTG9ncygpO1xuICAgICAgdHJ5IHtcbiAgICAgICAgdmFyIFJ1bkluUm9vdEZyYW1lID0ge1xuICAgICAgICAgIERldGVybWluZUNvbXBvbmVudEZyYW1lUm9vdDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgaWYgKGNvbnN0cnVjdCkge1xuICAgICAgICAgICAgICAgIHZhciBGYWtlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShGYWtlLnByb3RvdHlwZSwgXCJwcm9wc1wiLCB7XG4gICAgICAgICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBpZiAoXCJvYmplY3RcIiA9PT0gdHlwZW9mIFJlZmxlY3QgJiYgUmVmbGVjdC5jb25zdHJ1Y3QpIHtcbiAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIFJlZmxlY3QuY29uc3RydWN0KEZha2UsIFtdKTtcbiAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNvbnRyb2wgPSB4O1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgUmVmbGVjdC5jb25zdHJ1Y3QoZm4sIFtdLCBGYWtlKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgRmFrZS5jYWxsKCk7XG4gICAgICAgICAgICAgICAgICB9IGNhdGNoICh4JDApIHtcbiAgICAgICAgICAgICAgICAgICAgY29udHJvbCA9IHgkMDtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGZuLmNhbGwoRmFrZS5wcm90b3R5cGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoKTtcbiAgICAgICAgICAgICAgICB9IGNhdGNoICh4JDEpIHtcbiAgICAgICAgICAgICAgICAgIGNvbnRyb2wgPSB4JDE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIChGYWtlID0gZm4oKSkgJiZcbiAgICAgICAgICAgICAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIEZha2UuY2F0Y2ggJiZcbiAgICAgICAgICAgICAgICAgIEZha2UuY2F0Y2goZnVuY3Rpb24gKCkge30pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGNhdGNoIChzYW1wbGUpIHtcbiAgICAgICAgICAgICAgaWYgKHNhbXBsZSAmJiBjb250cm9sICYmIFwic3RyaW5nXCIgPT09IHR5cGVvZiBzYW1wbGUuc3RhY2spXG4gICAgICAgICAgICAgICAgcmV0dXJuIFtzYW1wbGUuc3RhY2ssIGNvbnRyb2wuc3RhY2tdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIFtudWxsLCBudWxsXTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIFJ1bkluUm9vdEZyYW1lLkRldGVybWluZUNvbXBvbmVudEZyYW1lUm9vdC5kaXNwbGF5TmFtZSA9XG4gICAgICAgICAgXCJEZXRlcm1pbmVDb21wb25lbnRGcmFtZVJvb3RcIjtcbiAgICAgICAgdmFyIG5hbWVQcm9wRGVzY3JpcHRvciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoXG4gICAgICAgICAgUnVuSW5Sb290RnJhbWUuRGV0ZXJtaW5lQ29tcG9uZW50RnJhbWVSb290LFxuICAgICAgICAgIFwibmFtZVwiXG4gICAgICAgICk7XG4gICAgICAgIG5hbWVQcm9wRGVzY3JpcHRvciAmJlxuICAgICAgICAgIG5hbWVQcm9wRGVzY3JpcHRvci5jb25maWd1cmFibGUgJiZcbiAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoXG4gICAgICAgICAgICBSdW5JblJvb3RGcmFtZS5EZXRlcm1pbmVDb21wb25lbnRGcmFtZVJvb3QsXG4gICAgICAgICAgICBcIm5hbWVcIixcbiAgICAgICAgICAgIHsgdmFsdWU6IFwiRGV0ZXJtaW5lQ29tcG9uZW50RnJhbWVSb290XCIgfVxuICAgICAgICAgICk7XG4gICAgICAgIHZhciBfUnVuSW5Sb290RnJhbWUkRGV0ZXIgPVxuICAgICAgICAgICAgUnVuSW5Sb290RnJhbWUuRGV0ZXJtaW5lQ29tcG9uZW50RnJhbWVSb290KCksXG4gICAgICAgICAgc2FtcGxlU3RhY2sgPSBfUnVuSW5Sb290RnJhbWUkRGV0ZXJbMF0sXG4gICAgICAgICAgY29udHJvbFN0YWNrID0gX1J1bkluUm9vdEZyYW1lJERldGVyWzFdO1xuICAgICAgICBpZiAoc2FtcGxlU3RhY2sgJiYgY29udHJvbFN0YWNrKSB7XG4gICAgICAgICAgdmFyIHNhbXBsZUxpbmVzID0gc2FtcGxlU3RhY2suc3BsaXQoXCJcXG5cIiksXG4gICAgICAgICAgICBjb250cm9sTGluZXMgPSBjb250cm9sU3RhY2suc3BsaXQoXCJcXG5cIik7XG4gICAgICAgICAgZm9yIChcbiAgICAgICAgICAgIF9SdW5JblJvb3RGcmFtZSREZXRlciA9IG5hbWVQcm9wRGVzY3JpcHRvciA9IDA7XG4gICAgICAgICAgICBuYW1lUHJvcERlc2NyaXB0b3IgPCBzYW1wbGVMaW5lcy5sZW5ndGggJiZcbiAgICAgICAgICAgICFzYW1wbGVMaW5lc1tuYW1lUHJvcERlc2NyaXB0b3JdLmluY2x1ZGVzKFxuICAgICAgICAgICAgICBcIkRldGVybWluZUNvbXBvbmVudEZyYW1lUm9vdFwiXG4gICAgICAgICAgICApO1xuXG4gICAgICAgICAgKVxuICAgICAgICAgICAgbmFtZVByb3BEZXNjcmlwdG9yKys7XG4gICAgICAgICAgZm9yIChcbiAgICAgICAgICAgIDtcbiAgICAgICAgICAgIF9SdW5JblJvb3RGcmFtZSREZXRlciA8IGNvbnRyb2xMaW5lcy5sZW5ndGggJiZcbiAgICAgICAgICAgICFjb250cm9sTGluZXNbX1J1bkluUm9vdEZyYW1lJERldGVyXS5pbmNsdWRlcyhcbiAgICAgICAgICAgICAgXCJEZXRlcm1pbmVDb21wb25lbnRGcmFtZVJvb3RcIlxuICAgICAgICAgICAgKTtcblxuICAgICAgICAgIClcbiAgICAgICAgICAgIF9SdW5JblJvb3RGcmFtZSREZXRlcisrO1xuICAgICAgICAgIGlmIChcbiAgICAgICAgICAgIG5hbWVQcm9wRGVzY3JpcHRvciA9PT0gc2FtcGxlTGluZXMubGVuZ3RoIHx8XG4gICAgICAgICAgICBfUnVuSW5Sb290RnJhbWUkRGV0ZXIgPT09IGNvbnRyb2xMaW5lcy5sZW5ndGhcbiAgICAgICAgICApXG4gICAgICAgICAgICBmb3IgKFxuICAgICAgICAgICAgICBuYW1lUHJvcERlc2NyaXB0b3IgPSBzYW1wbGVMaW5lcy5sZW5ndGggLSAxLFxuICAgICAgICAgICAgICAgIF9SdW5JblJvb3RGcmFtZSREZXRlciA9IGNvbnRyb2xMaW5lcy5sZW5ndGggLSAxO1xuICAgICAgICAgICAgICAxIDw9IG5hbWVQcm9wRGVzY3JpcHRvciAmJlxuICAgICAgICAgICAgICAwIDw9IF9SdW5JblJvb3RGcmFtZSREZXRlciAmJlxuICAgICAgICAgICAgICBzYW1wbGVMaW5lc1tuYW1lUHJvcERlc2NyaXB0b3JdICE9PVxuICAgICAgICAgICAgICAgIGNvbnRyb2xMaW5lc1tfUnVuSW5Sb290RnJhbWUkRGV0ZXJdO1xuXG4gICAgICAgICAgICApXG4gICAgICAgICAgICAgIF9SdW5JblJvb3RGcmFtZSREZXRlci0tO1xuICAgICAgICAgIGZvciAoXG4gICAgICAgICAgICA7XG4gICAgICAgICAgICAxIDw9IG5hbWVQcm9wRGVzY3JpcHRvciAmJiAwIDw9IF9SdW5JblJvb3RGcmFtZSREZXRlcjtcbiAgICAgICAgICAgIG5hbWVQcm9wRGVzY3JpcHRvci0tLCBfUnVuSW5Sb290RnJhbWUkRGV0ZXItLVxuICAgICAgICAgIClcbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgc2FtcGxlTGluZXNbbmFtZVByb3BEZXNjcmlwdG9yXSAhPT1cbiAgICAgICAgICAgICAgY29udHJvbExpbmVzW19SdW5JblJvb3RGcmFtZSREZXRlcl1cbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICBpZiAoMSAhPT0gbmFtZVByb3BEZXNjcmlwdG9yIHx8IDEgIT09IF9SdW5JblJvb3RGcmFtZSREZXRlcikge1xuICAgICAgICAgICAgICAgIGRvXG4gICAgICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgICAgIChuYW1lUHJvcERlc2NyaXB0b3ItLSxcbiAgICAgICAgICAgICAgICAgICAgX1J1bkluUm9vdEZyYW1lJERldGVyLS0sXG4gICAgICAgICAgICAgICAgICAgIDAgPiBfUnVuSW5Sb290RnJhbWUkRGV0ZXIgfHxcbiAgICAgICAgICAgICAgICAgICAgICBzYW1wbGVMaW5lc1tuYW1lUHJvcERlc2NyaXB0b3JdICE9PVxuICAgICAgICAgICAgICAgICAgICAgICAgY29udHJvbExpbmVzW19SdW5JblJvb3RGcmFtZSREZXRlcl0pXG4gICAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIF9mcmFtZSA9XG4gICAgICAgICAgICAgICAgICAgICAgXCJcXG5cIiArXG4gICAgICAgICAgICAgICAgICAgICAgc2FtcGxlTGluZXNbbmFtZVByb3BEZXNjcmlwdG9yXS5yZXBsYWNlKFxuICAgICAgICAgICAgICAgICAgICAgICAgXCIgYXQgbmV3IFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgXCIgYXQgXCJcbiAgICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICBmbi5kaXNwbGF5TmFtZSAmJlxuICAgICAgICAgICAgICAgICAgICAgIF9mcmFtZS5pbmNsdWRlcyhcIjxhbm9ueW1vdXM+XCIpICYmXG4gICAgICAgICAgICAgICAgICAgICAgKF9mcmFtZSA9IF9mcmFtZS5yZXBsYWNlKFwiPGFub255bW91cz5cIiwgZm4uZGlzcGxheU5hbWUpKTtcbiAgICAgICAgICAgICAgICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgZm4gJiZcbiAgICAgICAgICAgICAgICAgICAgICBjb21wb25lbnRGcmFtZUNhY2hlLnNldChmbiwgX2ZyYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9mcmFtZTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB3aGlsZSAoMSA8PSBuYW1lUHJvcERlc2NyaXB0b3IgJiYgMCA8PSBfUnVuSW5Sb290RnJhbWUkRGV0ZXIpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICAocmVlbnRyeSA9ICExKSxcbiAgICAgICAgICAoUmVhY3RTaGFyZWRJbnRlcm5hbHMuSCA9IHByZXZpb3VzRGlzcGF0Y2hlciksXG4gICAgICAgICAgcmVlbmFibGVMb2dzKCksXG4gICAgICAgICAgKEVycm9yLnByZXBhcmVTdGFja1RyYWNlID0gZnJhbWUpO1xuICAgICAgfVxuICAgICAgc2FtcGxlTGluZXMgPSAoc2FtcGxlTGluZXMgPSBmbiA/IGZuLmRpc3BsYXlOYW1lIHx8IGZuLm5hbWUgOiBcIlwiKVxuICAgICAgICA/IGRlc2NyaWJlQnVpbHRJbkNvbXBvbmVudEZyYW1lKHNhbXBsZUxpbmVzKVxuICAgICAgICA6IFwiXCI7XG4gICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBmbiAmJiBjb21wb25lbnRGcmFtZUNhY2hlLnNldChmbiwgc2FtcGxlTGluZXMpO1xuICAgICAgcmV0dXJuIHNhbXBsZUxpbmVzO1xuICAgIH1cbiAgICBmdW5jdGlvbiBkZXNjcmliZUZpYmVyKGZpYmVyKSB7XG4gICAgICBzd2l0Y2ggKGZpYmVyLnRhZykge1xuICAgICAgICBjYXNlIDI2OlxuICAgICAgICBjYXNlIDI3OlxuICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgcmV0dXJuIGRlc2NyaWJlQnVpbHRJbkNvbXBvbmVudEZyYW1lKGZpYmVyLnR5cGUpO1xuICAgICAgICBjYXNlIDE2OlxuICAgICAgICAgIHJldHVybiBkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZShcIkxhenlcIik7XG4gICAgICAgIGNhc2UgMTM6XG4gICAgICAgICAgcmV0dXJuIGRlc2NyaWJlQnVpbHRJbkNvbXBvbmVudEZyYW1lKFwiU3VzcGVuc2VcIik7XG4gICAgICAgIGNhc2UgMTk6XG4gICAgICAgICAgcmV0dXJuIGRlc2NyaWJlQnVpbHRJbkNvbXBvbmVudEZyYW1lKFwiU3VzcGVuc2VMaXN0XCIpO1xuICAgICAgICBjYXNlIDA6XG4gICAgICAgIGNhc2UgMTU6XG4gICAgICAgICAgcmV0dXJuIChmaWJlciA9IGRlc2NyaWJlTmF0aXZlQ29tcG9uZW50RnJhbWUoZmliZXIudHlwZSwgITEpKSwgZmliZXI7XG4gICAgICAgIGNhc2UgMTE6XG4gICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIChmaWJlciA9IGRlc2NyaWJlTmF0aXZlQ29tcG9uZW50RnJhbWUoZmliZXIudHlwZS5yZW5kZXIsICExKSksIGZpYmVyXG4gICAgICAgICAgKTtcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgIHJldHVybiAoZmliZXIgPSBkZXNjcmliZU5hdGl2ZUNvbXBvbmVudEZyYW1lKGZpYmVyLnR5cGUsICEwKSksIGZpYmVyO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHJldHVybiBcIlwiO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBnZXRTdGFja0J5RmliZXJJbkRldkFuZFByb2Qod29ya0luUHJvZ3Jlc3MpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHZhciBpbmZvID0gXCJcIjtcbiAgICAgICAgZG8ge1xuICAgICAgICAgIGluZm8gKz0gZGVzY3JpYmVGaWJlcih3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgICAgdmFyIGRlYnVnSW5mbyA9IHdvcmtJblByb2dyZXNzLl9kZWJ1Z0luZm87XG4gICAgICAgICAgaWYgKGRlYnVnSW5mbylcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSBkZWJ1Z0luZm8ubGVuZ3RoIC0gMTsgMCA8PSBpOyBpLS0pIHtcbiAgICAgICAgICAgICAgdmFyIGVudHJ5ID0gZGVidWdJbmZvW2ldO1xuICAgICAgICAgICAgICBpZiAoXCJzdHJpbmdcIiA9PT0gdHlwZW9mIGVudHJ5Lm5hbWUpIHtcbiAgICAgICAgICAgICAgICB2YXIgSlNDb21waWxlcl90ZW1wX2NvbnN0ID0gaW5mbyxcbiAgICAgICAgICAgICAgICAgIGVudiA9IGVudHJ5LmVudjtcbiAgICAgICAgICAgICAgICB2YXIgSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0ID0gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUoXG4gICAgICAgICAgICAgICAgICBlbnRyeS5uYW1lICsgKGVudiA/IFwiIFtcIiArIGVudiArIFwiXVwiIDogXCJcIilcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIGluZm8gPSBKU0NvbXBpbGVyX3RlbXBfY29uc3QgKyBKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQ7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB3b3JrSW5Qcm9ncmVzcyA9IHdvcmtJblByb2dyZXNzLnJldHVybjtcbiAgICAgICAgfSB3aGlsZSAod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICByZXR1cm4gaW5mbztcbiAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgcmV0dXJuIFwiXFxuRXJyb3IgZ2VuZXJhdGluZyBzdGFjazogXCIgKyB4Lm1lc3NhZ2UgKyBcIlxcblwiICsgeC5zdGFjaztcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gZ2V0Q3VycmVudEZpYmVyU3RhY2tJbkRldigpIHtcbiAgICAgIHJldHVybiBudWxsID09PSBjdXJyZW50ID8gXCJcIiA6IGdldFN0YWNrQnlGaWJlckluRGV2QW5kUHJvZChjdXJyZW50KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcnVuV2l0aEZpYmVySW5ERVYoZmliZXIsIGNhbGxiYWNrLCBhcmcwLCBhcmcxLCBhcmcyLCBhcmczLCBhcmc0KSB7XG4gICAgICB2YXIgcHJldmlvdXNGaWJlciA9IGN1cnJlbnQ7XG4gICAgICBSZWFjdFNoYXJlZEludGVybmFscy5nZXRDdXJyZW50U3RhY2sgPVxuICAgICAgICBudWxsID09PSBmaWJlciA/IG51bGwgOiBnZXRDdXJyZW50RmliZXJTdGFja0luRGV2O1xuICAgICAgaXNSZW5kZXJpbmcgPSAhMTtcbiAgICAgIGN1cnJlbnQgPSBmaWJlcjtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBjYWxsYmFjayhhcmcwLCBhcmcxLCBhcmcyLCBhcmczLCBhcmc0KTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIGN1cnJlbnQgPSBwcmV2aW91c0ZpYmVyO1xuICAgICAgfVxuICAgICAgdGhyb3cgRXJyb3IoXG4gICAgICAgIFwicnVuV2l0aEZpYmVySW5ERVYgc2hvdWxkIG5ldmVyIGJlIGNhbGxlZCBpbiBwcm9kdWN0aW9uLiBUaGlzIGlzIGEgYnVnIGluIFJlYWN0LlwiXG4gICAgICApO1xuICAgIH1cbiAgICBmdW5jdGlvbiBnZXROZWFyZXN0TW91bnRlZEZpYmVyKGZpYmVyKSB7XG4gICAgICB2YXIgbm9kZSA9IGZpYmVyLFxuICAgICAgICBuZWFyZXN0TW91bnRlZCA9IGZpYmVyO1xuICAgICAgaWYgKGZpYmVyLmFsdGVybmF0ZSkgZm9yICg7IG5vZGUucmV0dXJuOyApIG5vZGUgPSBub2RlLnJldHVybjtcbiAgICAgIGVsc2Uge1xuICAgICAgICBmaWJlciA9IG5vZGU7XG4gICAgICAgIGRvXG4gICAgICAgICAgKG5vZGUgPSBmaWJlciksXG4gICAgICAgICAgICAwICE9PSAobm9kZS5mbGFncyAmIDQwOTgpICYmIChuZWFyZXN0TW91bnRlZCA9IG5vZGUucmV0dXJuKSxcbiAgICAgICAgICAgIChmaWJlciA9IG5vZGUucmV0dXJuKTtcbiAgICAgICAgd2hpbGUgKGZpYmVyKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiAzID09PSBub2RlLnRhZyA/IG5lYXJlc3RNb3VudGVkIDogbnVsbDtcbiAgICB9XG4gICAgZnVuY3Rpb24gYXNzZXJ0SXNNb3VudGVkKGZpYmVyKSB7XG4gICAgICBpZiAoZ2V0TmVhcmVzdE1vdW50ZWRGaWJlcihmaWJlcikgIT09IGZpYmVyKVxuICAgICAgICB0aHJvdyBFcnJvcihcIlVuYWJsZSB0byBmaW5kIG5vZGUgb24gYW4gdW5tb3VudGVkIGNvbXBvbmVudC5cIik7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGZpbmRDdXJyZW50RmliZXJVc2luZ1Nsb3dQYXRoKGZpYmVyKSB7XG4gICAgICB2YXIgYWx0ZXJuYXRlID0gZmliZXIuYWx0ZXJuYXRlO1xuICAgICAgaWYgKCFhbHRlcm5hdGUpIHtcbiAgICAgICAgYWx0ZXJuYXRlID0gZ2V0TmVhcmVzdE1vdW50ZWRGaWJlcihmaWJlcik7XG4gICAgICAgIGlmIChudWxsID09PSBhbHRlcm5hdGUpXG4gICAgICAgICAgdGhyb3cgRXJyb3IoXCJVbmFibGUgdG8gZmluZCBub2RlIG9uIGFuIHVubW91bnRlZCBjb21wb25lbnQuXCIpO1xuICAgICAgICByZXR1cm4gYWx0ZXJuYXRlICE9PSBmaWJlciA/IG51bGwgOiBmaWJlcjtcbiAgICAgIH1cbiAgICAgIGZvciAodmFyIGEgPSBmaWJlciwgYiA9IGFsdGVybmF0ZTsgOyApIHtcbiAgICAgICAgdmFyIHBhcmVudEEgPSBhLnJldHVybjtcbiAgICAgICAgaWYgKG51bGwgPT09IHBhcmVudEEpIGJyZWFrO1xuICAgICAgICB2YXIgcGFyZW50QiA9IHBhcmVudEEuYWx0ZXJuYXRlO1xuICAgICAgICBpZiAobnVsbCA9PT0gcGFyZW50Qikge1xuICAgICAgICAgIGIgPSBwYXJlbnRBLnJldHVybjtcbiAgICAgICAgICBpZiAobnVsbCAhPT0gYikge1xuICAgICAgICAgICAgYSA9IGI7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBhcmVudEEuY2hpbGQgPT09IHBhcmVudEIuY2hpbGQpIHtcbiAgICAgICAgICBmb3IgKHBhcmVudEIgPSBwYXJlbnRBLmNoaWxkOyBwYXJlbnRCOyApIHtcbiAgICAgICAgICAgIGlmIChwYXJlbnRCID09PSBhKSByZXR1cm4gYXNzZXJ0SXNNb3VudGVkKHBhcmVudEEpLCBmaWJlcjtcbiAgICAgICAgICAgIGlmIChwYXJlbnRCID09PSBiKSByZXR1cm4gYXNzZXJ0SXNNb3VudGVkKHBhcmVudEEpLCBhbHRlcm5hdGU7XG4gICAgICAgICAgICBwYXJlbnRCID0gcGFyZW50Qi5zaWJsaW5nO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aHJvdyBFcnJvcihcIlVuYWJsZSB0byBmaW5kIG5vZGUgb24gYW4gdW5tb3VudGVkIGNvbXBvbmVudC5cIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGEucmV0dXJuICE9PSBiLnJldHVybikgKGEgPSBwYXJlbnRBKSwgKGIgPSBwYXJlbnRCKTtcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgZm9yICh2YXIgZGlkRmluZENoaWxkID0gITEsIF9jaGlsZCA9IHBhcmVudEEuY2hpbGQ7IF9jaGlsZDsgKSB7XG4gICAgICAgICAgICBpZiAoX2NoaWxkID09PSBhKSB7XG4gICAgICAgICAgICAgIGRpZEZpbmRDaGlsZCA9ICEwO1xuICAgICAgICAgICAgICBhID0gcGFyZW50QTtcbiAgICAgICAgICAgICAgYiA9IHBhcmVudEI7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKF9jaGlsZCA9PT0gYikge1xuICAgICAgICAgICAgICBkaWRGaW5kQ2hpbGQgPSAhMDtcbiAgICAgICAgICAgICAgYiA9IHBhcmVudEE7XG4gICAgICAgICAgICAgIGEgPSBwYXJlbnRCO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF9jaGlsZCA9IF9jaGlsZC5zaWJsaW5nO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIWRpZEZpbmRDaGlsZCkge1xuICAgICAgICAgICAgZm9yIChfY2hpbGQgPSBwYXJlbnRCLmNoaWxkOyBfY2hpbGQ7ICkge1xuICAgICAgICAgICAgICBpZiAoX2NoaWxkID09PSBhKSB7XG4gICAgICAgICAgICAgICAgZGlkRmluZENoaWxkID0gITA7XG4gICAgICAgICAgICAgICAgYSA9IHBhcmVudEI7XG4gICAgICAgICAgICAgICAgYiA9IHBhcmVudEE7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKF9jaGlsZCA9PT0gYikge1xuICAgICAgICAgICAgICAgIGRpZEZpbmRDaGlsZCA9ICEwO1xuICAgICAgICAgICAgICAgIGIgPSBwYXJlbnRCO1xuICAgICAgICAgICAgICAgIGEgPSBwYXJlbnRBO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIF9jaGlsZCA9IF9jaGlsZC5zaWJsaW5nO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFkaWRGaW5kQ2hpbGQpXG4gICAgICAgICAgICAgIHRocm93IEVycm9yKFxuICAgICAgICAgICAgICAgIFwiQ2hpbGQgd2FzIG5vdCBmb3VuZCBpbiBlaXRoZXIgcGFyZW50IHNldC4gVGhpcyBpbmRpY2F0ZXMgYSBidWcgaW4gUmVhY3QgcmVsYXRlZCB0byB0aGUgcmV0dXJuIHBvaW50ZXIuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLlwiXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChhLmFsdGVybmF0ZSAhPT0gYilcbiAgICAgICAgICB0aHJvdyBFcnJvcihcbiAgICAgICAgICAgIFwiUmV0dXJuIGZpYmVycyBzaG91bGQgYWx3YXlzIGJlIGVhY2ggb3RoZXJzJyBhbHRlcm5hdGVzLiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLlwiXG4gICAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGlmICgzICE9PSBhLnRhZylcbiAgICAgICAgdGhyb3cgRXJyb3IoXCJVbmFibGUgdG8gZmluZCBub2RlIG9uIGFuIHVubW91bnRlZCBjb21wb25lbnQuXCIpO1xuICAgICAgcmV0dXJuIGEuc3RhdGVOb2RlLmN1cnJlbnQgPT09IGEgPyBmaWJlciA6IGFsdGVybmF0ZTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZmluZEN1cnJlbnRIb3N0RmliZXIocGFyZW50KSB7XG4gICAgICBwYXJlbnQgPSBmaW5kQ3VycmVudEZpYmVyVXNpbmdTbG93UGF0aChwYXJlbnQpO1xuICAgICAgcmV0dXJuIG51bGwgIT09IHBhcmVudCA/IGZpbmRDdXJyZW50SG9zdEZpYmVySW1wbChwYXJlbnQpIDogbnVsbDtcbiAgICB9XG4gICAgZnVuY3Rpb24gZmluZEN1cnJlbnRIb3N0RmliZXJJbXBsKG5vZGUpIHtcbiAgICAgIHZhciB0YWcgPSBub2RlLnRhZztcbiAgICAgIGlmICg1ID09PSB0YWcgfHwgMjYgPT09IHRhZyB8fCAyNyA9PT0gdGFnIHx8IDYgPT09IHRhZykgcmV0dXJuIG5vZGU7XG4gICAgICBmb3IgKG5vZGUgPSBub2RlLmNoaWxkOyBudWxsICE9PSBub2RlOyApIHtcbiAgICAgICAgdGFnID0gZmluZEN1cnJlbnRIb3N0RmliZXJJbXBsKG5vZGUpO1xuICAgICAgICBpZiAobnVsbCAhPT0gdGFnKSByZXR1cm4gdGFnO1xuICAgICAgICBub2RlID0gbm9kZS5zaWJsaW5nO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGZpbmRDdXJyZW50SG9zdEZpYmVyV2l0aE5vUG9ydGFsc0ltcGwobm9kZSkge1xuICAgICAgdmFyIHRhZyA9IG5vZGUudGFnO1xuICAgICAgaWYgKDUgPT09IHRhZyB8fCAyNiA9PT0gdGFnIHx8IDI3ID09PSB0YWcgfHwgNiA9PT0gdGFnKSByZXR1cm4gbm9kZTtcbiAgICAgIGZvciAobm9kZSA9IG5vZGUuY2hpbGQ7IG51bGwgIT09IG5vZGU7ICkge1xuICAgICAgICBpZiAoXG4gICAgICAgICAgNCAhPT0gbm9kZS50YWcgJiZcbiAgICAgICAgICAoKHRhZyA9IGZpbmRDdXJyZW50SG9zdEZpYmVyV2l0aE5vUG9ydGFsc0ltcGwobm9kZSkpLCBudWxsICE9PSB0YWcpXG4gICAgICAgIClcbiAgICAgICAgICByZXR1cm4gdGFnO1xuICAgICAgICBub2RlID0gbm9kZS5zaWJsaW5nO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNyZWF0ZUN1cnNvcihkZWZhdWx0VmFsdWUpIHtcbiAgICAgIHJldHVybiB7IGN1cnJlbnQ6IGRlZmF1bHRWYWx1ZSB9O1xuICAgIH1cbiAgICBmdW5jdGlvbiBwb3AoY3Vyc29yLCBmaWJlcikge1xuICAgICAgMCA+IGluZGV4JGpzY29tcCQwXG4gICAgICAgID8gY29uc29sZS5lcnJvcihcIlVuZXhwZWN0ZWQgcG9wLlwiKVxuICAgICAgICA6IChmaWJlciAhPT0gZmliZXJTdGFja1tpbmRleCRqc2NvbXAkMF0gJiZcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJVbmV4cGVjdGVkIEZpYmVyIHBvcHBlZC5cIiksXG4gICAgICAgICAgKGN1cnNvci5jdXJyZW50ID0gdmFsdWVTdGFja1tpbmRleCRqc2NvbXAkMF0pLFxuICAgICAgICAgICh2YWx1ZVN0YWNrW2luZGV4JGpzY29tcCQwXSA9IG51bGwpLFxuICAgICAgICAgIChmaWJlclN0YWNrW2luZGV4JGpzY29tcCQwXSA9IG51bGwpLFxuICAgICAgICAgIGluZGV4JGpzY29tcCQwLS0pO1xuICAgIH1cbiAgICBmdW5jdGlvbiBwdXNoKGN1cnNvciwgdmFsdWUsIGZpYmVyKSB7XG4gICAgICBpbmRleCRqc2NvbXAkMCsrO1xuICAgICAgdmFsdWVTdGFja1tpbmRleCRqc2NvbXAkMF0gPSBjdXJzb3IuY3VycmVudDtcbiAgICAgIGZpYmVyU3RhY2tbaW5kZXgkanNjb21wJDBdID0gZmliZXI7XG4gICAgICBjdXJzb3IuY3VycmVudCA9IHZhbHVlO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjbHozMkZhbGxiYWNrKHgpIHtcbiAgICAgIHggPj4+PSAwO1xuICAgICAgcmV0dXJuIDAgPT09IHggPyAzMiA6ICgzMSAtICgobG9nJDEoeCkgLyBMTjIpIHwgMCkpIHwgMDtcbiAgICB9XG4gICAgZnVuY3Rpb24gZ2V0TGFiZWxGb3JMYW5lKGxhbmUpIHtcbiAgICAgIGlmIChsYW5lICYgMSkgcmV0dXJuIFwiU3luY0h5ZHJhdGlvbkxhbmVcIjtcbiAgICAgIGlmIChsYW5lICYgMikgcmV0dXJuIFwiU3luY1wiO1xuICAgICAgaWYgKGxhbmUgJiA0KSByZXR1cm4gXCJJbnB1dENvbnRpbnVvdXNIeWRyYXRpb25cIjtcbiAgICAgIGlmIChsYW5lICYgOCkgcmV0dXJuIFwiSW5wdXRDb250aW51b3VzXCI7XG4gICAgICBpZiAobGFuZSAmIDE2KSByZXR1cm4gXCJEZWZhdWx0SHlkcmF0aW9uXCI7XG4gICAgICBpZiAobGFuZSAmIDMyKSByZXR1cm4gXCJEZWZhdWx0XCI7XG4gICAgICBpZiAobGFuZSAmIDY0KSByZXR1cm4gXCJUcmFuc2l0aW9uSHlkcmF0aW9uXCI7XG4gICAgICBpZiAobGFuZSAmIDQxOTQxNzYpIHJldHVybiBcIlRyYW5zaXRpb25cIjtcbiAgICAgIGlmIChsYW5lICYgNjI5MTQ1NjApIHJldHVybiBcIlJldHJ5XCI7XG4gICAgICBpZiAobGFuZSAmIDY3MTA4ODY0KSByZXR1cm4gXCJTZWxlY3RpdmVIeWRyYXRpb25cIjtcbiAgICAgIGlmIChsYW5lICYgMTM0MjE3NzI4KSByZXR1cm4gXCJJZGxlSHlkcmF0aW9uXCI7XG4gICAgICBpZiAobGFuZSAmIDI2ODQzNTQ1NikgcmV0dXJuIFwiSWRsZVwiO1xuICAgICAgaWYgKGxhbmUgJiA1MzY4NzA5MTIpIHJldHVybiBcIk9mZnNjcmVlblwiO1xuICAgICAgaWYgKGxhbmUgJiAxMDczNzQxODI0KSByZXR1cm4gXCJEZWZlcnJlZFwiO1xuICAgIH1cbiAgICBmdW5jdGlvbiBnZXRIaWdoZXN0UHJpb3JpdHlMYW5lcyhsYW5lcykge1xuICAgICAgdmFyIHBlbmRpbmdTeW5jTGFuZXMgPSBsYW5lcyAmIDQyO1xuICAgICAgaWYgKDAgIT09IHBlbmRpbmdTeW5jTGFuZXMpIHJldHVybiBwZW5kaW5nU3luY0xhbmVzO1xuICAgICAgc3dpdGNoIChsYW5lcyAmIC1sYW5lcykge1xuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgIGNhc2UgMjpcbiAgICAgICAgICByZXR1cm4gMjtcbiAgICAgICAgY2FzZSA0OlxuICAgICAgICAgIHJldHVybiA0O1xuICAgICAgICBjYXNlIDg6XG4gICAgICAgICAgcmV0dXJuIDg7XG4gICAgICAgIGNhc2UgMTY6XG4gICAgICAgICAgcmV0dXJuIDE2O1xuICAgICAgICBjYXNlIDMyOlxuICAgICAgICAgIHJldHVybiAzMjtcbiAgICAgICAgY2FzZSA2NDpcbiAgICAgICAgICByZXR1cm4gNjQ7XG4gICAgICAgIGNhc2UgMTI4OlxuICAgICAgICBjYXNlIDI1NjpcbiAgICAgICAgY2FzZSA1MTI6XG4gICAgICAgIGNhc2UgMTAyNDpcbiAgICAgICAgY2FzZSAyMDQ4OlxuICAgICAgICBjYXNlIDQwOTY6XG4gICAgICAgIGNhc2UgODE5MjpcbiAgICAgICAgY2FzZSAxNjM4NDpcbiAgICAgICAgY2FzZSAzMjc2ODpcbiAgICAgICAgY2FzZSA2NTUzNjpcbiAgICAgICAgY2FzZSAxMzEwNzI6XG4gICAgICAgIGNhc2UgMjYyMTQ0OlxuICAgICAgICBjYXNlIDUyNDI4ODpcbiAgICAgICAgY2FzZSAxMDQ4NTc2OlxuICAgICAgICBjYXNlIDIwOTcxNTI6XG4gICAgICAgICAgcmV0dXJuIGxhbmVzICYgNDE5NDE3NjtcbiAgICAgICAgY2FzZSA0MTk0MzA0OlxuICAgICAgICBjYXNlIDgzODg2MDg6XG4gICAgICAgIGNhc2UgMTY3NzcyMTY6XG4gICAgICAgIGNhc2UgMzM1NTQ0MzI6XG4gICAgICAgICAgcmV0dXJuIGxhbmVzICYgNjI5MTQ1NjA7XG4gICAgICAgIGNhc2UgNjcxMDg4NjQ6XG4gICAgICAgICAgcmV0dXJuIDY3MTA4ODY0O1xuICAgICAgICBjYXNlIDEzNDIxNzcyODpcbiAgICAgICAgICByZXR1cm4gMTM0MjE3NzI4O1xuICAgICAgICBjYXNlIDI2ODQzNTQ1NjpcbiAgICAgICAgICByZXR1cm4gMjY4NDM1NDU2O1xuICAgICAgICBjYXNlIDUzNjg3MDkxMjpcbiAgICAgICAgICByZXR1cm4gNTM2ODcwOTEyO1xuICAgICAgICBjYXNlIDEwNzM3NDE4MjQ6XG4gICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgIFwiU2hvdWxkIGhhdmUgZm91bmQgbWF0Y2hpbmcgbGFuZXMuIFRoaXMgaXMgYSBidWcgaW4gUmVhY3QuXCJcbiAgICAgICAgICAgICksXG4gICAgICAgICAgICBsYW5lc1xuICAgICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGdldE5leHRMYW5lcyhyb290LCB3aXBMYW5lcykge1xuICAgICAgdmFyIHBlbmRpbmdMYW5lcyA9IHJvb3QucGVuZGluZ0xhbmVzO1xuICAgICAgaWYgKDAgPT09IHBlbmRpbmdMYW5lcykgcmV0dXJuIDA7XG4gICAgICB2YXIgbmV4dExhbmVzID0gMCxcbiAgICAgICAgc3VzcGVuZGVkTGFuZXMgPSByb290LnN1c3BlbmRlZExhbmVzLFxuICAgICAgICBwaW5nZWRMYW5lcyA9IHJvb3QucGluZ2VkTGFuZXMsXG4gICAgICAgIHdhcm1MYW5lcyA9IHJvb3Qud2FybUxhbmVzO1xuICAgICAgcm9vdCA9IDAgIT09IHJvb3QuZmluaXNoZWRMYW5lcztcbiAgICAgIHZhciBub25JZGxlUGVuZGluZ0xhbmVzID0gcGVuZGluZ0xhbmVzICYgMTM0MjE3NzI3O1xuICAgICAgMCAhPT0gbm9uSWRsZVBlbmRpbmdMYW5lc1xuICAgICAgICA/ICgocGVuZGluZ0xhbmVzID0gbm9uSWRsZVBlbmRpbmdMYW5lcyAmIH5zdXNwZW5kZWRMYW5lcyksXG4gICAgICAgICAgMCAhPT0gcGVuZGluZ0xhbmVzXG4gICAgICAgICAgICA/IChuZXh0TGFuZXMgPSBnZXRIaWdoZXN0UHJpb3JpdHlMYW5lcyhwZW5kaW5nTGFuZXMpKVxuICAgICAgICAgICAgOiAoKHBpbmdlZExhbmVzICY9IG5vbklkbGVQZW5kaW5nTGFuZXMpLFxuICAgICAgICAgICAgICAwICE9PSBwaW5nZWRMYW5lc1xuICAgICAgICAgICAgICAgID8gKG5leHRMYW5lcyA9IGdldEhpZ2hlc3RQcmlvcml0eUxhbmVzKHBpbmdlZExhbmVzKSlcbiAgICAgICAgICAgICAgICA6IHJvb3QgfHxcbiAgICAgICAgICAgICAgICAgICgod2FybUxhbmVzID0gbm9uSWRsZVBlbmRpbmdMYW5lcyAmIH53YXJtTGFuZXMpLFxuICAgICAgICAgICAgICAgICAgMCAhPT0gd2FybUxhbmVzICYmXG4gICAgICAgICAgICAgICAgICAgIChuZXh0TGFuZXMgPSBnZXRIaWdoZXN0UHJpb3JpdHlMYW5lcyh3YXJtTGFuZXMpKSkpKVxuICAgICAgICA6ICgobm9uSWRsZVBlbmRpbmdMYW5lcyA9IHBlbmRpbmdMYW5lcyAmIH5zdXNwZW5kZWRMYW5lcyksXG4gICAgICAgICAgMCAhPT0gbm9uSWRsZVBlbmRpbmdMYW5lc1xuICAgICAgICAgICAgPyAobmV4dExhbmVzID0gZ2V0SGlnaGVzdFByaW9yaXR5TGFuZXMobm9uSWRsZVBlbmRpbmdMYW5lcykpXG4gICAgICAgICAgICA6IDAgIT09IHBpbmdlZExhbmVzXG4gICAgICAgICAgICAgID8gKG5leHRMYW5lcyA9IGdldEhpZ2hlc3RQcmlvcml0eUxhbmVzKHBpbmdlZExhbmVzKSlcbiAgICAgICAgICAgICAgOiByb290IHx8XG4gICAgICAgICAgICAgICAgKCh3YXJtTGFuZXMgPSBwZW5kaW5nTGFuZXMgJiB+d2FybUxhbmVzKSxcbiAgICAgICAgICAgICAgICAwICE9PSB3YXJtTGFuZXMgJiZcbiAgICAgICAgICAgICAgICAgIChuZXh0TGFuZXMgPSBnZXRIaWdoZXN0UHJpb3JpdHlMYW5lcyh3YXJtTGFuZXMpKSkpO1xuICAgICAgcmV0dXJuIDAgPT09IG5leHRMYW5lc1xuICAgICAgICA/IDBcbiAgICAgICAgOiAwICE9PSB3aXBMYW5lcyAmJlxuICAgICAgICAgICAgd2lwTGFuZXMgIT09IG5leHRMYW5lcyAmJlxuICAgICAgICAgICAgMCA9PT0gKHdpcExhbmVzICYgc3VzcGVuZGVkTGFuZXMpICYmXG4gICAgICAgICAgICAoKHN1c3BlbmRlZExhbmVzID0gbmV4dExhbmVzICYgLW5leHRMYW5lcyksXG4gICAgICAgICAgICAod2FybUxhbmVzID0gd2lwTGFuZXMgJiAtd2lwTGFuZXMpLFxuICAgICAgICAgICAgc3VzcGVuZGVkTGFuZXMgPj0gd2FybUxhbmVzIHx8XG4gICAgICAgICAgICAgICgzMiA9PT0gc3VzcGVuZGVkTGFuZXMgJiYgMCAhPT0gKHdhcm1MYW5lcyAmIDQxOTQxNzYpKSlcbiAgICAgICAgICA/IHdpcExhbmVzXG4gICAgICAgICAgOiBuZXh0TGFuZXM7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNoZWNrSWZSb290SXNQcmVyZW5kZXJpbmcocm9vdCwgcmVuZGVyTGFuZXMpIHtcbiAgICAgIHJldHVybiAoXG4gICAgICAgIDAgPT09XG4gICAgICAgIChyb290LnBlbmRpbmdMYW5lcyAmXG4gICAgICAgICAgfihyb290LnN1c3BlbmRlZExhbmVzICYgfnJvb3QucGluZ2VkTGFuZXMpICZcbiAgICAgICAgICByZW5kZXJMYW5lcylcbiAgICAgICk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNvbXB1dGVFeHBpcmF0aW9uVGltZShsYW5lLCBjdXJyZW50VGltZSkge1xuICAgICAgc3dpdGNoIChsYW5lKSB7XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgY2FzZSAyOlxuICAgICAgICBjYXNlIDQ6XG4gICAgICAgIGNhc2UgODpcbiAgICAgICAgICByZXR1cm4gY3VycmVudFRpbWUgKyAyNTA7XG4gICAgICAgIGNhc2UgMTY6XG4gICAgICAgIGNhc2UgMzI6XG4gICAgICAgIGNhc2UgNjQ6XG4gICAgICAgIGNhc2UgMTI4OlxuICAgICAgICBjYXNlIDI1NjpcbiAgICAgICAgY2FzZSA1MTI6XG4gICAgICAgIGNhc2UgMTAyNDpcbiAgICAgICAgY2FzZSAyMDQ4OlxuICAgICAgICBjYXNlIDQwOTY6XG4gICAgICAgIGNhc2UgODE5MjpcbiAgICAgICAgY2FzZSAxNjM4NDpcbiAgICAgICAgY2FzZSAzMjc2ODpcbiAgICAgICAgY2FzZSA2NTUzNjpcbiAgICAgICAgY2FzZSAxMzEwNzI6XG4gICAgICAgIGNhc2UgMjYyMTQ0OlxuICAgICAgICBjYXNlIDUyNDI4ODpcbiAgICAgICAgY2FzZSAxMDQ4NTc2OlxuICAgICAgICBjYXNlIDIwOTcxNTI6XG4gICAgICAgICAgcmV0dXJuIGN1cnJlbnRUaW1lICsgNWUzO1xuICAgICAgICBjYXNlIDQxOTQzMDQ6XG4gICAgICAgIGNhc2UgODM4ODYwODpcbiAgICAgICAgY2FzZSAxNjc3NzIxNjpcbiAgICAgICAgY2FzZSAzMzU1NDQzMjpcbiAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgIGNhc2UgNjcxMDg4NjQ6XG4gICAgICAgIGNhc2UgMTM0MjE3NzI4OlxuICAgICAgICBjYXNlIDI2ODQzNTQ1NjpcbiAgICAgICAgY2FzZSA1MzY4NzA5MTI6XG4gICAgICAgIGNhc2UgMTA3Mzc0MTgyNDpcbiAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgIFwiU2hvdWxkIGhhdmUgZm91bmQgbWF0Y2hpbmcgbGFuZXMuIFRoaXMgaXMgYSBidWcgaW4gUmVhY3QuXCJcbiAgICAgICAgICAgICksXG4gICAgICAgICAgICAtMVxuICAgICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNsYWltTmV4dFRyYW5zaXRpb25MYW5lKCkge1xuICAgICAgdmFyIGxhbmUgPSBuZXh0VHJhbnNpdGlvbkxhbmU7XG4gICAgICBuZXh0VHJhbnNpdGlvbkxhbmUgPDw9IDE7XG4gICAgICAwID09PSAobmV4dFRyYW5zaXRpb25MYW5lICYgNDE5NDE3NikgJiYgKG5leHRUcmFuc2l0aW9uTGFuZSA9IDEyOCk7XG4gICAgICByZXR1cm4gbGFuZTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY2xhaW1OZXh0UmV0cnlMYW5lKCkge1xuICAgICAgdmFyIGxhbmUgPSBuZXh0UmV0cnlMYW5lO1xuICAgICAgbmV4dFJldHJ5TGFuZSA8PD0gMTtcbiAgICAgIDAgPT09IChuZXh0UmV0cnlMYW5lICYgNjI5MTQ1NjApICYmIChuZXh0UmV0cnlMYW5lID0gNDE5NDMwNCk7XG4gICAgICByZXR1cm4gbGFuZTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY3JlYXRlTGFuZU1hcChpbml0aWFsKSB7XG4gICAgICBmb3IgKHZhciBsYW5lTWFwID0gW10sIGkgPSAwOyAzMSA+IGk7IGkrKykgbGFuZU1hcC5wdXNoKGluaXRpYWwpO1xuICAgICAgcmV0dXJuIGxhbmVNYXA7XG4gICAgfVxuICAgIGZ1bmN0aW9uIG1hcmtSb290VXBkYXRlZCQxKHJvb3QsIHVwZGF0ZUxhbmUpIHtcbiAgICAgIHJvb3QucGVuZGluZ0xhbmVzIHw9IHVwZGF0ZUxhbmU7XG4gICAgICAyNjg0MzU0NTYgIT09IHVwZGF0ZUxhbmUgJiZcbiAgICAgICAgKChyb290LnN1c3BlbmRlZExhbmVzID0gMCksXG4gICAgICAgIChyb290LnBpbmdlZExhbmVzID0gMCksXG4gICAgICAgIChyb290Lndhcm1MYW5lcyA9IDApKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gbWFya1Jvb3RGaW5pc2hlZChcbiAgICAgIHJvb3QsXG4gICAgICBmaW5pc2hlZExhbmVzLFxuICAgICAgcmVtYWluaW5nTGFuZXMsXG4gICAgICBzcGF3bmVkTGFuZSxcbiAgICAgIHVwZGF0ZWRMYW5lcyxcbiAgICAgIHN1c3BlbmRlZFJldHJ5TGFuZXNcbiAgICApIHtcbiAgICAgIHZhciBwcmV2aW91c2x5UGVuZGluZ0xhbmVzID0gcm9vdC5wZW5kaW5nTGFuZXM7XG4gICAgICByb290LnBlbmRpbmdMYW5lcyA9IHJlbWFpbmluZ0xhbmVzO1xuICAgICAgcm9vdC5zdXNwZW5kZWRMYW5lcyA9IDA7XG4gICAgICByb290LnBpbmdlZExhbmVzID0gMDtcbiAgICAgIHJvb3Qud2FybUxhbmVzID0gMDtcbiAgICAgIHJvb3QuZXhwaXJlZExhbmVzICY9IHJlbWFpbmluZ0xhbmVzO1xuICAgICAgcm9vdC5lbnRhbmdsZWRMYW5lcyAmPSByZW1haW5pbmdMYW5lcztcbiAgICAgIHJvb3QuZXJyb3JSZWNvdmVyeURpc2FibGVkTGFuZXMgJj0gcmVtYWluaW5nTGFuZXM7XG4gICAgICByb290LnNoZWxsU3VzcGVuZENvdW50ZXIgPSAwO1xuICAgICAgdmFyIGVudGFuZ2xlbWVudHMgPSByb290LmVudGFuZ2xlbWVudHMsXG4gICAgICAgIGV4cGlyYXRpb25UaW1lcyA9IHJvb3QuZXhwaXJhdGlvblRpbWVzLFxuICAgICAgICBoaWRkZW5VcGRhdGVzID0gcm9vdC5oaWRkZW5VcGRhdGVzO1xuICAgICAgZm9yIChcbiAgICAgICAgcmVtYWluaW5nTGFuZXMgPSBwcmV2aW91c2x5UGVuZGluZ0xhbmVzICYgfnJlbWFpbmluZ0xhbmVzO1xuICAgICAgICAwIDwgcmVtYWluaW5nTGFuZXM7XG5cbiAgICAgICkge1xuICAgICAgICB2YXIgaW5kZXggPSAzMSAtIGNsejMyKHJlbWFpbmluZ0xhbmVzKSxcbiAgICAgICAgICBsYW5lID0gMSA8PCBpbmRleDtcbiAgICAgICAgZW50YW5nbGVtZW50c1tpbmRleF0gPSAwO1xuICAgICAgICBleHBpcmF0aW9uVGltZXNbaW5kZXhdID0gLTE7XG4gICAgICAgIHZhciBoaWRkZW5VcGRhdGVzRm9yTGFuZSA9IGhpZGRlblVwZGF0ZXNbaW5kZXhdO1xuICAgICAgICBpZiAobnVsbCAhPT0gaGlkZGVuVXBkYXRlc0ZvckxhbmUpXG4gICAgICAgICAgZm9yIChcbiAgICAgICAgICAgIGhpZGRlblVwZGF0ZXNbaW5kZXhdID0gbnVsbCwgaW5kZXggPSAwO1xuICAgICAgICAgICAgaW5kZXggPCBoaWRkZW5VcGRhdGVzRm9yTGFuZS5sZW5ndGg7XG4gICAgICAgICAgICBpbmRleCsrXG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICB2YXIgdXBkYXRlID0gaGlkZGVuVXBkYXRlc0ZvckxhbmVbaW5kZXhdO1xuICAgICAgICAgICAgbnVsbCAhPT0gdXBkYXRlICYmICh1cGRhdGUubGFuZSAmPSAtNTM2ODcwOTEzKTtcbiAgICAgICAgICB9XG4gICAgICAgIHJlbWFpbmluZ0xhbmVzICY9IH5sYW5lO1xuICAgICAgfVxuICAgICAgMCAhPT0gc3Bhd25lZExhbmUgJiYgbWFya1NwYXduZWREZWZlcnJlZExhbmUocm9vdCwgc3Bhd25lZExhbmUsIDApO1xuICAgICAgMCAhPT0gc3VzcGVuZGVkUmV0cnlMYW5lcyAmJlxuICAgICAgICAwID09PSB1cGRhdGVkTGFuZXMgJiZcbiAgICAgICAgMCAhPT0gcm9vdC50YWcgJiZcbiAgICAgICAgKHJvb3Quc3VzcGVuZGVkTGFuZXMgfD1cbiAgICAgICAgICBzdXNwZW5kZWRSZXRyeUxhbmVzICYgfihwcmV2aW91c2x5UGVuZGluZ0xhbmVzICYgfmZpbmlzaGVkTGFuZXMpKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gbWFya1NwYXduZWREZWZlcnJlZExhbmUocm9vdCwgc3Bhd25lZExhbmUsIGVudGFuZ2xlZExhbmVzKSB7XG4gICAgICByb290LnBlbmRpbmdMYW5lcyB8PSBzcGF3bmVkTGFuZTtcbiAgICAgIHJvb3Quc3VzcGVuZGVkTGFuZXMgJj0gfnNwYXduZWRMYW5lO1xuICAgICAgdmFyIHNwYXduZWRMYW5lSW5kZXggPSAzMSAtIGNsejMyKHNwYXduZWRMYW5lKTtcbiAgICAgIHJvb3QuZW50YW5nbGVkTGFuZXMgfD0gc3Bhd25lZExhbmU7XG4gICAgICByb290LmVudGFuZ2xlbWVudHNbc3Bhd25lZExhbmVJbmRleF0gPVxuICAgICAgICByb290LmVudGFuZ2xlbWVudHNbc3Bhd25lZExhbmVJbmRleF0gfFxuICAgICAgICAxMDczNzQxODI0IHxcbiAgICAgICAgKGVudGFuZ2xlZExhbmVzICYgNDE5NDIxOCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIG1hcmtSb290RW50YW5nbGVkKHJvb3QsIGVudGFuZ2xlZExhbmVzKSB7XG4gICAgICB2YXIgcm9vdEVudGFuZ2xlZExhbmVzID0gKHJvb3QuZW50YW5nbGVkTGFuZXMgfD0gZW50YW5nbGVkTGFuZXMpO1xuICAgICAgZm9yIChyb290ID0gcm9vdC5lbnRhbmdsZW1lbnRzOyByb290RW50YW5nbGVkTGFuZXM7ICkge1xuICAgICAgICB2YXIgaW5kZXggPSAzMSAtIGNsejMyKHJvb3RFbnRhbmdsZWRMYW5lcyksXG4gICAgICAgICAgbGFuZSA9IDEgPDwgaW5kZXg7XG4gICAgICAgIChsYW5lICYgZW50YW5nbGVkTGFuZXMpIHwgKHJvb3RbaW5kZXhdICYgZW50YW5nbGVkTGFuZXMpICYmXG4gICAgICAgICAgKHJvb3RbaW5kZXhdIHw9IGVudGFuZ2xlZExhbmVzKTtcbiAgICAgICAgcm9vdEVudGFuZ2xlZExhbmVzICY9IH5sYW5lO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBhZGRGaWJlclRvTGFuZXNNYXAocm9vdCwgZmliZXIsIGxhbmVzKSB7XG4gICAgICBpZiAoaXNEZXZUb29sc1ByZXNlbnQpXG4gICAgICAgIGZvciAocm9vdCA9IHJvb3QucGVuZGluZ1VwZGF0ZXJzTGFuZU1hcDsgMCA8IGxhbmVzOyApIHtcbiAgICAgICAgICB2YXIgaW5kZXggPSAzMSAtIGNsejMyKGxhbmVzKSxcbiAgICAgICAgICAgIGxhbmUgPSAxIDw8IGluZGV4O1xuICAgICAgICAgIHJvb3RbaW5kZXhdLmFkZChmaWJlcik7XG4gICAgICAgICAgbGFuZXMgJj0gfmxhbmU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gbW92ZVBlbmRpbmdGaWJlcnNUb01lbW9pemVkKHJvb3QsIGxhbmVzKSB7XG4gICAgICBpZiAoaXNEZXZUb29sc1ByZXNlbnQpXG4gICAgICAgIGZvciAoXG4gICAgICAgICAgdmFyIHBlbmRpbmdVcGRhdGVyc0xhbmVNYXAgPSByb290LnBlbmRpbmdVcGRhdGVyc0xhbmVNYXAsXG4gICAgICAgICAgICBtZW1vaXplZFVwZGF0ZXJzID0gcm9vdC5tZW1vaXplZFVwZGF0ZXJzO1xuICAgICAgICAgIDAgPCBsYW5lcztcblxuICAgICAgICApIHtcbiAgICAgICAgICB2YXIgaW5kZXggPSAzMSAtIGNsejMyKGxhbmVzKTtcbiAgICAgICAgICByb290ID0gMSA8PCBpbmRleDtcbiAgICAgICAgICBpbmRleCA9IHBlbmRpbmdVcGRhdGVyc0xhbmVNYXBbaW5kZXhdO1xuICAgICAgICAgIDAgPCBpbmRleC5zaXplICYmXG4gICAgICAgICAgICAoaW5kZXguZm9yRWFjaChmdW5jdGlvbiAoZmliZXIpIHtcbiAgICAgICAgICAgICAgdmFyIGFsdGVybmF0ZSA9IGZpYmVyLmFsdGVybmF0ZTtcbiAgICAgICAgICAgICAgKG51bGwgIT09IGFsdGVybmF0ZSAmJiBtZW1vaXplZFVwZGF0ZXJzLmhhcyhhbHRlcm5hdGUpKSB8fFxuICAgICAgICAgICAgICAgIG1lbW9pemVkVXBkYXRlcnMuYWRkKGZpYmVyKTtcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgaW5kZXguY2xlYXIoKSk7XG4gICAgICAgICAgbGFuZXMgJj0gfnJvb3Q7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gbGFuZXNUb0V2ZW50UHJpb3JpdHkobGFuZXMpIHtcbiAgICAgIGxhbmVzICY9IC1sYW5lcztcbiAgICAgIHJldHVybiAyIDwgbGFuZXNcbiAgICAgICAgPyA4IDwgbGFuZXNcbiAgICAgICAgICA/IDAgIT09IChsYW5lcyAmIDEzNDIxNzcyNylcbiAgICAgICAgICAgID8gMzJcbiAgICAgICAgICAgIDogMjY4NDM1NDU2XG4gICAgICAgICAgOiA4XG4gICAgICAgIDogMjtcbiAgICB9XG4gICAgZnVuY3Rpb24gaW5qZWN0SW50ZXJuYWxzKGludGVybmFscykge1xuICAgICAgaWYgKFwidW5kZWZpbmVkXCIgPT09IHR5cGVvZiBfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX18pIHJldHVybiAhMTtcbiAgICAgIHZhciBob29rID0gX19SRUFDVF9ERVZUT09MU19HTE9CQUxfSE9PS19fO1xuICAgICAgaWYgKGhvb2suaXNEaXNhYmxlZCkgcmV0dXJuICEwO1xuICAgICAgaWYgKCFob29rLnN1cHBvcnRzRmliZXIpXG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgIFwiVGhlIGluc3RhbGxlZCB2ZXJzaW9uIG9mIFJlYWN0IERldlRvb2xzIGlzIHRvbyBvbGQgYW5kIHdpbGwgbm90IHdvcmsgd2l0aCB0aGUgY3VycmVudCB2ZXJzaW9uIG9mIFJlYWN0LiBQbGVhc2UgdXBkYXRlIFJlYWN0IERldlRvb2xzLiBodHRwczovL3JlYWN0LmRldi9saW5rL3JlYWN0LWRldnRvb2xzXCJcbiAgICAgICAgICApLFxuICAgICAgICAgICEwXG4gICAgICAgICk7XG4gICAgICB0cnkge1xuICAgICAgICAocmVuZGVyZXJJRCA9IGhvb2suaW5qZWN0KGludGVybmFscykpLCAoaW5qZWN0ZWRIb29rID0gaG9vayk7XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihcIlJlYWN0IGluc3RydW1lbnRhdGlvbiBlbmNvdW50ZXJlZCBhbiBlcnJvcjogJXMuXCIsIGVycik7XG4gICAgICB9XG4gICAgICByZXR1cm4gaG9vay5jaGVja0RDRSA/ICEwIDogITE7XG4gICAgfVxuICAgIGZ1bmN0aW9uIG9uQ29tbWl0Um9vdCQxKHJvb3QsIGV2ZW50UHJpb3JpdHkpIHtcbiAgICAgIGlmIChpbmplY3RlZEhvb2sgJiYgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgaW5qZWN0ZWRIb29rLm9uQ29tbWl0RmliZXJSb290KVxuICAgICAgICB0cnkge1xuICAgICAgICAgIHZhciBkaWRFcnJvciA9IDEyOCA9PT0gKHJvb3QuY3VycmVudC5mbGFncyAmIDEyOCk7XG4gICAgICAgICAgc3dpdGNoIChldmVudFByaW9yaXR5KSB7XG4gICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgIHZhciBzY2hlZHVsZXJQcmlvcml0eSA9IEltbWVkaWF0ZVByaW9yaXR5O1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgODpcbiAgICAgICAgICAgICAgc2NoZWR1bGVyUHJpb3JpdHkgPSBVc2VyQmxvY2tpbmdQcmlvcml0eTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDMyOlxuICAgICAgICAgICAgICBzY2hlZHVsZXJQcmlvcml0eSA9IE5vcm1hbFByaW9yaXR5JDE7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAyNjg0MzU0NTY6XG4gICAgICAgICAgICAgIHNjaGVkdWxlclByaW9yaXR5ID0gSWRsZVByaW9yaXR5O1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgIHNjaGVkdWxlclByaW9yaXR5ID0gTm9ybWFsUHJpb3JpdHkkMTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaW5qZWN0ZWRIb29rLm9uQ29tbWl0RmliZXJSb290KFxuICAgICAgICAgICAgcmVuZGVyZXJJRCxcbiAgICAgICAgICAgIHJvb3QsXG4gICAgICAgICAgICBzY2hlZHVsZXJQcmlvcml0eSxcbiAgICAgICAgICAgIGRpZEVycm9yXG4gICAgICAgICAgKTtcbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgaGFzTG9nZ2VkRXJyb3IgfHxcbiAgICAgICAgICAgICgoaGFzTG9nZ2VkRXJyb3IgPSAhMCksXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICBcIlJlYWN0IGluc3RydW1lbnRhdGlvbiBlbmNvdW50ZXJlZCBhbiBlcnJvcjogJXNcIixcbiAgICAgICAgICAgICAgZXJyXG4gICAgICAgICAgICApKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBzZXRJc1N0cmljdE1vZGVGb3JEZXZ0b29scyhuZXdJc1N0cmljdE1vZGUpIHtcbiAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIGxvZyAmJlxuICAgICAgICB1bnN0YWJsZV9zZXREaXNhYmxlWWllbGRWYWx1ZShuZXdJc1N0cmljdE1vZGUpO1xuICAgICAgaWYgKGluamVjdGVkSG9vayAmJiBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBpbmplY3RlZEhvb2suc2V0U3RyaWN0TW9kZSlcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBpbmplY3RlZEhvb2suc2V0U3RyaWN0TW9kZShyZW5kZXJlcklELCBuZXdJc1N0cmljdE1vZGUpO1xuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICBoYXNMb2dnZWRFcnJvciB8fFxuICAgICAgICAgICAgKChoYXNMb2dnZWRFcnJvciA9ICEwKSxcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgIFwiUmVhY3QgaW5zdHJ1bWVudGF0aW9uIGVuY291bnRlcmVkIGFuIGVycm9yOiAlc1wiLFxuICAgICAgICAgICAgICBlcnJcbiAgICAgICAgICAgICkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGluamVjdFByb2ZpbGluZ0hvb2tzKHByb2ZpbGluZ0hvb2tzKSB7XG4gICAgICBpbmplY3RlZFByb2ZpbGluZ0hvb2tzID0gcHJvZmlsaW5nSG9va3M7XG4gICAgfVxuICAgIGZ1bmN0aW9uIG1hcmtDb21taXRTdG9wcGVkKCkge1xuICAgICAgbnVsbCAhPT0gaW5qZWN0ZWRQcm9maWxpbmdIb29rcyAmJlxuICAgICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBpbmplY3RlZFByb2ZpbGluZ0hvb2tzLm1hcmtDb21taXRTdG9wcGVkICYmXG4gICAgICAgIGluamVjdGVkUHJvZmlsaW5nSG9va3MubWFya0NvbW1pdFN0b3BwZWQoKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gbWFya0NvbXBvbmVudFJlbmRlclN0YXJ0ZWQoZmliZXIpIHtcbiAgICAgIG51bGwgIT09IGluamVjdGVkUHJvZmlsaW5nSG9va3MgJiZcbiAgICAgICAgXCJmdW5jdGlvblwiID09PVxuICAgICAgICAgIHR5cGVvZiBpbmplY3RlZFByb2ZpbGluZ0hvb2tzLm1hcmtDb21wb25lbnRSZW5kZXJTdGFydGVkICYmXG4gICAgICAgIGluamVjdGVkUHJvZmlsaW5nSG9va3MubWFya0NvbXBvbmVudFJlbmRlclN0YXJ0ZWQoZmliZXIpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBtYXJrQ29tcG9uZW50UmVuZGVyU3RvcHBlZCgpIHtcbiAgICAgIG51bGwgIT09IGluamVjdGVkUHJvZmlsaW5nSG9va3MgJiZcbiAgICAgICAgXCJmdW5jdGlvblwiID09PVxuICAgICAgICAgIHR5cGVvZiBpbmplY3RlZFByb2ZpbGluZ0hvb2tzLm1hcmtDb21wb25lbnRSZW5kZXJTdG9wcGVkICYmXG4gICAgICAgIGluamVjdGVkUHJvZmlsaW5nSG9va3MubWFya0NvbXBvbmVudFJlbmRlclN0b3BwZWQoKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gbWFya1JlbmRlclN0YXJ0ZWQobGFuZXMpIHtcbiAgICAgIG51bGwgIT09IGluamVjdGVkUHJvZmlsaW5nSG9va3MgJiZcbiAgICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgaW5qZWN0ZWRQcm9maWxpbmdIb29rcy5tYXJrUmVuZGVyU3RhcnRlZCAmJlxuICAgICAgICBpbmplY3RlZFByb2ZpbGluZ0hvb2tzLm1hcmtSZW5kZXJTdGFydGVkKGxhbmVzKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gbWFya1JlbmRlclN0b3BwZWQoKSB7XG4gICAgICBudWxsICE9PSBpbmplY3RlZFByb2ZpbGluZ0hvb2tzICYmXG4gICAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIGluamVjdGVkUHJvZmlsaW5nSG9va3MubWFya1JlbmRlclN0b3BwZWQgJiZcbiAgICAgICAgaW5qZWN0ZWRQcm9maWxpbmdIb29rcy5tYXJrUmVuZGVyU3RvcHBlZCgpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBtYXJrU3RhdGVVcGRhdGVTY2hlZHVsZWQoZmliZXIsIGxhbmUpIHtcbiAgICAgIG51bGwgIT09IGluamVjdGVkUHJvZmlsaW5nSG9va3MgJiZcbiAgICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgaW5qZWN0ZWRQcm9maWxpbmdIb29rcy5tYXJrU3RhdGVVcGRhdGVTY2hlZHVsZWQgJiZcbiAgICAgICAgaW5qZWN0ZWRQcm9maWxpbmdIb29rcy5tYXJrU3RhdGVVcGRhdGVTY2hlZHVsZWQoZmliZXIsIGxhbmUpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBpcyh4LCB5KSB7XG4gICAgICByZXR1cm4gKHggPT09IHkgJiYgKDAgIT09IHggfHwgMSAvIHggPT09IDEgLyB5KSkgfHwgKHggIT09IHggJiYgeSAhPT0geSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNyZWF0ZUNhcHR1cmVkVmFsdWVBdEZpYmVyKHZhbHVlLCBzb3VyY2UpIHtcbiAgICAgIGlmIChcIm9iamVjdFwiID09PSB0eXBlb2YgdmFsdWUgJiYgbnVsbCAhPT0gdmFsdWUpIHtcbiAgICAgICAgdmFyIGV4aXN0aW5nID0gQ2FwdHVyZWRTdGFja3MuZ2V0KHZhbHVlKTtcbiAgICAgICAgaWYgKHZvaWQgMCAhPT0gZXhpc3RpbmcpIHJldHVybiBleGlzdGluZztcbiAgICAgICAgc291cmNlID0ge1xuICAgICAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgICAgICBzb3VyY2U6IHNvdXJjZSxcbiAgICAgICAgICBzdGFjazogZ2V0U3RhY2tCeUZpYmVySW5EZXZBbmRQcm9kKHNvdXJjZSlcbiAgICAgICAgfTtcbiAgICAgICAgQ2FwdHVyZWRTdGFja3Muc2V0KHZhbHVlLCBzb3VyY2UpO1xuICAgICAgICByZXR1cm4gc291cmNlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgICBzb3VyY2U6IHNvdXJjZSxcbiAgICAgICAgc3RhY2s6IGdldFN0YWNrQnlGaWJlckluRGV2QW5kUHJvZChzb3VyY2UpXG4gICAgICB9O1xuICAgIH1cbiAgICBmdW5jdGlvbiBwdXNoVHJlZUZvcmsod29ya0luUHJvZ3Jlc3MsIHRvdGFsQ2hpbGRyZW4pIHtcbiAgICAgIHdhcm5JZk5vdEh5ZHJhdGluZygpO1xuICAgICAgZm9ya1N0YWNrW2ZvcmtTdGFja0luZGV4KytdID0gdHJlZUZvcmtDb3VudDtcbiAgICAgIGZvcmtTdGFja1tmb3JrU3RhY2tJbmRleCsrXSA9IHRyZWVGb3JrUHJvdmlkZXI7XG4gICAgICB0cmVlRm9ya1Byb3ZpZGVyID0gd29ya0luUHJvZ3Jlc3M7XG4gICAgICB0cmVlRm9ya0NvdW50ID0gdG90YWxDaGlsZHJlbjtcbiAgICB9XG4gICAgZnVuY3Rpb24gcHVzaFRyZWVJZCh3b3JrSW5Qcm9ncmVzcywgdG90YWxDaGlsZHJlbiwgaW5kZXgpIHtcbiAgICAgIHdhcm5JZk5vdEh5ZHJhdGluZygpO1xuICAgICAgaWRTdGFja1tpZFN0YWNrSW5kZXgrK10gPSB0cmVlQ29udGV4dElkO1xuICAgICAgaWRTdGFja1tpZFN0YWNrSW5kZXgrK10gPSB0cmVlQ29udGV4dE92ZXJmbG93O1xuICAgICAgaWRTdGFja1tpZFN0YWNrSW5kZXgrK10gPSB0cmVlQ29udGV4dFByb3ZpZGVyO1xuICAgICAgdHJlZUNvbnRleHRQcm92aWRlciA9IHdvcmtJblByb2dyZXNzO1xuICAgICAgdmFyIGJhc2VJZFdpdGhMZWFkaW5nQml0ID0gdHJlZUNvbnRleHRJZDtcbiAgICAgIHdvcmtJblByb2dyZXNzID0gdHJlZUNvbnRleHRPdmVyZmxvdztcbiAgICAgIHZhciBiYXNlTGVuZ3RoID0gMzIgLSBjbHozMihiYXNlSWRXaXRoTGVhZGluZ0JpdCkgLSAxO1xuICAgICAgYmFzZUlkV2l0aExlYWRpbmdCaXQgJj0gfigxIDw8IGJhc2VMZW5ndGgpO1xuICAgICAgaW5kZXggKz0gMTtcbiAgICAgIHZhciBsZW5ndGggPSAzMiAtIGNsejMyKHRvdGFsQ2hpbGRyZW4pICsgYmFzZUxlbmd0aDtcbiAgICAgIGlmICgzMCA8IGxlbmd0aCkge1xuICAgICAgICB2YXIgbnVtYmVyT2ZPdmVyZmxvd0JpdHMgPSBiYXNlTGVuZ3RoIC0gKGJhc2VMZW5ndGggJSA1KTtcbiAgICAgICAgbGVuZ3RoID0gKFxuICAgICAgICAgIGJhc2VJZFdpdGhMZWFkaW5nQml0ICZcbiAgICAgICAgICAoKDEgPDwgbnVtYmVyT2ZPdmVyZmxvd0JpdHMpIC0gMSlcbiAgICAgICAgKS50b1N0cmluZygzMik7XG4gICAgICAgIGJhc2VJZFdpdGhMZWFkaW5nQml0ID4+PSBudW1iZXJPZk92ZXJmbG93Qml0cztcbiAgICAgICAgYmFzZUxlbmd0aCAtPSBudW1iZXJPZk92ZXJmbG93Qml0cztcbiAgICAgICAgdHJlZUNvbnRleHRJZCA9XG4gICAgICAgICAgKDEgPDwgKDMyIC0gY2x6MzIodG90YWxDaGlsZHJlbikgKyBiYXNlTGVuZ3RoKSkgfFxuICAgICAgICAgIChpbmRleCA8PCBiYXNlTGVuZ3RoKSB8XG4gICAgICAgICAgYmFzZUlkV2l0aExlYWRpbmdCaXQ7XG4gICAgICAgIHRyZWVDb250ZXh0T3ZlcmZsb3cgPSBsZW5ndGggKyB3b3JrSW5Qcm9ncmVzcztcbiAgICAgIH0gZWxzZVxuICAgICAgICAodHJlZUNvbnRleHRJZCA9XG4gICAgICAgICAgKDEgPDwgbGVuZ3RoKSB8IChpbmRleCA8PCBiYXNlTGVuZ3RoKSB8IGJhc2VJZFdpdGhMZWFkaW5nQml0KSxcbiAgICAgICAgICAodHJlZUNvbnRleHRPdmVyZmxvdyA9IHdvcmtJblByb2dyZXNzKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcHVzaE1hdGVyaWFsaXplZFRyZWVJZCh3b3JrSW5Qcm9ncmVzcykge1xuICAgICAgd2FybklmTm90SHlkcmF0aW5nKCk7XG4gICAgICBudWxsICE9PSB3b3JrSW5Qcm9ncmVzcy5yZXR1cm4gJiZcbiAgICAgICAgKHB1c2hUcmVlRm9yayh3b3JrSW5Qcm9ncmVzcywgMSksIHB1c2hUcmVlSWQod29ya0luUHJvZ3Jlc3MsIDEsIDApKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcG9wVHJlZUNvbnRleHQod29ya0luUHJvZ3Jlc3MpIHtcbiAgICAgIGZvciAoOyB3b3JrSW5Qcm9ncmVzcyA9PT0gdHJlZUZvcmtQcm92aWRlcjsgKVxuICAgICAgICAodHJlZUZvcmtQcm92aWRlciA9IGZvcmtTdGFja1stLWZvcmtTdGFja0luZGV4XSksXG4gICAgICAgICAgKGZvcmtTdGFja1tmb3JrU3RhY2tJbmRleF0gPSBudWxsKSxcbiAgICAgICAgICAodHJlZUZvcmtDb3VudCA9IGZvcmtTdGFja1stLWZvcmtTdGFja0luZGV4XSksXG4gICAgICAgICAgKGZvcmtTdGFja1tmb3JrU3RhY2tJbmRleF0gPSBudWxsKTtcbiAgICAgIGZvciAoOyB3b3JrSW5Qcm9ncmVzcyA9PT0gdHJlZUNvbnRleHRQcm92aWRlcjsgKVxuICAgICAgICAodHJlZUNvbnRleHRQcm92aWRlciA9IGlkU3RhY2tbLS1pZFN0YWNrSW5kZXhdKSxcbiAgICAgICAgICAoaWRTdGFja1tpZFN0YWNrSW5kZXhdID0gbnVsbCksXG4gICAgICAgICAgKHRyZWVDb250ZXh0T3ZlcmZsb3cgPSBpZFN0YWNrWy0taWRTdGFja0luZGV4XSksXG4gICAgICAgICAgKGlkU3RhY2tbaWRTdGFja0luZGV4XSA9IG51bGwpLFxuICAgICAgICAgICh0cmVlQ29udGV4dElkID0gaWRTdGFja1stLWlkU3RhY2tJbmRleF0pLFxuICAgICAgICAgIChpZFN0YWNrW2lkU3RhY2tJbmRleF0gPSBudWxsKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gd2FybklmTm90SHlkcmF0aW5nKCkge1xuICAgICAgaXNIeWRyYXRpbmcgfHxcbiAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICBcIkV4cGVjdGVkIHRvIGJlIGh5ZHJhdGluZy4gVGhpcyBpcyBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuXCJcbiAgICAgICAgKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcmVxdWlyZWRDb250ZXh0KGMpIHtcbiAgICAgIG51bGwgPT09IGMgJiZcbiAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICBcIkV4cGVjdGVkIGhvc3QgY29udGV4dCB0byBleGlzdC4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS5cIlxuICAgICAgICApO1xuICAgICAgcmV0dXJuIGM7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHB1c2hIb3N0Q29udGFpbmVyKGZpYmVyLCBuZXh0Um9vdEluc3RhbmNlKSB7XG4gICAgICBwdXNoKHJvb3RJbnN0YW5jZVN0YWNrQ3Vyc29yLCBuZXh0Um9vdEluc3RhbmNlLCBmaWJlcik7XG4gICAgICBwdXNoKGNvbnRleHRGaWJlclN0YWNrQ3Vyc29yLCBmaWJlciwgZmliZXIpO1xuICAgICAgcHVzaChjb250ZXh0U3RhY2tDdXJzb3IsIG51bGwsIGZpYmVyKTtcbiAgICAgIG5leHRSb290SW5zdGFuY2UgPSBnZXRSb290SG9zdENvbnRleHQobmV4dFJvb3RJbnN0YW5jZSk7XG4gICAgICBwb3AoY29udGV4dFN0YWNrQ3Vyc29yLCBmaWJlcik7XG4gICAgICBwdXNoKGNvbnRleHRTdGFja0N1cnNvciwgbmV4dFJvb3RJbnN0YW5jZSwgZmliZXIpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBwb3BIb3N0Q29udGFpbmVyKGZpYmVyKSB7XG4gICAgICBwb3AoY29udGV4dFN0YWNrQ3Vyc29yLCBmaWJlcik7XG4gICAgICBwb3AoY29udGV4dEZpYmVyU3RhY2tDdXJzb3IsIGZpYmVyKTtcbiAgICAgIHBvcChyb290SW5zdGFuY2VTdGFja0N1cnNvciwgZmliZXIpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBnZXRIb3N0Q29udGV4dCgpIHtcbiAgICAgIHJldHVybiByZXF1aXJlZENvbnRleHQoY29udGV4dFN0YWNrQ3Vyc29yLmN1cnJlbnQpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBwdXNoSG9zdENvbnRleHQoZmliZXIpIHtcbiAgICAgIG51bGwgIT09IGZpYmVyLm1lbW9pemVkU3RhdGUgJiZcbiAgICAgICAgcHVzaChob3N0VHJhbnNpdGlvblByb3ZpZGVyQ3Vyc29yLCBmaWJlciwgZmliZXIpO1xuICAgICAgdmFyIGNvbnRleHQgPSByZXF1aXJlZENvbnRleHQoY29udGV4dFN0YWNrQ3Vyc29yLmN1cnJlbnQpLFxuICAgICAgICBuZXh0Q29udGV4dCA9IGdldENoaWxkSG9zdENvbnRleHQoY29udGV4dCwgZmliZXIudHlwZSk7XG4gICAgICBjb250ZXh0ICE9PSBuZXh0Q29udGV4dCAmJlxuICAgICAgICAocHVzaChjb250ZXh0RmliZXJTdGFja0N1cnNvciwgZmliZXIsIGZpYmVyKSxcbiAgICAgICAgcHVzaChjb250ZXh0U3RhY2tDdXJzb3IsIG5leHRDb250ZXh0LCBmaWJlcikpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBwb3BIb3N0Q29udGV4dChmaWJlcikge1xuICAgICAgY29udGV4dEZpYmVyU3RhY2tDdXJzb3IuY3VycmVudCA9PT0gZmliZXIgJiZcbiAgICAgICAgKHBvcChjb250ZXh0U3RhY2tDdXJzb3IsIGZpYmVyKSwgcG9wKGNvbnRleHRGaWJlclN0YWNrQ3Vyc29yLCBmaWJlcikpO1xuICAgICAgaG9zdFRyYW5zaXRpb25Qcm92aWRlckN1cnNvci5jdXJyZW50ID09PSBmaWJlciAmJlxuICAgICAgICAocG9wKGhvc3RUcmFuc2l0aW9uUHJvdmlkZXJDdXJzb3IsIGZpYmVyKSxcbiAgICAgICAgaXNQcmltYXJ5UmVuZGVyZXJcbiAgICAgICAgICA/IChIb3N0VHJhbnNpdGlvbkNvbnRleHQuX2N1cnJlbnRWYWx1ZSA9IE5vdFBlbmRpbmdUcmFuc2l0aW9uKVxuICAgICAgICAgIDogKEhvc3RUcmFuc2l0aW9uQ29udGV4dC5fY3VycmVudFZhbHVlMiA9IE5vdFBlbmRpbmdUcmFuc2l0aW9uKSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGZpbmROb3RhYmxlTm9kZShub2RlLCBpbmRlbnQpIHtcbiAgICAgIHJldHVybiB2b2lkIDAgPT09IG5vZGUuc2VydmVyUHJvcHMgJiZcbiAgICAgICAgMCA9PT0gbm9kZS5zZXJ2ZXJUYWlsLmxlbmd0aCAmJlxuICAgICAgICAxID09PSBub2RlLmNoaWxkcmVuLmxlbmd0aCAmJlxuICAgICAgICAzIDwgbm9kZS5kaXN0YW5jZUZyb21MZWFmICYmXG4gICAgICAgIG5vZGUuZGlzdGFuY2VGcm9tTGVhZiA+IDE1IC0gaW5kZW50XG4gICAgICAgID8gZmluZE5vdGFibGVOb2RlKG5vZGUuY2hpbGRyZW5bMF0sIGluZGVudClcbiAgICAgICAgOiBub2RlO1xuICAgIH1cbiAgICBmdW5jdGlvbiBpbmRlbnRhdGlvbihpbmRlbnQpIHtcbiAgICAgIHJldHVybiBcIiAgXCIgKyBcIiAgXCIucmVwZWF0KGluZGVudCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGFkZGVkKGluZGVudCkge1xuICAgICAgcmV0dXJuIFwiKyBcIiArIFwiICBcIi5yZXBlYXQoaW5kZW50KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcmVtb3ZlZChpbmRlbnQpIHtcbiAgICAgIHJldHVybiBcIi0gXCIgKyBcIiAgXCIucmVwZWF0KGluZGVudCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGRlc2NyaWJlRmliZXJUeXBlKGZpYmVyKSB7XG4gICAgICBzd2l0Y2ggKGZpYmVyLnRhZykge1xuICAgICAgICBjYXNlIDI2OlxuICAgICAgICBjYXNlIDI3OlxuICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgcmV0dXJuIGZpYmVyLnR5cGU7XG4gICAgICAgIGNhc2UgMTY6XG4gICAgICAgICAgcmV0dXJuIFwiTGF6eVwiO1xuICAgICAgICBjYXNlIDEzOlxuICAgICAgICAgIHJldHVybiBcIlN1c3BlbnNlXCI7XG4gICAgICAgIGNhc2UgMTk6XG4gICAgICAgICAgcmV0dXJuIFwiU3VzcGVuc2VMaXN0XCI7XG4gICAgICAgIGNhc2UgMDpcbiAgICAgICAgY2FzZSAxNTpcbiAgICAgICAgICByZXR1cm4gKGZpYmVyID0gZmliZXIudHlwZSksIGZpYmVyLmRpc3BsYXlOYW1lIHx8IGZpYmVyLm5hbWUgfHwgbnVsbDtcbiAgICAgICAgY2FzZSAxMTpcbiAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgKGZpYmVyID0gZmliZXIudHlwZS5yZW5kZXIpLCBmaWJlci5kaXNwbGF5TmFtZSB8fCBmaWJlci5uYW1lIHx8IG51bGxcbiAgICAgICAgICApO1xuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgcmV0dXJuIChmaWJlciA9IGZpYmVyLnR5cGUpLCBmaWJlci5kaXNwbGF5TmFtZSB8fCBmaWJlci5uYW1lIHx8IG51bGw7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGRlc2NyaWJlVGV4dE5vZGUoY29udGVudCwgbWF4TGVuZ3RoKSB7XG4gICAgICByZXR1cm4gbmVlZHNFc2NhcGluZy50ZXN0KGNvbnRlbnQpXG4gICAgICAgID8gKChjb250ZW50ID0gSlNPTi5zdHJpbmdpZnkoY29udGVudCkpLFxuICAgICAgICAgIGNvbnRlbnQubGVuZ3RoID4gbWF4TGVuZ3RoIC0gMlxuICAgICAgICAgICAgPyA4ID4gbWF4TGVuZ3RoXG4gICAgICAgICAgICAgID8gJ3tcIi4uLlwifSdcbiAgICAgICAgICAgICAgOiBcIntcIiArIGNvbnRlbnQuc2xpY2UoMCwgbWF4TGVuZ3RoIC0gNykgKyAnLi4uXCJ9J1xuICAgICAgICAgICAgOiBcIntcIiArIGNvbnRlbnQgKyBcIn1cIilcbiAgICAgICAgOiBjb250ZW50Lmxlbmd0aCA+IG1heExlbmd0aFxuICAgICAgICAgID8gNSA+IG1heExlbmd0aFxuICAgICAgICAgICAgPyAne1wiLi4uXCJ9J1xuICAgICAgICAgICAgOiBjb250ZW50LnNsaWNlKDAsIG1heExlbmd0aCAtIDMpICsgXCIuLi5cIlxuICAgICAgICAgIDogY29udGVudDtcbiAgICB9XG4gICAgZnVuY3Rpb24gZGVzY3JpYmVUZXh0RGlmZihjbGllbnRUZXh0LCBzZXJ2ZXJQcm9wcywgaW5kZW50KSB7XG4gICAgICB2YXIgbWF4TGVuZ3RoID0gMTIwIC0gMiAqIGluZGVudDtcbiAgICAgIGlmIChudWxsID09PSBzZXJ2ZXJQcm9wcylcbiAgICAgICAgcmV0dXJuIGFkZGVkKGluZGVudCkgKyBkZXNjcmliZVRleHROb2RlKGNsaWVudFRleHQsIG1heExlbmd0aCkgKyBcIlxcblwiO1xuICAgICAgaWYgKFwic3RyaW5nXCIgPT09IHR5cGVvZiBzZXJ2ZXJQcm9wcykge1xuICAgICAgICBmb3IgKFxuICAgICAgICAgIHZhciBmaXJzdERpZmYgPSAwO1xuICAgICAgICAgIGZpcnN0RGlmZiA8IHNlcnZlclByb3BzLmxlbmd0aCAmJlxuICAgICAgICAgIGZpcnN0RGlmZiA8IGNsaWVudFRleHQubGVuZ3RoICYmXG4gICAgICAgICAgc2VydmVyUHJvcHMuY2hhckNvZGVBdChmaXJzdERpZmYpID09PVxuICAgICAgICAgICAgY2xpZW50VGV4dC5jaGFyQ29kZUF0KGZpcnN0RGlmZik7XG4gICAgICAgICAgZmlyc3REaWZmKytcbiAgICAgICAgKTtcbiAgICAgICAgZmlyc3REaWZmID4gbWF4TGVuZ3RoIC0gOCAmJlxuICAgICAgICAgIDEwIDwgZmlyc3REaWZmICYmXG4gICAgICAgICAgKChjbGllbnRUZXh0ID0gXCIuLi5cIiArIGNsaWVudFRleHQuc2xpY2UoZmlyc3REaWZmIC0gOCkpLFxuICAgICAgICAgIChzZXJ2ZXJQcm9wcyA9IFwiLi4uXCIgKyBzZXJ2ZXJQcm9wcy5zbGljZShmaXJzdERpZmYgLSA4KSkpO1xuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgIGFkZGVkKGluZGVudCkgK1xuICAgICAgICAgIGRlc2NyaWJlVGV4dE5vZGUoY2xpZW50VGV4dCwgbWF4TGVuZ3RoKSArXG4gICAgICAgICAgXCJcXG5cIiArXG4gICAgICAgICAgcmVtb3ZlZChpbmRlbnQpICtcbiAgICAgICAgICBkZXNjcmliZVRleHROb2RlKHNlcnZlclByb3BzLCBtYXhMZW5ndGgpICtcbiAgICAgICAgICBcIlxcblwiXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICByZXR1cm4gKFxuICAgICAgICBpbmRlbnRhdGlvbihpbmRlbnQpICsgZGVzY3JpYmVUZXh0Tm9kZShjbGllbnRUZXh0LCBtYXhMZW5ndGgpICsgXCJcXG5cIlxuICAgICAgKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gb2JqZWN0TmFtZShvYmplY3QpIHtcbiAgICAgIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nXG4gICAgICAgIC5jYWxsKG9iamVjdClcbiAgICAgICAgLnJlcGxhY2UoL15cXFtvYmplY3QgKC4qKVxcXSQvLCBmdW5jdGlvbiAobSwgcDApIHtcbiAgICAgICAgICByZXR1cm4gcDA7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBmdW5jdGlvbiBkZXNjcmliZVZhbHVlKHZhbHVlLCBtYXhMZW5ndGgpIHtcbiAgICAgIHN3aXRjaCAodHlwZW9mIHZhbHVlKSB7XG4gICAgICAgIGNhc2UgXCJzdHJpbmdcIjpcbiAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgKHZhbHVlID0gSlNPTi5zdHJpbmdpZnkodmFsdWUpKSxcbiAgICAgICAgICAgIHZhbHVlLmxlbmd0aCA+IG1heExlbmd0aFxuICAgICAgICAgICAgICA/IDUgPiBtYXhMZW5ndGhcbiAgICAgICAgICAgICAgICA/ICdcIi4uLlwiJ1xuICAgICAgICAgICAgICAgIDogdmFsdWUuc2xpY2UoMCwgbWF4TGVuZ3RoIC0gNCkgKyAnLi4uXCInXG4gICAgICAgICAgICAgIDogdmFsdWVcbiAgICAgICAgICApO1xuICAgICAgICBjYXNlIFwib2JqZWN0XCI6XG4gICAgICAgICAgaWYgKG51bGwgPT09IHZhbHVlKSByZXR1cm4gXCJudWxsXCI7XG4gICAgICAgICAgaWYgKGlzQXJyYXlJbXBsKHZhbHVlKSkgcmV0dXJuIFwiWy4uLl1cIjtcbiAgICAgICAgICBpZiAodmFsdWUuJCR0eXBlb2YgPT09IFJFQUNUX0VMRU1FTlRfVFlQRSlcbiAgICAgICAgICAgIHJldHVybiAobWF4TGVuZ3RoID0gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHZhbHVlLnR5cGUpKVxuICAgICAgICAgICAgICA/IFwiPFwiICsgbWF4TGVuZ3RoICsgXCI+XCJcbiAgICAgICAgICAgICAgOiBcIjwuLi4+XCI7XG4gICAgICAgICAgdmFyIG5hbWUgPSBvYmplY3ROYW1lKHZhbHVlKTtcbiAgICAgICAgICBpZiAoXCJPYmplY3RcIiA9PT0gbmFtZSkge1xuICAgICAgICAgICAgbmFtZSA9IFwiXCI7XG4gICAgICAgICAgICBtYXhMZW5ndGggLT0gMjtcbiAgICAgICAgICAgIGZvciAodmFyIHByb3BOYW1lIGluIHZhbHVlKVxuICAgICAgICAgICAgICBpZiAodmFsdWUuaGFzT3duUHJvcGVydHkocHJvcE5hbWUpKSB7XG4gICAgICAgICAgICAgICAgdmFyIGpzb25Qcm9wTmFtZSA9IEpTT04uc3RyaW5naWZ5KHByb3BOYW1lKTtcbiAgICAgICAgICAgICAgICBqc29uUHJvcE5hbWUgIT09ICdcIicgKyBwcm9wTmFtZSArICdcIicgJiZcbiAgICAgICAgICAgICAgICAgIChwcm9wTmFtZSA9IGpzb25Qcm9wTmFtZSk7XG4gICAgICAgICAgICAgICAgbWF4TGVuZ3RoIC09IHByb3BOYW1lLmxlbmd0aCAtIDI7XG4gICAgICAgICAgICAgICAganNvblByb3BOYW1lID0gZGVzY3JpYmVWYWx1ZShcbiAgICAgICAgICAgICAgICAgIHZhbHVlW3Byb3BOYW1lXSxcbiAgICAgICAgICAgICAgICAgIDE1ID4gbWF4TGVuZ3RoID8gbWF4TGVuZ3RoIDogMTVcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIG1heExlbmd0aCAtPSBqc29uUHJvcE5hbWUubGVuZ3RoO1xuICAgICAgICAgICAgICAgIGlmICgwID4gbWF4TGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICBuYW1lICs9IFwiXCIgPT09IG5hbWUgPyBcIi4uLlwiIDogXCIsIC4uLlwiO1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG5hbWUgKz1cbiAgICAgICAgICAgICAgICAgIChcIlwiID09PSBuYW1lID8gXCJcIiA6IFwiLFwiKSArIHByb3BOYW1lICsgXCI6XCIgKyBqc29uUHJvcE5hbWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBcIntcIiArIG5hbWUgKyBcIn1cIjtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIG5hbWU7XG4gICAgICAgIGNhc2UgXCJmdW5jdGlvblwiOlxuICAgICAgICAgIHJldHVybiAobWF4TGVuZ3RoID0gdmFsdWUuZGlzcGxheU5hbWUgfHwgdmFsdWUubmFtZSlcbiAgICAgICAgICAgID8gXCJmdW5jdGlvbiBcIiArIG1heExlbmd0aFxuICAgICAgICAgICAgOiBcImZ1bmN0aW9uXCI7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgcmV0dXJuIFN0cmluZyh2YWx1ZSk7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGRlc2NyaWJlUHJvcFZhbHVlKHZhbHVlLCBtYXhMZW5ndGgpIHtcbiAgICAgIHJldHVybiBcInN0cmluZ1wiICE9PSB0eXBlb2YgdmFsdWUgfHwgbmVlZHNFc2NhcGluZy50ZXN0KHZhbHVlKVxuICAgICAgICA/IFwie1wiICsgZGVzY3JpYmVWYWx1ZSh2YWx1ZSwgbWF4TGVuZ3RoIC0gMikgKyBcIn1cIlxuICAgICAgICA6IHZhbHVlLmxlbmd0aCA+IG1heExlbmd0aCAtIDJcbiAgICAgICAgICA/IDUgPiBtYXhMZW5ndGhcbiAgICAgICAgICAgID8gJ1wiLi4uXCInXG4gICAgICAgICAgICA6ICdcIicgKyB2YWx1ZS5zbGljZSgwLCBtYXhMZW5ndGggLSA1KSArICcuLi5cIidcbiAgICAgICAgICA6ICdcIicgKyB2YWx1ZSArICdcIic7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGRlc2NyaWJlRXhwYW5kZWRFbGVtZW50KHR5cGUsIHByb3BzLCByb3dQcmVmaXgpIHtcbiAgICAgIHZhciByZW1haW5pbmdSb3dMZW5ndGggPSAxMjAgLSByb3dQcmVmaXgubGVuZ3RoIC0gdHlwZS5sZW5ndGgsXG4gICAgICAgIHByb3BlcnRpZXMgPSBbXSxcbiAgICAgICAgcHJvcE5hbWU7XG4gICAgICBmb3IgKHByb3BOYW1lIGluIHByb3BzKVxuICAgICAgICBpZiAocHJvcHMuaGFzT3duUHJvcGVydHkocHJvcE5hbWUpICYmIFwiY2hpbGRyZW5cIiAhPT0gcHJvcE5hbWUpIHtcbiAgICAgICAgICB2YXIgcHJvcFZhbHVlID0gZGVzY3JpYmVQcm9wVmFsdWUoXG4gICAgICAgICAgICBwcm9wc1twcm9wTmFtZV0sXG4gICAgICAgICAgICAxMjAgLSByb3dQcmVmaXgubGVuZ3RoIC0gcHJvcE5hbWUubGVuZ3RoIC0gMVxuICAgICAgICAgICk7XG4gICAgICAgICAgcmVtYWluaW5nUm93TGVuZ3RoIC09IHByb3BOYW1lLmxlbmd0aCArIHByb3BWYWx1ZS5sZW5ndGggKyAyO1xuICAgICAgICAgIHByb3BlcnRpZXMucHVzaChwcm9wTmFtZSArIFwiPVwiICsgcHJvcFZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgcmV0dXJuIDAgPT09IHByb3BlcnRpZXMubGVuZ3RoXG4gICAgICAgID8gcm93UHJlZml4ICsgXCI8XCIgKyB0eXBlICsgXCI+XFxuXCJcbiAgICAgICAgOiAwIDwgcmVtYWluaW5nUm93TGVuZ3RoXG4gICAgICAgICAgPyByb3dQcmVmaXggKyBcIjxcIiArIHR5cGUgKyBcIiBcIiArIHByb3BlcnRpZXMuam9pbihcIiBcIikgKyBcIj5cXG5cIlxuICAgICAgICAgIDogcm93UHJlZml4ICtcbiAgICAgICAgICAgIFwiPFwiICtcbiAgICAgICAgICAgIHR5cGUgK1xuICAgICAgICAgICAgXCJcXG5cIiArXG4gICAgICAgICAgICByb3dQcmVmaXggK1xuICAgICAgICAgICAgXCIgIFwiICtcbiAgICAgICAgICAgIHByb3BlcnRpZXMuam9pbihcIlxcblwiICsgcm93UHJlZml4ICsgXCIgIFwiKSArXG4gICAgICAgICAgICBcIlxcblwiICtcbiAgICAgICAgICAgIHJvd1ByZWZpeCArXG4gICAgICAgICAgICBcIj5cXG5cIjtcbiAgICB9XG4gICAgZnVuY3Rpb24gZGVzY3JpYmVQcm9wZXJ0aWVzRGlmZihjbGllbnRPYmplY3QsIHNlcnZlck9iamVjdCwgaW5kZW50KSB7XG4gICAgICB2YXIgcHJvcGVydGllcyA9IFwiXCIsXG4gICAgICAgIHJlbWFpbmluZ1NlcnZlclByb3BlcnRpZXMgPSBhc3NpZ24oe30sIHNlcnZlck9iamVjdCksXG4gICAgICAgIHByb3BOYW1lO1xuICAgICAgZm9yIChwcm9wTmFtZSBpbiBjbGllbnRPYmplY3QpXG4gICAgICAgIGlmIChjbGllbnRPYmplY3QuaGFzT3duUHJvcGVydHkocHJvcE5hbWUpKSB7XG4gICAgICAgICAgZGVsZXRlIHJlbWFpbmluZ1NlcnZlclByb3BlcnRpZXNbcHJvcE5hbWVdO1xuICAgICAgICAgIHZhciBtYXhMZW5ndGggPSAxMjAgLSAyICogaW5kZW50IC0gcHJvcE5hbWUubGVuZ3RoIC0gMixcbiAgICAgICAgICAgIGNsaWVudFByb3BWYWx1ZSA9IGRlc2NyaWJlVmFsdWUoY2xpZW50T2JqZWN0W3Byb3BOYW1lXSwgbWF4TGVuZ3RoKTtcbiAgICAgICAgICBzZXJ2ZXJPYmplY3QuaGFzT3duUHJvcGVydHkocHJvcE5hbWUpXG4gICAgICAgICAgICA/ICgobWF4TGVuZ3RoID0gZGVzY3JpYmVWYWx1ZShzZXJ2ZXJPYmplY3RbcHJvcE5hbWVdLCBtYXhMZW5ndGgpKSxcbiAgICAgICAgICAgICAgKHByb3BlcnRpZXMgKz1cbiAgICAgICAgICAgICAgICBhZGRlZChpbmRlbnQpICsgcHJvcE5hbWUgKyBcIjogXCIgKyBjbGllbnRQcm9wVmFsdWUgKyBcIlxcblwiKSxcbiAgICAgICAgICAgICAgKHByb3BlcnRpZXMgKz1cbiAgICAgICAgICAgICAgICByZW1vdmVkKGluZGVudCkgKyBwcm9wTmFtZSArIFwiOiBcIiArIG1heExlbmd0aCArIFwiXFxuXCIpKVxuICAgICAgICAgICAgOiAocHJvcGVydGllcyArPVxuICAgICAgICAgICAgICAgIGFkZGVkKGluZGVudCkgKyBwcm9wTmFtZSArIFwiOiBcIiArIGNsaWVudFByb3BWYWx1ZSArIFwiXFxuXCIpO1xuICAgICAgICB9XG4gICAgICBmb3IgKHZhciBfcHJvcE5hbWUgaW4gcmVtYWluaW5nU2VydmVyUHJvcGVydGllcylcbiAgICAgICAgcmVtYWluaW5nU2VydmVyUHJvcGVydGllcy5oYXNPd25Qcm9wZXJ0eShfcHJvcE5hbWUpICYmXG4gICAgICAgICAgKChjbGllbnRPYmplY3QgPSBkZXNjcmliZVZhbHVlKFxuICAgICAgICAgICAgcmVtYWluaW5nU2VydmVyUHJvcGVydGllc1tfcHJvcE5hbWVdLFxuICAgICAgICAgICAgMTIwIC0gMiAqIGluZGVudCAtIF9wcm9wTmFtZS5sZW5ndGggLSAyXG4gICAgICAgICAgKSksXG4gICAgICAgICAgKHByb3BlcnRpZXMgKz1cbiAgICAgICAgICAgIHJlbW92ZWQoaW5kZW50KSArIF9wcm9wTmFtZSArIFwiOiBcIiArIGNsaWVudE9iamVjdCArIFwiXFxuXCIpKTtcbiAgICAgIHJldHVybiBwcm9wZXJ0aWVzO1xuICAgIH1cbiAgICBmdW5jdGlvbiBkZXNjcmliZUVsZW1lbnREaWZmKHR5cGUsIGNsaWVudFByb3BzLCBzZXJ2ZXJQcm9wcywgaW5kZW50KSB7XG4gICAgICB2YXIgY29udGVudCA9IFwiXCIsXG4gICAgICAgIHNlcnZlclByb3BOYW1lcyA9IG5ldyBNYXAoKTtcbiAgICAgIGZvciAocHJvcE5hbWUkanNjb21wJDAgaW4gc2VydmVyUHJvcHMpXG4gICAgICAgIHNlcnZlclByb3BzLmhhc093blByb3BlcnR5KHByb3BOYW1lJGpzY29tcCQwKSAmJlxuICAgICAgICAgIHNlcnZlclByb3BOYW1lcy5zZXQoXG4gICAgICAgICAgICBwcm9wTmFtZSRqc2NvbXAkMC50b0xvd2VyQ2FzZSgpLFxuICAgICAgICAgICAgcHJvcE5hbWUkanNjb21wJDBcbiAgICAgICAgICApO1xuICAgICAgaWYgKDEgPT09IHNlcnZlclByb3BOYW1lcy5zaXplICYmIHNlcnZlclByb3BOYW1lcy5oYXMoXCJjaGlsZHJlblwiKSlcbiAgICAgICAgY29udGVudCArPSBkZXNjcmliZUV4cGFuZGVkRWxlbWVudChcbiAgICAgICAgICB0eXBlLFxuICAgICAgICAgIGNsaWVudFByb3BzLFxuICAgICAgICAgIGluZGVudGF0aW9uKGluZGVudClcbiAgICAgICAgKTtcbiAgICAgIGVsc2Uge1xuICAgICAgICBmb3IgKHZhciBfcHJvcE5hbWUyIGluIGNsaWVudFByb3BzKVxuICAgICAgICAgIGlmIChcbiAgICAgICAgICAgIGNsaWVudFByb3BzLmhhc093blByb3BlcnR5KF9wcm9wTmFtZTIpICYmXG4gICAgICAgICAgICBcImNoaWxkcmVuXCIgIT09IF9wcm9wTmFtZTJcbiAgICAgICAgICApIHtcbiAgICAgICAgICAgIHZhciBtYXhMZW5ndGgkanNjb21wJDAgPVxuICAgICAgICAgICAgICAgIDEyMCAtIDIgKiAoaW5kZW50ICsgMSkgLSBfcHJvcE5hbWUyLmxlbmd0aCAtIDEsXG4gICAgICAgICAgICAgIHNlcnZlclByb3BOYW1lID0gc2VydmVyUHJvcE5hbWVzLmdldChfcHJvcE5hbWUyLnRvTG93ZXJDYXNlKCkpO1xuICAgICAgICAgICAgaWYgKHZvaWQgMCAhPT0gc2VydmVyUHJvcE5hbWUpIHtcbiAgICAgICAgICAgICAgc2VydmVyUHJvcE5hbWVzLmRlbGV0ZShfcHJvcE5hbWUyLnRvTG93ZXJDYXNlKCkpO1xuICAgICAgICAgICAgICB2YXIgcHJvcE5hbWUkanNjb21wJDAgPSBjbGllbnRQcm9wc1tfcHJvcE5hbWUyXTtcbiAgICAgICAgICAgICAgc2VydmVyUHJvcE5hbWUgPSBzZXJ2ZXJQcm9wc1tzZXJ2ZXJQcm9wTmFtZV07XG4gICAgICAgICAgICAgIHZhciBjbGllbnRQcm9wVmFsdWUgPSBkZXNjcmliZVByb3BWYWx1ZShcbiAgICAgICAgICAgICAgICBwcm9wTmFtZSRqc2NvbXAkMCxcbiAgICAgICAgICAgICAgICBtYXhMZW5ndGgkanNjb21wJDBcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgbWF4TGVuZ3RoJGpzY29tcCQwID0gZGVzY3JpYmVQcm9wVmFsdWUoXG4gICAgICAgICAgICAgICAgc2VydmVyUHJvcE5hbWUsXG4gICAgICAgICAgICAgICAgbWF4TGVuZ3RoJGpzY29tcCQwXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIFwib2JqZWN0XCIgPT09IHR5cGVvZiBwcm9wTmFtZSRqc2NvbXAkMCAmJlxuICAgICAgICAgICAgICBudWxsICE9PSBwcm9wTmFtZSRqc2NvbXAkMCAmJlxuICAgICAgICAgICAgICBcIm9iamVjdFwiID09PSB0eXBlb2Ygc2VydmVyUHJvcE5hbWUgJiZcbiAgICAgICAgICAgICAgbnVsbCAhPT0gc2VydmVyUHJvcE5hbWUgJiZcbiAgICAgICAgICAgICAgXCJPYmplY3RcIiA9PT0gb2JqZWN0TmFtZShwcm9wTmFtZSRqc2NvbXAkMCkgJiZcbiAgICAgICAgICAgICAgXCJPYmplY3RcIiA9PT0gb2JqZWN0TmFtZShzZXJ2ZXJQcm9wTmFtZSkgJiZcbiAgICAgICAgICAgICAgKDIgPCBPYmplY3Qua2V5cyhwcm9wTmFtZSRqc2NvbXAkMCkubGVuZ3RoIHx8XG4gICAgICAgICAgICAgICAgMiA8IE9iamVjdC5rZXlzKHNlcnZlclByb3BOYW1lKS5sZW5ndGggfHxcbiAgICAgICAgICAgICAgICAtMSA8IGNsaWVudFByb3BWYWx1ZS5pbmRleE9mKFwiLi4uXCIpIHx8XG4gICAgICAgICAgICAgICAgLTEgPCBtYXhMZW5ndGgkanNjb21wJDAuaW5kZXhPZihcIi4uLlwiKSlcbiAgICAgICAgICAgICAgICA/IChjb250ZW50ICs9XG4gICAgICAgICAgICAgICAgICAgIGluZGVudGF0aW9uKGluZGVudCArIDEpICtcbiAgICAgICAgICAgICAgICAgICAgX3Byb3BOYW1lMiArXG4gICAgICAgICAgICAgICAgICAgIFwiPXt7XFxuXCIgK1xuICAgICAgICAgICAgICAgICAgICBkZXNjcmliZVByb3BlcnRpZXNEaWZmKFxuICAgICAgICAgICAgICAgICAgICAgIHByb3BOYW1lJGpzY29tcCQwLFxuICAgICAgICAgICAgICAgICAgICAgIHNlcnZlclByb3BOYW1lLFxuICAgICAgICAgICAgICAgICAgICAgIGluZGVudCArIDJcbiAgICAgICAgICAgICAgICAgICAgKSArXG4gICAgICAgICAgICAgICAgICAgIGluZGVudGF0aW9uKGluZGVudCArIDEpICtcbiAgICAgICAgICAgICAgICAgICAgXCJ9fVxcblwiKVxuICAgICAgICAgICAgICAgIDogKChjb250ZW50ICs9XG4gICAgICAgICAgICAgICAgICAgIGFkZGVkKGluZGVudCArIDEpICtcbiAgICAgICAgICAgICAgICAgICAgX3Byb3BOYW1lMiArXG4gICAgICAgICAgICAgICAgICAgIFwiPVwiICtcbiAgICAgICAgICAgICAgICAgICAgY2xpZW50UHJvcFZhbHVlICtcbiAgICAgICAgICAgICAgICAgICAgXCJcXG5cIiksXG4gICAgICAgICAgICAgICAgICAoY29udGVudCArPVxuICAgICAgICAgICAgICAgICAgICByZW1vdmVkKGluZGVudCArIDEpICtcbiAgICAgICAgICAgICAgICAgICAgX3Byb3BOYW1lMiArXG4gICAgICAgICAgICAgICAgICAgIFwiPVwiICtcbiAgICAgICAgICAgICAgICAgICAgbWF4TGVuZ3RoJGpzY29tcCQwICtcbiAgICAgICAgICAgICAgICAgICAgXCJcXG5cIikpO1xuICAgICAgICAgICAgfSBlbHNlXG4gICAgICAgICAgICAgIGNvbnRlbnQgKz1cbiAgICAgICAgICAgICAgICBpbmRlbnRhdGlvbihpbmRlbnQgKyAxKSArXG4gICAgICAgICAgICAgICAgX3Byb3BOYW1lMiArXG4gICAgICAgICAgICAgICAgXCI9XCIgK1xuICAgICAgICAgICAgICAgIGRlc2NyaWJlUHJvcFZhbHVlKGNsaWVudFByb3BzW19wcm9wTmFtZTJdLCBtYXhMZW5ndGgkanNjb21wJDApICtcbiAgICAgICAgICAgICAgICBcIlxcblwiO1xuICAgICAgICAgIH1cbiAgICAgICAgc2VydmVyUHJvcE5hbWVzLmZvckVhY2goZnVuY3Rpb24gKHByb3BOYW1lKSB7XG4gICAgICAgICAgaWYgKFwiY2hpbGRyZW5cIiAhPT0gcHJvcE5hbWUpIHtcbiAgICAgICAgICAgIHZhciBtYXhMZW5ndGggPSAxMjAgLSAyICogKGluZGVudCArIDEpIC0gcHJvcE5hbWUubGVuZ3RoIC0gMTtcbiAgICAgICAgICAgIGNvbnRlbnQgKz1cbiAgICAgICAgICAgICAgcmVtb3ZlZChpbmRlbnQgKyAxKSArXG4gICAgICAgICAgICAgIHByb3BOYW1lICtcbiAgICAgICAgICAgICAgXCI9XCIgK1xuICAgICAgICAgICAgICBkZXNjcmliZVByb3BWYWx1ZShzZXJ2ZXJQcm9wc1twcm9wTmFtZV0sIG1heExlbmd0aCkgK1xuICAgICAgICAgICAgICBcIlxcblwiO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnRlbnQgPVxuICAgICAgICAgIFwiXCIgPT09IGNvbnRlbnRcbiAgICAgICAgICAgID8gaW5kZW50YXRpb24oaW5kZW50KSArIFwiPFwiICsgdHlwZSArIFwiPlxcblwiXG4gICAgICAgICAgICA6IGluZGVudGF0aW9uKGluZGVudCkgK1xuICAgICAgICAgICAgICBcIjxcIiArXG4gICAgICAgICAgICAgIHR5cGUgK1xuICAgICAgICAgICAgICBcIlxcblwiICtcbiAgICAgICAgICAgICAgY29udGVudCArXG4gICAgICAgICAgICAgIGluZGVudGF0aW9uKGluZGVudCkgK1xuICAgICAgICAgICAgICBcIj5cXG5cIjtcbiAgICAgIH1cbiAgICAgIHR5cGUgPSBzZXJ2ZXJQcm9wcy5jaGlsZHJlbjtcbiAgICAgIGNsaWVudFByb3BzID0gY2xpZW50UHJvcHMuY2hpbGRyZW47XG4gICAgICBpZiAoXG4gICAgICAgIFwic3RyaW5nXCIgPT09IHR5cGVvZiB0eXBlIHx8XG4gICAgICAgIFwibnVtYmVyXCIgPT09IHR5cGVvZiB0eXBlIHx8XG4gICAgICAgIFwiYmlnaW50XCIgPT09IHR5cGVvZiB0eXBlXG4gICAgICApIHtcbiAgICAgICAgc2VydmVyUHJvcE5hbWVzID0gXCJcIjtcbiAgICAgICAgaWYgKFxuICAgICAgICAgIFwic3RyaW5nXCIgPT09IHR5cGVvZiBjbGllbnRQcm9wcyB8fFxuICAgICAgICAgIFwibnVtYmVyXCIgPT09IHR5cGVvZiBjbGllbnRQcm9wcyB8fFxuICAgICAgICAgIFwiYmlnaW50XCIgPT09IHR5cGVvZiBjbGllbnRQcm9wc1xuICAgICAgICApXG4gICAgICAgICAgc2VydmVyUHJvcE5hbWVzID0gXCJcIiArIGNsaWVudFByb3BzO1xuICAgICAgICBjb250ZW50ICs9IGRlc2NyaWJlVGV4dERpZmYoc2VydmVyUHJvcE5hbWVzLCBcIlwiICsgdHlwZSwgaW5kZW50ICsgMSk7XG4gICAgICB9IGVsc2UgaWYgKFxuICAgICAgICBcInN0cmluZ1wiID09PSB0eXBlb2YgY2xpZW50UHJvcHMgfHxcbiAgICAgICAgXCJudW1iZXJcIiA9PT0gdHlwZW9mIGNsaWVudFByb3BzIHx8XG4gICAgICAgIFwiYmlnaW50XCIgPT09IHR5cGVvZiBjbGllbnRQcm9wc1xuICAgICAgKVxuICAgICAgICBjb250ZW50ID1cbiAgICAgICAgICBudWxsID09IHR5cGVcbiAgICAgICAgICAgID8gY29udGVudCArIGRlc2NyaWJlVGV4dERpZmYoXCJcIiArIGNsaWVudFByb3BzLCBudWxsLCBpbmRlbnQgKyAxKVxuICAgICAgICAgICAgOiBjb250ZW50ICsgZGVzY3JpYmVUZXh0RGlmZihcIlwiICsgY2xpZW50UHJvcHMsIHZvaWQgMCwgaW5kZW50ICsgMSk7XG4gICAgICByZXR1cm4gY29udGVudDtcbiAgICB9XG4gICAgZnVuY3Rpb24gZGVzY3JpYmVTaWJsaW5nRmliZXIoZmliZXIsIGluZGVudCkge1xuICAgICAgdmFyIHR5cGUgPSBkZXNjcmliZUZpYmVyVHlwZShmaWJlcik7XG4gICAgICBpZiAobnVsbCA9PT0gdHlwZSkge1xuICAgICAgICB0eXBlID0gXCJcIjtcbiAgICAgICAgZm9yIChmaWJlciA9IGZpYmVyLmNoaWxkOyBmaWJlcjsgKVxuICAgICAgICAgICh0eXBlICs9IGRlc2NyaWJlU2libGluZ0ZpYmVyKGZpYmVyLCBpbmRlbnQpKSxcbiAgICAgICAgICAgIChmaWJlciA9IGZpYmVyLnNpYmxpbmcpO1xuICAgICAgICByZXR1cm4gdHlwZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBpbmRlbnRhdGlvbihpbmRlbnQpICsgXCI8XCIgKyB0eXBlICsgXCI+XFxuXCI7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGRlc2NyaWJlTm9kZShub2RlLCBpbmRlbnQpIHtcbiAgICAgIHZhciBza2lwVG9Ob2RlID0gZmluZE5vdGFibGVOb2RlKG5vZGUsIGluZGVudCk7XG4gICAgICBpZiAoXG4gICAgICAgIHNraXBUb05vZGUgIT09IG5vZGUgJiZcbiAgICAgICAgKDEgIT09IG5vZGUuY2hpbGRyZW4ubGVuZ3RoIHx8IG5vZGUuY2hpbGRyZW5bMF0gIT09IHNraXBUb05vZGUpXG4gICAgICApXG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgaW5kZW50YXRpb24oaW5kZW50KSArIFwiLi4uXFxuXCIgKyBkZXNjcmliZU5vZGUoc2tpcFRvTm9kZSwgaW5kZW50ICsgMSlcbiAgICAgICAgKTtcbiAgICAgIHNraXBUb05vZGUgPSBcIlwiO1xuICAgICAgdmFyIGRlYnVnSW5mbyA9IG5vZGUuZmliZXIuX2RlYnVnSW5mbztcbiAgICAgIGlmIChkZWJ1Z0luZm8pXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGVidWdJbmZvLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdmFyIHNlcnZlckNvbXBvbmVudE5hbWUgPSBkZWJ1Z0luZm9baV0ubmFtZTtcbiAgICAgICAgICBcInN0cmluZ1wiID09PSB0eXBlb2Ygc2VydmVyQ29tcG9uZW50TmFtZSAmJlxuICAgICAgICAgICAgKChza2lwVG9Ob2RlICs9XG4gICAgICAgICAgICAgIGluZGVudGF0aW9uKGluZGVudCkgKyBcIjxcIiArIHNlcnZlckNvbXBvbmVudE5hbWUgKyBcIj5cXG5cIiksXG4gICAgICAgICAgICBpbmRlbnQrKyk7XG4gICAgICAgIH1cbiAgICAgIGRlYnVnSW5mbyA9IFwiXCI7XG4gICAgICBpID0gbm9kZS5maWJlci5wZW5kaW5nUHJvcHM7XG4gICAgICBpZiAoNiA9PT0gbm9kZS5maWJlci50YWcpXG4gICAgICAgIChkZWJ1Z0luZm8gPSBkZXNjcmliZVRleHREaWZmKGksIG5vZGUuc2VydmVyUHJvcHMsIGluZGVudCkpLCBpbmRlbnQrKztcbiAgICAgIGVsc2UgaWYgKFxuICAgICAgICAoKHNlcnZlckNvbXBvbmVudE5hbWUgPSBkZXNjcmliZUZpYmVyVHlwZShub2RlLmZpYmVyKSksXG4gICAgICAgIG51bGwgIT09IHNlcnZlckNvbXBvbmVudE5hbWUpXG4gICAgICApXG4gICAgICAgIGlmICh2b2lkIDAgPT09IG5vZGUuc2VydmVyUHJvcHMpIHtcbiAgICAgICAgICBkZWJ1Z0luZm8gPSBpbmRlbnQ7XG4gICAgICAgICAgdmFyIG1heExlbmd0aCA9IDEyMCAtIDIgKiBkZWJ1Z0luZm8gLSBzZXJ2ZXJDb21wb25lbnROYW1lLmxlbmd0aCAtIDIsXG4gICAgICAgICAgICBjb250ZW50ID0gXCJcIjtcbiAgICAgICAgICBmb3IgKHByb3BOYW1lIGluIGkpXG4gICAgICAgICAgICBpZiAoaS5oYXNPd25Qcm9wZXJ0eShwcm9wTmFtZSkgJiYgXCJjaGlsZHJlblwiICE9PSBwcm9wTmFtZSkge1xuICAgICAgICAgICAgICB2YXIgcHJvcFZhbHVlID0gZGVzY3JpYmVQcm9wVmFsdWUoaVtwcm9wTmFtZV0sIDE1KTtcbiAgICAgICAgICAgICAgbWF4TGVuZ3RoIC09IHByb3BOYW1lLmxlbmd0aCArIHByb3BWYWx1ZS5sZW5ndGggKyAyO1xuICAgICAgICAgICAgICBpZiAoMCA+IG1heExlbmd0aCkge1xuICAgICAgICAgICAgICAgIGNvbnRlbnQgKz0gXCIgLi4uXCI7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgY29udGVudCArPSBcIiBcIiArIHByb3BOYW1lICsgXCI9XCIgKyBwcm9wVmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgZGVidWdJbmZvID1cbiAgICAgICAgICAgIGluZGVudGF0aW9uKGRlYnVnSW5mbykgK1xuICAgICAgICAgICAgXCI8XCIgK1xuICAgICAgICAgICAgc2VydmVyQ29tcG9uZW50TmFtZSArXG4gICAgICAgICAgICBjb250ZW50ICtcbiAgICAgICAgICAgIFwiPlxcblwiO1xuICAgICAgICAgIGluZGVudCsrO1xuICAgICAgICB9IGVsc2VcbiAgICAgICAgICBudWxsID09PSBub2RlLnNlcnZlclByb3BzXG4gICAgICAgICAgICA/ICgoZGVidWdJbmZvID0gZGVzY3JpYmVFeHBhbmRlZEVsZW1lbnQoXG4gICAgICAgICAgICAgICAgc2VydmVyQ29tcG9uZW50TmFtZSxcbiAgICAgICAgICAgICAgICBpLFxuICAgICAgICAgICAgICAgIGFkZGVkKGluZGVudClcbiAgICAgICAgICAgICAgKSksXG4gICAgICAgICAgICAgIGluZGVudCsrKVxuICAgICAgICAgICAgOiBcInN0cmluZ1wiID09PSB0eXBlb2Ygbm9kZS5zZXJ2ZXJQcm9wc1xuICAgICAgICAgICAgICA/IGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgICAgICBcIlNob3VsZCBub3QgaGF2ZSBtYXRjaGVkIGEgbm9uIEhvc3RUZXh0IGZpYmVyIHRvIGEgVGV4dCBub2RlLiBUaGlzIGlzIGEgYnVnIGluIFJlYWN0LlwiXG4gICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICA6ICgoZGVidWdJbmZvID0gZGVzY3JpYmVFbGVtZW50RGlmZihcbiAgICAgICAgICAgICAgICAgIHNlcnZlckNvbXBvbmVudE5hbWUsXG4gICAgICAgICAgICAgICAgICBpLFxuICAgICAgICAgICAgICAgICAgbm9kZS5zZXJ2ZXJQcm9wcyxcbiAgICAgICAgICAgICAgICAgIGluZGVudFxuICAgICAgICAgICAgICAgICkpLFxuICAgICAgICAgICAgICAgIGluZGVudCsrKTtcbiAgICAgIHZhciBwcm9wTmFtZSA9IFwiXCI7XG4gICAgICBpID0gbm9kZS5maWJlci5jaGlsZDtcbiAgICAgIGZvciAoXG4gICAgICAgIHNlcnZlckNvbXBvbmVudE5hbWUgPSAwO1xuICAgICAgICBpICYmIHNlcnZlckNvbXBvbmVudE5hbWUgPCBub2RlLmNoaWxkcmVuLmxlbmd0aDtcblxuICAgICAgKVxuICAgICAgICAobWF4TGVuZ3RoID0gbm9kZS5jaGlsZHJlbltzZXJ2ZXJDb21wb25lbnROYW1lXSksXG4gICAgICAgICAgbWF4TGVuZ3RoLmZpYmVyID09PSBpXG4gICAgICAgICAgICA/ICgocHJvcE5hbWUgKz0gZGVzY3JpYmVOb2RlKG1heExlbmd0aCwgaW5kZW50KSksXG4gICAgICAgICAgICAgIHNlcnZlckNvbXBvbmVudE5hbWUrKylcbiAgICAgICAgICAgIDogKHByb3BOYW1lICs9IGRlc2NyaWJlU2libGluZ0ZpYmVyKGksIGluZGVudCkpLFxuICAgICAgICAgIChpID0gaS5zaWJsaW5nKTtcbiAgICAgIGkgJiZcbiAgICAgICAgMCA8IG5vZGUuY2hpbGRyZW4ubGVuZ3RoICYmXG4gICAgICAgIChwcm9wTmFtZSArPSBpbmRlbnRhdGlvbihpbmRlbnQpICsgXCIuLi5cXG5cIik7XG4gICAgICBpID0gbm9kZS5zZXJ2ZXJUYWlsO1xuICAgICAgbnVsbCA9PT0gbm9kZS5zZXJ2ZXJQcm9wcyAmJiBpbmRlbnQtLTtcbiAgICAgIGZvciAobm9kZSA9IDA7IG5vZGUgPCBpLmxlbmd0aDsgbm9kZSsrKVxuICAgICAgICAoc2VydmVyQ29tcG9uZW50TmFtZSA9IGlbbm9kZV0pLFxuICAgICAgICAgIChwcm9wTmFtZSA9XG4gICAgICAgICAgICBcInN0cmluZ1wiID09PSB0eXBlb2Ygc2VydmVyQ29tcG9uZW50TmFtZVxuICAgICAgICAgICAgICA/IHByb3BOYW1lICtcbiAgICAgICAgICAgICAgICAocmVtb3ZlZChpbmRlbnQpICtcbiAgICAgICAgICAgICAgICAgIGRlc2NyaWJlVGV4dE5vZGUoc2VydmVyQ29tcG9uZW50TmFtZSwgMTIwIC0gMiAqIGluZGVudCkgK1xuICAgICAgICAgICAgICAgICAgXCJcXG5cIilcbiAgICAgICAgICAgICAgOiBwcm9wTmFtZSArXG4gICAgICAgICAgICAgICAgZGVzY3JpYmVFeHBhbmRlZEVsZW1lbnQoXG4gICAgICAgICAgICAgICAgICBzZXJ2ZXJDb21wb25lbnROYW1lLnR5cGUsXG4gICAgICAgICAgICAgICAgICBzZXJ2ZXJDb21wb25lbnROYW1lLnByb3BzLFxuICAgICAgICAgICAgICAgICAgcmVtb3ZlZChpbmRlbnQpXG4gICAgICAgICAgICAgICAgKSk7XG4gICAgICByZXR1cm4gc2tpcFRvTm9kZSArIGRlYnVnSW5mbyArIHByb3BOYW1lO1xuICAgIH1cbiAgICBmdW5jdGlvbiBkZXNjcmliZURpZmYocm9vdE5vZGUpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBcIlxcblxcblwiICsgZGVzY3JpYmVOb2RlKHJvb3ROb2RlLCAwKTtcbiAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgcmV0dXJuIFwiXCI7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGJ1aWxkSHlkcmF0aW9uRGlmZk5vZGUoZmliZXIsIGRpc3RhbmNlRnJvbUxlYWYpIHtcbiAgICAgIGlmIChudWxsID09PSBmaWJlci5yZXR1cm4pIHtcbiAgICAgICAgaWYgKG51bGwgPT09IGh5ZHJhdGlvbkRpZmZSb290REVWKVxuICAgICAgICAgIGh5ZHJhdGlvbkRpZmZSb290REVWID0ge1xuICAgICAgICAgICAgZmliZXI6IGZpYmVyLFxuICAgICAgICAgICAgY2hpbGRyZW46IFtdLFxuICAgICAgICAgICAgc2VydmVyUHJvcHM6IHZvaWQgMCxcbiAgICAgICAgICAgIHNlcnZlclRhaWw6IFtdLFxuICAgICAgICAgICAgZGlzdGFuY2VGcm9tTGVhZjogZGlzdGFuY2VGcm9tTGVhZlxuICAgICAgICAgIH07XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIGlmIChoeWRyYXRpb25EaWZmUm9vdERFVi5maWJlciAhPT0gZmliZXIpXG4gICAgICAgICAgICB0aHJvdyBFcnJvcihcbiAgICAgICAgICAgICAgXCJTYXcgbXVsdGlwbGUgaHlkcmF0aW9uIGRpZmYgcm9vdHMgaW4gYSBwYXNzLiBUaGlzIGlzIGEgYnVnIGluIFJlYWN0LlwiXG4gICAgICAgICAgICApO1xuICAgICAgICAgIGh5ZHJhdGlvbkRpZmZSb290REVWLmRpc3RhbmNlRnJvbUxlYWYgPiBkaXN0YW5jZUZyb21MZWFmICYmXG4gICAgICAgICAgICAoaHlkcmF0aW9uRGlmZlJvb3RERVYuZGlzdGFuY2VGcm9tTGVhZiA9IGRpc3RhbmNlRnJvbUxlYWYpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBoeWRyYXRpb25EaWZmUm9vdERFVjtcbiAgICAgIH1cbiAgICAgIHZhciBzaWJsaW5ncyA9IGJ1aWxkSHlkcmF0aW9uRGlmZk5vZGUoXG4gICAgICAgIGZpYmVyLnJldHVybixcbiAgICAgICAgZGlzdGFuY2VGcm9tTGVhZiArIDFcbiAgICAgICkuY2hpbGRyZW47XG4gICAgICBpZiAoMCA8IHNpYmxpbmdzLmxlbmd0aCAmJiBzaWJsaW5nc1tzaWJsaW5ncy5sZW5ndGggLSAxXS5maWJlciA9PT0gZmliZXIpXG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgKHNpYmxpbmdzID0gc2libGluZ3Nbc2libGluZ3MubGVuZ3RoIC0gMV0pLFxuICAgICAgICAgIHNpYmxpbmdzLmRpc3RhbmNlRnJvbUxlYWYgPiBkaXN0YW5jZUZyb21MZWFmICYmXG4gICAgICAgICAgICAoc2libGluZ3MuZGlzdGFuY2VGcm9tTGVhZiA9IGRpc3RhbmNlRnJvbUxlYWYpLFxuICAgICAgICAgIHNpYmxpbmdzXG4gICAgICAgICk7XG4gICAgICBkaXN0YW5jZUZyb21MZWFmID0ge1xuICAgICAgICBmaWJlcjogZmliZXIsXG4gICAgICAgIGNoaWxkcmVuOiBbXSxcbiAgICAgICAgc2VydmVyUHJvcHM6IHZvaWQgMCxcbiAgICAgICAgc2VydmVyVGFpbDogW10sXG4gICAgICAgIGRpc3RhbmNlRnJvbUxlYWY6IGRpc3RhbmNlRnJvbUxlYWZcbiAgICAgIH07XG4gICAgICBzaWJsaW5ncy5wdXNoKGRpc3RhbmNlRnJvbUxlYWYpO1xuICAgICAgcmV0dXJuIGRpc3RhbmNlRnJvbUxlYWY7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHdhcm5Ob25IeWRyYXRlZEluc3RhbmNlKGZpYmVyLCByZWplY3RlZENhbmRpZGF0ZSkge1xuICAgICAgZGlkU3VzcGVuZE9yRXJyb3JERVYgfHxcbiAgICAgICAgKChmaWJlciA9IGJ1aWxkSHlkcmF0aW9uRGlmZk5vZGUoZmliZXIsIDApKSxcbiAgICAgICAgKGZpYmVyLnNlcnZlclByb3BzID0gbnVsbCksXG4gICAgICAgIG51bGwgIT09IHJlamVjdGVkQ2FuZGlkYXRlICYmXG4gICAgICAgICAgKChyZWplY3RlZENhbmRpZGF0ZSA9XG4gICAgICAgICAgICBkZXNjcmliZUh5ZHJhdGFibGVJbnN0YW5jZUZvckRldldhcm5pbmdzKHJlamVjdGVkQ2FuZGlkYXRlKSksXG4gICAgICAgICAgZmliZXIuc2VydmVyVGFpbC5wdXNoKHJlamVjdGVkQ2FuZGlkYXRlKSkpO1xuICAgIH1cbiAgICBmdW5jdGlvbiB0aHJvd09uSHlkcmF0aW9uTWlzbWF0Y2goZmliZXIpIHtcbiAgICAgIHZhciBkaWZmID0gXCJcIixcbiAgICAgICAgZGlmZlJvb3QgPSBoeWRyYXRpb25EaWZmUm9vdERFVjtcbiAgICAgIG51bGwgIT09IGRpZmZSb290ICYmXG4gICAgICAgICgoaHlkcmF0aW9uRGlmZlJvb3RERVYgPSBudWxsKSwgKGRpZmYgPSBkZXNjcmliZURpZmYoZGlmZlJvb3QpKSk7XG4gICAgICBxdWV1ZUh5ZHJhdGlvbkVycm9yKFxuICAgICAgICBjcmVhdGVDYXB0dXJlZFZhbHVlQXRGaWJlcihcbiAgICAgICAgICBFcnJvcihcbiAgICAgICAgICAgIFwiSHlkcmF0aW9uIGZhaWxlZCBiZWNhdXNlIHRoZSBzZXJ2ZXIgcmVuZGVyZWQgSFRNTCBkaWRuJ3QgbWF0Y2ggdGhlIGNsaWVudC4gQXMgYSByZXN1bHQgdGhpcyB0cmVlIHdpbGwgYmUgcmVnZW5lcmF0ZWQgb24gdGhlIGNsaWVudC4gVGhpcyBjYW4gaGFwcGVuIGlmIGEgU1NSLWVkIENsaWVudCBDb21wb25lbnQgdXNlZDpcXG5cXG4tIEEgc2VydmVyL2NsaWVudCBicmFuY2ggYGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJylgLlxcbi0gVmFyaWFibGUgaW5wdXQgc3VjaCBhcyBgRGF0ZS5ub3coKWAgb3IgYE1hdGgucmFuZG9tKClgIHdoaWNoIGNoYW5nZXMgZWFjaCB0aW1lIGl0J3MgY2FsbGVkLlxcbi0gRGF0ZSBmb3JtYXR0aW5nIGluIGEgdXNlcidzIGxvY2FsZSB3aGljaCBkb2Vzbid0IG1hdGNoIHRoZSBzZXJ2ZXIuXFxuLSBFeHRlcm5hbCBjaGFuZ2luZyBkYXRhIHdpdGhvdXQgc2VuZGluZyBhIHNuYXBzaG90IG9mIGl0IGFsb25nIHdpdGggdGhlIEhUTUwuXFxuLSBJbnZhbGlkIEhUTUwgdGFnIG5lc3RpbmcuXFxuXFxuSXQgY2FuIGFsc28gaGFwcGVuIGlmIHRoZSBjbGllbnQgaGFzIGEgYnJvd3NlciBleHRlbnNpb24gaW5zdGFsbGVkIHdoaWNoIG1lc3NlcyB3aXRoIHRoZSBIVE1MIGJlZm9yZSBSZWFjdCBsb2FkZWQuXFxuXFxuaHR0cHM6Ly9yZWFjdC5kZXYvbGluay9oeWRyYXRpb24tbWlzbWF0Y2hcIiArXG4gICAgICAgICAgICAgIGRpZmZcbiAgICAgICAgICApLFxuICAgICAgICAgIGZpYmVyXG4gICAgICAgIClcbiAgICAgICk7XG4gICAgICB0aHJvdyBIeWRyYXRpb25NaXNtYXRjaEV4Y2VwdGlvbjtcbiAgICB9XG4gICAgZnVuY3Rpb24gcHJlcGFyZVRvSHlkcmF0ZUhvc3RJbnN0YW5jZShmaWJlciwgaG9zdENvbnRleHQpIHtcbiAgICAgIGlmICghc3VwcG9ydHNIeWRyYXRpb24pXG4gICAgICAgIHRocm93IEVycm9yKFxuICAgICAgICAgIFwiRXhwZWN0ZWQgcHJlcGFyZVRvSHlkcmF0ZUhvc3RJbnN0YW5jZSgpIHRvIG5ldmVyIGJlIGNhbGxlZC4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS5cIlxuICAgICAgICApO1xuICAgICAgaHlkcmF0ZUluc3RhbmNlKFxuICAgICAgICBmaWJlci5zdGF0ZU5vZGUsXG4gICAgICAgIGZpYmVyLnR5cGUsXG4gICAgICAgIGZpYmVyLm1lbW9pemVkUHJvcHMsXG4gICAgICAgIGhvc3RDb250ZXh0LFxuICAgICAgICBmaWJlclxuICAgICAgKSB8fCB0aHJvd09uSHlkcmF0aW9uTWlzbWF0Y2goZmliZXIpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBwb3BUb05leHRIb3N0UGFyZW50KGZpYmVyKSB7XG4gICAgICBmb3IgKGh5ZHJhdGlvblBhcmVudEZpYmVyID0gZmliZXIucmV0dXJuOyBoeWRyYXRpb25QYXJlbnRGaWJlcjsgKVxuICAgICAgICBzd2l0Y2ggKGh5ZHJhdGlvblBhcmVudEZpYmVyLnRhZykge1xuICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICBjYXNlIDI3OlxuICAgICAgICAgICAgcm9vdE9yU2luZ2xldG9uQ29udGV4dCA9ICEwO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIGNhc2UgNTpcbiAgICAgICAgICBjYXNlIDEzOlxuICAgICAgICAgICAgcm9vdE9yU2luZ2xldG9uQ29udGV4dCA9ICExO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBoeWRyYXRpb25QYXJlbnRGaWJlciA9IGh5ZHJhdGlvblBhcmVudEZpYmVyLnJldHVybjtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBwb3BIeWRyYXRpb25TdGF0ZShmaWJlcikge1xuICAgICAgaWYgKCFzdXBwb3J0c0h5ZHJhdGlvbiB8fCBmaWJlciAhPT0gaHlkcmF0aW9uUGFyZW50RmliZXIpIHJldHVybiAhMTtcbiAgICAgIGlmICghaXNIeWRyYXRpbmcpXG4gICAgICAgIHJldHVybiBwb3BUb05leHRIb3N0UGFyZW50KGZpYmVyKSwgKGlzSHlkcmF0aW5nID0gITApLCAhMTtcbiAgICAgIHZhciBzaG91bGRDbGVhciA9ICExO1xuICAgICAgc3VwcG9ydHNTaW5nbGV0b25zXG4gICAgICAgID8gMyAhPT0gZmliZXIudGFnICYmXG4gICAgICAgICAgMjcgIT09IGZpYmVyLnRhZyAmJlxuICAgICAgICAgICg1ICE9PSBmaWJlci50YWcgfHxcbiAgICAgICAgICAgIChzaG91bGREZWxldGVVbmh5ZHJhdGVkVGFpbEluc3RhbmNlcyhmaWJlci50eXBlKSAmJlxuICAgICAgICAgICAgICAhc2hvdWxkU2V0VGV4dENvbnRlbnQoZmliZXIudHlwZSwgZmliZXIubWVtb2l6ZWRQcm9wcykpKSAmJlxuICAgICAgICAgIChzaG91bGRDbGVhciA9ICEwKVxuICAgICAgICA6IDMgIT09IGZpYmVyLnRhZyAmJlxuICAgICAgICAgICg1ICE9PSBmaWJlci50YWcgfHxcbiAgICAgICAgICAgIChzaG91bGREZWxldGVVbmh5ZHJhdGVkVGFpbEluc3RhbmNlcyhmaWJlci50eXBlKSAmJlxuICAgICAgICAgICAgICAhc2hvdWxkU2V0VGV4dENvbnRlbnQoZmliZXIudHlwZSwgZmliZXIubWVtb2l6ZWRQcm9wcykpKSAmJlxuICAgICAgICAgIChzaG91bGRDbGVhciA9ICEwKTtcbiAgICAgIGlmIChzaG91bGRDbGVhciAmJiBuZXh0SHlkcmF0YWJsZUluc3RhbmNlKSB7XG4gICAgICAgIGZvciAoc2hvdWxkQ2xlYXIgPSBuZXh0SHlkcmF0YWJsZUluc3RhbmNlOyBzaG91bGRDbGVhcjsgKSB7XG4gICAgICAgICAgdmFyIGRpZmZOb2RlID0gYnVpbGRIeWRyYXRpb25EaWZmTm9kZShmaWJlciwgMCksXG4gICAgICAgICAgICBkZXNjcmlwdGlvbiA9IGRlc2NyaWJlSHlkcmF0YWJsZUluc3RhbmNlRm9yRGV2V2FybmluZ3Moc2hvdWxkQ2xlYXIpO1xuICAgICAgICAgIGRpZmZOb2RlLnNlcnZlclRhaWwucHVzaChkZXNjcmlwdGlvbik7XG4gICAgICAgICAgc2hvdWxkQ2xlYXIgPVxuICAgICAgICAgICAgXCJTdXNwZW5zZVwiID09PSBkZXNjcmlwdGlvbi50eXBlXG4gICAgICAgICAgICAgID8gZ2V0TmV4dEh5ZHJhdGFibGVJbnN0YW5jZUFmdGVyU3VzcGVuc2VJbnN0YW5jZShzaG91bGRDbGVhcilcbiAgICAgICAgICAgICAgOiBnZXROZXh0SHlkcmF0YWJsZVNpYmxpbmcoc2hvdWxkQ2xlYXIpO1xuICAgICAgICB9XG4gICAgICAgIHRocm93T25IeWRyYXRpb25NaXNtYXRjaChmaWJlcik7XG4gICAgICB9XG4gICAgICBwb3BUb05leHRIb3N0UGFyZW50KGZpYmVyKTtcbiAgICAgIGlmICgxMyA9PT0gZmliZXIudGFnKSB7XG4gICAgICAgIGlmICghc3VwcG9ydHNIeWRyYXRpb24pXG4gICAgICAgICAgdGhyb3cgRXJyb3IoXG4gICAgICAgICAgICBcIkV4cGVjdGVkIHNraXBQYXN0RGVoeWRyYXRlZFN1c3BlbnNlSW5zdGFuY2UoKSB0byBuZXZlciBiZSBjYWxsZWQuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuXCJcbiAgICAgICAgICApO1xuICAgICAgICBmaWJlciA9IGZpYmVyLm1lbW9pemVkU3RhdGU7XG4gICAgICAgIGZpYmVyID0gbnVsbCAhPT0gZmliZXIgPyBmaWJlci5kZWh5ZHJhdGVkIDogbnVsbDtcbiAgICAgICAgaWYgKCFmaWJlcilcbiAgICAgICAgICB0aHJvdyBFcnJvcihcbiAgICAgICAgICAgIFwiRXhwZWN0ZWQgdG8gaGF2ZSBhIGh5ZHJhdGVkIHN1c3BlbnNlIGluc3RhbmNlLiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLlwiXG4gICAgICAgICAgKTtcbiAgICAgICAgbmV4dEh5ZHJhdGFibGVJbnN0YW5jZSA9XG4gICAgICAgICAgZ2V0TmV4dEh5ZHJhdGFibGVJbnN0YW5jZUFmdGVyU3VzcGVuc2VJbnN0YW5jZShmaWJlcik7XG4gICAgICB9IGVsc2VcbiAgICAgICAgbmV4dEh5ZHJhdGFibGVJbnN0YW5jZSA9IGh5ZHJhdGlvblBhcmVudEZpYmVyXG4gICAgICAgICAgPyBnZXROZXh0SHlkcmF0YWJsZVNpYmxpbmcoZmliZXIuc3RhdGVOb2RlKVxuICAgICAgICAgIDogbnVsbDtcbiAgICAgIHJldHVybiAhMDtcbiAgICB9XG4gICAgZnVuY3Rpb24gcmVzZXRIeWRyYXRpb25TdGF0ZSgpIHtcbiAgICAgIHN1cHBvcnRzSHlkcmF0aW9uICYmXG4gICAgICAgICgobmV4dEh5ZHJhdGFibGVJbnN0YW5jZSA9IGh5ZHJhdGlvblBhcmVudEZpYmVyID0gbnVsbCksXG4gICAgICAgIChkaWRTdXNwZW5kT3JFcnJvckRFViA9IGlzSHlkcmF0aW5nID0gITEpKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcXVldWVIeWRyYXRpb25FcnJvcihlcnJvcikge1xuICAgICAgbnVsbCA9PT0gaHlkcmF0aW9uRXJyb3JzXG4gICAgICAgID8gKGh5ZHJhdGlvbkVycm9ycyA9IFtlcnJvcl0pXG4gICAgICAgIDogaHlkcmF0aW9uRXJyb3JzLnB1c2goZXJyb3IpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBlbWl0UGVuZGluZ0h5ZHJhdGlvbldhcm5pbmdzKCkge1xuICAgICAgdmFyIGRpZmZSb290ID0gaHlkcmF0aW9uRGlmZlJvb3RERVY7XG4gICAgICBudWxsICE9PSBkaWZmUm9vdCAmJlxuICAgICAgICAoKGh5ZHJhdGlvbkRpZmZSb290REVWID0gbnVsbCksXG4gICAgICAgIChkaWZmUm9vdCA9IGRlc2NyaWJlRGlmZihkaWZmUm9vdCkpLFxuICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgIFwiQSB0cmVlIGh5ZHJhdGVkIGJ1dCBzb21lIGF0dHJpYnV0ZXMgb2YgdGhlIHNlcnZlciByZW5kZXJlZCBIVE1MIGRpZG4ndCBtYXRjaCB0aGUgY2xpZW50IHByb3BlcnRpZXMuIFRoaXMgd29uJ3QgYmUgcGF0Y2hlZCB1cC4gVGhpcyBjYW4gaGFwcGVuIGlmIGEgU1NSLWVkIENsaWVudCBDb21wb25lbnQgdXNlZDpcXG5cXG4tIEEgc2VydmVyL2NsaWVudCBicmFuY2ggYGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJylgLlxcbi0gVmFyaWFibGUgaW5wdXQgc3VjaCBhcyBgRGF0ZS5ub3coKWAgb3IgYE1hdGgucmFuZG9tKClgIHdoaWNoIGNoYW5nZXMgZWFjaCB0aW1lIGl0J3MgY2FsbGVkLlxcbi0gRGF0ZSBmb3JtYXR0aW5nIGluIGEgdXNlcidzIGxvY2FsZSB3aGljaCBkb2Vzbid0IG1hdGNoIHRoZSBzZXJ2ZXIuXFxuLSBFeHRlcm5hbCBjaGFuZ2luZyBkYXRhIHdpdGhvdXQgc2VuZGluZyBhIHNuYXBzaG90IG9mIGl0IGFsb25nIHdpdGggdGhlIEhUTUwuXFxuLSBJbnZhbGlkIEhUTUwgdGFnIG5lc3RpbmcuXFxuXFxuSXQgY2FuIGFsc28gaGFwcGVuIGlmIHRoZSBjbGllbnQgaGFzIGEgYnJvd3NlciBleHRlbnNpb24gaW5zdGFsbGVkIHdoaWNoIG1lc3NlcyB3aXRoIHRoZSBIVE1MIGJlZm9yZSBSZWFjdCBsb2FkZWQuXFxuXFxuJXMlc1wiLFxuICAgICAgICAgIFwiaHR0cHM6Ly9yZWFjdC5kZXYvbGluay9oeWRyYXRpb24tbWlzbWF0Y2hcIixcbiAgICAgICAgICBkaWZmUm9vdFxuICAgICAgICApKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZmluaXNoUXVldWVpbmdDb25jdXJyZW50VXBkYXRlcygpIHtcbiAgICAgIGZvciAoXG4gICAgICAgIHZhciBlbmRJbmRleCA9IGNvbmN1cnJlbnRRdWV1ZXNJbmRleCxcbiAgICAgICAgICBpID0gKGNvbmN1cnJlbnRseVVwZGF0ZWRMYW5lcyA9IGNvbmN1cnJlbnRRdWV1ZXNJbmRleCA9IDApO1xuICAgICAgICBpIDwgZW5kSW5kZXg7XG5cbiAgICAgICkge1xuICAgICAgICB2YXIgZmliZXIgPSBjb25jdXJyZW50UXVldWVzW2ldO1xuICAgICAgICBjb25jdXJyZW50UXVldWVzW2krK10gPSBudWxsO1xuICAgICAgICB2YXIgcXVldWUgPSBjb25jdXJyZW50UXVldWVzW2ldO1xuICAgICAgICBjb25jdXJyZW50UXVldWVzW2krK10gPSBudWxsO1xuICAgICAgICB2YXIgdXBkYXRlID0gY29uY3VycmVudFF1ZXVlc1tpXTtcbiAgICAgICAgY29uY3VycmVudFF1ZXVlc1tpKytdID0gbnVsbDtcbiAgICAgICAgdmFyIGxhbmUgPSBjb25jdXJyZW50UXVldWVzW2ldO1xuICAgICAgICBjb25jdXJyZW50UXVldWVzW2krK10gPSBudWxsO1xuICAgICAgICBpZiAobnVsbCAhPT0gcXVldWUgJiYgbnVsbCAhPT0gdXBkYXRlKSB7XG4gICAgICAgICAgdmFyIHBlbmRpbmcgPSBxdWV1ZS5wZW5kaW5nO1xuICAgICAgICAgIG51bGwgPT09IHBlbmRpbmdcbiAgICAgICAgICAgID8gKHVwZGF0ZS5uZXh0ID0gdXBkYXRlKVxuICAgICAgICAgICAgOiAoKHVwZGF0ZS5uZXh0ID0gcGVuZGluZy5uZXh0KSwgKHBlbmRpbmcubmV4dCA9IHVwZGF0ZSkpO1xuICAgICAgICAgIHF1ZXVlLnBlbmRpbmcgPSB1cGRhdGU7XG4gICAgICAgIH1cbiAgICAgICAgMCAhPT0gbGFuZSAmJiBtYXJrVXBkYXRlTGFuZUZyb21GaWJlclRvUm9vdChmaWJlciwgdXBkYXRlLCBsYW5lKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gZW5xdWV1ZVVwZGF0ZSQxKGZpYmVyLCBxdWV1ZSwgdXBkYXRlLCBsYW5lKSB7XG4gICAgICBjb25jdXJyZW50UXVldWVzW2NvbmN1cnJlbnRRdWV1ZXNJbmRleCsrXSA9IGZpYmVyO1xuICAgICAgY29uY3VycmVudFF1ZXVlc1tjb25jdXJyZW50UXVldWVzSW5kZXgrK10gPSBxdWV1ZTtcbiAgICAgIGNvbmN1cnJlbnRRdWV1ZXNbY29uY3VycmVudFF1ZXVlc0luZGV4KytdID0gdXBkYXRlO1xuICAgICAgY29uY3VycmVudFF1ZXVlc1tjb25jdXJyZW50UXVldWVzSW5kZXgrK10gPSBsYW5lO1xuICAgICAgY29uY3VycmVudGx5VXBkYXRlZExhbmVzIHw9IGxhbmU7XG4gICAgICBmaWJlci5sYW5lcyB8PSBsYW5lO1xuICAgICAgZmliZXIgPSBmaWJlci5hbHRlcm5hdGU7XG4gICAgICBudWxsICE9PSBmaWJlciAmJiAoZmliZXIubGFuZXMgfD0gbGFuZSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGVucXVldWVDb25jdXJyZW50SG9va1VwZGF0ZShmaWJlciwgcXVldWUsIHVwZGF0ZSwgbGFuZSkge1xuICAgICAgZW5xdWV1ZVVwZGF0ZSQxKGZpYmVyLCBxdWV1ZSwgdXBkYXRlLCBsYW5lKTtcbiAgICAgIHJldHVybiBnZXRSb290Rm9yVXBkYXRlZEZpYmVyKGZpYmVyKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZW5xdWV1ZUNvbmN1cnJlbnRSZW5kZXJGb3JMYW5lKGZpYmVyLCBsYW5lKSB7XG4gICAgICBlbnF1ZXVlVXBkYXRlJDEoZmliZXIsIG51bGwsIG51bGwsIGxhbmUpO1xuICAgICAgcmV0dXJuIGdldFJvb3RGb3JVcGRhdGVkRmliZXIoZmliZXIpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBtYXJrVXBkYXRlTGFuZUZyb21GaWJlclRvUm9vdChzb3VyY2VGaWJlciwgdXBkYXRlLCBsYW5lKSB7XG4gICAgICBzb3VyY2VGaWJlci5sYW5lcyB8PSBsYW5lO1xuICAgICAgdmFyIGFsdGVybmF0ZSA9IHNvdXJjZUZpYmVyLmFsdGVybmF0ZTtcbiAgICAgIG51bGwgIT09IGFsdGVybmF0ZSAmJiAoYWx0ZXJuYXRlLmxhbmVzIHw9IGxhbmUpO1xuICAgICAgZm9yICh2YXIgaXNIaWRkZW4gPSAhMSwgcGFyZW50ID0gc291cmNlRmliZXIucmV0dXJuOyBudWxsICE9PSBwYXJlbnQ7IClcbiAgICAgICAgKHBhcmVudC5jaGlsZExhbmVzIHw9IGxhbmUpLFxuICAgICAgICAgIChhbHRlcm5hdGUgPSBwYXJlbnQuYWx0ZXJuYXRlKSxcbiAgICAgICAgICBudWxsICE9PSBhbHRlcm5hdGUgJiYgKGFsdGVybmF0ZS5jaGlsZExhbmVzIHw9IGxhbmUpLFxuICAgICAgICAgIDIyID09PSBwYXJlbnQudGFnICYmXG4gICAgICAgICAgICAoKHNvdXJjZUZpYmVyID0gcGFyZW50LnN0YXRlTm9kZSksXG4gICAgICAgICAgICBudWxsID09PSBzb3VyY2VGaWJlciB8fFxuICAgICAgICAgICAgICBzb3VyY2VGaWJlci5fdmlzaWJpbGl0eSAmIDEgfHxcbiAgICAgICAgICAgICAgKGlzSGlkZGVuID0gITApKSxcbiAgICAgICAgICAoc291cmNlRmliZXIgPSBwYXJlbnQpLFxuICAgICAgICAgIChwYXJlbnQgPSBwYXJlbnQucmV0dXJuKTtcbiAgICAgIGlzSGlkZGVuICYmXG4gICAgICAgIG51bGwgIT09IHVwZGF0ZSAmJlxuICAgICAgICAzID09PSBzb3VyY2VGaWJlci50YWcgJiZcbiAgICAgICAgKChwYXJlbnQgPSBzb3VyY2VGaWJlci5zdGF0ZU5vZGUpLFxuICAgICAgICAoaXNIaWRkZW4gPSAzMSAtIGNsejMyKGxhbmUpKSxcbiAgICAgICAgKHBhcmVudCA9IHBhcmVudC5oaWRkZW5VcGRhdGVzKSxcbiAgICAgICAgKHNvdXJjZUZpYmVyID0gcGFyZW50W2lzSGlkZGVuXSksXG4gICAgICAgIG51bGwgPT09IHNvdXJjZUZpYmVyXG4gICAgICAgICAgPyAocGFyZW50W2lzSGlkZGVuXSA9IFt1cGRhdGVdKVxuICAgICAgICAgIDogc291cmNlRmliZXIucHVzaCh1cGRhdGUpLFxuICAgICAgICAodXBkYXRlLmxhbmUgPSBsYW5lIHwgNTM2ODcwOTEyKSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGdldFJvb3RGb3JVcGRhdGVkRmliZXIoc291cmNlRmliZXIpIHtcbiAgICAgIGlmIChuZXN0ZWRVcGRhdGVDb3VudCA+IE5FU1RFRF9VUERBVEVfTElNSVQpXG4gICAgICAgIHRocm93IChcbiAgICAgICAgICAoKG5lc3RlZFBhc3NpdmVVcGRhdGVDb3VudCA9IG5lc3RlZFVwZGF0ZUNvdW50ID0gMCksXG4gICAgICAgICAgKHJvb3RXaXRoUGFzc2l2ZU5lc3RlZFVwZGF0ZXMgPSByb290V2l0aE5lc3RlZFVwZGF0ZXMgPSBudWxsKSxcbiAgICAgICAgICBFcnJvcihcbiAgICAgICAgICAgIFwiTWF4aW11bSB1cGRhdGUgZGVwdGggZXhjZWVkZWQuIFRoaXMgY2FuIGhhcHBlbiB3aGVuIGEgY29tcG9uZW50IHJlcGVhdGVkbHkgY2FsbHMgc2V0U3RhdGUgaW5zaWRlIGNvbXBvbmVudFdpbGxVcGRhdGUgb3IgY29tcG9uZW50RGlkVXBkYXRlLiBSZWFjdCBsaW1pdHMgdGhlIG51bWJlciBvZiBuZXN0ZWQgdXBkYXRlcyB0byBwcmV2ZW50IGluZmluaXRlIGxvb3BzLlwiXG4gICAgICAgICAgKSlcbiAgICAgICAgKTtcbiAgICAgIG5lc3RlZFBhc3NpdmVVcGRhdGVDb3VudCA+IE5FU1RFRF9QQVNTSVZFX1VQREFURV9MSU1JVCAmJlxuICAgICAgICAoKG5lc3RlZFBhc3NpdmVVcGRhdGVDb3VudCA9IDApLFxuICAgICAgICAocm9vdFdpdGhQYXNzaXZlTmVzdGVkVXBkYXRlcyA9IG51bGwpLFxuICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgIFwiTWF4aW11bSB1cGRhdGUgZGVwdGggZXhjZWVkZWQuIFRoaXMgY2FuIGhhcHBlbiB3aGVuIGEgY29tcG9uZW50IGNhbGxzIHNldFN0YXRlIGluc2lkZSB1c2VFZmZlY3QsIGJ1dCB1c2VFZmZlY3QgZWl0aGVyIGRvZXNuJ3QgaGF2ZSBhIGRlcGVuZGVuY3kgYXJyYXksIG9yIG9uZSBvZiB0aGUgZGVwZW5kZW5jaWVzIGNoYW5nZXMgb24gZXZlcnkgcmVuZGVyLlwiXG4gICAgICAgICkpO1xuICAgICAgbnVsbCA9PT0gc291cmNlRmliZXIuYWx0ZXJuYXRlICYmXG4gICAgICAgIDAgIT09IChzb3VyY2VGaWJlci5mbGFncyAmIDQwOTgpICYmXG4gICAgICAgIHdhcm5BYm91dFVwZGF0ZU9uTm90WWV0TW91bnRlZEZpYmVySW5ERVYoc291cmNlRmliZXIpO1xuICAgICAgZm9yICh2YXIgbm9kZSA9IHNvdXJjZUZpYmVyLCBwYXJlbnQgPSBub2RlLnJldHVybjsgbnVsbCAhPT0gcGFyZW50OyApXG4gICAgICAgIG51bGwgPT09IG5vZGUuYWx0ZXJuYXRlICYmXG4gICAgICAgICAgMCAhPT0gKG5vZGUuZmxhZ3MgJiA0MDk4KSAmJlxuICAgICAgICAgIHdhcm5BYm91dFVwZGF0ZU9uTm90WWV0TW91bnRlZEZpYmVySW5ERVYoc291cmNlRmliZXIpLFxuICAgICAgICAgIChub2RlID0gcGFyZW50KSxcbiAgICAgICAgICAocGFyZW50ID0gbm9kZS5yZXR1cm4pO1xuICAgICAgcmV0dXJuIDMgPT09IG5vZGUudGFnID8gbm9kZS5zdGF0ZU5vZGUgOiBudWxsO1xuICAgIH1cbiAgICBmdW5jdGlvbiBwdXNoTmVzdGVkRWZmZWN0RHVyYXRpb25zKCkge1xuICAgICAgdmFyIHByZXZFZmZlY3REdXJhdGlvbiA9IHByb2ZpbGVyRWZmZWN0RHVyYXRpb247XG4gICAgICBwcm9maWxlckVmZmVjdER1cmF0aW9uID0gMDtcbiAgICAgIHJldHVybiBwcmV2RWZmZWN0RHVyYXRpb247XG4gICAgfVxuICAgIGZ1bmN0aW9uIHBvcE5lc3RlZEVmZmVjdER1cmF0aW9ucyhwcmV2RWZmZWN0RHVyYXRpb24pIHtcbiAgICAgIHZhciBlbGFwc2VkVGltZSA9IHByb2ZpbGVyRWZmZWN0RHVyYXRpb247XG4gICAgICBwcm9maWxlckVmZmVjdER1cmF0aW9uID0gcHJldkVmZmVjdER1cmF0aW9uO1xuICAgICAgcmV0dXJuIGVsYXBzZWRUaW1lO1xuICAgIH1cbiAgICBmdW5jdGlvbiBidWJibGVOZXN0ZWRFZmZlY3REdXJhdGlvbnMocHJldkVmZmVjdER1cmF0aW9uKSB7XG4gICAgICB2YXIgZWxhcHNlZFRpbWUgPSBwcm9maWxlckVmZmVjdER1cmF0aW9uO1xuICAgICAgcHJvZmlsZXJFZmZlY3REdXJhdGlvbiArPSBwcmV2RWZmZWN0RHVyYXRpb247XG4gICAgICByZXR1cm4gZWxhcHNlZFRpbWU7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHN0YXJ0UHJvZmlsZXJUaW1lcihmaWJlcikge1xuICAgICAgcHJvZmlsZXJTdGFydFRpbWUgPSBub3coKTtcbiAgICAgIDAgPiBmaWJlci5hY3R1YWxTdGFydFRpbWUgJiYgKGZpYmVyLmFjdHVhbFN0YXJ0VGltZSA9IHByb2ZpbGVyU3RhcnRUaW1lKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gc3RvcFByb2ZpbGVyVGltZXJJZlJ1bm5pbmdBbmRSZWNvcmREdXJhdGlvbihmaWJlcikge1xuICAgICAgaWYgKDAgPD0gcHJvZmlsZXJTdGFydFRpbWUpIHtcbiAgICAgICAgdmFyIGVsYXBzZWRUaW1lID0gbm93KCkgLSBwcm9maWxlclN0YXJ0VGltZTtcbiAgICAgICAgZmliZXIuYWN0dWFsRHVyYXRpb24gKz0gZWxhcHNlZFRpbWU7XG4gICAgICAgIGZpYmVyLnNlbGZCYXNlRHVyYXRpb24gPSBlbGFwc2VkVGltZTtcbiAgICAgICAgcHJvZmlsZXJTdGFydFRpbWUgPSAtMTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gc3RvcFByb2ZpbGVyVGltZXJJZlJ1bm5pbmdBbmRSZWNvcmRJbmNvbXBsZXRlRHVyYXRpb24oZmliZXIpIHtcbiAgICAgIGlmICgwIDw9IHByb2ZpbGVyU3RhcnRUaW1lKSB7XG4gICAgICAgIHZhciBlbGFwc2VkVGltZSA9IG5vdygpIC0gcHJvZmlsZXJTdGFydFRpbWU7XG4gICAgICAgIGZpYmVyLmFjdHVhbER1cmF0aW9uICs9IGVsYXBzZWRUaW1lO1xuICAgICAgICBwcm9maWxlclN0YXJ0VGltZSA9IC0xO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiByZWNvcmRFZmZlY3REdXJhdGlvbigpIHtcbiAgICAgIGlmICgwIDw9IHByb2ZpbGVyU3RhcnRUaW1lKSB7XG4gICAgICAgIHZhciBlbGFwc2VkVGltZSA9IG5vdygpIC0gcHJvZmlsZXJTdGFydFRpbWU7XG4gICAgICAgIHByb2ZpbGVyU3RhcnRUaW1lID0gLTE7XG4gICAgICAgIHByb2ZpbGVyRWZmZWN0RHVyYXRpb24gKz0gZWxhcHNlZFRpbWU7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIHN0YXJ0RWZmZWN0VGltZXIoKSB7XG4gICAgICBwcm9maWxlclN0YXJ0VGltZSA9IG5vdygpO1xuICAgIH1cbiAgICBmdW5jdGlvbiB0cmFuc2ZlckFjdHVhbER1cmF0aW9uKGZpYmVyKSB7XG4gICAgICBmb3IgKHZhciBjaGlsZCA9IGZpYmVyLmNoaWxkOyBjaGlsZDsgKVxuICAgICAgICAoZmliZXIuYWN0dWFsRHVyYXRpb24gKz0gY2hpbGQuYWN0dWFsRHVyYXRpb24pLCAoY2hpbGQgPSBjaGlsZC5zaWJsaW5nKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZW5zdXJlUm9vdElzU2NoZWR1bGVkKHJvb3QpIHtcbiAgICAgIHJvb3QgIT09IGxhc3RTY2hlZHVsZWRSb290ICYmXG4gICAgICAgIG51bGwgPT09IHJvb3QubmV4dCAmJlxuICAgICAgICAobnVsbCA9PT0gbGFzdFNjaGVkdWxlZFJvb3RcbiAgICAgICAgICA/IChmaXJzdFNjaGVkdWxlZFJvb3QgPSBsYXN0U2NoZWR1bGVkUm9vdCA9IHJvb3QpXG4gICAgICAgICAgOiAobGFzdFNjaGVkdWxlZFJvb3QgPSBsYXN0U2NoZWR1bGVkUm9vdC5uZXh0ID0gcm9vdCkpO1xuICAgICAgbWlnaHRIYXZlUGVuZGluZ1N5bmNXb3JrID0gITA7XG4gICAgICBudWxsICE9PSBSZWFjdFNoYXJlZEludGVybmFscy5hY3RRdWV1ZVxuICAgICAgICA/IGRpZFNjaGVkdWxlTWljcm90YXNrX2FjdCB8fFxuICAgICAgICAgICgoZGlkU2NoZWR1bGVNaWNyb3Rhc2tfYWN0ID0gITApLFxuICAgICAgICAgIHNjaGVkdWxlSW1tZWRpYXRlVGFzayhwcm9jZXNzUm9vdFNjaGVkdWxlSW5NaWNyb3Rhc2spKVxuICAgICAgICA6IGRpZFNjaGVkdWxlTWljcm90YXNrIHx8XG4gICAgICAgICAgKChkaWRTY2hlZHVsZU1pY3JvdGFzayA9ICEwKSxcbiAgICAgICAgICBzY2hlZHVsZUltbWVkaWF0ZVRhc2socHJvY2Vzc1Jvb3RTY2hlZHVsZUluTWljcm90YXNrKSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGZsdXNoU3luY1dvcmtBY3Jvc3NSb290c19pbXBsKHN5bmNUcmFuc2l0aW9uTGFuZXMsIG9ubHlMZWdhY3kpIHtcbiAgICAgIGlmICghaXNGbHVzaGluZ1dvcmsgJiYgbWlnaHRIYXZlUGVuZGluZ1N5bmNXb3JrKSB7XG4gICAgICAgIGlzRmx1c2hpbmdXb3JrID0gITA7XG4gICAgICAgIGRvIHtcbiAgICAgICAgICB2YXIgZGlkUGVyZm9ybVNvbWVXb3JrID0gITE7XG4gICAgICAgICAgZm9yICh2YXIgcm9vdCA9IGZpcnN0U2NoZWR1bGVkUm9vdDsgbnVsbCAhPT0gcm9vdDsgKSB7XG4gICAgICAgICAgICBpZiAoIW9ubHlMZWdhY3kpXG4gICAgICAgICAgICAgIGlmICgwICE9PSBzeW5jVHJhbnNpdGlvbkxhbmVzKSB7XG4gICAgICAgICAgICAgICAgdmFyIHBlbmRpbmdMYW5lcyA9IHJvb3QucGVuZGluZ0xhbmVzO1xuICAgICAgICAgICAgICAgIGlmICgwID09PSBwZW5kaW5nTGFuZXMpIHZhciBuZXh0TGFuZXMgPSAwO1xuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgdmFyIHN1c3BlbmRlZExhbmVzID0gcm9vdC5zdXNwZW5kZWRMYW5lcyxcbiAgICAgICAgICAgICAgICAgICAgcGluZ2VkTGFuZXMgPSByb290LnBpbmdlZExhbmVzO1xuICAgICAgICAgICAgICAgICAgbmV4dExhbmVzID1cbiAgICAgICAgICAgICAgICAgICAgKDEgPDwgKDMxIC0gY2x6MzIoNDIgfCBzeW5jVHJhbnNpdGlvbkxhbmVzKSArIDEpKSAtIDE7XG4gICAgICAgICAgICAgICAgICBuZXh0TGFuZXMgJj0gcGVuZGluZ0xhbmVzICYgfihzdXNwZW5kZWRMYW5lcyAmIH5waW5nZWRMYW5lcyk7XG4gICAgICAgICAgICAgICAgICBuZXh0TGFuZXMgPVxuICAgICAgICAgICAgICAgICAgICBuZXh0TGFuZXMgJiAyMDEzMjY2NzdcbiAgICAgICAgICAgICAgICAgICAgICA/IChuZXh0TGFuZXMgJiAyMDEzMjY2NzcpIHwgMVxuICAgICAgICAgICAgICAgICAgICAgIDogbmV4dExhbmVzXG4gICAgICAgICAgICAgICAgICAgICAgICA/IG5leHRMYW5lcyB8IDJcbiAgICAgICAgICAgICAgICAgICAgICAgIDogMDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgMCAhPT0gbmV4dExhbmVzICYmXG4gICAgICAgICAgICAgICAgICAoKGRpZFBlcmZvcm1Tb21lV29yayA9ICEwKSxcbiAgICAgICAgICAgICAgICAgIHBlcmZvcm1TeW5jV29ya09uUm9vdChyb290LCBuZXh0TGFuZXMpKTtcbiAgICAgICAgICAgICAgfSBlbHNlXG4gICAgICAgICAgICAgICAgKG5leHRMYW5lcyA9IHdvcmtJblByb2dyZXNzUm9vdFJlbmRlckxhbmVzKSxcbiAgICAgICAgICAgICAgICAgIChuZXh0TGFuZXMgPSBnZXROZXh0TGFuZXMoXG4gICAgICAgICAgICAgICAgICAgIHJvb3QsXG4gICAgICAgICAgICAgICAgICAgIHJvb3QgPT09IHdvcmtJblByb2dyZXNzUm9vdCA/IG5leHRMYW5lcyA6IDBcbiAgICAgICAgICAgICAgICAgICkpLFxuICAgICAgICAgICAgICAgICAgMCA9PT0gKG5leHRMYW5lcyAmIDMpIHx8XG4gICAgICAgICAgICAgICAgICAgIGNoZWNrSWZSb290SXNQcmVyZW5kZXJpbmcocm9vdCwgbmV4dExhbmVzKSB8fFxuICAgICAgICAgICAgICAgICAgICAoKGRpZFBlcmZvcm1Tb21lV29yayA9ICEwKSxcbiAgICAgICAgICAgICAgICAgICAgcGVyZm9ybVN5bmNXb3JrT25Sb290KHJvb3QsIG5leHRMYW5lcykpO1xuICAgICAgICAgICAgcm9vdCA9IHJvb3QubmV4dDtcbiAgICAgICAgICB9XG4gICAgICAgIH0gd2hpbGUgKGRpZFBlcmZvcm1Tb21lV29yayk7XG4gICAgICAgIGlzRmx1c2hpbmdXb3JrID0gITE7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIHByb2Nlc3NSb290U2NoZWR1bGVJbk1pY3JvdGFzaygpIHtcbiAgICAgIG1pZ2h0SGF2ZVBlbmRpbmdTeW5jV29yayA9XG4gICAgICAgIGRpZFNjaGVkdWxlTWljcm90YXNrX2FjdCA9XG4gICAgICAgIGRpZFNjaGVkdWxlTWljcm90YXNrID1cbiAgICAgICAgICAhMTtcbiAgICAgIHZhciBzeW5jVHJhbnNpdGlvbkxhbmVzID0gMDtcbiAgICAgIDAgIT09IGN1cnJlbnRFdmVudFRyYW5zaXRpb25MYW5lICYmXG4gICAgICAgIChzaG91bGRBdHRlbXB0RWFnZXJUcmFuc2l0aW9uKCkgJiZcbiAgICAgICAgICAoc3luY1RyYW5zaXRpb25MYW5lcyA9IGN1cnJlbnRFdmVudFRyYW5zaXRpb25MYW5lKSxcbiAgICAgICAgKGN1cnJlbnRFdmVudFRyYW5zaXRpb25MYW5lID0gMCkpO1xuICAgICAgZm9yIChcbiAgICAgICAgdmFyIGN1cnJlbnRUaW1lID0gbm93JDEoKSwgcHJldiA9IG51bGwsIHJvb3QgPSBmaXJzdFNjaGVkdWxlZFJvb3Q7XG4gICAgICAgIG51bGwgIT09IHJvb3Q7XG5cbiAgICAgICkge1xuICAgICAgICB2YXIgbmV4dCA9IHJvb3QubmV4dCxcbiAgICAgICAgICBuZXh0TGFuZXMgPSBzY2hlZHVsZVRhc2tGb3JSb290RHVyaW5nTWljcm90YXNrKHJvb3QsIGN1cnJlbnRUaW1lKTtcbiAgICAgICAgaWYgKDAgPT09IG5leHRMYW5lcylcbiAgICAgICAgICAocm9vdC5uZXh0ID0gbnVsbCksXG4gICAgICAgICAgICBudWxsID09PSBwcmV2ID8gKGZpcnN0U2NoZWR1bGVkUm9vdCA9IG5leHQpIDogKHByZXYubmV4dCA9IG5leHQpLFxuICAgICAgICAgICAgbnVsbCA9PT0gbmV4dCAmJiAobGFzdFNjaGVkdWxlZFJvb3QgPSBwcmV2KTtcbiAgICAgICAgZWxzZSBpZiAoXG4gICAgICAgICAgKChwcmV2ID0gcm9vdCksIDAgIT09IHN5bmNUcmFuc2l0aW9uTGFuZXMgfHwgMCAhPT0gKG5leHRMYW5lcyAmIDMpKVxuICAgICAgICApXG4gICAgICAgICAgbWlnaHRIYXZlUGVuZGluZ1N5bmNXb3JrID0gITA7XG4gICAgICAgIHJvb3QgPSBuZXh0O1xuICAgICAgfVxuICAgICAgZmx1c2hTeW5jV29ya0Fjcm9zc1Jvb3RzX2ltcGwoc3luY1RyYW5zaXRpb25MYW5lcywgITEpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBzY2hlZHVsZVRhc2tGb3JSb290RHVyaW5nTWljcm90YXNrKHJvb3QsIGN1cnJlbnRUaW1lKSB7XG4gICAgICBmb3IgKFxuICAgICAgICB2YXIgc3VzcGVuZGVkTGFuZXMgPSByb290LnN1c3BlbmRlZExhbmVzLFxuICAgICAgICAgIHBpbmdlZExhbmVzID0gcm9vdC5waW5nZWRMYW5lcyxcbiAgICAgICAgICBleHBpcmF0aW9uVGltZXMgPSByb290LmV4cGlyYXRpb25UaW1lcyxcbiAgICAgICAgICBsYW5lcyA9IHJvb3QucGVuZGluZ0xhbmVzICYgLTYyOTE0NTYxO1xuICAgICAgICAwIDwgbGFuZXM7XG5cbiAgICAgICkge1xuICAgICAgICB2YXIgaW5kZXggPSAzMSAtIGNsejMyKGxhbmVzKSxcbiAgICAgICAgICBsYW5lID0gMSA8PCBpbmRleCxcbiAgICAgICAgICBleHBpcmF0aW9uVGltZSA9IGV4cGlyYXRpb25UaW1lc1tpbmRleF07XG4gICAgICAgIGlmICgtMSA9PT0gZXhwaXJhdGlvblRpbWUpIHtcbiAgICAgICAgICBpZiAoMCA9PT0gKGxhbmUgJiBzdXNwZW5kZWRMYW5lcykgfHwgMCAhPT0gKGxhbmUgJiBwaW5nZWRMYW5lcykpXG4gICAgICAgICAgICBleHBpcmF0aW9uVGltZXNbaW5kZXhdID0gY29tcHV0ZUV4cGlyYXRpb25UaW1lKGxhbmUsIGN1cnJlbnRUaW1lKTtcbiAgICAgICAgfSBlbHNlIGV4cGlyYXRpb25UaW1lIDw9IGN1cnJlbnRUaW1lICYmIChyb290LmV4cGlyZWRMYW5lcyB8PSBsYW5lKTtcbiAgICAgICAgbGFuZXMgJj0gfmxhbmU7XG4gICAgICB9XG4gICAgICBjdXJyZW50VGltZSA9IHdvcmtJblByb2dyZXNzUm9vdDtcbiAgICAgIHN1c3BlbmRlZExhbmVzID0gd29ya0luUHJvZ3Jlc3NSb290UmVuZGVyTGFuZXM7XG4gICAgICBzdXNwZW5kZWRMYW5lcyA9IGdldE5leHRMYW5lcyhcbiAgICAgICAgcm9vdCxcbiAgICAgICAgcm9vdCA9PT0gY3VycmVudFRpbWUgPyBzdXNwZW5kZWRMYW5lcyA6IDBcbiAgICAgICk7XG4gICAgICBwaW5nZWRMYW5lcyA9IHJvb3QuY2FsbGJhY2tOb2RlO1xuICAgICAgaWYgKFxuICAgICAgICAwID09PSBzdXNwZW5kZWRMYW5lcyB8fFxuICAgICAgICAocm9vdCA9PT0gY3VycmVudFRpbWUgJiZcbiAgICAgICAgICB3b3JrSW5Qcm9ncmVzc1N1c3BlbmRlZFJlYXNvbiA9PT0gU3VzcGVuZGVkT25EYXRhKSB8fFxuICAgICAgICBudWxsICE9PSByb290LmNhbmNlbFBlbmRpbmdDb21taXRcbiAgICAgIClcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICBudWxsICE9PSBwaW5nZWRMYW5lcyAmJiBjYW5jZWxDYWxsYmFjayhwaW5nZWRMYW5lcyksXG4gICAgICAgICAgKHJvb3QuY2FsbGJhY2tOb2RlID0gbnVsbCksXG4gICAgICAgICAgKHJvb3QuY2FsbGJhY2tQcmlvcml0eSA9IDApXG4gICAgICAgICk7XG4gICAgICBpZiAoXG4gICAgICAgIDAgPT09IChzdXNwZW5kZWRMYW5lcyAmIDMpIHx8XG4gICAgICAgIGNoZWNrSWZSb290SXNQcmVyZW5kZXJpbmcocm9vdCwgc3VzcGVuZGVkTGFuZXMpXG4gICAgICApIHtcbiAgICAgICAgY3VycmVudFRpbWUgPSBzdXNwZW5kZWRMYW5lcyAmIC1zdXNwZW5kZWRMYW5lcztcbiAgICAgICAgaWYgKFxuICAgICAgICAgIGN1cnJlbnRUaW1lICE9PSByb290LmNhbGxiYWNrUHJpb3JpdHkgfHxcbiAgICAgICAgICAobnVsbCAhPT0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuYWN0UXVldWUgJiZcbiAgICAgICAgICAgIHBpbmdlZExhbmVzICE9PSBmYWtlQWN0Q2FsbGJhY2tOb2RlJDEpXG4gICAgICAgIClcbiAgICAgICAgICBjYW5jZWxDYWxsYmFjayhwaW5nZWRMYW5lcyk7XG4gICAgICAgIGVsc2UgcmV0dXJuIGN1cnJlbnRUaW1lO1xuICAgICAgICBzd2l0Y2ggKGxhbmVzVG9FdmVudFByaW9yaXR5KHN1c3BlbmRlZExhbmVzKSkge1xuICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICBjYXNlIDg6XG4gICAgICAgICAgICBzdXNwZW5kZWRMYW5lcyA9IFVzZXJCbG9ja2luZ1ByaW9yaXR5O1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAzMjpcbiAgICAgICAgICAgIHN1c3BlbmRlZExhbmVzID0gTm9ybWFsUHJpb3JpdHkkMTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgMjY4NDM1NDU2OlxuICAgICAgICAgICAgc3VzcGVuZGVkTGFuZXMgPSBJZGxlUHJpb3JpdHk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgc3VzcGVuZGVkTGFuZXMgPSBOb3JtYWxQcmlvcml0eSQxO1xuICAgICAgICB9XG4gICAgICAgIHBpbmdlZExhbmVzID0gcGVyZm9ybVdvcmtPblJvb3RWaWFTY2hlZHVsZXJUYXNrLmJpbmQobnVsbCwgcm9vdCk7XG4gICAgICAgIG51bGwgIT09IFJlYWN0U2hhcmVkSW50ZXJuYWxzLmFjdFF1ZXVlXG4gICAgICAgICAgPyAoUmVhY3RTaGFyZWRJbnRlcm5hbHMuYWN0UXVldWUucHVzaChwaW5nZWRMYW5lcyksXG4gICAgICAgICAgICAoc3VzcGVuZGVkTGFuZXMgPSBmYWtlQWN0Q2FsbGJhY2tOb2RlJDEpKVxuICAgICAgICAgIDogKHN1c3BlbmRlZExhbmVzID0gc2NoZWR1bGVDYWxsYmFjayQzKHN1c3BlbmRlZExhbmVzLCBwaW5nZWRMYW5lcykpO1xuICAgICAgICByb290LmNhbGxiYWNrUHJpb3JpdHkgPSBjdXJyZW50VGltZTtcbiAgICAgICAgcm9vdC5jYWxsYmFja05vZGUgPSBzdXNwZW5kZWRMYW5lcztcbiAgICAgICAgcmV0dXJuIGN1cnJlbnRUaW1lO1xuICAgICAgfVxuICAgICAgbnVsbCAhPT0gcGluZ2VkTGFuZXMgJiYgY2FuY2VsQ2FsbGJhY2socGluZ2VkTGFuZXMpO1xuICAgICAgcm9vdC5jYWxsYmFja1ByaW9yaXR5ID0gMjtcbiAgICAgIHJvb3QuY2FsbGJhY2tOb2RlID0gbnVsbDtcbiAgICAgIHJldHVybiAyO1xuICAgIH1cbiAgICBmdW5jdGlvbiBwZXJmb3JtV29ya09uUm9vdFZpYVNjaGVkdWxlclRhc2socm9vdCwgZGlkVGltZW91dCkge1xuICAgICAgbmVzdGVkVXBkYXRlU2NoZWR1bGVkID0gY3VycmVudFVwZGF0ZUlzTmVzdGVkID0gITE7XG4gICAgICB2YXIgb3JpZ2luYWxDYWxsYmFja05vZGUgPSByb290LmNhbGxiYWNrTm9kZTtcbiAgICAgIGlmIChmbHVzaFBhc3NpdmVFZmZlY3RzKCkgJiYgcm9vdC5jYWxsYmFja05vZGUgIT09IG9yaWdpbmFsQ2FsbGJhY2tOb2RlKVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIHZhciB3b3JrSW5Qcm9ncmVzc1Jvb3RSZW5kZXJMYW5lcyRqc2NvbXAkMCA9XG4gICAgICAgIHdvcmtJblByb2dyZXNzUm9vdFJlbmRlckxhbmVzO1xuICAgICAgd29ya0luUHJvZ3Jlc3NSb290UmVuZGVyTGFuZXMkanNjb21wJDAgPSBnZXROZXh0TGFuZXMoXG4gICAgICAgIHJvb3QsXG4gICAgICAgIHJvb3QgPT09IHdvcmtJblByb2dyZXNzUm9vdCA/IHdvcmtJblByb2dyZXNzUm9vdFJlbmRlckxhbmVzJGpzY29tcCQwIDogMFxuICAgICAgKTtcbiAgICAgIGlmICgwID09PSB3b3JrSW5Qcm9ncmVzc1Jvb3RSZW5kZXJMYW5lcyRqc2NvbXAkMCkgcmV0dXJuIG51bGw7XG4gICAgICBwZXJmb3JtV29ya09uUm9vdChcbiAgICAgICAgcm9vdCxcbiAgICAgICAgd29ya0luUHJvZ3Jlc3NSb290UmVuZGVyTGFuZXMkanNjb21wJDAsXG4gICAgICAgIGRpZFRpbWVvdXRcbiAgICAgICk7XG4gICAgICBzY2hlZHVsZVRhc2tGb3JSb290RHVyaW5nTWljcm90YXNrKHJvb3QsIG5vdyQxKCkpO1xuICAgICAgcmV0dXJuIG51bGwgIT0gcm9vdC5jYWxsYmFja05vZGUgJiZcbiAgICAgICAgcm9vdC5jYWxsYmFja05vZGUgPT09IG9yaWdpbmFsQ2FsbGJhY2tOb2RlXG4gICAgICAgID8gcGVyZm9ybVdvcmtPblJvb3RWaWFTY2hlZHVsZXJUYXNrLmJpbmQobnVsbCwgcm9vdClcbiAgICAgICAgOiBudWxsO1xuICAgIH1cbiAgICBmdW5jdGlvbiBwZXJmb3JtU3luY1dvcmtPblJvb3Qocm9vdCwgbGFuZXMpIHtcbiAgICAgIGlmIChmbHVzaFBhc3NpdmVFZmZlY3RzKCkpIHJldHVybiBudWxsO1xuICAgICAgY3VycmVudFVwZGF0ZUlzTmVzdGVkID0gbmVzdGVkVXBkYXRlU2NoZWR1bGVkO1xuICAgICAgbmVzdGVkVXBkYXRlU2NoZWR1bGVkID0gITE7XG4gICAgICBwZXJmb3JtV29ya09uUm9vdChyb290LCBsYW5lcywgITApO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjYW5jZWxDYWxsYmFjayhjYWxsYmFja05vZGUpIHtcbiAgICAgIGNhbGxiYWNrTm9kZSAhPT0gZmFrZUFjdENhbGxiYWNrTm9kZSQxICYmXG4gICAgICAgIG51bGwgIT09IGNhbGxiYWNrTm9kZSAmJlxuICAgICAgICBjYW5jZWxDYWxsYmFjayQxKGNhbGxiYWNrTm9kZSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHNjaGVkdWxlSW1tZWRpYXRlVGFzayhjYikge1xuICAgICAgbnVsbCAhPT0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuYWN0UXVldWUgJiZcbiAgICAgICAgUmVhY3RTaGFyZWRJbnRlcm5hbHMuYWN0UXVldWUucHVzaChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgY2IoKTtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfSk7XG4gICAgICBzdXBwb3J0c01pY3JvdGFza3NcbiAgICAgICAgPyBzY2hlZHVsZU1pY3JvdGFzayhmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAoZXhlY3V0aW9uQ29udGV4dCAmIChSZW5kZXJDb250ZXh0IHwgQ29tbWl0Q29udGV4dCkpICE9PSBOb0NvbnRleHRcbiAgICAgICAgICAgICAgPyBzY2hlZHVsZUNhbGxiYWNrJDMoSW1tZWRpYXRlUHJpb3JpdHksIGNiKVxuICAgICAgICAgICAgICA6IGNiKCk7XG4gICAgICAgICAgfSlcbiAgICAgICAgOiBzY2hlZHVsZUNhbGxiYWNrJDMoSW1tZWRpYXRlUHJpb3JpdHksIGNiKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcmVxdWVzdFRyYW5zaXRpb25MYW5lKCkge1xuICAgICAgMCA9PT0gY3VycmVudEV2ZW50VHJhbnNpdGlvbkxhbmUgJiZcbiAgICAgICAgKGN1cnJlbnRFdmVudFRyYW5zaXRpb25MYW5lID0gY2xhaW1OZXh0VHJhbnNpdGlvbkxhbmUoKSk7XG4gICAgICByZXR1cm4gY3VycmVudEV2ZW50VHJhbnNpdGlvbkxhbmU7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGVudGFuZ2xlQXN5bmNBY3Rpb24odHJhbnNpdGlvbiwgdGhlbmFibGUpIHtcbiAgICAgIGlmIChudWxsID09PSBjdXJyZW50RW50YW5nbGVkTGlzdGVuZXJzKSB7XG4gICAgICAgIHZhciBlbnRhbmdsZWRMaXN0ZW5lcnMgPSAoY3VycmVudEVudGFuZ2xlZExpc3RlbmVycyA9IFtdKTtcbiAgICAgICAgY3VycmVudEVudGFuZ2xlZFBlbmRpbmdDb3VudCA9IDA7XG4gICAgICAgIGN1cnJlbnRFbnRhbmdsZWRMYW5lID0gcmVxdWVzdFRyYW5zaXRpb25MYW5lKCk7XG4gICAgICAgIGN1cnJlbnRFbnRhbmdsZWRBY3Rpb25UaGVuYWJsZSA9IHtcbiAgICAgICAgICBzdGF0dXM6IFwicGVuZGluZ1wiLFxuICAgICAgICAgIHZhbHVlOiB2b2lkIDAsXG4gICAgICAgICAgdGhlbjogZnVuY3Rpb24gKHJlc29sdmUpIHtcbiAgICAgICAgICAgIGVudGFuZ2xlZExpc3RlbmVycy5wdXNoKHJlc29sdmUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIGN1cnJlbnRFbnRhbmdsZWRQZW5kaW5nQ291bnQrKztcbiAgICAgIHRoZW5hYmxlLnRoZW4ocGluZ0VuZ3RhbmdsZWRBY3Rpb25TY29wZSwgcGluZ0VuZ3RhbmdsZWRBY3Rpb25TY29wZSk7XG4gICAgICByZXR1cm4gdGhlbmFibGU7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHBpbmdFbmd0YW5nbGVkQWN0aW9uU2NvcGUoKSB7XG4gICAgICBpZiAoXG4gICAgICAgIDAgPT09IC0tY3VycmVudEVudGFuZ2xlZFBlbmRpbmdDb3VudCAmJlxuICAgICAgICBudWxsICE9PSBjdXJyZW50RW50YW5nbGVkTGlzdGVuZXJzXG4gICAgICApIHtcbiAgICAgICAgbnVsbCAhPT0gY3VycmVudEVudGFuZ2xlZEFjdGlvblRoZW5hYmxlICYmXG4gICAgICAgICAgKGN1cnJlbnRFbnRhbmdsZWRBY3Rpb25UaGVuYWJsZS5zdGF0dXMgPSBcImZ1bGZpbGxlZFwiKTtcbiAgICAgICAgdmFyIGxpc3RlbmVycyA9IGN1cnJlbnRFbnRhbmdsZWRMaXN0ZW5lcnM7XG4gICAgICAgIGN1cnJlbnRFbnRhbmdsZWRMaXN0ZW5lcnMgPSBudWxsO1xuICAgICAgICBjdXJyZW50RW50YW5nbGVkTGFuZSA9IDA7XG4gICAgICAgIGN1cnJlbnRFbnRhbmdsZWRBY3Rpb25UaGVuYWJsZSA9IG51bGw7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGlzdGVuZXJzLmxlbmd0aDsgaSsrKSAoMCwgbGlzdGVuZXJzW2ldKSgpO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBjaGFpblRoZW5hYmxlVmFsdWUodGhlbmFibGUsIHJlc3VsdCkge1xuICAgICAgdmFyIGxpc3RlbmVycyA9IFtdLFxuICAgICAgICB0aGVuYWJsZVdpdGhPdmVycmlkZSA9IHtcbiAgICAgICAgICBzdGF0dXM6IFwicGVuZGluZ1wiLFxuICAgICAgICAgIHZhbHVlOiBudWxsLFxuICAgICAgICAgIHJlYXNvbjogbnVsbCxcbiAgICAgICAgICB0aGVuOiBmdW5jdGlvbiAocmVzb2x2ZSkge1xuICAgICAgICAgICAgbGlzdGVuZXJzLnB1c2gocmVzb2x2ZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgdGhlbmFibGUudGhlbihcbiAgICAgICAgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHRoZW5hYmxlV2l0aE92ZXJyaWRlLnN0YXR1cyA9IFwiZnVsZmlsbGVkXCI7XG4gICAgICAgICAgdGhlbmFibGVXaXRoT3ZlcnJpZGUudmFsdWUgPSByZXN1bHQ7XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaXN0ZW5lcnMubGVuZ3RoOyBpKyspICgwLCBsaXN0ZW5lcnNbaV0pKHJlc3VsdCk7XG4gICAgICAgIH0sXG4gICAgICAgIGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICAgIHRoZW5hYmxlV2l0aE92ZXJyaWRlLnN0YXR1cyA9IFwicmVqZWN0ZWRcIjtcbiAgICAgICAgICB0aGVuYWJsZVdpdGhPdmVycmlkZS5yZWFzb24gPSBlcnJvcjtcbiAgICAgICAgICBmb3IgKGVycm9yID0gMDsgZXJyb3IgPCBsaXN0ZW5lcnMubGVuZ3RoOyBlcnJvcisrKVxuICAgICAgICAgICAgKDAsIGxpc3RlbmVyc1tlcnJvcl0pKHZvaWQgMCk7XG4gICAgICAgIH1cbiAgICAgICk7XG4gICAgICByZXR1cm4gdGhlbmFibGVXaXRoT3ZlcnJpZGU7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGluaXRpYWxpemVVcGRhdGVRdWV1ZShmaWJlcikge1xuICAgICAgZmliZXIudXBkYXRlUXVldWUgPSB7XG4gICAgICAgIGJhc2VTdGF0ZTogZmliZXIubWVtb2l6ZWRTdGF0ZSxcbiAgICAgICAgZmlyc3RCYXNlVXBkYXRlOiBudWxsLFxuICAgICAgICBsYXN0QmFzZVVwZGF0ZTogbnVsbCxcbiAgICAgICAgc2hhcmVkOiB7IHBlbmRpbmc6IG51bGwsIGxhbmVzOiAwLCBoaWRkZW5DYWxsYmFja3M6IG51bGwgfSxcbiAgICAgICAgY2FsbGJhY2tzOiBudWxsXG4gICAgICB9O1xuICAgIH1cbiAgICBmdW5jdGlvbiBjbG9uZVVwZGF0ZVF1ZXVlKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzKSB7XG4gICAgICBjdXJyZW50ID0gY3VycmVudC51cGRhdGVRdWV1ZTtcbiAgICAgIHdvcmtJblByb2dyZXNzLnVwZGF0ZVF1ZXVlID09PSBjdXJyZW50ICYmXG4gICAgICAgICh3b3JrSW5Qcm9ncmVzcy51cGRhdGVRdWV1ZSA9IHtcbiAgICAgICAgICBiYXNlU3RhdGU6IGN1cnJlbnQuYmFzZVN0YXRlLFxuICAgICAgICAgIGZpcnN0QmFzZVVwZGF0ZTogY3VycmVudC5maXJzdEJhc2VVcGRhdGUsXG4gICAgICAgICAgbGFzdEJhc2VVcGRhdGU6IGN1cnJlbnQubGFzdEJhc2VVcGRhdGUsXG4gICAgICAgICAgc2hhcmVkOiBjdXJyZW50LnNoYXJlZCxcbiAgICAgICAgICBjYWxsYmFja3M6IG51bGxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNyZWF0ZVVwZGF0ZShsYW5lKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBsYW5lOiBsYW5lLFxuICAgICAgICB0YWc6IFVwZGF0ZVN0YXRlLFxuICAgICAgICBwYXlsb2FkOiBudWxsLFxuICAgICAgICBjYWxsYmFjazogbnVsbCxcbiAgICAgICAgbmV4dDogbnVsbFxuICAgICAgfTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZW5xdWV1ZVVwZGF0ZShmaWJlciwgdXBkYXRlLCBsYW5lKSB7XG4gICAgICB2YXIgdXBkYXRlUXVldWUgPSBmaWJlci51cGRhdGVRdWV1ZTtcbiAgICAgIGlmIChudWxsID09PSB1cGRhdGVRdWV1ZSkgcmV0dXJuIG51bGw7XG4gICAgICB1cGRhdGVRdWV1ZSA9IHVwZGF0ZVF1ZXVlLnNoYXJlZDtcbiAgICAgIGlmIChcbiAgICAgICAgY3VycmVudGx5UHJvY2Vzc2luZ1F1ZXVlID09PSB1cGRhdGVRdWV1ZSAmJlxuICAgICAgICAhZGlkV2FyblVwZGF0ZUluc2lkZVVwZGF0ZVxuICAgICAgKSB7XG4gICAgICAgIHZhciBjb21wb25lbnROYW1lID0gZ2V0Q29tcG9uZW50TmFtZUZyb21GaWJlcihmaWJlcik7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgXCJBbiB1cGRhdGUgKHNldFN0YXRlLCByZXBsYWNlU3RhdGUsIG9yIGZvcmNlVXBkYXRlKSB3YXMgc2NoZWR1bGVkIGZyb20gaW5zaWRlIGFuIHVwZGF0ZSBmdW5jdGlvbi4gVXBkYXRlIGZ1bmN0aW9ucyBzaG91bGQgYmUgcHVyZSwgd2l0aCB6ZXJvIHNpZGUtZWZmZWN0cy4gQ29uc2lkZXIgdXNpbmcgY29tcG9uZW50RGlkVXBkYXRlIG9yIGEgY2FsbGJhY2suXFxuXFxuUGxlYXNlIHVwZGF0ZSB0aGUgZm9sbG93aW5nIGNvbXBvbmVudDogJXNcIixcbiAgICAgICAgICBjb21wb25lbnROYW1lXG4gICAgICAgICk7XG4gICAgICAgIGRpZFdhcm5VcGRhdGVJbnNpZGVVcGRhdGUgPSAhMDtcbiAgICAgIH1cbiAgICAgIGlmICgoZXhlY3V0aW9uQ29udGV4dCAmIFJlbmRlckNvbnRleHQpICE9PSBOb0NvbnRleHQpXG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgKGNvbXBvbmVudE5hbWUgPSB1cGRhdGVRdWV1ZS5wZW5kaW5nKSxcbiAgICAgICAgICBudWxsID09PSBjb21wb25lbnROYW1lXG4gICAgICAgICAgICA/ICh1cGRhdGUubmV4dCA9IHVwZGF0ZSlcbiAgICAgICAgICAgIDogKCh1cGRhdGUubmV4dCA9IGNvbXBvbmVudE5hbWUubmV4dCksXG4gICAgICAgICAgICAgIChjb21wb25lbnROYW1lLm5leHQgPSB1cGRhdGUpKSxcbiAgICAgICAgICAodXBkYXRlUXVldWUucGVuZGluZyA9IHVwZGF0ZSksXG4gICAgICAgICAgKHVwZGF0ZSA9IGdldFJvb3RGb3JVcGRhdGVkRmliZXIoZmliZXIpKSxcbiAgICAgICAgICBtYXJrVXBkYXRlTGFuZUZyb21GaWJlclRvUm9vdChmaWJlciwgbnVsbCwgbGFuZSksXG4gICAgICAgICAgdXBkYXRlXG4gICAgICAgICk7XG4gICAgICBlbnF1ZXVlVXBkYXRlJDEoZmliZXIsIHVwZGF0ZVF1ZXVlLCB1cGRhdGUsIGxhbmUpO1xuICAgICAgcmV0dXJuIGdldFJvb3RGb3JVcGRhdGVkRmliZXIoZmliZXIpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBlbnRhbmdsZVRyYW5zaXRpb25zKHJvb3QsIGZpYmVyLCBsYW5lKSB7XG4gICAgICBmaWJlciA9IGZpYmVyLnVwZGF0ZVF1ZXVlO1xuICAgICAgaWYgKG51bGwgIT09IGZpYmVyICYmICgoZmliZXIgPSBmaWJlci5zaGFyZWQpLCAwICE9PSAobGFuZSAmIDQxOTQxNzYpKSkge1xuICAgICAgICB2YXIgcXVldWVMYW5lcyA9IGZpYmVyLmxhbmVzO1xuICAgICAgICBxdWV1ZUxhbmVzICY9IHJvb3QucGVuZGluZ0xhbmVzO1xuICAgICAgICBsYW5lIHw9IHF1ZXVlTGFuZXM7XG4gICAgICAgIGZpYmVyLmxhbmVzID0gbGFuZTtcbiAgICAgICAgbWFya1Jvb3RFbnRhbmdsZWQocm9vdCwgbGFuZSk7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGVucXVldWVDYXB0dXJlZFVwZGF0ZSh3b3JrSW5Qcm9ncmVzcywgY2FwdHVyZWRVcGRhdGUpIHtcbiAgICAgIHZhciBxdWV1ZSA9IHdvcmtJblByb2dyZXNzLnVwZGF0ZVF1ZXVlLFxuICAgICAgICBjdXJyZW50ID0gd29ya0luUHJvZ3Jlc3MuYWx0ZXJuYXRlO1xuICAgICAgaWYgKFxuICAgICAgICBudWxsICE9PSBjdXJyZW50ICYmXG4gICAgICAgICgoY3VycmVudCA9IGN1cnJlbnQudXBkYXRlUXVldWUpLCBxdWV1ZSA9PT0gY3VycmVudClcbiAgICAgICkge1xuICAgICAgICB2YXIgbmV3Rmlyc3QgPSBudWxsLFxuICAgICAgICAgIG5ld0xhc3QgPSBudWxsO1xuICAgICAgICBxdWV1ZSA9IHF1ZXVlLmZpcnN0QmFzZVVwZGF0ZTtcbiAgICAgICAgaWYgKG51bGwgIT09IHF1ZXVlKSB7XG4gICAgICAgICAgZG8ge1xuICAgICAgICAgICAgdmFyIGNsb25lID0ge1xuICAgICAgICAgICAgICBsYW5lOiBxdWV1ZS5sYW5lLFxuICAgICAgICAgICAgICB0YWc6IHF1ZXVlLnRhZyxcbiAgICAgICAgICAgICAgcGF5bG9hZDogcXVldWUucGF5bG9hZCxcbiAgICAgICAgICAgICAgY2FsbGJhY2s6IG51bGwsXG4gICAgICAgICAgICAgIG5leHQ6IG51bGxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBudWxsID09PSBuZXdMYXN0XG4gICAgICAgICAgICAgID8gKG5ld0ZpcnN0ID0gbmV3TGFzdCA9IGNsb25lKVxuICAgICAgICAgICAgICA6IChuZXdMYXN0ID0gbmV3TGFzdC5uZXh0ID0gY2xvbmUpO1xuICAgICAgICAgICAgcXVldWUgPSBxdWV1ZS5uZXh0O1xuICAgICAgICAgIH0gd2hpbGUgKG51bGwgIT09IHF1ZXVlKTtcbiAgICAgICAgICBudWxsID09PSBuZXdMYXN0XG4gICAgICAgICAgICA/IChuZXdGaXJzdCA9IG5ld0xhc3QgPSBjYXB0dXJlZFVwZGF0ZSlcbiAgICAgICAgICAgIDogKG5ld0xhc3QgPSBuZXdMYXN0Lm5leHQgPSBjYXB0dXJlZFVwZGF0ZSk7XG4gICAgICAgIH0gZWxzZSBuZXdGaXJzdCA9IG5ld0xhc3QgPSBjYXB0dXJlZFVwZGF0ZTtcbiAgICAgICAgcXVldWUgPSB7XG4gICAgICAgICAgYmFzZVN0YXRlOiBjdXJyZW50LmJhc2VTdGF0ZSxcbiAgICAgICAgICBmaXJzdEJhc2VVcGRhdGU6IG5ld0ZpcnN0LFxuICAgICAgICAgIGxhc3RCYXNlVXBkYXRlOiBuZXdMYXN0LFxuICAgICAgICAgIHNoYXJlZDogY3VycmVudC5zaGFyZWQsXG4gICAgICAgICAgY2FsbGJhY2tzOiBjdXJyZW50LmNhbGxiYWNrc1xuICAgICAgICB9O1xuICAgICAgICB3b3JrSW5Qcm9ncmVzcy51cGRhdGVRdWV1ZSA9IHF1ZXVlO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB3b3JrSW5Qcm9ncmVzcyA9IHF1ZXVlLmxhc3RCYXNlVXBkYXRlO1xuICAgICAgbnVsbCA9PT0gd29ya0luUHJvZ3Jlc3NcbiAgICAgICAgPyAocXVldWUuZmlyc3RCYXNlVXBkYXRlID0gY2FwdHVyZWRVcGRhdGUpXG4gICAgICAgIDogKHdvcmtJblByb2dyZXNzLm5leHQgPSBjYXB0dXJlZFVwZGF0ZSk7XG4gICAgICBxdWV1ZS5sYXN0QmFzZVVwZGF0ZSA9IGNhcHR1cmVkVXBkYXRlO1xuICAgIH1cbiAgICBmdW5jdGlvbiBzdXNwZW5kSWZVcGRhdGVSZWFkRnJvbUVudGFuZ2xlZEFzeW5jQWN0aW9uKCkge1xuICAgICAgaWYgKGRpZFJlYWRGcm9tRW50YW5nbGVkQXN5bmNBY3Rpb24pIHtcbiAgICAgICAgdmFyIGVudGFuZ2xlZEFjdGlvblRoZW5hYmxlID0gY3VycmVudEVudGFuZ2xlZEFjdGlvblRoZW5hYmxlO1xuICAgICAgICBpZiAobnVsbCAhPT0gZW50YW5nbGVkQWN0aW9uVGhlbmFibGUpIHRocm93IGVudGFuZ2xlZEFjdGlvblRoZW5hYmxlO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBwcm9jZXNzVXBkYXRlUXVldWUoXG4gICAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgICAgIHByb3BzLFxuICAgICAgaW5zdGFuY2UkanNjb21wJDAsXG4gICAgICByZW5kZXJMYW5lc1xuICAgICkge1xuICAgICAgZGlkUmVhZEZyb21FbnRhbmdsZWRBc3luY0FjdGlvbiA9ICExO1xuICAgICAgdmFyIHF1ZXVlID0gd29ya0luUHJvZ3Jlc3MudXBkYXRlUXVldWU7XG4gICAgICBoYXNGb3JjZVVwZGF0ZSA9ICExO1xuICAgICAgY3VycmVudGx5UHJvY2Vzc2luZ1F1ZXVlID0gcXVldWUuc2hhcmVkO1xuICAgICAgdmFyIGZpcnN0QmFzZVVwZGF0ZSA9IHF1ZXVlLmZpcnN0QmFzZVVwZGF0ZSxcbiAgICAgICAgbGFzdEJhc2VVcGRhdGUgPSBxdWV1ZS5sYXN0QmFzZVVwZGF0ZSxcbiAgICAgICAgcGVuZGluZ1F1ZXVlID0gcXVldWUuc2hhcmVkLnBlbmRpbmc7XG4gICAgICBpZiAobnVsbCAhPT0gcGVuZGluZ1F1ZXVlKSB7XG4gICAgICAgIHF1ZXVlLnNoYXJlZC5wZW5kaW5nID0gbnVsbDtcbiAgICAgICAgdmFyIGxhc3RQZW5kaW5nVXBkYXRlID0gcGVuZGluZ1F1ZXVlLFxuICAgICAgICAgIGZpcnN0UGVuZGluZ1VwZGF0ZSA9IGxhc3RQZW5kaW5nVXBkYXRlLm5leHQ7XG4gICAgICAgIGxhc3RQZW5kaW5nVXBkYXRlLm5leHQgPSBudWxsO1xuICAgICAgICBudWxsID09PSBsYXN0QmFzZVVwZGF0ZVxuICAgICAgICAgID8gKGZpcnN0QmFzZVVwZGF0ZSA9IGZpcnN0UGVuZGluZ1VwZGF0ZSlcbiAgICAgICAgICA6IChsYXN0QmFzZVVwZGF0ZS5uZXh0ID0gZmlyc3RQZW5kaW5nVXBkYXRlKTtcbiAgICAgICAgbGFzdEJhc2VVcGRhdGUgPSBsYXN0UGVuZGluZ1VwZGF0ZTtcbiAgICAgICAgdmFyIGN1cnJlbnQgPSB3b3JrSW5Qcm9ncmVzcy5hbHRlcm5hdGU7XG4gICAgICAgIG51bGwgIT09IGN1cnJlbnQgJiZcbiAgICAgICAgICAoKGN1cnJlbnQgPSBjdXJyZW50LnVwZGF0ZVF1ZXVlKSxcbiAgICAgICAgICAocGVuZGluZ1F1ZXVlID0gY3VycmVudC5sYXN0QmFzZVVwZGF0ZSksXG4gICAgICAgICAgcGVuZGluZ1F1ZXVlICE9PSBsYXN0QmFzZVVwZGF0ZSAmJlxuICAgICAgICAgICAgKG51bGwgPT09IHBlbmRpbmdRdWV1ZVxuICAgICAgICAgICAgICA/IChjdXJyZW50LmZpcnN0QmFzZVVwZGF0ZSA9IGZpcnN0UGVuZGluZ1VwZGF0ZSlcbiAgICAgICAgICAgICAgOiAocGVuZGluZ1F1ZXVlLm5leHQgPSBmaXJzdFBlbmRpbmdVcGRhdGUpLFxuICAgICAgICAgICAgKGN1cnJlbnQubGFzdEJhc2VVcGRhdGUgPSBsYXN0UGVuZGluZ1VwZGF0ZSkpKTtcbiAgICAgIH1cbiAgICAgIGlmIChudWxsICE9PSBmaXJzdEJhc2VVcGRhdGUpIHtcbiAgICAgICAgdmFyIG5ld1N0YXRlID0gcXVldWUuYmFzZVN0YXRlO1xuICAgICAgICBsYXN0QmFzZVVwZGF0ZSA9IDA7XG4gICAgICAgIGN1cnJlbnQgPSBmaXJzdFBlbmRpbmdVcGRhdGUgPSBsYXN0UGVuZGluZ1VwZGF0ZSA9IG51bGw7XG4gICAgICAgIHBlbmRpbmdRdWV1ZSA9IGZpcnN0QmFzZVVwZGF0ZTtcbiAgICAgICAgZG8ge1xuICAgICAgICAgIHZhciB1cGRhdGVMYW5lID0gcGVuZGluZ1F1ZXVlLmxhbmUgJiAtNTM2ODcwOTEzLFxuICAgICAgICAgICAgaXNIaWRkZW5VcGRhdGUgPSB1cGRhdGVMYW5lICE9PSBwZW5kaW5nUXVldWUubGFuZTtcbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgICBpc0hpZGRlblVwZGF0ZVxuICAgICAgICAgICAgICA/ICh3b3JrSW5Qcm9ncmVzc1Jvb3RSZW5kZXJMYW5lcyAmIHVwZGF0ZUxhbmUpID09PSB1cGRhdGVMYW5lXG4gICAgICAgICAgICAgIDogKHJlbmRlckxhbmVzICYgdXBkYXRlTGFuZSkgPT09IHVwZGF0ZUxhbmVcbiAgICAgICAgICApIHtcbiAgICAgICAgICAgIDAgIT09IHVwZGF0ZUxhbmUgJiZcbiAgICAgICAgICAgICAgdXBkYXRlTGFuZSA9PT0gY3VycmVudEVudGFuZ2xlZExhbmUgJiZcbiAgICAgICAgICAgICAgKGRpZFJlYWRGcm9tRW50YW5nbGVkQXN5bmNBY3Rpb24gPSAhMCk7XG4gICAgICAgICAgICBudWxsICE9PSBjdXJyZW50ICYmXG4gICAgICAgICAgICAgIChjdXJyZW50ID0gY3VycmVudC5uZXh0ID1cbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICBsYW5lOiAwLFxuICAgICAgICAgICAgICAgICAgdGFnOiBwZW5kaW5nUXVldWUudGFnLFxuICAgICAgICAgICAgICAgICAgcGF5bG9hZDogcGVuZGluZ1F1ZXVlLnBheWxvYWQsXG4gICAgICAgICAgICAgICAgICBjYWxsYmFjazogbnVsbCxcbiAgICAgICAgICAgICAgICAgIG5leHQ6IG51bGxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGE6IHtcbiAgICAgICAgICAgICAgdXBkYXRlTGFuZSA9IHdvcmtJblByb2dyZXNzO1xuICAgICAgICAgICAgICB2YXIgcGFydGlhbFN0YXRlID0gcGVuZGluZ1F1ZXVlO1xuICAgICAgICAgICAgICB2YXIgbmV4dFByb3BzID0gcHJvcHMsXG4gICAgICAgICAgICAgICAgaW5zdGFuY2UgPSBpbnN0YW5jZSRqc2NvbXAkMDtcbiAgICAgICAgICAgICAgc3dpdGNoIChwYXJ0aWFsU3RhdGUudGFnKSB7XG4gICAgICAgICAgICAgICAgY2FzZSBSZXBsYWNlU3RhdGU6XG4gICAgICAgICAgICAgICAgICBwYXJ0aWFsU3RhdGUgPSBwYXJ0aWFsU3RhdGUucGF5bG9hZDtcbiAgICAgICAgICAgICAgICAgIGlmIChcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBwYXJ0aWFsU3RhdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgaXNEaXNhbGxvd2VkQ29udGV4dFJlYWRJbkRFViA9ICEwO1xuICAgICAgICAgICAgICAgICAgICB2YXIgbmV4dFN0YXRlID0gcGFydGlhbFN0YXRlLmNhbGwoXG4gICAgICAgICAgICAgICAgICAgICAgaW5zdGFuY2UsXG4gICAgICAgICAgICAgICAgICAgICAgbmV3U3RhdGUsXG4gICAgICAgICAgICAgICAgICAgICAgbmV4dFByb3BzXG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh1cGRhdGVMYW5lLm1vZGUgJiA4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgc2V0SXNTdHJpY3RNb2RlRm9yRGV2dG9vbHMoITApO1xuICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJ0aWFsU3RhdGUuY2FsbChpbnN0YW5jZSwgbmV3U3RhdGUsIG5leHRQcm9wcyk7XG4gICAgICAgICAgICAgICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNldElzU3RyaWN0TW9kZUZvckRldnRvb2xzKCExKTtcbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaXNEaXNhbGxvd2VkQ29udGV4dFJlYWRJbkRFViA9ICExO1xuICAgICAgICAgICAgICAgICAgICBuZXdTdGF0ZSA9IG5leHRTdGF0ZTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWsgYTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIG5ld1N0YXRlID0gcGFydGlhbFN0YXRlO1xuICAgICAgICAgICAgICAgICAgYnJlYWsgYTtcbiAgICAgICAgICAgICAgICBjYXNlIENhcHR1cmVVcGRhdGU6XG4gICAgICAgICAgICAgICAgICB1cGRhdGVMYW5lLmZsYWdzID0gKHVwZGF0ZUxhbmUuZmxhZ3MgJiAtNjU1MzcpIHwgMTI4O1xuICAgICAgICAgICAgICAgIGNhc2UgVXBkYXRlU3RhdGU6XG4gICAgICAgICAgICAgICAgICBuZXh0U3RhdGUgPSBwYXJ0aWFsU3RhdGUucGF5bG9hZDtcbiAgICAgICAgICAgICAgICAgIGlmIChcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBuZXh0U3RhdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgaXNEaXNhbGxvd2VkQ29udGV4dFJlYWRJbkRFViA9ICEwO1xuICAgICAgICAgICAgICAgICAgICBwYXJ0aWFsU3RhdGUgPSBuZXh0U3RhdGUuY2FsbChcbiAgICAgICAgICAgICAgICAgICAgICBpbnN0YW5jZSxcbiAgICAgICAgICAgICAgICAgICAgICBuZXdTdGF0ZSxcbiAgICAgICAgICAgICAgICAgICAgICBuZXh0UHJvcHNcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHVwZGF0ZUxhbmUubW9kZSAmIDgpIHtcbiAgICAgICAgICAgICAgICAgICAgICBzZXRJc1N0cmljdE1vZGVGb3JEZXZ0b29scyghMCk7XG4gICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5leHRTdGF0ZS5jYWxsKGluc3RhbmNlLCBuZXdTdGF0ZSwgbmV4dFByb3BzKTtcbiAgICAgICAgICAgICAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2V0SXNTdHJpY3RNb2RlRm9yRGV2dG9vbHMoITEpO1xuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpc0Rpc2FsbG93ZWRDb250ZXh0UmVhZEluREVWID0gITE7XG4gICAgICAgICAgICAgICAgICB9IGVsc2UgcGFydGlhbFN0YXRlID0gbmV4dFN0YXRlO1xuICAgICAgICAgICAgICAgICAgaWYgKG51bGwgPT09IHBhcnRpYWxTdGF0ZSB8fCB2b2lkIDAgPT09IHBhcnRpYWxTdGF0ZSkgYnJlYWsgYTtcbiAgICAgICAgICAgICAgICAgIG5ld1N0YXRlID0gYXNzaWduKHt9LCBuZXdTdGF0ZSwgcGFydGlhbFN0YXRlKTtcbiAgICAgICAgICAgICAgICAgIGJyZWFrIGE7XG4gICAgICAgICAgICAgICAgY2FzZSBGb3JjZVVwZGF0ZTpcbiAgICAgICAgICAgICAgICAgIGhhc0ZvcmNlVXBkYXRlID0gITA7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHVwZGF0ZUxhbmUgPSBwZW5kaW5nUXVldWUuY2FsbGJhY2s7XG4gICAgICAgICAgICBudWxsICE9PSB1cGRhdGVMYW5lICYmXG4gICAgICAgICAgICAgICgod29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gNjQpLFxuICAgICAgICAgICAgICBpc0hpZGRlblVwZGF0ZSAmJiAod29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gODE5MiksXG4gICAgICAgICAgICAgIChpc0hpZGRlblVwZGF0ZSA9IHF1ZXVlLmNhbGxiYWNrcyksXG4gICAgICAgICAgICAgIG51bGwgPT09IGlzSGlkZGVuVXBkYXRlXG4gICAgICAgICAgICAgICAgPyAocXVldWUuY2FsbGJhY2tzID0gW3VwZGF0ZUxhbmVdKVxuICAgICAgICAgICAgICAgIDogaXNIaWRkZW5VcGRhdGUucHVzaCh1cGRhdGVMYW5lKSk7XG4gICAgICAgICAgfSBlbHNlXG4gICAgICAgICAgICAoaXNIaWRkZW5VcGRhdGUgPSB7XG4gICAgICAgICAgICAgIGxhbmU6IHVwZGF0ZUxhbmUsXG4gICAgICAgICAgICAgIHRhZzogcGVuZGluZ1F1ZXVlLnRhZyxcbiAgICAgICAgICAgICAgcGF5bG9hZDogcGVuZGluZ1F1ZXVlLnBheWxvYWQsXG4gICAgICAgICAgICAgIGNhbGxiYWNrOiBwZW5kaW5nUXVldWUuY2FsbGJhY2ssXG4gICAgICAgICAgICAgIG5leHQ6IG51bGxcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICBudWxsID09PSBjdXJyZW50XG4gICAgICAgICAgICAgICAgPyAoKGZpcnN0UGVuZGluZ1VwZGF0ZSA9IGN1cnJlbnQgPSBpc0hpZGRlblVwZGF0ZSksXG4gICAgICAgICAgICAgICAgICAobGFzdFBlbmRpbmdVcGRhdGUgPSBuZXdTdGF0ZSkpXG4gICAgICAgICAgICAgICAgOiAoY3VycmVudCA9IGN1cnJlbnQubmV4dCA9IGlzSGlkZGVuVXBkYXRlKSxcbiAgICAgICAgICAgICAgKGxhc3RCYXNlVXBkYXRlIHw9IHVwZGF0ZUxhbmUpO1xuICAgICAgICAgIHBlbmRpbmdRdWV1ZSA9IHBlbmRpbmdRdWV1ZS5uZXh0O1xuICAgICAgICAgIGlmIChudWxsID09PSBwZW5kaW5nUXVldWUpXG4gICAgICAgICAgICBpZiAoKChwZW5kaW5nUXVldWUgPSBxdWV1ZS5zaGFyZWQucGVuZGluZyksIG51bGwgPT09IHBlbmRpbmdRdWV1ZSkpXG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAoaXNIaWRkZW5VcGRhdGUgPSBwZW5kaW5nUXVldWUpLFxuICAgICAgICAgICAgICAgIChwZW5kaW5nUXVldWUgPSBpc0hpZGRlblVwZGF0ZS5uZXh0KSxcbiAgICAgICAgICAgICAgICAoaXNIaWRkZW5VcGRhdGUubmV4dCA9IG51bGwpLFxuICAgICAgICAgICAgICAgIChxdWV1ZS5sYXN0QmFzZVVwZGF0ZSA9IGlzSGlkZGVuVXBkYXRlKSxcbiAgICAgICAgICAgICAgICAocXVldWUuc2hhcmVkLnBlbmRpbmcgPSBudWxsKTtcbiAgICAgICAgfSB3aGlsZSAoMSk7XG4gICAgICAgIG51bGwgPT09IGN1cnJlbnQgJiYgKGxhc3RQZW5kaW5nVXBkYXRlID0gbmV3U3RhdGUpO1xuICAgICAgICBxdWV1ZS5iYXNlU3RhdGUgPSBsYXN0UGVuZGluZ1VwZGF0ZTtcbiAgICAgICAgcXVldWUuZmlyc3RCYXNlVXBkYXRlID0gZmlyc3RQZW5kaW5nVXBkYXRlO1xuICAgICAgICBxdWV1ZS5sYXN0QmFzZVVwZGF0ZSA9IGN1cnJlbnQ7XG4gICAgICAgIG51bGwgPT09IGZpcnN0QmFzZVVwZGF0ZSAmJiAocXVldWUuc2hhcmVkLmxhbmVzID0gMCk7XG4gICAgICAgIHdvcmtJblByb2dyZXNzUm9vdFNraXBwZWRMYW5lcyB8PSBsYXN0QmFzZVVwZGF0ZTtcbiAgICAgICAgd29ya0luUHJvZ3Jlc3MubGFuZXMgPSBsYXN0QmFzZVVwZGF0ZTtcbiAgICAgICAgd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZSA9IG5ld1N0YXRlO1xuICAgICAgfVxuICAgICAgY3VycmVudGx5UHJvY2Vzc2luZ1F1ZXVlID0gbnVsbDtcbiAgICB9XG4gICAgZnVuY3Rpb24gY2FsbENhbGxiYWNrKGNhbGxiYWNrLCBjb250ZXh0KSB7XG4gICAgICBpZiAoXCJmdW5jdGlvblwiICE9PSB0eXBlb2YgY2FsbGJhY2spXG4gICAgICAgIHRocm93IEVycm9yKFxuICAgICAgICAgIFwiSW52YWxpZCBhcmd1bWVudCBwYXNzZWQgYXMgY2FsbGJhY2suIEV4cGVjdGVkIGEgZnVuY3Rpb24uIEluc3RlYWQgcmVjZWl2ZWQ6IFwiICtcbiAgICAgICAgICAgIGNhbGxiYWNrXG4gICAgICAgICk7XG4gICAgICBjYWxsYmFjay5jYWxsKGNvbnRleHQpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjb21taXRIaWRkZW5DYWxsYmFja3ModXBkYXRlUXVldWUsIGNvbnRleHQpIHtcbiAgICAgIHZhciBoaWRkZW5DYWxsYmFja3MgPSB1cGRhdGVRdWV1ZS5zaGFyZWQuaGlkZGVuQ2FsbGJhY2tzO1xuICAgICAgaWYgKG51bGwgIT09IGhpZGRlbkNhbGxiYWNrcylcbiAgICAgICAgZm9yIChcbiAgICAgICAgICB1cGRhdGVRdWV1ZS5zaGFyZWQuaGlkZGVuQ2FsbGJhY2tzID0gbnVsbCwgdXBkYXRlUXVldWUgPSAwO1xuICAgICAgICAgIHVwZGF0ZVF1ZXVlIDwgaGlkZGVuQ2FsbGJhY2tzLmxlbmd0aDtcbiAgICAgICAgICB1cGRhdGVRdWV1ZSsrXG4gICAgICAgIClcbiAgICAgICAgICBjYWxsQ2FsbGJhY2soaGlkZGVuQ2FsbGJhY2tzW3VwZGF0ZVF1ZXVlXSwgY29udGV4dCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNvbW1pdENhbGxiYWNrcyh1cGRhdGVRdWV1ZSwgY29udGV4dCkge1xuICAgICAgdmFyIGNhbGxiYWNrcyA9IHVwZGF0ZVF1ZXVlLmNhbGxiYWNrcztcbiAgICAgIGlmIChudWxsICE9PSBjYWxsYmFja3MpXG4gICAgICAgIGZvciAoXG4gICAgICAgICAgdXBkYXRlUXVldWUuY2FsbGJhY2tzID0gbnVsbCwgdXBkYXRlUXVldWUgPSAwO1xuICAgICAgICAgIHVwZGF0ZVF1ZXVlIDwgY2FsbGJhY2tzLmxlbmd0aDtcbiAgICAgICAgICB1cGRhdGVRdWV1ZSsrXG4gICAgICAgIClcbiAgICAgICAgICBjYWxsQ2FsbGJhY2soY2FsbGJhY2tzW3VwZGF0ZVF1ZXVlXSwgY29udGV4dCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHNoYWxsb3dFcXVhbChvYmpBLCBvYmpCKSB7XG4gICAgICBpZiAob2JqZWN0SXMob2JqQSwgb2JqQikpIHJldHVybiAhMDtcbiAgICAgIGlmIChcbiAgICAgICAgXCJvYmplY3RcIiAhPT0gdHlwZW9mIG9iakEgfHxcbiAgICAgICAgbnVsbCA9PT0gb2JqQSB8fFxuICAgICAgICBcIm9iamVjdFwiICE9PSB0eXBlb2Ygb2JqQiB8fFxuICAgICAgICBudWxsID09PSBvYmpCXG4gICAgICApXG4gICAgICAgIHJldHVybiAhMTtcbiAgICAgIHZhciBrZXlzQSA9IE9iamVjdC5rZXlzKG9iakEpLFxuICAgICAgICBrZXlzQiA9IE9iamVjdC5rZXlzKG9iakIpO1xuICAgICAgaWYgKGtleXNBLmxlbmd0aCAhPT0ga2V5c0IubGVuZ3RoKSByZXR1cm4gITE7XG4gICAgICBmb3IgKGtleXNCID0gMDsga2V5c0IgPCBrZXlzQS5sZW5ndGg7IGtleXNCKyspIHtcbiAgICAgICAgdmFyIGN1cnJlbnRLZXkgPSBrZXlzQVtrZXlzQl07XG4gICAgICAgIGlmIChcbiAgICAgICAgICAhaGFzT3duUHJvcGVydHkuY2FsbChvYmpCLCBjdXJyZW50S2V5KSB8fFxuICAgICAgICAgICFvYmplY3RJcyhvYmpBW2N1cnJlbnRLZXldLCBvYmpCW2N1cnJlbnRLZXldKVxuICAgICAgICApXG4gICAgICAgICAgcmV0dXJuICExO1xuICAgICAgfVxuICAgICAgcmV0dXJuICEwO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjcmVhdGVUaGVuYWJsZVN0YXRlKCkge1xuICAgICAgcmV0dXJuIHsgZGlkV2FybkFib3V0VW5jYWNoZWRQcm9taXNlOiAhMSwgdGhlbmFibGVzOiBbXSB9O1xuICAgIH1cbiAgICBmdW5jdGlvbiBpc1RoZW5hYmxlUmVzb2x2ZWQodGhlbmFibGUpIHtcbiAgICAgIHRoZW5hYmxlID0gdGhlbmFibGUuc3RhdHVzO1xuICAgICAgcmV0dXJuIFwiZnVsZmlsbGVkXCIgPT09IHRoZW5hYmxlIHx8IFwicmVqZWN0ZWRcIiA9PT0gdGhlbmFibGU7XG4gICAgfVxuICAgIGZ1bmN0aW9uIG5vb3AkMSgpIHt9XG4gICAgZnVuY3Rpb24gdHJhY2tVc2VkVGhlbmFibGUodGhlbmFibGVTdGF0ZSwgdGhlbmFibGUsIGluZGV4KSB7XG4gICAgICBudWxsICE9PSBSZWFjdFNoYXJlZEludGVybmFscy5hY3RRdWV1ZSAmJlxuICAgICAgICAoUmVhY3RTaGFyZWRJbnRlcm5hbHMuZGlkVXNlUHJvbWlzZSA9ICEwKTtcbiAgICAgIHZhciB0cmFja2VkVGhlbmFibGVzID0gdGhlbmFibGVTdGF0ZS50aGVuYWJsZXM7XG4gICAgICBpbmRleCA9IHRyYWNrZWRUaGVuYWJsZXNbaW5kZXhdO1xuICAgICAgdm9pZCAwID09PSBpbmRleFxuICAgICAgICA/IHRyYWNrZWRUaGVuYWJsZXMucHVzaCh0aGVuYWJsZSlcbiAgICAgICAgOiBpbmRleCAhPT0gdGhlbmFibGUgJiZcbiAgICAgICAgICAodGhlbmFibGVTdGF0ZS5kaWRXYXJuQWJvdXRVbmNhY2hlZFByb21pc2UgfHxcbiAgICAgICAgICAgICgodGhlbmFibGVTdGF0ZS5kaWRXYXJuQWJvdXRVbmNhY2hlZFByb21pc2UgPSAhMCksXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICBcIkEgY29tcG9uZW50IHdhcyBzdXNwZW5kZWQgYnkgYW4gdW5jYWNoZWQgcHJvbWlzZS4gQ3JlYXRpbmcgcHJvbWlzZXMgaW5zaWRlIGEgQ2xpZW50IENvbXBvbmVudCBvciBob29rIGlzIG5vdCB5ZXQgc3VwcG9ydGVkLCBleGNlcHQgdmlhIGEgU3VzcGVuc2UtY29tcGF0aWJsZSBsaWJyYXJ5IG9yIGZyYW1ld29yay5cIlxuICAgICAgICAgICAgKSksXG4gICAgICAgICAgdGhlbmFibGUudGhlbihub29wJDEsIG5vb3AkMSksXG4gICAgICAgICAgKHRoZW5hYmxlID0gaW5kZXgpKTtcbiAgICAgIHN3aXRjaCAodGhlbmFibGUuc3RhdHVzKSB7XG4gICAgICAgIGNhc2UgXCJmdWxmaWxsZWRcIjpcbiAgICAgICAgICByZXR1cm4gdGhlbmFibGUudmFsdWU7XG4gICAgICAgIGNhc2UgXCJyZWplY3RlZFwiOlxuICAgICAgICAgIHRocm93IChcbiAgICAgICAgICAgICgodGhlbmFibGVTdGF0ZSA9IHRoZW5hYmxlLnJlYXNvbiksXG4gICAgICAgICAgICBjaGVja0lmVXNlV3JhcHBlZEluQXN5bmNDYXRjaCh0aGVuYWJsZVN0YXRlKSxcbiAgICAgICAgICAgIHRoZW5hYmxlU3RhdGUpXG4gICAgICAgICAgKTtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBpZiAoXCJzdHJpbmdcIiA9PT0gdHlwZW9mIHRoZW5hYmxlLnN0YXR1cylcbiAgICAgICAgICAgIHRoZW5hYmxlLnRoZW4obm9vcCQxLCBub29wJDEpO1xuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhlbmFibGVTdGF0ZSA9IHdvcmtJblByb2dyZXNzUm9vdDtcbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgbnVsbCAhPT0gdGhlbmFibGVTdGF0ZSAmJlxuICAgICAgICAgICAgICAxMDAgPCB0aGVuYWJsZVN0YXRlLnNoZWxsU3VzcGVuZENvdW50ZXJcbiAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXG4gICAgICAgICAgICAgICAgXCJhc3luYy9hd2FpdCBpcyBub3QgeWV0IHN1cHBvcnRlZCBpbiBDbGllbnQgQ29tcG9uZW50cywgb25seSBTZXJ2ZXIgQ29tcG9uZW50cy4gVGhpcyBlcnJvciBpcyBvZnRlbiBjYXVzZWQgYnkgYWNjaWRlbnRhbGx5IGFkZGluZyBgJ3VzZSBjbGllbnQnYCB0byBhIG1vZHVsZSB0aGF0IHdhcyBvcmlnaW5hbGx5IHdyaXR0ZW4gZm9yIHRoZSBzZXJ2ZXIuXCJcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIHRoZW5hYmxlU3RhdGUgPSB0aGVuYWJsZTtcbiAgICAgICAgICAgIHRoZW5hYmxlU3RhdGUuc3RhdHVzID0gXCJwZW5kaW5nXCI7XG4gICAgICAgICAgICB0aGVuYWJsZVN0YXRlLnRoZW4oXG4gICAgICAgICAgICAgIGZ1bmN0aW9uIChmdWxmaWxsZWRWYWx1ZSkge1xuICAgICAgICAgICAgICAgIGlmIChcInBlbmRpbmdcIiA9PT0gdGhlbmFibGUuc3RhdHVzKSB7XG4gICAgICAgICAgICAgICAgICB2YXIgZnVsZmlsbGVkVGhlbmFibGUgPSB0aGVuYWJsZTtcbiAgICAgICAgICAgICAgICAgIGZ1bGZpbGxlZFRoZW5hYmxlLnN0YXR1cyA9IFwiZnVsZmlsbGVkXCI7XG4gICAgICAgICAgICAgICAgICBmdWxmaWxsZWRUaGVuYWJsZS52YWx1ZSA9IGZ1bGZpbGxlZFZhbHVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgaWYgKFwicGVuZGluZ1wiID09PSB0aGVuYWJsZS5zdGF0dXMpIHtcbiAgICAgICAgICAgICAgICAgIHZhciByZWplY3RlZFRoZW5hYmxlID0gdGhlbmFibGU7XG4gICAgICAgICAgICAgICAgICByZWplY3RlZFRoZW5hYmxlLnN0YXR1cyA9IFwicmVqZWN0ZWRcIjtcbiAgICAgICAgICAgICAgICAgIHJlamVjdGVkVGhlbmFibGUucmVhc29uID0gZXJyb3I7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgICBzd2l0Y2ggKHRoZW5hYmxlLnN0YXR1cykge1xuICAgICAgICAgICAgY2FzZSBcImZ1bGZpbGxlZFwiOlxuICAgICAgICAgICAgICByZXR1cm4gdGhlbmFibGUudmFsdWU7XG4gICAgICAgICAgICBjYXNlIFwicmVqZWN0ZWRcIjpcbiAgICAgICAgICAgICAgdGhyb3cgKFxuICAgICAgICAgICAgICAgICgodGhlbmFibGVTdGF0ZSA9IHRoZW5hYmxlLnJlYXNvbiksXG4gICAgICAgICAgICAgICAgY2hlY2tJZlVzZVdyYXBwZWRJbkFzeW5jQ2F0Y2godGhlbmFibGVTdGF0ZSksXG4gICAgICAgICAgICAgICAgdGhlbmFibGVTdGF0ZSlcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgc3VzcGVuZGVkVGhlbmFibGUgPSB0aGVuYWJsZTtcbiAgICAgICAgICBuZWVkc1RvUmVzZXRTdXNwZW5kZWRUaGVuYWJsZURFViA9ICEwO1xuICAgICAgICAgIHRocm93IFN1c3BlbnNlRXhjZXB0aW9uO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBnZXRTdXNwZW5kZWRUaGVuYWJsZSgpIHtcbiAgICAgIGlmIChudWxsID09PSBzdXNwZW5kZWRUaGVuYWJsZSlcbiAgICAgICAgdGhyb3cgRXJyb3IoXG4gICAgICAgICAgXCJFeHBlY3RlZCBhIHN1c3BlbmRlZCB0aGVuYWJsZS4gVGhpcyBpcyBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuXCJcbiAgICAgICAgKTtcbiAgICAgIHZhciB0aGVuYWJsZSA9IHN1c3BlbmRlZFRoZW5hYmxlO1xuICAgICAgc3VzcGVuZGVkVGhlbmFibGUgPSBudWxsO1xuICAgICAgbmVlZHNUb1Jlc2V0U3VzcGVuZGVkVGhlbmFibGVERVYgPSAhMTtcbiAgICAgIHJldHVybiB0aGVuYWJsZTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY2hlY2tJZlVzZVdyYXBwZWRJbkFzeW5jQ2F0Y2gocmVqZWN0ZWRSZWFzb24pIHtcbiAgICAgIGlmIChyZWplY3RlZFJlYXNvbiA9PT0gU3VzcGVuc2VFeGNlcHRpb24pXG4gICAgICAgIHRocm93IEVycm9yKFxuICAgICAgICAgIFwiSG9va3MgYXJlIG5vdCBzdXBwb3J0ZWQgaW5zaWRlIGFuIGFzeW5jIGNvbXBvbmVudC4gVGhpcyBlcnJvciBpcyBvZnRlbiBjYXVzZWQgYnkgYWNjaWRlbnRhbGx5IGFkZGluZyBgJ3VzZSBjbGllbnQnYCB0byBhIG1vZHVsZSB0aGF0IHdhcyBvcmlnaW5hbGx5IHdyaXR0ZW4gZm9yIHRoZSBzZXJ2ZXIuXCJcbiAgICAgICAgKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcHVzaERlYnVnSW5mbyhkZWJ1Z0luZm8pIHtcbiAgICAgIHZhciBwcmV2aW91c0RlYnVnSW5mbyA9IGN1cnJlbnREZWJ1Z0luZm87XG4gICAgICBudWxsICE9IGRlYnVnSW5mbyAmJlxuICAgICAgICAoY3VycmVudERlYnVnSW5mbyA9XG4gICAgICAgICAgbnVsbCA9PT0gcHJldmlvdXNEZWJ1Z0luZm9cbiAgICAgICAgICAgID8gZGVidWdJbmZvXG4gICAgICAgICAgICA6IHByZXZpb3VzRGVidWdJbmZvLmNvbmNhdChkZWJ1Z0luZm8pKTtcbiAgICAgIHJldHVybiBwcmV2aW91c0RlYnVnSW5mbztcbiAgICB9XG4gICAgZnVuY3Rpb24gdmFsaWRhdGVGcmFnbWVudFByb3BzKGVsZW1lbnQsIGZpYmVyLCByZXR1cm5GaWJlcikge1xuICAgICAgZm9yICh2YXIga2V5cyA9IE9iamVjdC5rZXlzKGVsZW1lbnQucHJvcHMpLCBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGtleSA9IGtleXNbaV07XG4gICAgICAgIGlmIChcImNoaWxkcmVuXCIgIT09IGtleSAmJiBcImtleVwiICE9PSBrZXkpIHtcbiAgICAgICAgICBudWxsID09PSBmaWJlciAmJlxuICAgICAgICAgICAgKChmaWJlciA9IGNyZWF0ZUZpYmVyRnJvbUVsZW1lbnQoZWxlbWVudCwgcmV0dXJuRmliZXIubW9kZSwgMCkpLFxuICAgICAgICAgICAgKGZpYmVyLl9kZWJ1Z0luZm8gPSBjdXJyZW50RGVidWdJbmZvKSxcbiAgICAgICAgICAgIChmaWJlci5yZXR1cm4gPSByZXR1cm5GaWJlcikpO1xuICAgICAgICAgIHJ1bldpdGhGaWJlckluREVWKFxuICAgICAgICAgICAgZmliZXIsXG4gICAgICAgICAgICBmdW5jdGlvbiAoZXJyb3JlZEtleSkge1xuICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICAgIFwiSW52YWxpZCBwcm9wIGAlc2Agc3VwcGxpZWQgdG8gYFJlYWN0LkZyYWdtZW50YC4gUmVhY3QuRnJhZ21lbnQgY2FuIG9ubHkgaGF2ZSBga2V5YCBhbmQgYGNoaWxkcmVuYCBwcm9wcy5cIixcbiAgICAgICAgICAgICAgICBlcnJvcmVkS2V5XG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAga2V5XG4gICAgICAgICAgKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiB1bndyYXBUaGVuYWJsZSh0aGVuYWJsZSkge1xuICAgICAgdmFyIGluZGV4ID0gdGhlbmFibGVJbmRleENvdW50ZXIkMTtcbiAgICAgIHRoZW5hYmxlSW5kZXhDb3VudGVyJDEgKz0gMTtcbiAgICAgIG51bGwgPT09IHRoZW5hYmxlU3RhdGUkMSAmJiAodGhlbmFibGVTdGF0ZSQxID0gY3JlYXRlVGhlbmFibGVTdGF0ZSgpKTtcbiAgICAgIHJldHVybiB0cmFja1VzZWRUaGVuYWJsZSh0aGVuYWJsZVN0YXRlJDEsIHRoZW5hYmxlLCBpbmRleCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNvZXJjZVJlZih3b3JrSW5Qcm9ncmVzcywgZWxlbWVudCkge1xuICAgICAgZWxlbWVudCA9IGVsZW1lbnQucHJvcHMucmVmO1xuICAgICAgd29ya0luUHJvZ3Jlc3MucmVmID0gdm9pZCAwICE9PSBlbGVtZW50ID8gZWxlbWVudCA6IG51bGw7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHRocm93T25JbnZhbGlkT2JqZWN0VHlwZShyZXR1cm5GaWJlciwgbmV3Q2hpbGQpIHtcbiAgICAgIGlmIChuZXdDaGlsZC4kJHR5cGVvZiA9PT0gUkVBQ1RfTEVHQUNZX0VMRU1FTlRfVFlQRSlcbiAgICAgICAgdGhyb3cgRXJyb3IoXG4gICAgICAgICAgJ0EgUmVhY3QgRWxlbWVudCBmcm9tIGFuIG9sZGVyIHZlcnNpb24gb2YgUmVhY3Qgd2FzIHJlbmRlcmVkLiBUaGlzIGlzIG5vdCBzdXBwb3J0ZWQuIEl0IGNhbiBoYXBwZW4gaWY6XFxuLSBNdWx0aXBsZSBjb3BpZXMgb2YgdGhlIFwicmVhY3RcIiBwYWNrYWdlIGlzIHVzZWQuXFxuLSBBIGxpYnJhcnkgcHJlLWJ1bmRsZWQgYW4gb2xkIGNvcHkgb2YgXCJyZWFjdFwiIG9yIFwicmVhY3QvanN4LXJ1bnRpbWVcIi5cXG4tIEEgY29tcGlsZXIgdHJpZXMgdG8gXCJpbmxpbmVcIiBKU1ggaW5zdGVhZCBvZiB1c2luZyB0aGUgcnVudGltZS4nXG4gICAgICAgICk7XG4gICAgICByZXR1cm5GaWJlciA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChuZXdDaGlsZCk7XG4gICAgICB0aHJvdyBFcnJvcihcbiAgICAgICAgXCJPYmplY3RzIGFyZSBub3QgdmFsaWQgYXMgYSBSZWFjdCBjaGlsZCAoZm91bmQ6IFwiICtcbiAgICAgICAgICAoXCJbb2JqZWN0IE9iamVjdF1cIiA9PT0gcmV0dXJuRmliZXJcbiAgICAgICAgICAgID8gXCJvYmplY3Qgd2l0aCBrZXlzIHtcIiArIE9iamVjdC5rZXlzKG5ld0NoaWxkKS5qb2luKFwiLCBcIikgKyBcIn1cIlxuICAgICAgICAgICAgOiByZXR1cm5GaWJlcikgK1xuICAgICAgICAgIFwiKS4gSWYgeW91IG1lYW50IHRvIHJlbmRlciBhIGNvbGxlY3Rpb24gb2YgY2hpbGRyZW4sIHVzZSBhbiBhcnJheSBpbnN0ZWFkLlwiXG4gICAgICApO1xuICAgIH1cbiAgICBmdW5jdGlvbiB3YXJuT25GdW5jdGlvblR5cGUocmV0dXJuRmliZXIsIGludmFsaWRDaGlsZCkge1xuICAgICAgdmFyIHBhcmVudE5hbWUgPSBnZXRDb21wb25lbnROYW1lRnJvbUZpYmVyKHJldHVybkZpYmVyKSB8fCBcIkNvbXBvbmVudFwiO1xuICAgICAgb3duZXJIYXNGdW5jdGlvblR5cGVXYXJuaW5nW3BhcmVudE5hbWVdIHx8XG4gICAgICAgICgob3duZXJIYXNGdW5jdGlvblR5cGVXYXJuaW5nW3BhcmVudE5hbWVdID0gITApLFxuICAgICAgICAoaW52YWxpZENoaWxkID1cbiAgICAgICAgICBpbnZhbGlkQ2hpbGQuZGlzcGxheU5hbWUgfHwgaW52YWxpZENoaWxkLm5hbWUgfHwgXCJDb21wb25lbnRcIiksXG4gICAgICAgIDMgPT09IHJldHVybkZpYmVyLnRhZ1xuICAgICAgICAgID8gY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgXCJGdW5jdGlvbnMgYXJlIG5vdCB2YWxpZCBhcyBhIFJlYWN0IGNoaWxkLiBUaGlzIG1heSBoYXBwZW4gaWYgeW91IHJldHVybiAlcyBpbnN0ZWFkIG9mIDwlcyAvPiBmcm9tIHJlbmRlci4gT3IgbWF5YmUgeW91IG1lYW50IHRvIGNhbGwgdGhpcyBmdW5jdGlvbiByYXRoZXIgdGhhbiByZXR1cm4gaXQuXFxuICByb290LnJlbmRlciglcylcIixcbiAgICAgICAgICAgICAgaW52YWxpZENoaWxkLFxuICAgICAgICAgICAgICBpbnZhbGlkQ2hpbGQsXG4gICAgICAgICAgICAgIGludmFsaWRDaGlsZFxuICAgICAgICAgICAgKVxuICAgICAgICAgIDogY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgXCJGdW5jdGlvbnMgYXJlIG5vdCB2YWxpZCBhcyBhIFJlYWN0IGNoaWxkLiBUaGlzIG1heSBoYXBwZW4gaWYgeW91IHJldHVybiAlcyBpbnN0ZWFkIG9mIDwlcyAvPiBmcm9tIHJlbmRlci4gT3IgbWF5YmUgeW91IG1lYW50IHRvIGNhbGwgdGhpcyBmdW5jdGlvbiByYXRoZXIgdGhhbiByZXR1cm4gaXQuXFxuICA8JXM+eyVzfTwvJXM+XCIsXG4gICAgICAgICAgICAgIGludmFsaWRDaGlsZCxcbiAgICAgICAgICAgICAgaW52YWxpZENoaWxkLFxuICAgICAgICAgICAgICBwYXJlbnROYW1lLFxuICAgICAgICAgICAgICBpbnZhbGlkQ2hpbGQsXG4gICAgICAgICAgICAgIHBhcmVudE5hbWVcbiAgICAgICAgICAgICkpO1xuICAgIH1cbiAgICBmdW5jdGlvbiB3YXJuT25TeW1ib2xUeXBlKHJldHVybkZpYmVyLCBpbnZhbGlkQ2hpbGQpIHtcbiAgICAgIHZhciBwYXJlbnROYW1lID0gZ2V0Q29tcG9uZW50TmFtZUZyb21GaWJlcihyZXR1cm5GaWJlcikgfHwgXCJDb21wb25lbnRcIjtcbiAgICAgIG93bmVySGFzU3ltYm9sVHlwZVdhcm5pbmdbcGFyZW50TmFtZV0gfHxcbiAgICAgICAgKChvd25lckhhc1N5bWJvbFR5cGVXYXJuaW5nW3BhcmVudE5hbWVdID0gITApLFxuICAgICAgICAoaW52YWxpZENoaWxkID0gU3RyaW5nKGludmFsaWRDaGlsZCkpLFxuICAgICAgICAzID09PSByZXR1cm5GaWJlci50YWdcbiAgICAgICAgICA/IGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgIFwiU3ltYm9scyBhcmUgbm90IHZhbGlkIGFzIGEgUmVhY3QgY2hpbGQuXFxuICByb290LnJlbmRlciglcylcIixcbiAgICAgICAgICAgICAgaW52YWxpZENoaWxkXG4gICAgICAgICAgICApXG4gICAgICAgICAgOiBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICBcIlN5bWJvbHMgYXJlIG5vdCB2YWxpZCBhcyBhIFJlYWN0IGNoaWxkLlxcbiAgPCVzPiVzPC8lcz5cIixcbiAgICAgICAgICAgICAgcGFyZW50TmFtZSxcbiAgICAgICAgICAgICAgaW52YWxpZENoaWxkLFxuICAgICAgICAgICAgICBwYXJlbnROYW1lXG4gICAgICAgICAgICApKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY3JlYXRlQ2hpbGRSZWNvbmNpbGVyKHNob3VsZFRyYWNrU2lkZUVmZmVjdHMpIHtcbiAgICAgIGZ1bmN0aW9uIGRlbGV0ZUNoaWxkKHJldHVybkZpYmVyLCBjaGlsZFRvRGVsZXRlKSB7XG4gICAgICAgIGlmIChzaG91bGRUcmFja1NpZGVFZmZlY3RzKSB7XG4gICAgICAgICAgdmFyIGRlbGV0aW9ucyA9IHJldHVybkZpYmVyLmRlbGV0aW9ucztcbiAgICAgICAgICBudWxsID09PSBkZWxldGlvbnNcbiAgICAgICAgICAgID8gKChyZXR1cm5GaWJlci5kZWxldGlvbnMgPSBbY2hpbGRUb0RlbGV0ZV0pLFxuICAgICAgICAgICAgICAocmV0dXJuRmliZXIuZmxhZ3MgfD0gMTYpKVxuICAgICAgICAgICAgOiBkZWxldGlvbnMucHVzaChjaGlsZFRvRGVsZXRlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZnVuY3Rpb24gZGVsZXRlUmVtYWluaW5nQ2hpbGRyZW4ocmV0dXJuRmliZXIsIGN1cnJlbnRGaXJzdENoaWxkKSB7XG4gICAgICAgIGlmICghc2hvdWxkVHJhY2tTaWRlRWZmZWN0cykgcmV0dXJuIG51bGw7XG4gICAgICAgIGZvciAoOyBudWxsICE9PSBjdXJyZW50Rmlyc3RDaGlsZDsgKVxuICAgICAgICAgIGRlbGV0ZUNoaWxkKHJldHVybkZpYmVyLCBjdXJyZW50Rmlyc3RDaGlsZCksXG4gICAgICAgICAgICAoY3VycmVudEZpcnN0Q2hpbGQgPSBjdXJyZW50Rmlyc3RDaGlsZC5zaWJsaW5nKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBtYXBSZW1haW5pbmdDaGlsZHJlbihjdXJyZW50Rmlyc3RDaGlsZCkge1xuICAgICAgICBmb3IgKHZhciBleGlzdGluZ0NoaWxkcmVuID0gbmV3IE1hcCgpOyBudWxsICE9PSBjdXJyZW50Rmlyc3RDaGlsZDsgKVxuICAgICAgICAgIG51bGwgIT09IGN1cnJlbnRGaXJzdENoaWxkLmtleVxuICAgICAgICAgICAgPyBleGlzdGluZ0NoaWxkcmVuLnNldChjdXJyZW50Rmlyc3RDaGlsZC5rZXksIGN1cnJlbnRGaXJzdENoaWxkKVxuICAgICAgICAgICAgOiBleGlzdGluZ0NoaWxkcmVuLnNldChjdXJyZW50Rmlyc3RDaGlsZC5pbmRleCwgY3VycmVudEZpcnN0Q2hpbGQpLFxuICAgICAgICAgICAgKGN1cnJlbnRGaXJzdENoaWxkID0gY3VycmVudEZpcnN0Q2hpbGQuc2libGluZyk7XG4gICAgICAgIHJldHVybiBleGlzdGluZ0NoaWxkcmVuO1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gdXNlRmliZXIoZmliZXIsIHBlbmRpbmdQcm9wcykge1xuICAgICAgICBmaWJlciA9IGNyZWF0ZVdvcmtJblByb2dyZXNzKGZpYmVyLCBwZW5kaW5nUHJvcHMpO1xuICAgICAgICBmaWJlci5pbmRleCA9IDA7XG4gICAgICAgIGZpYmVyLnNpYmxpbmcgPSBudWxsO1xuICAgICAgICByZXR1cm4gZmliZXI7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBwbGFjZUNoaWxkKG5ld0ZpYmVyLCBsYXN0UGxhY2VkSW5kZXgsIG5ld0luZGV4KSB7XG4gICAgICAgIG5ld0ZpYmVyLmluZGV4ID0gbmV3SW5kZXg7XG4gICAgICAgIGlmICghc2hvdWxkVHJhY2tTaWRlRWZmZWN0cylcbiAgICAgICAgICByZXR1cm4gKG5ld0ZpYmVyLmZsYWdzIHw9IDEwNDg1NzYpLCBsYXN0UGxhY2VkSW5kZXg7XG4gICAgICAgIG5ld0luZGV4ID0gbmV3RmliZXIuYWx0ZXJuYXRlO1xuICAgICAgICBpZiAobnVsbCAhPT0gbmV3SW5kZXgpXG4gICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIChuZXdJbmRleCA9IG5ld0luZGV4LmluZGV4KSxcbiAgICAgICAgICAgIG5ld0luZGV4IDwgbGFzdFBsYWNlZEluZGV4XG4gICAgICAgICAgICAgID8gKChuZXdGaWJlci5mbGFncyB8PSAzMzU1NDQzNCksIGxhc3RQbGFjZWRJbmRleClcbiAgICAgICAgICAgICAgOiBuZXdJbmRleFxuICAgICAgICAgICk7XG4gICAgICAgIG5ld0ZpYmVyLmZsYWdzIHw9IDMzNTU0NDM0O1xuICAgICAgICByZXR1cm4gbGFzdFBsYWNlZEluZGV4O1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gcGxhY2VTaW5nbGVDaGlsZChuZXdGaWJlcikge1xuICAgICAgICBzaG91bGRUcmFja1NpZGVFZmZlY3RzICYmXG4gICAgICAgICAgbnVsbCA9PT0gbmV3RmliZXIuYWx0ZXJuYXRlICYmXG4gICAgICAgICAgKG5ld0ZpYmVyLmZsYWdzIHw9IDMzNTU0NDM0KTtcbiAgICAgICAgcmV0dXJuIG5ld0ZpYmVyO1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gdXBkYXRlVGV4dE5vZGUocmV0dXJuRmliZXIsIGN1cnJlbnQsIHRleHRDb250ZW50LCBsYW5lcykge1xuICAgICAgICBpZiAobnVsbCA9PT0gY3VycmVudCB8fCA2ICE9PSBjdXJyZW50LnRhZylcbiAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgKGN1cnJlbnQgPSBjcmVhdGVGaWJlckZyb21UZXh0KFxuICAgICAgICAgICAgICB0ZXh0Q29udGVudCxcbiAgICAgICAgICAgICAgcmV0dXJuRmliZXIubW9kZSxcbiAgICAgICAgICAgICAgbGFuZXNcbiAgICAgICAgICAgICkpLFxuICAgICAgICAgICAgKGN1cnJlbnQucmV0dXJuID0gcmV0dXJuRmliZXIpLFxuICAgICAgICAgICAgKGN1cnJlbnQuX2RlYnVnT3duZXIgPSByZXR1cm5GaWJlciksXG4gICAgICAgICAgICAoY3VycmVudC5fZGVidWdJbmZvID0gY3VycmVudERlYnVnSW5mbyksXG4gICAgICAgICAgICBjdXJyZW50XG4gICAgICAgICAgKTtcbiAgICAgICAgY3VycmVudCA9IHVzZUZpYmVyKGN1cnJlbnQsIHRleHRDb250ZW50KTtcbiAgICAgICAgY3VycmVudC5yZXR1cm4gPSByZXR1cm5GaWJlcjtcbiAgICAgICAgY3VycmVudC5fZGVidWdJbmZvID0gY3VycmVudERlYnVnSW5mbztcbiAgICAgICAgcmV0dXJuIGN1cnJlbnQ7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiB1cGRhdGVFbGVtZW50KHJldHVybkZpYmVyLCBjdXJyZW50LCBlbGVtZW50LCBsYW5lcykge1xuICAgICAgICB2YXIgZWxlbWVudFR5cGUgPSBlbGVtZW50LnR5cGU7XG4gICAgICAgIGlmIChlbGVtZW50VHlwZSA9PT0gUkVBQ1RfRlJBR01FTlRfVFlQRSlcbiAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgKGN1cnJlbnQgPSB1cGRhdGVGcmFnbWVudChcbiAgICAgICAgICAgICAgcmV0dXJuRmliZXIsXG4gICAgICAgICAgICAgIGN1cnJlbnQsXG4gICAgICAgICAgICAgIGVsZW1lbnQucHJvcHMuY2hpbGRyZW4sXG4gICAgICAgICAgICAgIGxhbmVzLFxuICAgICAgICAgICAgICBlbGVtZW50LmtleVxuICAgICAgICAgICAgKSksXG4gICAgICAgICAgICB2YWxpZGF0ZUZyYWdtZW50UHJvcHMoZWxlbWVudCwgY3VycmVudCwgcmV0dXJuRmliZXIpLFxuICAgICAgICAgICAgY3VycmVudFxuICAgICAgICAgICk7XG4gICAgICAgIGlmIChcbiAgICAgICAgICBudWxsICE9PSBjdXJyZW50ICYmXG4gICAgICAgICAgKGN1cnJlbnQuZWxlbWVudFR5cGUgPT09IGVsZW1lbnRUeXBlIHx8XG4gICAgICAgICAgICBpc0NvbXBhdGlibGVGYW1pbHlGb3JIb3RSZWxvYWRpbmcoY3VycmVudCwgZWxlbWVudCkgfHxcbiAgICAgICAgICAgIChcIm9iamVjdFwiID09PSB0eXBlb2YgZWxlbWVudFR5cGUgJiZcbiAgICAgICAgICAgICAgbnVsbCAhPT0gZWxlbWVudFR5cGUgJiZcbiAgICAgICAgICAgICAgZWxlbWVudFR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0xBWllfVFlQRSAmJlxuICAgICAgICAgICAgICBjYWxsTGF6eUluaXRJbkRFVihlbGVtZW50VHlwZSkgPT09IGN1cnJlbnQudHlwZSkpXG4gICAgICAgIClcbiAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgKGN1cnJlbnQgPSB1c2VGaWJlcihjdXJyZW50LCBlbGVtZW50LnByb3BzKSksXG4gICAgICAgICAgICBjb2VyY2VSZWYoY3VycmVudCwgZWxlbWVudCksXG4gICAgICAgICAgICAoY3VycmVudC5yZXR1cm4gPSByZXR1cm5GaWJlciksXG4gICAgICAgICAgICAoY3VycmVudC5fZGVidWdPd25lciA9IGVsZW1lbnQuX293bmVyKSxcbiAgICAgICAgICAgIChjdXJyZW50Ll9kZWJ1Z0luZm8gPSBjdXJyZW50RGVidWdJbmZvKSxcbiAgICAgICAgICAgIGN1cnJlbnRcbiAgICAgICAgICApO1xuICAgICAgICBjdXJyZW50ID0gY3JlYXRlRmliZXJGcm9tRWxlbWVudChlbGVtZW50LCByZXR1cm5GaWJlci5tb2RlLCBsYW5lcyk7XG4gICAgICAgIGNvZXJjZVJlZihjdXJyZW50LCBlbGVtZW50KTtcbiAgICAgICAgY3VycmVudC5yZXR1cm4gPSByZXR1cm5GaWJlcjtcbiAgICAgICAgY3VycmVudC5fZGVidWdJbmZvID0gY3VycmVudERlYnVnSW5mbztcbiAgICAgICAgcmV0dXJuIGN1cnJlbnQ7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiB1cGRhdGVQb3J0YWwocmV0dXJuRmliZXIsIGN1cnJlbnQsIHBvcnRhbCwgbGFuZXMpIHtcbiAgICAgICAgaWYgKFxuICAgICAgICAgIG51bGwgPT09IGN1cnJlbnQgfHxcbiAgICAgICAgICA0ICE9PSBjdXJyZW50LnRhZyB8fFxuICAgICAgICAgIGN1cnJlbnQuc3RhdGVOb2RlLmNvbnRhaW5lckluZm8gIT09IHBvcnRhbC5jb250YWluZXJJbmZvIHx8XG4gICAgICAgICAgY3VycmVudC5zdGF0ZU5vZGUuaW1wbGVtZW50YXRpb24gIT09IHBvcnRhbC5pbXBsZW1lbnRhdGlvblxuICAgICAgICApXG4gICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIChjdXJyZW50ID0gY3JlYXRlRmliZXJGcm9tUG9ydGFsKHBvcnRhbCwgcmV0dXJuRmliZXIubW9kZSwgbGFuZXMpKSxcbiAgICAgICAgICAgIChjdXJyZW50LnJldHVybiA9IHJldHVybkZpYmVyKSxcbiAgICAgICAgICAgIChjdXJyZW50Ll9kZWJ1Z0luZm8gPSBjdXJyZW50RGVidWdJbmZvKSxcbiAgICAgICAgICAgIGN1cnJlbnRcbiAgICAgICAgICApO1xuICAgICAgICBjdXJyZW50ID0gdXNlRmliZXIoY3VycmVudCwgcG9ydGFsLmNoaWxkcmVuIHx8IFtdKTtcbiAgICAgICAgY3VycmVudC5yZXR1cm4gPSByZXR1cm5GaWJlcjtcbiAgICAgICAgY3VycmVudC5fZGVidWdJbmZvID0gY3VycmVudERlYnVnSW5mbztcbiAgICAgICAgcmV0dXJuIGN1cnJlbnQ7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiB1cGRhdGVGcmFnbWVudChyZXR1cm5GaWJlciwgY3VycmVudCwgZnJhZ21lbnQsIGxhbmVzLCBrZXkpIHtcbiAgICAgICAgaWYgKG51bGwgPT09IGN1cnJlbnQgfHwgNyAhPT0gY3VycmVudC50YWcpXG4gICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIChjdXJyZW50ID0gY3JlYXRlRmliZXJGcm9tRnJhZ21lbnQoXG4gICAgICAgICAgICAgIGZyYWdtZW50LFxuICAgICAgICAgICAgICByZXR1cm5GaWJlci5tb2RlLFxuICAgICAgICAgICAgICBsYW5lcyxcbiAgICAgICAgICAgICAga2V5XG4gICAgICAgICAgICApKSxcbiAgICAgICAgICAgIChjdXJyZW50LnJldHVybiA9IHJldHVybkZpYmVyKSxcbiAgICAgICAgICAgIChjdXJyZW50Ll9kZWJ1Z093bmVyID0gcmV0dXJuRmliZXIpLFxuICAgICAgICAgICAgKGN1cnJlbnQuX2RlYnVnSW5mbyA9IGN1cnJlbnREZWJ1Z0luZm8pLFxuICAgICAgICAgICAgY3VycmVudFxuICAgICAgICAgICk7XG4gICAgICAgIGN1cnJlbnQgPSB1c2VGaWJlcihjdXJyZW50LCBmcmFnbWVudCk7XG4gICAgICAgIGN1cnJlbnQucmV0dXJuID0gcmV0dXJuRmliZXI7XG4gICAgICAgIGN1cnJlbnQuX2RlYnVnSW5mbyA9IGN1cnJlbnREZWJ1Z0luZm87XG4gICAgICAgIHJldHVybiBjdXJyZW50O1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gY3JlYXRlQ2hpbGQocmV0dXJuRmliZXIsIG5ld0NoaWxkLCBsYW5lcykge1xuICAgICAgICBpZiAoXG4gICAgICAgICAgKFwic3RyaW5nXCIgPT09IHR5cGVvZiBuZXdDaGlsZCAmJiBcIlwiICE9PSBuZXdDaGlsZCkgfHxcbiAgICAgICAgICBcIm51bWJlclwiID09PSB0eXBlb2YgbmV3Q2hpbGQgfHxcbiAgICAgICAgICBcImJpZ2ludFwiID09PSB0eXBlb2YgbmV3Q2hpbGRcbiAgICAgICAgKVxuICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAobmV3Q2hpbGQgPSBjcmVhdGVGaWJlckZyb21UZXh0KFxuICAgICAgICAgICAgICBcIlwiICsgbmV3Q2hpbGQsXG4gICAgICAgICAgICAgIHJldHVybkZpYmVyLm1vZGUsXG4gICAgICAgICAgICAgIGxhbmVzXG4gICAgICAgICAgICApKSxcbiAgICAgICAgICAgIChuZXdDaGlsZC5yZXR1cm4gPSByZXR1cm5GaWJlciksXG4gICAgICAgICAgICAobmV3Q2hpbGQuX2RlYnVnT3duZXIgPSByZXR1cm5GaWJlciksXG4gICAgICAgICAgICAobmV3Q2hpbGQuX2RlYnVnSW5mbyA9IGN1cnJlbnREZWJ1Z0luZm8pLFxuICAgICAgICAgICAgbmV3Q2hpbGRcbiAgICAgICAgICApO1xuICAgICAgICBpZiAoXCJvYmplY3RcIiA9PT0gdHlwZW9mIG5ld0NoaWxkICYmIG51bGwgIT09IG5ld0NoaWxkKSB7XG4gICAgICAgICAgc3dpdGNoIChuZXdDaGlsZC4kJHR5cGVvZikge1xuICAgICAgICAgICAgY2FzZSBSRUFDVF9FTEVNRU5UX1RZUEU6XG4gICAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAgICAgKGxhbmVzID0gY3JlYXRlRmliZXJGcm9tRWxlbWVudChcbiAgICAgICAgICAgICAgICAgIG5ld0NoaWxkLFxuICAgICAgICAgICAgICAgICAgcmV0dXJuRmliZXIubW9kZSxcbiAgICAgICAgICAgICAgICAgIGxhbmVzXG4gICAgICAgICAgICAgICAgKSksXG4gICAgICAgICAgICAgICAgY29lcmNlUmVmKGxhbmVzLCBuZXdDaGlsZCksXG4gICAgICAgICAgICAgICAgKGxhbmVzLnJldHVybiA9IHJldHVybkZpYmVyKSxcbiAgICAgICAgICAgICAgICAocmV0dXJuRmliZXIgPSBwdXNoRGVidWdJbmZvKG5ld0NoaWxkLl9kZWJ1Z0luZm8pKSxcbiAgICAgICAgICAgICAgICAobGFuZXMuX2RlYnVnSW5mbyA9IGN1cnJlbnREZWJ1Z0luZm8pLFxuICAgICAgICAgICAgICAgIChjdXJyZW50RGVidWdJbmZvID0gcmV0dXJuRmliZXIpLFxuICAgICAgICAgICAgICAgIGxhbmVzXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICBjYXNlIFJFQUNUX1BPUlRBTF9UWVBFOlxuICAgICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICAgIChuZXdDaGlsZCA9IGNyZWF0ZUZpYmVyRnJvbVBvcnRhbChcbiAgICAgICAgICAgICAgICAgIG5ld0NoaWxkLFxuICAgICAgICAgICAgICAgICAgcmV0dXJuRmliZXIubW9kZSxcbiAgICAgICAgICAgICAgICAgIGxhbmVzXG4gICAgICAgICAgICAgICAgKSksXG4gICAgICAgICAgICAgICAgKG5ld0NoaWxkLnJldHVybiA9IHJldHVybkZpYmVyKSxcbiAgICAgICAgICAgICAgICAobmV3Q2hpbGQuX2RlYnVnSW5mbyA9IGN1cnJlbnREZWJ1Z0luZm8pLFxuICAgICAgICAgICAgICAgIG5ld0NoaWxkXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICBjYXNlIFJFQUNUX0xBWllfVFlQRTpcbiAgICAgICAgICAgICAgdmFyIF9wcmV2RGVidWdJbmZvID0gcHVzaERlYnVnSW5mbyhuZXdDaGlsZC5fZGVidWdJbmZvKTtcbiAgICAgICAgICAgICAgbmV3Q2hpbGQgPSBjYWxsTGF6eUluaXRJbkRFVihuZXdDaGlsZCk7XG4gICAgICAgICAgICAgIHJldHVybkZpYmVyID0gY3JlYXRlQ2hpbGQocmV0dXJuRmliZXIsIG5ld0NoaWxkLCBsYW5lcyk7XG4gICAgICAgICAgICAgIGN1cnJlbnREZWJ1Z0luZm8gPSBfcHJldkRlYnVnSW5mbztcbiAgICAgICAgICAgICAgcmV0dXJuIHJldHVybkZpYmVyO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoaXNBcnJheUltcGwobmV3Q2hpbGQpIHx8IGdldEl0ZXJhdG9yRm4obmV3Q2hpbGQpKVxuICAgICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICAgKGxhbmVzID0gY3JlYXRlRmliZXJGcm9tRnJhZ21lbnQoXG4gICAgICAgICAgICAgICAgbmV3Q2hpbGQsXG4gICAgICAgICAgICAgICAgcmV0dXJuRmliZXIubW9kZSxcbiAgICAgICAgICAgICAgICBsYW5lcyxcbiAgICAgICAgICAgICAgICBudWxsXG4gICAgICAgICAgICAgICkpLFxuICAgICAgICAgICAgICAobGFuZXMucmV0dXJuID0gcmV0dXJuRmliZXIpLFxuICAgICAgICAgICAgICAobGFuZXMuX2RlYnVnT3duZXIgPSByZXR1cm5GaWJlciksXG4gICAgICAgICAgICAgIChyZXR1cm5GaWJlciA9IHB1c2hEZWJ1Z0luZm8obmV3Q2hpbGQuX2RlYnVnSW5mbykpLFxuICAgICAgICAgICAgICAobGFuZXMuX2RlYnVnSW5mbyA9IGN1cnJlbnREZWJ1Z0luZm8pLFxuICAgICAgICAgICAgICAoY3VycmVudERlYnVnSW5mbyA9IHJldHVybkZpYmVyKSxcbiAgICAgICAgICAgICAgbGFuZXNcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgaWYgKFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIG5ld0NoaWxkLnRoZW4pXG4gICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICAoX3ByZXZEZWJ1Z0luZm8gPSBwdXNoRGVidWdJbmZvKG5ld0NoaWxkLl9kZWJ1Z0luZm8pKSxcbiAgICAgICAgICAgICAgKHJldHVybkZpYmVyID0gY3JlYXRlQ2hpbGQoXG4gICAgICAgICAgICAgICAgcmV0dXJuRmliZXIsXG4gICAgICAgICAgICAgICAgdW53cmFwVGhlbmFibGUobmV3Q2hpbGQpLFxuICAgICAgICAgICAgICAgIGxhbmVzXG4gICAgICAgICAgICAgICkpLFxuICAgICAgICAgICAgICAoY3VycmVudERlYnVnSW5mbyA9IF9wcmV2RGVidWdJbmZvKSxcbiAgICAgICAgICAgICAgcmV0dXJuRmliZXJcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgaWYgKG5ld0NoaWxkLiQkdHlwZW9mID09PSBSRUFDVF9DT05URVhUX1RZUEUpXG4gICAgICAgICAgICByZXR1cm4gY3JlYXRlQ2hpbGQoXG4gICAgICAgICAgICAgIHJldHVybkZpYmVyLFxuICAgICAgICAgICAgICByZWFkQ29udGV4dER1cmluZ1JlY29uY2lsaWF0aW9uKHJldHVybkZpYmVyLCBuZXdDaGlsZCksXG4gICAgICAgICAgICAgIGxhbmVzXG4gICAgICAgICAgICApO1xuICAgICAgICAgIHRocm93T25JbnZhbGlkT2JqZWN0VHlwZShyZXR1cm5GaWJlciwgbmV3Q2hpbGQpO1xuICAgICAgICB9XG4gICAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIG5ld0NoaWxkICYmXG4gICAgICAgICAgd2Fybk9uRnVuY3Rpb25UeXBlKHJldHVybkZpYmVyLCBuZXdDaGlsZCk7XG4gICAgICAgIFwic3ltYm9sXCIgPT09IHR5cGVvZiBuZXdDaGlsZCAmJiB3YXJuT25TeW1ib2xUeXBlKHJldHVybkZpYmVyLCBuZXdDaGlsZCk7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gdXBkYXRlU2xvdChyZXR1cm5GaWJlciwgb2xkRmliZXIsIG5ld0NoaWxkLCBsYW5lcykge1xuICAgICAgICB2YXIga2V5ID0gbnVsbCAhPT0gb2xkRmliZXIgPyBvbGRGaWJlci5rZXkgOiBudWxsO1xuICAgICAgICBpZiAoXG4gICAgICAgICAgKFwic3RyaW5nXCIgPT09IHR5cGVvZiBuZXdDaGlsZCAmJiBcIlwiICE9PSBuZXdDaGlsZCkgfHxcbiAgICAgICAgICBcIm51bWJlclwiID09PSB0eXBlb2YgbmV3Q2hpbGQgfHxcbiAgICAgICAgICBcImJpZ2ludFwiID09PSB0eXBlb2YgbmV3Q2hpbGRcbiAgICAgICAgKVxuICAgICAgICAgIHJldHVybiBudWxsICE9PSBrZXlcbiAgICAgICAgICAgID8gbnVsbFxuICAgICAgICAgICAgOiB1cGRhdGVUZXh0Tm9kZShyZXR1cm5GaWJlciwgb2xkRmliZXIsIFwiXCIgKyBuZXdDaGlsZCwgbGFuZXMpO1xuICAgICAgICBpZiAoXCJvYmplY3RcIiA9PT0gdHlwZW9mIG5ld0NoaWxkICYmIG51bGwgIT09IG5ld0NoaWxkKSB7XG4gICAgICAgICAgc3dpdGNoIChuZXdDaGlsZC4kJHR5cGVvZikge1xuICAgICAgICAgICAgY2FzZSBSRUFDVF9FTEVNRU5UX1RZUEU6XG4gICAgICAgICAgICAgIHJldHVybiBuZXdDaGlsZC5rZXkgPT09IGtleVxuICAgICAgICAgICAgICAgID8gKChrZXkgPSBwdXNoRGVidWdJbmZvKG5ld0NoaWxkLl9kZWJ1Z0luZm8pKSxcbiAgICAgICAgICAgICAgICAgIChyZXR1cm5GaWJlciA9IHVwZGF0ZUVsZW1lbnQoXG4gICAgICAgICAgICAgICAgICAgIHJldHVybkZpYmVyLFxuICAgICAgICAgICAgICAgICAgICBvbGRGaWJlcixcbiAgICAgICAgICAgICAgICAgICAgbmV3Q2hpbGQsXG4gICAgICAgICAgICAgICAgICAgIGxhbmVzXG4gICAgICAgICAgICAgICAgICApKSxcbiAgICAgICAgICAgICAgICAgIChjdXJyZW50RGVidWdJbmZvID0ga2V5KSxcbiAgICAgICAgICAgICAgICAgIHJldHVybkZpYmVyKVxuICAgICAgICAgICAgICAgIDogbnVsbDtcbiAgICAgICAgICAgIGNhc2UgUkVBQ1RfUE9SVEFMX1RZUEU6XG4gICAgICAgICAgICAgIHJldHVybiBuZXdDaGlsZC5rZXkgPT09IGtleVxuICAgICAgICAgICAgICAgID8gdXBkYXRlUG9ydGFsKHJldHVybkZpYmVyLCBvbGRGaWJlciwgbmV3Q2hpbGQsIGxhbmVzKVxuICAgICAgICAgICAgICAgIDogbnVsbDtcbiAgICAgICAgICAgIGNhc2UgUkVBQ1RfTEFaWV9UWVBFOlxuICAgICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICAgIChrZXkgPSBwdXNoRGVidWdJbmZvKG5ld0NoaWxkLl9kZWJ1Z0luZm8pKSxcbiAgICAgICAgICAgICAgICAobmV3Q2hpbGQgPSBjYWxsTGF6eUluaXRJbkRFVihuZXdDaGlsZCkpLFxuICAgICAgICAgICAgICAgIChyZXR1cm5GaWJlciA9IHVwZGF0ZVNsb3QoXG4gICAgICAgICAgICAgICAgICByZXR1cm5GaWJlcixcbiAgICAgICAgICAgICAgICAgIG9sZEZpYmVyLFxuICAgICAgICAgICAgICAgICAgbmV3Q2hpbGQsXG4gICAgICAgICAgICAgICAgICBsYW5lc1xuICAgICAgICAgICAgICAgICkpLFxuICAgICAgICAgICAgICAgIChjdXJyZW50RGVidWdJbmZvID0ga2V5KSxcbiAgICAgICAgICAgICAgICByZXR1cm5GaWJlclxuICAgICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoaXNBcnJheUltcGwobmV3Q2hpbGQpIHx8IGdldEl0ZXJhdG9yRm4obmV3Q2hpbGQpKSB7XG4gICAgICAgICAgICBpZiAobnVsbCAhPT0ga2V5KSByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIGtleSA9IHB1c2hEZWJ1Z0luZm8obmV3Q2hpbGQuX2RlYnVnSW5mbyk7XG4gICAgICAgICAgICByZXR1cm5GaWJlciA9IHVwZGF0ZUZyYWdtZW50KFxuICAgICAgICAgICAgICByZXR1cm5GaWJlcixcbiAgICAgICAgICAgICAgb2xkRmliZXIsXG4gICAgICAgICAgICAgIG5ld0NoaWxkLFxuICAgICAgICAgICAgICBsYW5lcyxcbiAgICAgICAgICAgICAgbnVsbFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGN1cnJlbnREZWJ1Z0luZm8gPSBrZXk7XG4gICAgICAgICAgICByZXR1cm4gcmV0dXJuRmliZXI7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBuZXdDaGlsZC50aGVuKVxuICAgICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICAgKGtleSA9IHB1c2hEZWJ1Z0luZm8obmV3Q2hpbGQuX2RlYnVnSW5mbykpLFxuICAgICAgICAgICAgICAocmV0dXJuRmliZXIgPSB1cGRhdGVTbG90KFxuICAgICAgICAgICAgICAgIHJldHVybkZpYmVyLFxuICAgICAgICAgICAgICAgIG9sZEZpYmVyLFxuICAgICAgICAgICAgICAgIHVud3JhcFRoZW5hYmxlKG5ld0NoaWxkKSxcbiAgICAgICAgICAgICAgICBsYW5lc1xuICAgICAgICAgICAgICApKSxcbiAgICAgICAgICAgICAgKGN1cnJlbnREZWJ1Z0luZm8gPSBrZXkpLFxuICAgICAgICAgICAgICByZXR1cm5GaWJlclxuICAgICAgICAgICAgKTtcbiAgICAgICAgICBpZiAobmV3Q2hpbGQuJCR0eXBlb2YgPT09IFJFQUNUX0NPTlRFWFRfVFlQRSlcbiAgICAgICAgICAgIHJldHVybiB1cGRhdGVTbG90KFxuICAgICAgICAgICAgICByZXR1cm5GaWJlcixcbiAgICAgICAgICAgICAgb2xkRmliZXIsXG4gICAgICAgICAgICAgIHJlYWRDb250ZXh0RHVyaW5nUmVjb25jaWxpYXRpb24ocmV0dXJuRmliZXIsIG5ld0NoaWxkKSxcbiAgICAgICAgICAgICAgbGFuZXNcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgdGhyb3dPbkludmFsaWRPYmplY3RUeXBlKHJldHVybkZpYmVyLCBuZXdDaGlsZCk7XG4gICAgICAgIH1cbiAgICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgbmV3Q2hpbGQgJiZcbiAgICAgICAgICB3YXJuT25GdW5jdGlvblR5cGUocmV0dXJuRmliZXIsIG5ld0NoaWxkKTtcbiAgICAgICAgXCJzeW1ib2xcIiA9PT0gdHlwZW9mIG5ld0NoaWxkICYmIHdhcm5PblN5bWJvbFR5cGUocmV0dXJuRmliZXIsIG5ld0NoaWxkKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiB1cGRhdGVGcm9tTWFwKFxuICAgICAgICBleGlzdGluZ0NoaWxkcmVuLFxuICAgICAgICByZXR1cm5GaWJlcixcbiAgICAgICAgbmV3SWR4LFxuICAgICAgICBuZXdDaGlsZCxcbiAgICAgICAgbGFuZXNcbiAgICAgICkge1xuICAgICAgICBpZiAoXG4gICAgICAgICAgKFwic3RyaW5nXCIgPT09IHR5cGVvZiBuZXdDaGlsZCAmJiBcIlwiICE9PSBuZXdDaGlsZCkgfHxcbiAgICAgICAgICBcIm51bWJlclwiID09PSB0eXBlb2YgbmV3Q2hpbGQgfHxcbiAgICAgICAgICBcImJpZ2ludFwiID09PSB0eXBlb2YgbmV3Q2hpbGRcbiAgICAgICAgKVxuICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAoZXhpc3RpbmdDaGlsZHJlbiA9IGV4aXN0aW5nQ2hpbGRyZW4uZ2V0KG5ld0lkeCkgfHwgbnVsbCksXG4gICAgICAgICAgICB1cGRhdGVUZXh0Tm9kZShyZXR1cm5GaWJlciwgZXhpc3RpbmdDaGlsZHJlbiwgXCJcIiArIG5ld0NoaWxkLCBsYW5lcylcbiAgICAgICAgICApO1xuICAgICAgICBpZiAoXCJvYmplY3RcIiA9PT0gdHlwZW9mIG5ld0NoaWxkICYmIG51bGwgIT09IG5ld0NoaWxkKSB7XG4gICAgICAgICAgc3dpdGNoIChuZXdDaGlsZC4kJHR5cGVvZikge1xuICAgICAgICAgICAgY2FzZSBSRUFDVF9FTEVNRU5UX1RZUEU6XG4gICAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAgICAgKG5ld0lkeCA9XG4gICAgICAgICAgICAgICAgICBleGlzdGluZ0NoaWxkcmVuLmdldChcbiAgICAgICAgICAgICAgICAgICAgbnVsbCA9PT0gbmV3Q2hpbGQua2V5ID8gbmV3SWR4IDogbmV3Q2hpbGQua2V5XG4gICAgICAgICAgICAgICAgICApIHx8IG51bGwpLFxuICAgICAgICAgICAgICAgIChleGlzdGluZ0NoaWxkcmVuID0gcHVzaERlYnVnSW5mbyhuZXdDaGlsZC5fZGVidWdJbmZvKSksXG4gICAgICAgICAgICAgICAgKHJldHVybkZpYmVyID0gdXBkYXRlRWxlbWVudChcbiAgICAgICAgICAgICAgICAgIHJldHVybkZpYmVyLFxuICAgICAgICAgICAgICAgICAgbmV3SWR4LFxuICAgICAgICAgICAgICAgICAgbmV3Q2hpbGQsXG4gICAgICAgICAgICAgICAgICBsYW5lc1xuICAgICAgICAgICAgICAgICkpLFxuICAgICAgICAgICAgICAgIChjdXJyZW50RGVidWdJbmZvID0gZXhpc3RpbmdDaGlsZHJlbiksXG4gICAgICAgICAgICAgICAgcmV0dXJuRmliZXJcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGNhc2UgUkVBQ1RfUE9SVEFMX1RZUEU6XG4gICAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAgICAgKGV4aXN0aW5nQ2hpbGRyZW4gPVxuICAgICAgICAgICAgICAgICAgZXhpc3RpbmdDaGlsZHJlbi5nZXQoXG4gICAgICAgICAgICAgICAgICAgIG51bGwgPT09IG5ld0NoaWxkLmtleSA/IG5ld0lkeCA6IG5ld0NoaWxkLmtleVxuICAgICAgICAgICAgICAgICAgKSB8fCBudWxsKSxcbiAgICAgICAgICAgICAgICB1cGRhdGVQb3J0YWwocmV0dXJuRmliZXIsIGV4aXN0aW5nQ2hpbGRyZW4sIG5ld0NoaWxkLCBsYW5lcylcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGNhc2UgUkVBQ1RfTEFaWV9UWVBFOlxuICAgICAgICAgICAgICB2YXIgX3ByZXZEZWJ1Z0luZm83ID0gcHVzaERlYnVnSW5mbyhuZXdDaGlsZC5fZGVidWdJbmZvKTtcbiAgICAgICAgICAgICAgbmV3Q2hpbGQgPSBjYWxsTGF6eUluaXRJbkRFVihuZXdDaGlsZCk7XG4gICAgICAgICAgICAgIHJldHVybkZpYmVyID0gdXBkYXRlRnJvbU1hcChcbiAgICAgICAgICAgICAgICBleGlzdGluZ0NoaWxkcmVuLFxuICAgICAgICAgICAgICAgIHJldHVybkZpYmVyLFxuICAgICAgICAgICAgICAgIG5ld0lkeCxcbiAgICAgICAgICAgICAgICBuZXdDaGlsZCxcbiAgICAgICAgICAgICAgICBsYW5lc1xuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICBjdXJyZW50RGVidWdJbmZvID0gX3ByZXZEZWJ1Z0luZm83O1xuICAgICAgICAgICAgICByZXR1cm4gcmV0dXJuRmliZXI7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChpc0FycmF5SW1wbChuZXdDaGlsZCkgfHwgZ2V0SXRlcmF0b3JGbihuZXdDaGlsZCkpXG4gICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICAobmV3SWR4ID0gZXhpc3RpbmdDaGlsZHJlbi5nZXQobmV3SWR4KSB8fCBudWxsKSxcbiAgICAgICAgICAgICAgKGV4aXN0aW5nQ2hpbGRyZW4gPSBwdXNoRGVidWdJbmZvKG5ld0NoaWxkLl9kZWJ1Z0luZm8pKSxcbiAgICAgICAgICAgICAgKHJldHVybkZpYmVyID0gdXBkYXRlRnJhZ21lbnQoXG4gICAgICAgICAgICAgICAgcmV0dXJuRmliZXIsXG4gICAgICAgICAgICAgICAgbmV3SWR4LFxuICAgICAgICAgICAgICAgIG5ld0NoaWxkLFxuICAgICAgICAgICAgICAgIGxhbmVzLFxuICAgICAgICAgICAgICAgIG51bGxcbiAgICAgICAgICAgICAgKSksXG4gICAgICAgICAgICAgIChjdXJyZW50RGVidWdJbmZvID0gZXhpc3RpbmdDaGlsZHJlbiksXG4gICAgICAgICAgICAgIHJldHVybkZpYmVyXG4gICAgICAgICAgICApO1xuICAgICAgICAgIGlmIChcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBuZXdDaGlsZC50aGVuKVxuICAgICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICAgKF9wcmV2RGVidWdJbmZvNyA9IHB1c2hEZWJ1Z0luZm8obmV3Q2hpbGQuX2RlYnVnSW5mbykpLFxuICAgICAgICAgICAgICAocmV0dXJuRmliZXIgPSB1cGRhdGVGcm9tTWFwKFxuICAgICAgICAgICAgICAgIGV4aXN0aW5nQ2hpbGRyZW4sXG4gICAgICAgICAgICAgICAgcmV0dXJuRmliZXIsXG4gICAgICAgICAgICAgICAgbmV3SWR4LFxuICAgICAgICAgICAgICAgIHVud3JhcFRoZW5hYmxlKG5ld0NoaWxkKSxcbiAgICAgICAgICAgICAgICBsYW5lc1xuICAgICAgICAgICAgICApKSxcbiAgICAgICAgICAgICAgKGN1cnJlbnREZWJ1Z0luZm8gPSBfcHJldkRlYnVnSW5mbzcpLFxuICAgICAgICAgICAgICByZXR1cm5GaWJlclxuICAgICAgICAgICAgKTtcbiAgICAgICAgICBpZiAobmV3Q2hpbGQuJCR0eXBlb2YgPT09IFJFQUNUX0NPTlRFWFRfVFlQRSlcbiAgICAgICAgICAgIHJldHVybiB1cGRhdGVGcm9tTWFwKFxuICAgICAgICAgICAgICBleGlzdGluZ0NoaWxkcmVuLFxuICAgICAgICAgICAgICByZXR1cm5GaWJlcixcbiAgICAgICAgICAgICAgbmV3SWR4LFxuICAgICAgICAgICAgICByZWFkQ29udGV4dER1cmluZ1JlY29uY2lsaWF0aW9uKHJldHVybkZpYmVyLCBuZXdDaGlsZCksXG4gICAgICAgICAgICAgIGxhbmVzXG4gICAgICAgICAgICApO1xuICAgICAgICAgIHRocm93T25JbnZhbGlkT2JqZWN0VHlwZShyZXR1cm5GaWJlciwgbmV3Q2hpbGQpO1xuICAgICAgICB9XG4gICAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIG5ld0NoaWxkICYmXG4gICAgICAgICAgd2Fybk9uRnVuY3Rpb25UeXBlKHJldHVybkZpYmVyLCBuZXdDaGlsZCk7XG4gICAgICAgIFwic3ltYm9sXCIgPT09IHR5cGVvZiBuZXdDaGlsZCAmJiB3YXJuT25TeW1ib2xUeXBlKHJldHVybkZpYmVyLCBuZXdDaGlsZCk7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gd2Fybk9uSW52YWxpZEtleShyZXR1cm5GaWJlciwgd29ya0luUHJvZ3Jlc3MsIGNoaWxkLCBrbm93bktleXMpIHtcbiAgICAgICAgaWYgKFwib2JqZWN0XCIgIT09IHR5cGVvZiBjaGlsZCB8fCBudWxsID09PSBjaGlsZCkgcmV0dXJuIGtub3duS2V5cztcbiAgICAgICAgc3dpdGNoIChjaGlsZC4kJHR5cGVvZikge1xuICAgICAgICAgIGNhc2UgUkVBQ1RfRUxFTUVOVF9UWVBFOlxuICAgICAgICAgIGNhc2UgUkVBQ1RfUE9SVEFMX1RZUEU6XG4gICAgICAgICAgICB3YXJuRm9yTWlzc2luZ0tleShyZXR1cm5GaWJlciwgd29ya0luUHJvZ3Jlc3MsIGNoaWxkKTtcbiAgICAgICAgICAgIHZhciBrZXkgPSBjaGlsZC5rZXk7XG4gICAgICAgICAgICBpZiAoXCJzdHJpbmdcIiAhPT0gdHlwZW9mIGtleSkgYnJlYWs7XG4gICAgICAgICAgICBpZiAobnVsbCA9PT0ga25vd25LZXlzKSB7XG4gICAgICAgICAgICAgIGtub3duS2V5cyA9IG5ldyBTZXQoKTtcbiAgICAgICAgICAgICAga25vd25LZXlzLmFkZChrZXkpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICgha25vd25LZXlzLmhhcyhrZXkpKSB7XG4gICAgICAgICAgICAgIGtub3duS2V5cy5hZGQoa2V5KTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBydW5XaXRoRmliZXJJbkRFVih3b3JrSW5Qcm9ncmVzcywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICAgIFwiRW5jb3VudGVyZWQgdHdvIGNoaWxkcmVuIHdpdGggdGhlIHNhbWUga2V5LCBgJXNgLiBLZXlzIHNob3VsZCBiZSB1bmlxdWUgc28gdGhhdCBjb21wb25lbnRzIG1haW50YWluIHRoZWlyIGlkZW50aXR5IGFjcm9zcyB1cGRhdGVzLiBOb24tdW5pcXVlIGtleXMgbWF5IGNhdXNlIGNoaWxkcmVuIHRvIGJlIGR1cGxpY2F0ZWQgYW5kL29yIG9taXR0ZWQgXFx1MjAxNCB0aGUgYmVoYXZpb3IgaXMgdW5zdXBwb3J0ZWQgYW5kIGNvdWxkIGNoYW5nZSBpbiBhIGZ1dHVyZSB2ZXJzaW9uLlwiLFxuICAgICAgICAgICAgICAgIGtleVxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIFJFQUNUX0xBWllfVFlQRTpcbiAgICAgICAgICAgIChjaGlsZCA9IGNhbGxMYXp5SW5pdEluREVWKGNoaWxkKSksXG4gICAgICAgICAgICAgIHdhcm5PbkludmFsaWRLZXkocmV0dXJuRmliZXIsIHdvcmtJblByb2dyZXNzLCBjaGlsZCwga25vd25LZXlzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ga25vd25LZXlzO1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gcmVjb25jaWxlQ2hpbGRyZW5BcnJheShcbiAgICAgICAgcmV0dXJuRmliZXIsXG4gICAgICAgIGN1cnJlbnRGaXJzdENoaWxkLFxuICAgICAgICBuZXdDaGlsZHJlbixcbiAgICAgICAgbGFuZXNcbiAgICAgICkge1xuICAgICAgICBmb3IgKFxuICAgICAgICAgIHZhciBrbm93bktleXMgPSBudWxsLFxuICAgICAgICAgICAgcmVzdWx0aW5nRmlyc3RDaGlsZCA9IG51bGwsXG4gICAgICAgICAgICBwcmV2aW91c05ld0ZpYmVyID0gbnVsbCxcbiAgICAgICAgICAgIG9sZEZpYmVyID0gY3VycmVudEZpcnN0Q2hpbGQsXG4gICAgICAgICAgICBuZXdJZHggPSAoY3VycmVudEZpcnN0Q2hpbGQgPSAwKSxcbiAgICAgICAgICAgIG5leHRPbGRGaWJlciA9IG51bGw7XG4gICAgICAgICAgbnVsbCAhPT0gb2xkRmliZXIgJiYgbmV3SWR4IDwgbmV3Q2hpbGRyZW4ubGVuZ3RoO1xuICAgICAgICAgIG5ld0lkeCsrXG4gICAgICAgICkge1xuICAgICAgICAgIG9sZEZpYmVyLmluZGV4ID4gbmV3SWR4XG4gICAgICAgICAgICA/ICgobmV4dE9sZEZpYmVyID0gb2xkRmliZXIpLCAob2xkRmliZXIgPSBudWxsKSlcbiAgICAgICAgICAgIDogKG5leHRPbGRGaWJlciA9IG9sZEZpYmVyLnNpYmxpbmcpO1xuICAgICAgICAgIHZhciBuZXdGaWJlciA9IHVwZGF0ZVNsb3QoXG4gICAgICAgICAgICByZXR1cm5GaWJlcixcbiAgICAgICAgICAgIG9sZEZpYmVyLFxuICAgICAgICAgICAgbmV3Q2hpbGRyZW5bbmV3SWR4XSxcbiAgICAgICAgICAgIGxhbmVzXG4gICAgICAgICAgKTtcbiAgICAgICAgICBpZiAobnVsbCA9PT0gbmV3RmliZXIpIHtcbiAgICAgICAgICAgIG51bGwgPT09IG9sZEZpYmVyICYmIChvbGRGaWJlciA9IG5leHRPbGRGaWJlcik7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAga25vd25LZXlzID0gd2Fybk9uSW52YWxpZEtleShcbiAgICAgICAgICAgIHJldHVybkZpYmVyLFxuICAgICAgICAgICAgbmV3RmliZXIsXG4gICAgICAgICAgICBuZXdDaGlsZHJlbltuZXdJZHhdLFxuICAgICAgICAgICAga25vd25LZXlzXG4gICAgICAgICAgKTtcbiAgICAgICAgICBzaG91bGRUcmFja1NpZGVFZmZlY3RzICYmXG4gICAgICAgICAgICBvbGRGaWJlciAmJlxuICAgICAgICAgICAgbnVsbCA9PT0gbmV3RmliZXIuYWx0ZXJuYXRlICYmXG4gICAgICAgICAgICBkZWxldGVDaGlsZChyZXR1cm5GaWJlciwgb2xkRmliZXIpO1xuICAgICAgICAgIGN1cnJlbnRGaXJzdENoaWxkID0gcGxhY2VDaGlsZChuZXdGaWJlciwgY3VycmVudEZpcnN0Q2hpbGQsIG5ld0lkeCk7XG4gICAgICAgICAgbnVsbCA9PT0gcHJldmlvdXNOZXdGaWJlclxuICAgICAgICAgICAgPyAocmVzdWx0aW5nRmlyc3RDaGlsZCA9IG5ld0ZpYmVyKVxuICAgICAgICAgICAgOiAocHJldmlvdXNOZXdGaWJlci5zaWJsaW5nID0gbmV3RmliZXIpO1xuICAgICAgICAgIHByZXZpb3VzTmV3RmliZXIgPSBuZXdGaWJlcjtcbiAgICAgICAgICBvbGRGaWJlciA9IG5leHRPbGRGaWJlcjtcbiAgICAgICAgfVxuICAgICAgICBpZiAobmV3SWR4ID09PSBuZXdDaGlsZHJlbi5sZW5ndGgpXG4gICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIGRlbGV0ZVJlbWFpbmluZ0NoaWxkcmVuKHJldHVybkZpYmVyLCBvbGRGaWJlciksXG4gICAgICAgICAgICBpc0h5ZHJhdGluZyAmJiBwdXNoVHJlZUZvcmsocmV0dXJuRmliZXIsIG5ld0lkeCksXG4gICAgICAgICAgICByZXN1bHRpbmdGaXJzdENoaWxkXG4gICAgICAgICAgKTtcbiAgICAgICAgaWYgKG51bGwgPT09IG9sZEZpYmVyKSB7XG4gICAgICAgICAgZm9yICg7IG5ld0lkeCA8IG5ld0NoaWxkcmVuLmxlbmd0aDsgbmV3SWR4KyspXG4gICAgICAgICAgICAob2xkRmliZXIgPSBjcmVhdGVDaGlsZChyZXR1cm5GaWJlciwgbmV3Q2hpbGRyZW5bbmV3SWR4XSwgbGFuZXMpKSxcbiAgICAgICAgICAgICAgbnVsbCAhPT0gb2xkRmliZXIgJiZcbiAgICAgICAgICAgICAgICAoKGtub3duS2V5cyA9IHdhcm5PbkludmFsaWRLZXkoXG4gICAgICAgICAgICAgICAgICByZXR1cm5GaWJlcixcbiAgICAgICAgICAgICAgICAgIG9sZEZpYmVyLFxuICAgICAgICAgICAgICAgICAgbmV3Q2hpbGRyZW5bbmV3SWR4XSxcbiAgICAgICAgICAgICAgICAgIGtub3duS2V5c1xuICAgICAgICAgICAgICAgICkpLFxuICAgICAgICAgICAgICAgIChjdXJyZW50Rmlyc3RDaGlsZCA9IHBsYWNlQ2hpbGQoXG4gICAgICAgICAgICAgICAgICBvbGRGaWJlcixcbiAgICAgICAgICAgICAgICAgIGN1cnJlbnRGaXJzdENoaWxkLFxuICAgICAgICAgICAgICAgICAgbmV3SWR4XG4gICAgICAgICAgICAgICAgKSksXG4gICAgICAgICAgICAgICAgbnVsbCA9PT0gcHJldmlvdXNOZXdGaWJlclxuICAgICAgICAgICAgICAgICAgPyAocmVzdWx0aW5nRmlyc3RDaGlsZCA9IG9sZEZpYmVyKVxuICAgICAgICAgICAgICAgICAgOiAocHJldmlvdXNOZXdGaWJlci5zaWJsaW5nID0gb2xkRmliZXIpLFxuICAgICAgICAgICAgICAgIChwcmV2aW91c05ld0ZpYmVyID0gb2xkRmliZXIpKTtcbiAgICAgICAgICBpc0h5ZHJhdGluZyAmJiBwdXNoVHJlZUZvcmsocmV0dXJuRmliZXIsIG5ld0lkeCk7XG4gICAgICAgICAgcmV0dXJuIHJlc3VsdGluZ0ZpcnN0Q2hpbGQ7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChcbiAgICAgICAgICBvbGRGaWJlciA9IG1hcFJlbWFpbmluZ0NoaWxkcmVuKG9sZEZpYmVyKTtcbiAgICAgICAgICBuZXdJZHggPCBuZXdDaGlsZHJlbi5sZW5ndGg7XG4gICAgICAgICAgbmV3SWR4KytcbiAgICAgICAgKVxuICAgICAgICAgIChuZXh0T2xkRmliZXIgPSB1cGRhdGVGcm9tTWFwKFxuICAgICAgICAgICAgb2xkRmliZXIsXG4gICAgICAgICAgICByZXR1cm5GaWJlcixcbiAgICAgICAgICAgIG5ld0lkeCxcbiAgICAgICAgICAgIG5ld0NoaWxkcmVuW25ld0lkeF0sXG4gICAgICAgICAgICBsYW5lc1xuICAgICAgICAgICkpLFxuICAgICAgICAgICAgbnVsbCAhPT0gbmV4dE9sZEZpYmVyICYmXG4gICAgICAgICAgICAgICgoa25vd25LZXlzID0gd2Fybk9uSW52YWxpZEtleShcbiAgICAgICAgICAgICAgICByZXR1cm5GaWJlcixcbiAgICAgICAgICAgICAgICBuZXh0T2xkRmliZXIsXG4gICAgICAgICAgICAgICAgbmV3Q2hpbGRyZW5bbmV3SWR4XSxcbiAgICAgICAgICAgICAgICBrbm93bktleXNcbiAgICAgICAgICAgICAgKSksXG4gICAgICAgICAgICAgIHNob3VsZFRyYWNrU2lkZUVmZmVjdHMgJiZcbiAgICAgICAgICAgICAgICBudWxsICE9PSBuZXh0T2xkRmliZXIuYWx0ZXJuYXRlICYmXG4gICAgICAgICAgICAgICAgb2xkRmliZXIuZGVsZXRlKFxuICAgICAgICAgICAgICAgICAgbnVsbCA9PT0gbmV4dE9sZEZpYmVyLmtleSA/IG5ld0lkeCA6IG5leHRPbGRGaWJlci5rZXlcbiAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAoY3VycmVudEZpcnN0Q2hpbGQgPSBwbGFjZUNoaWxkKFxuICAgICAgICAgICAgICAgIG5leHRPbGRGaWJlcixcbiAgICAgICAgICAgICAgICBjdXJyZW50Rmlyc3RDaGlsZCxcbiAgICAgICAgICAgICAgICBuZXdJZHhcbiAgICAgICAgICAgICAgKSksXG4gICAgICAgICAgICAgIG51bGwgPT09IHByZXZpb3VzTmV3RmliZXJcbiAgICAgICAgICAgICAgICA/IChyZXN1bHRpbmdGaXJzdENoaWxkID0gbmV4dE9sZEZpYmVyKVxuICAgICAgICAgICAgICAgIDogKHByZXZpb3VzTmV3RmliZXIuc2libGluZyA9IG5leHRPbGRGaWJlciksXG4gICAgICAgICAgICAgIChwcmV2aW91c05ld0ZpYmVyID0gbmV4dE9sZEZpYmVyKSk7XG4gICAgICAgIHNob3VsZFRyYWNrU2lkZUVmZmVjdHMgJiZcbiAgICAgICAgICBvbGRGaWJlci5mb3JFYWNoKGZ1bmN0aW9uIChjaGlsZCkge1xuICAgICAgICAgICAgcmV0dXJuIGRlbGV0ZUNoaWxkKHJldHVybkZpYmVyLCBjaGlsZCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIGlzSHlkcmF0aW5nICYmIHB1c2hUcmVlRm9yayhyZXR1cm5GaWJlciwgbmV3SWR4KTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdGluZ0ZpcnN0Q2hpbGQ7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiByZWNvbmNpbGVDaGlsZHJlbkl0ZXJhdG9yKFxuICAgICAgICByZXR1cm5GaWJlcixcbiAgICAgICAgY3VycmVudEZpcnN0Q2hpbGQsXG4gICAgICAgIG5ld0NoaWxkcmVuLFxuICAgICAgICBsYW5lc1xuICAgICAgKSB7XG4gICAgICAgIGlmIChudWxsID09IG5ld0NoaWxkcmVuKVxuICAgICAgICAgIHRocm93IEVycm9yKFwiQW4gaXRlcmFibGUgb2JqZWN0IHByb3ZpZGVkIG5vIGl0ZXJhdG9yLlwiKTtcbiAgICAgICAgZm9yIChcbiAgICAgICAgICB2YXIgcmVzdWx0aW5nRmlyc3RDaGlsZCA9IG51bGwsXG4gICAgICAgICAgICBwcmV2aW91c05ld0ZpYmVyID0gbnVsbCxcbiAgICAgICAgICAgIG9sZEZpYmVyID0gY3VycmVudEZpcnN0Q2hpbGQsXG4gICAgICAgICAgICBuZXdJZHggPSAoY3VycmVudEZpcnN0Q2hpbGQgPSAwKSxcbiAgICAgICAgICAgIG5leHRPbGRGaWJlciA9IG51bGwsXG4gICAgICAgICAgICBrbm93bktleXMgPSBudWxsLFxuICAgICAgICAgICAgc3RlcCA9IG5ld0NoaWxkcmVuLm5leHQoKTtcbiAgICAgICAgICBudWxsICE9PSBvbGRGaWJlciAmJiAhc3RlcC5kb25lO1xuICAgICAgICAgIG5ld0lkeCsrLCBzdGVwID0gbmV3Q2hpbGRyZW4ubmV4dCgpXG4gICAgICAgICkge1xuICAgICAgICAgIG9sZEZpYmVyLmluZGV4ID4gbmV3SWR4XG4gICAgICAgICAgICA/ICgobmV4dE9sZEZpYmVyID0gb2xkRmliZXIpLCAob2xkRmliZXIgPSBudWxsKSlcbiAgICAgICAgICAgIDogKG5leHRPbGRGaWJlciA9IG9sZEZpYmVyLnNpYmxpbmcpO1xuICAgICAgICAgIHZhciBuZXdGaWJlciA9IHVwZGF0ZVNsb3QocmV0dXJuRmliZXIsIG9sZEZpYmVyLCBzdGVwLnZhbHVlLCBsYW5lcyk7XG4gICAgICAgICAgaWYgKG51bGwgPT09IG5ld0ZpYmVyKSB7XG4gICAgICAgICAgICBudWxsID09PSBvbGRGaWJlciAmJiAob2xkRmliZXIgPSBuZXh0T2xkRmliZXIpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGtub3duS2V5cyA9IHdhcm5PbkludmFsaWRLZXkoXG4gICAgICAgICAgICByZXR1cm5GaWJlcixcbiAgICAgICAgICAgIG5ld0ZpYmVyLFxuICAgICAgICAgICAgc3RlcC52YWx1ZSxcbiAgICAgICAgICAgIGtub3duS2V5c1xuICAgICAgICAgICk7XG4gICAgICAgICAgc2hvdWxkVHJhY2tTaWRlRWZmZWN0cyAmJlxuICAgICAgICAgICAgb2xkRmliZXIgJiZcbiAgICAgICAgICAgIG51bGwgPT09IG5ld0ZpYmVyLmFsdGVybmF0ZSAmJlxuICAgICAgICAgICAgZGVsZXRlQ2hpbGQocmV0dXJuRmliZXIsIG9sZEZpYmVyKTtcbiAgICAgICAgICBjdXJyZW50Rmlyc3RDaGlsZCA9IHBsYWNlQ2hpbGQobmV3RmliZXIsIGN1cnJlbnRGaXJzdENoaWxkLCBuZXdJZHgpO1xuICAgICAgICAgIG51bGwgPT09IHByZXZpb3VzTmV3RmliZXJcbiAgICAgICAgICAgID8gKHJlc3VsdGluZ0ZpcnN0Q2hpbGQgPSBuZXdGaWJlcilcbiAgICAgICAgICAgIDogKHByZXZpb3VzTmV3RmliZXIuc2libGluZyA9IG5ld0ZpYmVyKTtcbiAgICAgICAgICBwcmV2aW91c05ld0ZpYmVyID0gbmV3RmliZXI7XG4gICAgICAgICAgb2xkRmliZXIgPSBuZXh0T2xkRmliZXI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0ZXAuZG9uZSlcbiAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgZGVsZXRlUmVtYWluaW5nQ2hpbGRyZW4ocmV0dXJuRmliZXIsIG9sZEZpYmVyKSxcbiAgICAgICAgICAgIGlzSHlkcmF0aW5nICYmIHB1c2hUcmVlRm9yayhyZXR1cm5GaWJlciwgbmV3SWR4KSxcbiAgICAgICAgICAgIHJlc3VsdGluZ0ZpcnN0Q2hpbGRcbiAgICAgICAgICApO1xuICAgICAgICBpZiAobnVsbCA9PT0gb2xkRmliZXIpIHtcbiAgICAgICAgICBmb3IgKDsgIXN0ZXAuZG9uZTsgbmV3SWR4KyssIHN0ZXAgPSBuZXdDaGlsZHJlbi5uZXh0KCkpXG4gICAgICAgICAgICAob2xkRmliZXIgPSBjcmVhdGVDaGlsZChyZXR1cm5GaWJlciwgc3RlcC52YWx1ZSwgbGFuZXMpKSxcbiAgICAgICAgICAgICAgbnVsbCAhPT0gb2xkRmliZXIgJiZcbiAgICAgICAgICAgICAgICAoKGtub3duS2V5cyA9IHdhcm5PbkludmFsaWRLZXkoXG4gICAgICAgICAgICAgICAgICByZXR1cm5GaWJlcixcbiAgICAgICAgICAgICAgICAgIG9sZEZpYmVyLFxuICAgICAgICAgICAgICAgICAgc3RlcC52YWx1ZSxcbiAgICAgICAgICAgICAgICAgIGtub3duS2V5c1xuICAgICAgICAgICAgICAgICkpLFxuICAgICAgICAgICAgICAgIChjdXJyZW50Rmlyc3RDaGlsZCA9IHBsYWNlQ2hpbGQoXG4gICAgICAgICAgICAgICAgICBvbGRGaWJlcixcbiAgICAgICAgICAgICAgICAgIGN1cnJlbnRGaXJzdENoaWxkLFxuICAgICAgICAgICAgICAgICAgbmV3SWR4XG4gICAgICAgICAgICAgICAgKSksXG4gICAgICAgICAgICAgICAgbnVsbCA9PT0gcHJldmlvdXNOZXdGaWJlclxuICAgICAgICAgICAgICAgICAgPyAocmVzdWx0aW5nRmlyc3RDaGlsZCA9IG9sZEZpYmVyKVxuICAgICAgICAgICAgICAgICAgOiAocHJldmlvdXNOZXdGaWJlci5zaWJsaW5nID0gb2xkRmliZXIpLFxuICAgICAgICAgICAgICAgIChwcmV2aW91c05ld0ZpYmVyID0gb2xkRmliZXIpKTtcbiAgICAgICAgICBpc0h5ZHJhdGluZyAmJiBwdXNoVHJlZUZvcmsocmV0dXJuRmliZXIsIG5ld0lkeCk7XG4gICAgICAgICAgcmV0dXJuIHJlc3VsdGluZ0ZpcnN0Q2hpbGQ7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChcbiAgICAgICAgICBvbGRGaWJlciA9IG1hcFJlbWFpbmluZ0NoaWxkcmVuKG9sZEZpYmVyKTtcbiAgICAgICAgICAhc3RlcC5kb25lO1xuICAgICAgICAgIG5ld0lkeCsrLCBzdGVwID0gbmV3Q2hpbGRyZW4ubmV4dCgpXG4gICAgICAgIClcbiAgICAgICAgICAobmV4dE9sZEZpYmVyID0gdXBkYXRlRnJvbU1hcChcbiAgICAgICAgICAgIG9sZEZpYmVyLFxuICAgICAgICAgICAgcmV0dXJuRmliZXIsXG4gICAgICAgICAgICBuZXdJZHgsXG4gICAgICAgICAgICBzdGVwLnZhbHVlLFxuICAgICAgICAgICAgbGFuZXNcbiAgICAgICAgICApKSxcbiAgICAgICAgICAgIG51bGwgIT09IG5leHRPbGRGaWJlciAmJlxuICAgICAgICAgICAgICAoKGtub3duS2V5cyA9IHdhcm5PbkludmFsaWRLZXkoXG4gICAgICAgICAgICAgICAgcmV0dXJuRmliZXIsXG4gICAgICAgICAgICAgICAgbmV4dE9sZEZpYmVyLFxuICAgICAgICAgICAgICAgIHN0ZXAudmFsdWUsXG4gICAgICAgICAgICAgICAga25vd25LZXlzXG4gICAgICAgICAgICAgICkpLFxuICAgICAgICAgICAgICBzaG91bGRUcmFja1NpZGVFZmZlY3RzICYmXG4gICAgICAgICAgICAgICAgbnVsbCAhPT0gbmV4dE9sZEZpYmVyLmFsdGVybmF0ZSAmJlxuICAgICAgICAgICAgICAgIG9sZEZpYmVyLmRlbGV0ZShcbiAgICAgICAgICAgICAgICAgIG51bGwgPT09IG5leHRPbGRGaWJlci5rZXkgPyBuZXdJZHggOiBuZXh0T2xkRmliZXIua2V5XG4gICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgKGN1cnJlbnRGaXJzdENoaWxkID0gcGxhY2VDaGlsZChcbiAgICAgICAgICAgICAgICBuZXh0T2xkRmliZXIsXG4gICAgICAgICAgICAgICAgY3VycmVudEZpcnN0Q2hpbGQsXG4gICAgICAgICAgICAgICAgbmV3SWR4XG4gICAgICAgICAgICAgICkpLFxuICAgICAgICAgICAgICBudWxsID09PSBwcmV2aW91c05ld0ZpYmVyXG4gICAgICAgICAgICAgICAgPyAocmVzdWx0aW5nRmlyc3RDaGlsZCA9IG5leHRPbGRGaWJlcilcbiAgICAgICAgICAgICAgICA6IChwcmV2aW91c05ld0ZpYmVyLnNpYmxpbmcgPSBuZXh0T2xkRmliZXIpLFxuICAgICAgICAgICAgICAocHJldmlvdXNOZXdGaWJlciA9IG5leHRPbGRGaWJlcikpO1xuICAgICAgICBzaG91bGRUcmFja1NpZGVFZmZlY3RzICYmXG4gICAgICAgICAgb2xkRmliZXIuZm9yRWFjaChmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICAgICAgICAgIHJldHVybiBkZWxldGVDaGlsZChyZXR1cm5GaWJlciwgY2hpbGQpO1xuICAgICAgICAgIH0pO1xuICAgICAgICBpc0h5ZHJhdGluZyAmJiBwdXNoVHJlZUZvcmsocmV0dXJuRmliZXIsIG5ld0lkeCk7XG4gICAgICAgIHJldHVybiByZXN1bHRpbmdGaXJzdENoaWxkO1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gcmVjb25jaWxlQ2hpbGRGaWJlcnNJbXBsKFxuICAgICAgICByZXR1cm5GaWJlcixcbiAgICAgICAgY3VycmVudEZpcnN0Q2hpbGQsXG4gICAgICAgIG5ld0NoaWxkLFxuICAgICAgICBsYW5lc1xuICAgICAgKSB7XG4gICAgICAgIFwib2JqZWN0XCIgPT09IHR5cGVvZiBuZXdDaGlsZCAmJlxuICAgICAgICAgIG51bGwgIT09IG5ld0NoaWxkICYmXG4gICAgICAgICAgbmV3Q2hpbGQudHlwZSA9PT0gUkVBQ1RfRlJBR01FTlRfVFlQRSAmJlxuICAgICAgICAgIG51bGwgPT09IG5ld0NoaWxkLmtleSAmJlxuICAgICAgICAgICh2YWxpZGF0ZUZyYWdtZW50UHJvcHMobmV3Q2hpbGQsIG51bGwsIHJldHVybkZpYmVyKSxcbiAgICAgICAgICAobmV3Q2hpbGQgPSBuZXdDaGlsZC5wcm9wcy5jaGlsZHJlbikpO1xuICAgICAgICBpZiAoXCJvYmplY3RcIiA9PT0gdHlwZW9mIG5ld0NoaWxkICYmIG51bGwgIT09IG5ld0NoaWxkKSB7XG4gICAgICAgICAgc3dpdGNoIChuZXdDaGlsZC4kJHR5cGVvZikge1xuICAgICAgICAgICAgY2FzZSBSRUFDVF9FTEVNRU5UX1RZUEU6XG4gICAgICAgICAgICAgIHZhciBwcmV2RGVidWdJbmZvID0gcHVzaERlYnVnSW5mbyhuZXdDaGlsZC5fZGVidWdJbmZvKTtcbiAgICAgICAgICAgICAgYToge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGtleSA9IG5ld0NoaWxkLmtleTsgbnVsbCAhPT0gY3VycmVudEZpcnN0Q2hpbGQ7ICkge1xuICAgICAgICAgICAgICAgICAgaWYgKGN1cnJlbnRGaXJzdENoaWxkLmtleSA9PT0ga2V5KSB7XG4gICAgICAgICAgICAgICAgICAgIGtleSA9IG5ld0NoaWxkLnR5cGU7XG4gICAgICAgICAgICAgICAgICAgIGlmIChrZXkgPT09IFJFQUNUX0ZSQUdNRU5UX1RZUEUpIHtcbiAgICAgICAgICAgICAgICAgICAgICBpZiAoNyA9PT0gY3VycmVudEZpcnN0Q2hpbGQudGFnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWxldGVSZW1haW5pbmdDaGlsZHJlbihcbiAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuRmliZXIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRGaXJzdENoaWxkLnNpYmxpbmdcbiAgICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgICAgICBsYW5lcyA9IHVzZUZpYmVyKFxuICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50Rmlyc3RDaGlsZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3Q2hpbGQucHJvcHMuY2hpbGRyZW5cbiAgICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgICAgICBsYW5lcy5yZXR1cm4gPSByZXR1cm5GaWJlcjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxhbmVzLl9kZWJ1Z093bmVyID0gbmV3Q2hpbGQuX293bmVyO1xuICAgICAgICAgICAgICAgICAgICAgICAgbGFuZXMuX2RlYnVnSW5mbyA9IGN1cnJlbnREZWJ1Z0luZm87XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWxpZGF0ZUZyYWdtZW50UHJvcHMobmV3Q2hpbGQsIGxhbmVzLCByZXR1cm5GaWJlcik7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm5GaWJlciA9IGxhbmVzO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWsgYTtcbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoXG4gICAgICAgICAgICAgICAgICAgICAgY3VycmVudEZpcnN0Q2hpbGQuZWxlbWVudFR5cGUgPT09IGtleSB8fFxuICAgICAgICAgICAgICAgICAgICAgIGlzQ29tcGF0aWJsZUZhbWlseUZvckhvdFJlbG9hZGluZyhcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRGaXJzdENoaWxkLFxuICAgICAgICAgICAgICAgICAgICAgICAgbmV3Q2hpbGRcbiAgICAgICAgICAgICAgICAgICAgICApIHx8XG4gICAgICAgICAgICAgICAgICAgICAgKFwib2JqZWN0XCIgPT09IHR5cGVvZiBrZXkgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIG51bGwgIT09IGtleSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAga2V5LiQkdHlwZW9mID09PSBSRUFDVF9MQVpZX1RZUEUgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxMYXp5SW5pdEluREVWKGtleSkgPT09IGN1cnJlbnRGaXJzdENoaWxkLnR5cGUpXG4gICAgICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZVJlbWFpbmluZ0NoaWxkcmVuKFxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuRmliZXIsXG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50Rmlyc3RDaGlsZC5zaWJsaW5nXG4gICAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgICBsYW5lcyA9IHVzZUZpYmVyKGN1cnJlbnRGaXJzdENoaWxkLCBuZXdDaGlsZC5wcm9wcyk7XG4gICAgICAgICAgICAgICAgICAgICAgY29lcmNlUmVmKGxhbmVzLCBuZXdDaGlsZCk7XG4gICAgICAgICAgICAgICAgICAgICAgbGFuZXMucmV0dXJuID0gcmV0dXJuRmliZXI7XG4gICAgICAgICAgICAgICAgICAgICAgbGFuZXMuX2RlYnVnT3duZXIgPSBuZXdDaGlsZC5fb3duZXI7XG4gICAgICAgICAgICAgICAgICAgICAgbGFuZXMuX2RlYnVnSW5mbyA9IGN1cnJlbnREZWJ1Z0luZm87XG4gICAgICAgICAgICAgICAgICAgICAgcmV0dXJuRmliZXIgPSBsYW5lcztcbiAgICAgICAgICAgICAgICAgICAgICBicmVhayBhO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZVJlbWFpbmluZ0NoaWxkcmVuKHJldHVybkZpYmVyLCBjdXJyZW50Rmlyc3RDaGlsZCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgfSBlbHNlIGRlbGV0ZUNoaWxkKHJldHVybkZpYmVyLCBjdXJyZW50Rmlyc3RDaGlsZCk7XG4gICAgICAgICAgICAgICAgICBjdXJyZW50Rmlyc3RDaGlsZCA9IGN1cnJlbnRGaXJzdENoaWxkLnNpYmxpbmc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG5ld0NoaWxkLnR5cGUgPT09IFJFQUNUX0ZSQUdNRU5UX1RZUEVcbiAgICAgICAgICAgICAgICAgID8gKChsYW5lcyA9IGNyZWF0ZUZpYmVyRnJvbUZyYWdtZW50KFxuICAgICAgICAgICAgICAgICAgICAgIG5ld0NoaWxkLnByb3BzLmNoaWxkcmVuLFxuICAgICAgICAgICAgICAgICAgICAgIHJldHVybkZpYmVyLm1vZGUsXG4gICAgICAgICAgICAgICAgICAgICAgbGFuZXMsXG4gICAgICAgICAgICAgICAgICAgICAgbmV3Q2hpbGQua2V5XG4gICAgICAgICAgICAgICAgICAgICkpLFxuICAgICAgICAgICAgICAgICAgICAobGFuZXMucmV0dXJuID0gcmV0dXJuRmliZXIpLFxuICAgICAgICAgICAgICAgICAgICAobGFuZXMuX2RlYnVnT3duZXIgPSByZXR1cm5GaWJlciksXG4gICAgICAgICAgICAgICAgICAgIChsYW5lcy5fZGVidWdJbmZvID0gY3VycmVudERlYnVnSW5mbyksXG4gICAgICAgICAgICAgICAgICAgIHZhbGlkYXRlRnJhZ21lbnRQcm9wcyhuZXdDaGlsZCwgbGFuZXMsIHJldHVybkZpYmVyKSxcbiAgICAgICAgICAgICAgICAgICAgKHJldHVybkZpYmVyID0gbGFuZXMpKVxuICAgICAgICAgICAgICAgICAgOiAoKGxhbmVzID0gY3JlYXRlRmliZXJGcm9tRWxlbWVudChcbiAgICAgICAgICAgICAgICAgICAgICBuZXdDaGlsZCxcbiAgICAgICAgICAgICAgICAgICAgICByZXR1cm5GaWJlci5tb2RlLFxuICAgICAgICAgICAgICAgICAgICAgIGxhbmVzXG4gICAgICAgICAgICAgICAgICAgICkpLFxuICAgICAgICAgICAgICAgICAgICBjb2VyY2VSZWYobGFuZXMsIG5ld0NoaWxkKSxcbiAgICAgICAgICAgICAgICAgICAgKGxhbmVzLnJldHVybiA9IHJldHVybkZpYmVyKSxcbiAgICAgICAgICAgICAgICAgICAgKGxhbmVzLl9kZWJ1Z0luZm8gPSBjdXJyZW50RGVidWdJbmZvKSxcbiAgICAgICAgICAgICAgICAgICAgKHJldHVybkZpYmVyID0gbGFuZXMpKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm5GaWJlciA9IHBsYWNlU2luZ2xlQ2hpbGQocmV0dXJuRmliZXIpO1xuICAgICAgICAgICAgICBjdXJyZW50RGVidWdJbmZvID0gcHJldkRlYnVnSW5mbztcbiAgICAgICAgICAgICAgcmV0dXJuIHJldHVybkZpYmVyO1xuICAgICAgICAgICAgY2FzZSBSRUFDVF9QT1JUQUxfVFlQRTpcbiAgICAgICAgICAgICAgYToge1xuICAgICAgICAgICAgICAgIHByZXZEZWJ1Z0luZm8gPSBuZXdDaGlsZDtcbiAgICAgICAgICAgICAgICBmb3IgKFxuICAgICAgICAgICAgICAgICAgbmV3Q2hpbGQgPSBwcmV2RGVidWdJbmZvLmtleTtcbiAgICAgICAgICAgICAgICAgIG51bGwgIT09IGN1cnJlbnRGaXJzdENoaWxkO1xuXG4gICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICBpZiAoY3VycmVudEZpcnN0Q2hpbGQua2V5ID09PSBuZXdDaGlsZClcbiAgICAgICAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICAgICAgIDQgPT09IGN1cnJlbnRGaXJzdENoaWxkLnRhZyAmJlxuICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRGaXJzdENoaWxkLnN0YXRlTm9kZS5jb250YWluZXJJbmZvID09PVxuICAgICAgICAgICAgICAgICAgICAgICAgcHJldkRlYnVnSW5mby5jb250YWluZXJJbmZvICYmXG4gICAgICAgICAgICAgICAgICAgICAgY3VycmVudEZpcnN0Q2hpbGQuc3RhdGVOb2RlLmltcGxlbWVudGF0aW9uID09PVxuICAgICAgICAgICAgICAgICAgICAgICAgcHJldkRlYnVnSW5mby5pbXBsZW1lbnRhdGlvblxuICAgICAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgICBkZWxldGVSZW1haW5pbmdDaGlsZHJlbihcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybkZpYmVyLFxuICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudEZpcnN0Q2hpbGQuc2libGluZ1xuICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgICAgbGFuZXMgPSB1c2VGaWJlcihcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRGaXJzdENoaWxkLFxuICAgICAgICAgICAgICAgICAgICAgICAgcHJldkRlYnVnSW5mby5jaGlsZHJlbiB8fCBbXVxuICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgICAgbGFuZXMucmV0dXJuID0gcmV0dXJuRmliZXI7XG4gICAgICAgICAgICAgICAgICAgICAgcmV0dXJuRmliZXIgPSBsYW5lcztcbiAgICAgICAgICAgICAgICAgICAgICBicmVhayBhO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZVJlbWFpbmluZ0NoaWxkcmVuKHJldHVybkZpYmVyLCBjdXJyZW50Rmlyc3RDaGlsZCk7XG4gICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGVsc2UgZGVsZXRlQ2hpbGQocmV0dXJuRmliZXIsIGN1cnJlbnRGaXJzdENoaWxkKTtcbiAgICAgICAgICAgICAgICAgIGN1cnJlbnRGaXJzdENoaWxkID0gY3VycmVudEZpcnN0Q2hpbGQuc2libGluZztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbGFuZXMgPSBjcmVhdGVGaWJlckZyb21Qb3J0YWwoXG4gICAgICAgICAgICAgICAgICBwcmV2RGVidWdJbmZvLFxuICAgICAgICAgICAgICAgICAgcmV0dXJuRmliZXIubW9kZSxcbiAgICAgICAgICAgICAgICAgIGxhbmVzXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICBsYW5lcy5yZXR1cm4gPSByZXR1cm5GaWJlcjtcbiAgICAgICAgICAgICAgICByZXR1cm5GaWJlciA9IGxhbmVzO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJldHVybiBwbGFjZVNpbmdsZUNoaWxkKHJldHVybkZpYmVyKTtcbiAgICAgICAgICAgIGNhc2UgUkVBQ1RfTEFaWV9UWVBFOlxuICAgICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICAgIChwcmV2RGVidWdJbmZvID0gcHVzaERlYnVnSW5mbyhuZXdDaGlsZC5fZGVidWdJbmZvKSksXG4gICAgICAgICAgICAgICAgKG5ld0NoaWxkID0gY2FsbExhenlJbml0SW5ERVYobmV3Q2hpbGQpKSxcbiAgICAgICAgICAgICAgICAocmV0dXJuRmliZXIgPSByZWNvbmNpbGVDaGlsZEZpYmVyc0ltcGwoXG4gICAgICAgICAgICAgICAgICByZXR1cm5GaWJlcixcbiAgICAgICAgICAgICAgICAgIGN1cnJlbnRGaXJzdENoaWxkLFxuICAgICAgICAgICAgICAgICAgbmV3Q2hpbGQsXG4gICAgICAgICAgICAgICAgICBsYW5lc1xuICAgICAgICAgICAgICAgICkpLFxuICAgICAgICAgICAgICAgIChjdXJyZW50RGVidWdJbmZvID0gcHJldkRlYnVnSW5mbyksXG4gICAgICAgICAgICAgICAgcmV0dXJuRmliZXJcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGlzQXJyYXlJbXBsKG5ld0NoaWxkKSlcbiAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAgIChwcmV2RGVidWdJbmZvID0gcHVzaERlYnVnSW5mbyhuZXdDaGlsZC5fZGVidWdJbmZvKSksXG4gICAgICAgICAgICAgIChyZXR1cm5GaWJlciA9IHJlY29uY2lsZUNoaWxkcmVuQXJyYXkoXG4gICAgICAgICAgICAgICAgcmV0dXJuRmliZXIsXG4gICAgICAgICAgICAgICAgY3VycmVudEZpcnN0Q2hpbGQsXG4gICAgICAgICAgICAgICAgbmV3Q2hpbGQsXG4gICAgICAgICAgICAgICAgbGFuZXNcbiAgICAgICAgICAgICAgKSksXG4gICAgICAgICAgICAgIChjdXJyZW50RGVidWdJbmZvID0gcHJldkRlYnVnSW5mbyksXG4gICAgICAgICAgICAgIHJldHVybkZpYmVyXG4gICAgICAgICAgICApO1xuICAgICAgICAgIGlmIChnZXRJdGVyYXRvckZuKG5ld0NoaWxkKSkge1xuICAgICAgICAgICAgcHJldkRlYnVnSW5mbyA9IHB1c2hEZWJ1Z0luZm8obmV3Q2hpbGQuX2RlYnVnSW5mbyk7XG4gICAgICAgICAgICBrZXkgPSBnZXRJdGVyYXRvckZuKG5ld0NoaWxkKTtcbiAgICAgICAgICAgIGlmIChcImZ1bmN0aW9uXCIgIT09IHR5cGVvZiBrZXkpXG4gICAgICAgICAgICAgIHRocm93IEVycm9yKFxuICAgICAgICAgICAgICAgIFwiQW4gb2JqZWN0IGlzIG5vdCBhbiBpdGVyYWJsZS4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS5cIlxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgdmFyIG5ld0NoaWxkcmVuID0ga2V5LmNhbGwobmV3Q2hpbGQpO1xuICAgICAgICAgICAgaWYgKG5ld0NoaWxkcmVuID09PSBuZXdDaGlsZCkge1xuICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgMCAhPT0gcmV0dXJuRmliZXIudGFnIHx8XG4gICAgICAgICAgICAgICAgXCJbb2JqZWN0IEdlbmVyYXRvckZ1bmN0aW9uXVwiICE9PVxuICAgICAgICAgICAgICAgICAgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHJldHVybkZpYmVyLnR5cGUpIHx8XG4gICAgICAgICAgICAgICAgXCJbb2JqZWN0IEdlbmVyYXRvcl1cIiAhPT1cbiAgICAgICAgICAgICAgICAgIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChuZXdDaGlsZHJlbilcbiAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgIGRpZFdhcm5BYm91dEdlbmVyYXRvcnMgfHxcbiAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgICAgICAgIFwiVXNpbmcgSXRlcmF0b3JzIGFzIGNoaWxkcmVuIGlzIHVuc3VwcG9ydGVkIGFuZCB3aWxsIGxpa2VseSB5aWVsZCB1bmV4cGVjdGVkIHJlc3VsdHMgYmVjYXVzZSBlbnVtZXJhdGluZyBhIGdlbmVyYXRvciBtdXRhdGVzIGl0LiBZb3UgbWF5IGNvbnZlcnQgaXQgdG8gYW4gYXJyYXkgd2l0aCBgQXJyYXkuZnJvbSgpYCBvciB0aGUgYFsuLi5zcHJlYWRdYCBvcGVyYXRvciBiZWZvcmUgcmVuZGVyaW5nLiBZb3UgY2FuIGFsc28gdXNlIGFuIEl0ZXJhYmxlIHRoYXQgY2FuIGl0ZXJhdGUgbXVsdGlwbGUgdGltZXMgb3ZlciB0aGUgc2FtZSBpdGVtcy5cIlxuICAgICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICAgIChkaWRXYXJuQWJvdXRHZW5lcmF0b3JzID0gITApO1xuICAgICAgICAgICAgfSBlbHNlXG4gICAgICAgICAgICAgIG5ld0NoaWxkLmVudHJpZXMgIT09IGtleSB8fFxuICAgICAgICAgICAgICAgIGRpZFdhcm5BYm91dE1hcHMgfHxcbiAgICAgICAgICAgICAgICAoY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgICAgIFwiVXNpbmcgTWFwcyBhcyBjaGlsZHJlbiBpcyBub3Qgc3VwcG9ydGVkLiBVc2UgYW4gYXJyYXkgb2Yga2V5ZWQgUmVhY3RFbGVtZW50cyBpbnN0ZWFkLlwiXG4gICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICAoZGlkV2FybkFib3V0TWFwcyA9ICEwKSk7XG4gICAgICAgICAgICByZXR1cm5GaWJlciA9IHJlY29uY2lsZUNoaWxkcmVuSXRlcmF0b3IoXG4gICAgICAgICAgICAgIHJldHVybkZpYmVyLFxuICAgICAgICAgICAgICBjdXJyZW50Rmlyc3RDaGlsZCxcbiAgICAgICAgICAgICAgbmV3Q2hpbGRyZW4sXG4gICAgICAgICAgICAgIGxhbmVzXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgY3VycmVudERlYnVnSW5mbyA9IHByZXZEZWJ1Z0luZm87XG4gICAgICAgICAgICByZXR1cm4gcmV0dXJuRmliZXI7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBuZXdDaGlsZC50aGVuKVxuICAgICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICAgKHByZXZEZWJ1Z0luZm8gPSBwdXNoRGVidWdJbmZvKG5ld0NoaWxkLl9kZWJ1Z0luZm8pKSxcbiAgICAgICAgICAgICAgKHJldHVybkZpYmVyID0gcmVjb25jaWxlQ2hpbGRGaWJlcnNJbXBsKFxuICAgICAgICAgICAgICAgIHJldHVybkZpYmVyLFxuICAgICAgICAgICAgICAgIGN1cnJlbnRGaXJzdENoaWxkLFxuICAgICAgICAgICAgICAgIHVud3JhcFRoZW5hYmxlKG5ld0NoaWxkKSxcbiAgICAgICAgICAgICAgICBsYW5lc1xuICAgICAgICAgICAgICApKSxcbiAgICAgICAgICAgICAgKGN1cnJlbnREZWJ1Z0luZm8gPSBwcmV2RGVidWdJbmZvKSxcbiAgICAgICAgICAgICAgcmV0dXJuRmliZXJcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgaWYgKG5ld0NoaWxkLiQkdHlwZW9mID09PSBSRUFDVF9DT05URVhUX1RZUEUpXG4gICAgICAgICAgICByZXR1cm4gcmVjb25jaWxlQ2hpbGRGaWJlcnNJbXBsKFxuICAgICAgICAgICAgICByZXR1cm5GaWJlcixcbiAgICAgICAgICAgICAgY3VycmVudEZpcnN0Q2hpbGQsXG4gICAgICAgICAgICAgIHJlYWRDb250ZXh0RHVyaW5nUmVjb25jaWxpYXRpb24ocmV0dXJuRmliZXIsIG5ld0NoaWxkKSxcbiAgICAgICAgICAgICAgbGFuZXNcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgdGhyb3dPbkludmFsaWRPYmplY3RUeXBlKHJldHVybkZpYmVyLCBuZXdDaGlsZCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKFxuICAgICAgICAgIChcInN0cmluZ1wiID09PSB0eXBlb2YgbmV3Q2hpbGQgJiYgXCJcIiAhPT0gbmV3Q2hpbGQpIHx8XG4gICAgICAgICAgXCJudW1iZXJcIiA9PT0gdHlwZW9mIG5ld0NoaWxkIHx8XG4gICAgICAgICAgXCJiaWdpbnRcIiA9PT0gdHlwZW9mIG5ld0NoaWxkXG4gICAgICAgIClcbiAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgKHByZXZEZWJ1Z0luZm8gPSBcIlwiICsgbmV3Q2hpbGQpLFxuICAgICAgICAgICAgbnVsbCAhPT0gY3VycmVudEZpcnN0Q2hpbGQgJiYgNiA9PT0gY3VycmVudEZpcnN0Q2hpbGQudGFnXG4gICAgICAgICAgICAgID8gKGRlbGV0ZVJlbWFpbmluZ0NoaWxkcmVuKFxuICAgICAgICAgICAgICAgICAgcmV0dXJuRmliZXIsXG4gICAgICAgICAgICAgICAgICBjdXJyZW50Rmlyc3RDaGlsZC5zaWJsaW5nXG4gICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICAobGFuZXMgPSB1c2VGaWJlcihjdXJyZW50Rmlyc3RDaGlsZCwgcHJldkRlYnVnSW5mbykpLFxuICAgICAgICAgICAgICAgIChsYW5lcy5yZXR1cm4gPSByZXR1cm5GaWJlciksXG4gICAgICAgICAgICAgICAgKHJldHVybkZpYmVyID0gbGFuZXMpKVxuICAgICAgICAgICAgICA6IChkZWxldGVSZW1haW5pbmdDaGlsZHJlbihyZXR1cm5GaWJlciwgY3VycmVudEZpcnN0Q2hpbGQpLFxuICAgICAgICAgICAgICAgIChsYW5lcyA9IGNyZWF0ZUZpYmVyRnJvbVRleHQoXG4gICAgICAgICAgICAgICAgICBwcmV2RGVidWdJbmZvLFxuICAgICAgICAgICAgICAgICAgcmV0dXJuRmliZXIubW9kZSxcbiAgICAgICAgICAgICAgICAgIGxhbmVzXG4gICAgICAgICAgICAgICAgKSksXG4gICAgICAgICAgICAgICAgKGxhbmVzLnJldHVybiA9IHJldHVybkZpYmVyKSxcbiAgICAgICAgICAgICAgICAobGFuZXMuX2RlYnVnT3duZXIgPSByZXR1cm5GaWJlciksXG4gICAgICAgICAgICAgICAgKGxhbmVzLl9kZWJ1Z0luZm8gPSBjdXJyZW50RGVidWdJbmZvKSxcbiAgICAgICAgICAgICAgICAocmV0dXJuRmliZXIgPSBsYW5lcykpLFxuICAgICAgICAgICAgcGxhY2VTaW5nbGVDaGlsZChyZXR1cm5GaWJlcilcbiAgICAgICAgICApO1xuICAgICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBuZXdDaGlsZCAmJlxuICAgICAgICAgIHdhcm5PbkZ1bmN0aW9uVHlwZShyZXR1cm5GaWJlciwgbmV3Q2hpbGQpO1xuICAgICAgICBcInN5bWJvbFwiID09PSB0eXBlb2YgbmV3Q2hpbGQgJiYgd2Fybk9uU3ltYm9sVHlwZShyZXR1cm5GaWJlciwgbmV3Q2hpbGQpO1xuICAgICAgICByZXR1cm4gZGVsZXRlUmVtYWluaW5nQ2hpbGRyZW4ocmV0dXJuRmliZXIsIGN1cnJlbnRGaXJzdENoaWxkKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmdW5jdGlvbiAocmV0dXJuRmliZXIsIGN1cnJlbnRGaXJzdENoaWxkLCBuZXdDaGlsZCwgbGFuZXMpIHtcbiAgICAgICAgdmFyIHByZXZEZWJ1Z0luZm8gPSBjdXJyZW50RGVidWdJbmZvO1xuICAgICAgICBjdXJyZW50RGVidWdJbmZvID0gbnVsbDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICB0aGVuYWJsZUluZGV4Q291bnRlciQxID0gMDtcbiAgICAgICAgICB2YXIgZmlyc3RDaGlsZEZpYmVyID0gcmVjb25jaWxlQ2hpbGRGaWJlcnNJbXBsKFxuICAgICAgICAgICAgcmV0dXJuRmliZXIsXG4gICAgICAgICAgICBjdXJyZW50Rmlyc3RDaGlsZCxcbiAgICAgICAgICAgIG5ld0NoaWxkLFxuICAgICAgICAgICAgbGFuZXNcbiAgICAgICAgICApO1xuICAgICAgICAgIHRoZW5hYmxlU3RhdGUkMSA9IG51bGw7XG4gICAgICAgICAgcmV0dXJuIGZpcnN0Q2hpbGRGaWJlcjtcbiAgICAgICAgfSBjYXRjaCAoeCkge1xuICAgICAgICAgIGlmICh4ID09PSBTdXNwZW5zZUV4Y2VwdGlvbikgdGhyb3cgeDtcbiAgICAgICAgICB2YXIgZmliZXIgPSBjcmVhdGVGaWJlcigyOSwgeCwgbnVsbCwgcmV0dXJuRmliZXIubW9kZSk7XG4gICAgICAgICAgZmliZXIubGFuZXMgPSBsYW5lcztcbiAgICAgICAgICBmaWJlci5yZXR1cm4gPSByZXR1cm5GaWJlcjtcbiAgICAgICAgICB2YXIgZGVidWdJbmZvID0gKGZpYmVyLl9kZWJ1Z0luZm8gPSBjdXJyZW50RGVidWdJbmZvKTtcbiAgICAgICAgICBmaWJlci5fZGVidWdPd25lciA9IHJldHVybkZpYmVyLl9kZWJ1Z093bmVyO1xuICAgICAgICAgIGlmIChudWxsICE9IGRlYnVnSW5mbylcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSBkZWJ1Z0luZm8ubGVuZ3RoIC0gMTsgMCA8PSBpOyBpLS0pXG4gICAgICAgICAgICAgIGlmIChcInN0cmluZ1wiID09PSB0eXBlb2YgZGVidWdJbmZvW2ldLnN0YWNrKSB7XG4gICAgICAgICAgICAgICAgZmliZXIuX2RlYnVnT3duZXIgPSBkZWJ1Z0luZm9baV07XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gZmliZXI7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgY3VycmVudERlYnVnSW5mbyA9IHByZXZEZWJ1Z0luZm87XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfVxuICAgIGZ1bmN0aW9uIHB1c2hIaWRkZW5Db250ZXh0KGZpYmVyLCBjb250ZXh0KSB7XG4gICAgICB2YXIgcHJldkVudGFuZ2xlZFJlbmRlckxhbmVzID0gZW50YW5nbGVkUmVuZGVyTGFuZXM7XG4gICAgICBwdXNoKHByZXZFbnRhbmdsZWRSZW5kZXJMYW5lc0N1cnNvciwgcHJldkVudGFuZ2xlZFJlbmRlckxhbmVzLCBmaWJlcik7XG4gICAgICBwdXNoKGN1cnJlbnRUcmVlSGlkZGVuU3RhY2tDdXJzb3IsIGNvbnRleHQsIGZpYmVyKTtcbiAgICAgIGVudGFuZ2xlZFJlbmRlckxhbmVzID0gcHJldkVudGFuZ2xlZFJlbmRlckxhbmVzIHwgY29udGV4dC5iYXNlTGFuZXM7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJldXNlSGlkZGVuQ29udGV4dE9uU3RhY2soZmliZXIpIHtcbiAgICAgIHB1c2gocHJldkVudGFuZ2xlZFJlbmRlckxhbmVzQ3Vyc29yLCBlbnRhbmdsZWRSZW5kZXJMYW5lcywgZmliZXIpO1xuICAgICAgcHVzaChcbiAgICAgICAgY3VycmVudFRyZWVIaWRkZW5TdGFja0N1cnNvcixcbiAgICAgICAgY3VycmVudFRyZWVIaWRkZW5TdGFja0N1cnNvci5jdXJyZW50LFxuICAgICAgICBmaWJlclxuICAgICAgKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcG9wSGlkZGVuQ29udGV4dChmaWJlcikge1xuICAgICAgZW50YW5nbGVkUmVuZGVyTGFuZXMgPSBwcmV2RW50YW5nbGVkUmVuZGVyTGFuZXNDdXJzb3IuY3VycmVudDtcbiAgICAgIHBvcChjdXJyZW50VHJlZUhpZGRlblN0YWNrQ3Vyc29yLCBmaWJlcik7XG4gICAgICBwb3AocHJldkVudGFuZ2xlZFJlbmRlckxhbmVzQ3Vyc29yLCBmaWJlcik7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHB1c2hQcmltYXJ5VHJlZVN1c3BlbnNlSGFuZGxlcihoYW5kbGVyKSB7XG4gICAgICB2YXIgY3VycmVudCA9IGhhbmRsZXIuYWx0ZXJuYXRlO1xuICAgICAgcHVzaChcbiAgICAgICAgc3VzcGVuc2VTdGFja0N1cnNvcixcbiAgICAgICAgc3VzcGVuc2VTdGFja0N1cnNvci5jdXJyZW50ICYgU3VidHJlZVN1c3BlbnNlQ29udGV4dE1hc2ssXG4gICAgICAgIGhhbmRsZXJcbiAgICAgICk7XG4gICAgICBwdXNoKHN1c3BlbnNlSGFuZGxlclN0YWNrQ3Vyc29yLCBoYW5kbGVyLCBoYW5kbGVyKTtcbiAgICAgIG51bGwgPT09IHNoZWxsQm91bmRhcnkgJiZcbiAgICAgICAgKG51bGwgPT09IGN1cnJlbnQgfHwgbnVsbCAhPT0gY3VycmVudFRyZWVIaWRkZW5TdGFja0N1cnNvci5jdXJyZW50XG4gICAgICAgICAgPyAoc2hlbGxCb3VuZGFyeSA9IGhhbmRsZXIpXG4gICAgICAgICAgOiBudWxsICE9PSBjdXJyZW50Lm1lbW9pemVkU3RhdGUgJiYgKHNoZWxsQm91bmRhcnkgPSBoYW5kbGVyKSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHB1c2hPZmZzY3JlZW5TdXNwZW5zZUhhbmRsZXIoZmliZXIpIHtcbiAgICAgIGlmICgyMiA9PT0gZmliZXIudGFnKSB7XG4gICAgICAgIGlmIChcbiAgICAgICAgICAocHVzaChzdXNwZW5zZVN0YWNrQ3Vyc29yLCBzdXNwZW5zZVN0YWNrQ3Vyc29yLmN1cnJlbnQsIGZpYmVyKSxcbiAgICAgICAgICBwdXNoKHN1c3BlbnNlSGFuZGxlclN0YWNrQ3Vyc29yLCBmaWJlciwgZmliZXIpLFxuICAgICAgICAgIG51bGwgPT09IHNoZWxsQm91bmRhcnkpXG4gICAgICAgICkge1xuICAgICAgICAgIHZhciBjdXJyZW50ID0gZmliZXIuYWx0ZXJuYXRlO1xuICAgICAgICAgIG51bGwgIT09IGN1cnJlbnQgJiZcbiAgICAgICAgICAgIG51bGwgIT09IGN1cnJlbnQubWVtb2l6ZWRTdGF0ZSAmJlxuICAgICAgICAgICAgKHNoZWxsQm91bmRhcnkgPSBmaWJlcik7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSByZXVzZVN1c3BlbnNlSGFuZGxlck9uU3RhY2soZmliZXIpO1xuICAgIH1cbiAgICBmdW5jdGlvbiByZXVzZVN1c3BlbnNlSGFuZGxlck9uU3RhY2soZmliZXIpIHtcbiAgICAgIHB1c2goc3VzcGVuc2VTdGFja0N1cnNvciwgc3VzcGVuc2VTdGFja0N1cnNvci5jdXJyZW50LCBmaWJlcik7XG4gICAgICBwdXNoKFxuICAgICAgICBzdXNwZW5zZUhhbmRsZXJTdGFja0N1cnNvcixcbiAgICAgICAgc3VzcGVuc2VIYW5kbGVyU3RhY2tDdXJzb3IuY3VycmVudCxcbiAgICAgICAgZmliZXJcbiAgICAgICk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHBvcFN1c3BlbnNlSGFuZGxlcihmaWJlcikge1xuICAgICAgcG9wKHN1c3BlbnNlSGFuZGxlclN0YWNrQ3Vyc29yLCBmaWJlcik7XG4gICAgICBzaGVsbEJvdW5kYXJ5ID09PSBmaWJlciAmJiAoc2hlbGxCb3VuZGFyeSA9IG51bGwpO1xuICAgICAgcG9wKHN1c3BlbnNlU3RhY2tDdXJzb3IsIGZpYmVyKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZmluZEZpcnN0U3VzcGVuZGVkKHJvdykge1xuICAgICAgZm9yICh2YXIgbm9kZSA9IHJvdzsgbnVsbCAhPT0gbm9kZTsgKSB7XG4gICAgICAgIGlmICgxMyA9PT0gbm9kZS50YWcpIHtcbiAgICAgICAgICB2YXIgc3RhdGUgPSBub2RlLm1lbW9pemVkU3RhdGU7XG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgbnVsbCAhPT0gc3RhdGUgJiZcbiAgICAgICAgICAgICgoc3RhdGUgPSBzdGF0ZS5kZWh5ZHJhdGVkKSxcbiAgICAgICAgICAgIG51bGwgPT09IHN0YXRlIHx8XG4gICAgICAgICAgICAgIGlzU3VzcGVuc2VJbnN0YW5jZVBlbmRpbmcoc3RhdGUpIHx8XG4gICAgICAgICAgICAgIGlzU3VzcGVuc2VJbnN0YW5jZUZhbGxiYWNrKHN0YXRlKSlcbiAgICAgICAgICApXG4gICAgICAgICAgICByZXR1cm4gbm9kZTtcbiAgICAgICAgfSBlbHNlIGlmIChcbiAgICAgICAgICAxOSA9PT0gbm9kZS50YWcgJiZcbiAgICAgICAgICB2b2lkIDAgIT09IG5vZGUubWVtb2l6ZWRQcm9wcy5yZXZlYWxPcmRlclxuICAgICAgICApIHtcbiAgICAgICAgICBpZiAoMCAhPT0gKG5vZGUuZmxhZ3MgJiAxMjgpKSByZXR1cm4gbm9kZTtcbiAgICAgICAgfSBlbHNlIGlmIChudWxsICE9PSBub2RlLmNoaWxkKSB7XG4gICAgICAgICAgbm9kZS5jaGlsZC5yZXR1cm4gPSBub2RlO1xuICAgICAgICAgIG5vZGUgPSBub2RlLmNoaWxkO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChub2RlID09PSByb3cpIGJyZWFrO1xuICAgICAgICBmb3IgKDsgbnVsbCA9PT0gbm9kZS5zaWJsaW5nOyApIHtcbiAgICAgICAgICBpZiAobnVsbCA9PT0gbm9kZS5yZXR1cm4gfHwgbm9kZS5yZXR1cm4gPT09IHJvdykgcmV0dXJuIG51bGw7XG4gICAgICAgICAgbm9kZSA9IG5vZGUucmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIG5vZGUuc2libGluZy5yZXR1cm4gPSBub2RlLnJldHVybjtcbiAgICAgICAgbm9kZSA9IG5vZGUuc2libGluZztcbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBmdW5jdGlvbiBtb3VudEhvb2tUeXBlc0RldigpIHtcbiAgICAgIHZhciBob29rTmFtZSA9IGN1cnJlbnRIb29rTmFtZUluRGV2O1xuICAgICAgbnVsbCA9PT0gaG9va1R5cGVzRGV2XG4gICAgICAgID8gKGhvb2tUeXBlc0RldiA9IFtob29rTmFtZV0pXG4gICAgICAgIDogaG9va1R5cGVzRGV2LnB1c2goaG9va05hbWUpO1xuICAgIH1cbiAgICBmdW5jdGlvbiB1cGRhdGVIb29rVHlwZXNEZXYoKSB7XG4gICAgICB2YXIgaG9va05hbWUgPSBjdXJyZW50SG9va05hbWVJbkRldjtcbiAgICAgIGlmIChcbiAgICAgICAgbnVsbCAhPT0gaG9va1R5cGVzRGV2ICYmXG4gICAgICAgIChob29rVHlwZXNVcGRhdGVJbmRleERldisrLFxuICAgICAgICBob29rVHlwZXNEZXZbaG9va1R5cGVzVXBkYXRlSW5kZXhEZXZdICE9PSBob29rTmFtZSlcbiAgICAgICkge1xuICAgICAgICB2YXIgY29tcG9uZW50TmFtZSA9IGdldENvbXBvbmVudE5hbWVGcm9tRmliZXIoXG4gICAgICAgICAgY3VycmVudGx5UmVuZGVyaW5nRmliZXIkMVxuICAgICAgICApO1xuICAgICAgICBpZiAoXG4gICAgICAgICAgIWRpZFdhcm5BYm91dE1pc21hdGNoZWRIb29rc0ZvckNvbXBvbmVudC5oYXMoY29tcG9uZW50TmFtZSkgJiZcbiAgICAgICAgICAoZGlkV2FybkFib3V0TWlzbWF0Y2hlZEhvb2tzRm9yQ29tcG9uZW50LmFkZChjb21wb25lbnROYW1lKSxcbiAgICAgICAgICBudWxsICE9PSBob29rVHlwZXNEZXYpXG4gICAgICAgICkge1xuICAgICAgICAgIGZvciAodmFyIHRhYmxlID0gXCJcIiwgaSA9IDA7IGkgPD0gaG9va1R5cGVzVXBkYXRlSW5kZXhEZXY7IGkrKykge1xuICAgICAgICAgICAgdmFyIG9sZEhvb2tOYW1lID0gaG9va1R5cGVzRGV2W2ldLFxuICAgICAgICAgICAgICBuZXdIb29rTmFtZSA9XG4gICAgICAgICAgICAgICAgaSA9PT0gaG9va1R5cGVzVXBkYXRlSW5kZXhEZXYgPyBob29rTmFtZSA6IG9sZEhvb2tOYW1lO1xuICAgICAgICAgICAgZm9yIChcbiAgICAgICAgICAgICAgb2xkSG9va05hbWUgPSBpICsgMSArIFwiLiBcIiArIG9sZEhvb2tOYW1lO1xuICAgICAgICAgICAgICAzMCA+IG9sZEhvb2tOYW1lLmxlbmd0aDtcblxuICAgICAgICAgICAgKVxuICAgICAgICAgICAgICBvbGRIb29rTmFtZSArPSBcIiBcIjtcbiAgICAgICAgICAgIG9sZEhvb2tOYW1lICs9IG5ld0hvb2tOYW1lICsgXCJcXG5cIjtcbiAgICAgICAgICAgIHRhYmxlICs9IG9sZEhvb2tOYW1lO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgXCJSZWFjdCBoYXMgZGV0ZWN0ZWQgYSBjaGFuZ2UgaW4gdGhlIG9yZGVyIG9mIEhvb2tzIGNhbGxlZCBieSAlcy4gVGhpcyB3aWxsIGxlYWQgdG8gYnVncyBhbmQgZXJyb3JzIGlmIG5vdCBmaXhlZC4gRm9yIG1vcmUgaW5mb3JtYXRpb24sIHJlYWQgdGhlIFJ1bGVzIG9mIEhvb2tzOiBodHRwczovL3JlYWN0LmRldi9saW5rL3J1bGVzLW9mLWhvb2tzXFxuXFxuICAgUHJldmlvdXMgcmVuZGVyICAgICAgICAgICAgTmV4dCByZW5kZXJcXG4gICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cXG4lcyAgIF5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXlxcblwiLFxuICAgICAgICAgICAgY29tcG9uZW50TmFtZSxcbiAgICAgICAgICAgIHRhYmxlXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBjaGVja0RlcHNBcmVBcnJheURldihkZXBzKSB7XG4gICAgICB2b2lkIDAgPT09IGRlcHMgfHxcbiAgICAgICAgbnVsbCA9PT0gZGVwcyB8fFxuICAgICAgICBpc0FycmF5SW1wbChkZXBzKSB8fFxuICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgIFwiJXMgcmVjZWl2ZWQgYSBmaW5hbCBhcmd1bWVudCB0aGF0IGlzIG5vdCBhbiBhcnJheSAoaW5zdGVhZCwgcmVjZWl2ZWQgYCVzYCkuIFdoZW4gc3BlY2lmaWVkLCB0aGUgZmluYWwgYXJndW1lbnQgbXVzdCBiZSBhbiBhcnJheS5cIixcbiAgICAgICAgICBjdXJyZW50SG9va05hbWVJbkRldixcbiAgICAgICAgICB0eXBlb2YgZGVwc1xuICAgICAgICApO1xuICAgIH1cbiAgICBmdW5jdGlvbiB3YXJuT25Vc2VGb3JtU3RhdGVJbkRldigpIHtcbiAgICAgIHZhciBjb21wb25lbnROYW1lID0gZ2V0Q29tcG9uZW50TmFtZUZyb21GaWJlcihjdXJyZW50bHlSZW5kZXJpbmdGaWJlciQxKTtcbiAgICAgIGRpZFdhcm5BYm91dFVzZUZvcm1TdGF0ZS5oYXMoY29tcG9uZW50TmFtZSkgfHxcbiAgICAgICAgKGRpZFdhcm5BYm91dFVzZUZvcm1TdGF0ZS5hZGQoY29tcG9uZW50TmFtZSksXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgXCJSZWFjdERPTS51c2VGb3JtU3RhdGUgaGFzIGJlZW4gcmVuYW1lZCB0byBSZWFjdC51c2VBY3Rpb25TdGF0ZS4gUGxlYXNlIHVwZGF0ZSAlcyB0byB1c2UgUmVhY3QudXNlQWN0aW9uU3RhdGUuXCIsXG4gICAgICAgICAgY29tcG9uZW50TmFtZVxuICAgICAgICApKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gdGhyb3dJbnZhbGlkSG9va0Vycm9yKCkge1xuICAgICAgdGhyb3cgRXJyb3IoXG4gICAgICAgIFwiSW52YWxpZCBob29rIGNhbGwuIEhvb2tzIGNhbiBvbmx5IGJlIGNhbGxlZCBpbnNpZGUgb2YgdGhlIGJvZHkgb2YgYSBmdW5jdGlvbiBjb21wb25lbnQuIFRoaXMgY291bGQgaGFwcGVuIGZvciBvbmUgb2YgdGhlIGZvbGxvd2luZyByZWFzb25zOlxcbjEuIFlvdSBtaWdodCBoYXZlIG1pc21hdGNoaW5nIHZlcnNpb25zIG9mIFJlYWN0IGFuZCB0aGUgcmVuZGVyZXIgKHN1Y2ggYXMgUmVhY3QgRE9NKVxcbjIuIFlvdSBtaWdodCBiZSBicmVha2luZyB0aGUgUnVsZXMgb2YgSG9va3NcXG4zLiBZb3UgbWlnaHQgaGF2ZSBtb3JlIHRoYW4gb25lIGNvcHkgb2YgUmVhY3QgaW4gdGhlIHNhbWUgYXBwXFxuU2VlIGh0dHBzOi8vcmVhY3QuZGV2L2xpbmsvaW52YWxpZC1ob29rLWNhbGwgZm9yIHRpcHMgYWJvdXQgaG93IHRvIGRlYnVnIGFuZCBmaXggdGhpcyBwcm9ibGVtLlwiXG4gICAgICApO1xuICAgIH1cbiAgICBmdW5jdGlvbiBhcmVIb29rSW5wdXRzRXF1YWwobmV4dERlcHMsIHByZXZEZXBzKSB7XG4gICAgICBpZiAoaWdub3JlUHJldmlvdXNEZXBlbmRlbmNpZXMpIHJldHVybiAhMTtcbiAgICAgIGlmIChudWxsID09PSBwcmV2RGVwcylcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgXCIlcyByZWNlaXZlZCBhIGZpbmFsIGFyZ3VtZW50IGR1cmluZyB0aGlzIHJlbmRlciwgYnV0IG5vdCBkdXJpbmcgdGhlIHByZXZpb3VzIHJlbmRlci4gRXZlbiB0aG91Z2ggdGhlIGZpbmFsIGFyZ3VtZW50IGlzIG9wdGlvbmFsLCBpdHMgdHlwZSBjYW5ub3QgY2hhbmdlIGJldHdlZW4gcmVuZGVycy5cIixcbiAgICAgICAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2XG4gICAgICAgICAgKSxcbiAgICAgICAgICAhMVxuICAgICAgICApO1xuICAgICAgbmV4dERlcHMubGVuZ3RoICE9PSBwcmV2RGVwcy5sZW5ndGggJiZcbiAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICBcIlRoZSBmaW5hbCBhcmd1bWVudCBwYXNzZWQgdG8gJXMgY2hhbmdlZCBzaXplIGJldHdlZW4gcmVuZGVycy4gVGhlIG9yZGVyIGFuZCBzaXplIG9mIHRoaXMgYXJyYXkgbXVzdCByZW1haW4gY29uc3RhbnQuXFxuXFxuUHJldmlvdXM6ICVzXFxuSW5jb21pbmc6ICVzXCIsXG4gICAgICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYsXG4gICAgICAgICAgXCJbXCIgKyBwcmV2RGVwcy5qb2luKFwiLCBcIikgKyBcIl1cIixcbiAgICAgICAgICBcIltcIiArIG5leHREZXBzLmpvaW4oXCIsIFwiKSArIFwiXVwiXG4gICAgICAgICk7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHByZXZEZXBzLmxlbmd0aCAmJiBpIDwgbmV4dERlcHMubGVuZ3RoOyBpKyspXG4gICAgICAgIGlmICghb2JqZWN0SXMobmV4dERlcHNbaV0sIHByZXZEZXBzW2ldKSkgcmV0dXJuICExO1xuICAgICAgcmV0dXJuICEwO1xuICAgIH1cbiAgICBmdW5jdGlvbiByZW5kZXJXaXRoSG9va3MoXG4gICAgICBjdXJyZW50LFxuICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gICAgICBDb21wb25lbnQsXG4gICAgICBwcm9wcyxcbiAgICAgIHNlY29uZEFyZyxcbiAgICAgIG5leHRSZW5kZXJMYW5lc1xuICAgICkge1xuICAgICAgcmVuZGVyTGFuZXMgPSBuZXh0UmVuZGVyTGFuZXM7XG4gICAgICBjdXJyZW50bHlSZW5kZXJpbmdGaWJlciQxID0gd29ya0luUHJvZ3Jlc3M7XG4gICAgICBob29rVHlwZXNEZXYgPSBudWxsICE9PSBjdXJyZW50ID8gY3VycmVudC5fZGVidWdIb29rVHlwZXMgOiBudWxsO1xuICAgICAgaG9va1R5cGVzVXBkYXRlSW5kZXhEZXYgPSAtMTtcbiAgICAgIGlnbm9yZVByZXZpb3VzRGVwZW5kZW5jaWVzID1cbiAgICAgICAgbnVsbCAhPT0gY3VycmVudCAmJiBjdXJyZW50LnR5cGUgIT09IHdvcmtJblByb2dyZXNzLnR5cGU7XG4gICAgICBpZiAoXG4gICAgICAgIFwiW29iamVjdCBBc3luY0Z1bmN0aW9uXVwiID09PVxuICAgICAgICAgIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChDb21wb25lbnQpIHx8XG4gICAgICAgIFwiW29iamVjdCBBc3luY0dlbmVyYXRvckZ1bmN0aW9uXVwiID09PVxuICAgICAgICAgIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChDb21wb25lbnQpXG4gICAgICApXG4gICAgICAgIChuZXh0UmVuZGVyTGFuZXMgPSBnZXRDb21wb25lbnROYW1lRnJvbUZpYmVyKFxuICAgICAgICAgIGN1cnJlbnRseVJlbmRlcmluZ0ZpYmVyJDFcbiAgICAgICAgKSksXG4gICAgICAgICAgZGlkV2FybkFib3V0QXN5bmNDbGllbnRDb21wb25lbnQuaGFzKG5leHRSZW5kZXJMYW5lcykgfHxcbiAgICAgICAgICAgIChkaWRXYXJuQWJvdXRBc3luY0NsaWVudENvbXBvbmVudC5hZGQobmV4dFJlbmRlckxhbmVzKSxcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgIFwiYXN5bmMvYXdhaXQgaXMgbm90IHlldCBzdXBwb3J0ZWQgaW4gQ2xpZW50IENvbXBvbmVudHMsIG9ubHkgU2VydmVyIENvbXBvbmVudHMuIFRoaXMgZXJyb3IgaXMgb2Z0ZW4gY2F1c2VkIGJ5IGFjY2lkZW50YWxseSBhZGRpbmcgYCd1c2UgY2xpZW50J2AgdG8gYSBtb2R1bGUgdGhhdCB3YXMgb3JpZ2luYWxseSB3cml0dGVuIGZvciB0aGUgc2VydmVyLlwiXG4gICAgICAgICAgICApKTtcbiAgICAgIHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGUgPSBudWxsO1xuICAgICAgd29ya0luUHJvZ3Jlc3MudXBkYXRlUXVldWUgPSBudWxsO1xuICAgICAgd29ya0luUHJvZ3Jlc3MubGFuZXMgPSAwO1xuICAgICAgUmVhY3RTaGFyZWRJbnRlcm5hbHMuSCA9XG4gICAgICAgIG51bGwgIT09IGN1cnJlbnQgJiYgbnVsbCAhPT0gY3VycmVudC5tZW1vaXplZFN0YXRlXG4gICAgICAgICAgPyBIb29rc0Rpc3BhdGNoZXJPblVwZGF0ZUluREVWXG4gICAgICAgICAgOiBudWxsICE9PSBob29rVHlwZXNEZXZcbiAgICAgICAgICAgID8gSG9va3NEaXNwYXRjaGVyT25Nb3VudFdpdGhIb29rVHlwZXNJbkRFVlxuICAgICAgICAgICAgOiBIb29rc0Rpc3BhdGNoZXJPbk1vdW50SW5ERVY7XG4gICAgICBzaG91bGREb3VibGVJbnZva2VVc2VyRm5zSW5Ib29rc0RFViA9IG5leHRSZW5kZXJMYW5lcyA9XG4gICAgICAgICh3b3JrSW5Qcm9ncmVzcy5tb2RlICYgOCkgIT09IE5vTW9kZTtcbiAgICAgIHZhciBjaGlsZHJlbiA9IGNhbGxDb21wb25lbnRJbkRFVihDb21wb25lbnQsIHByb3BzLCBzZWNvbmRBcmcpO1xuICAgICAgc2hvdWxkRG91YmxlSW52b2tlVXNlckZuc0luSG9va3NERVYgPSAhMTtcbiAgICAgIGRpZFNjaGVkdWxlUmVuZGVyUGhhc2VVcGRhdGVEdXJpbmdUaGlzUGFzcyAmJlxuICAgICAgICAoY2hpbGRyZW4gPSByZW5kZXJXaXRoSG9va3NBZ2FpbihcbiAgICAgICAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgICAgICAgICBDb21wb25lbnQsXG4gICAgICAgICAgcHJvcHMsXG4gICAgICAgICAgc2Vjb25kQXJnXG4gICAgICAgICkpO1xuICAgICAgaWYgKG5leHRSZW5kZXJMYW5lcykge1xuICAgICAgICBzZXRJc1N0cmljdE1vZGVGb3JEZXZ0b29scyghMCk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgY2hpbGRyZW4gPSByZW5kZXJXaXRoSG9va3NBZ2FpbihcbiAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLFxuICAgICAgICAgICAgQ29tcG9uZW50LFxuICAgICAgICAgICAgcHJvcHMsXG4gICAgICAgICAgICBzZWNvbmRBcmdcbiAgICAgICAgICApO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIHNldElzU3RyaWN0TW9kZUZvckRldnRvb2xzKCExKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZmluaXNoUmVuZGVyaW5nSG9va3MoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MpO1xuICAgICAgcmV0dXJuIGNoaWxkcmVuO1xuICAgIH1cbiAgICBmdW5jdGlvbiBmaW5pc2hSZW5kZXJpbmdIb29rcyhjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcykge1xuICAgICAgd29ya0luUHJvZ3Jlc3MuX2RlYnVnSG9va1R5cGVzID0gaG9va1R5cGVzRGV2O1xuICAgICAgbnVsbCA9PT0gd29ya0luUHJvZ3Jlc3MuZGVwZW5kZW5jaWVzXG4gICAgICAgID8gbnVsbCAhPT0gdGhlbmFibGVTdGF0ZSAmJlxuICAgICAgICAgICh3b3JrSW5Qcm9ncmVzcy5kZXBlbmRlbmNpZXMgPSB7XG4gICAgICAgICAgICBsYW5lczogMCxcbiAgICAgICAgICAgIGZpcnN0Q29udGV4dDogbnVsbCxcbiAgICAgICAgICAgIF9kZWJ1Z1RoZW5hYmxlU3RhdGU6IHRoZW5hYmxlU3RhdGVcbiAgICAgICAgICB9KVxuICAgICAgICA6ICh3b3JrSW5Qcm9ncmVzcy5kZXBlbmRlbmNpZXMuX2RlYnVnVGhlbmFibGVTdGF0ZSA9IHRoZW5hYmxlU3RhdGUpO1xuICAgICAgUmVhY3RTaGFyZWRJbnRlcm5hbHMuSCA9IENvbnRleHRPbmx5RGlzcGF0Y2hlcjtcbiAgICAgIHZhciBkaWRSZW5kZXJUb29GZXdIb29rcyA9XG4gICAgICAgIG51bGwgIT09IGN1cnJlbnRIb29rICYmIG51bGwgIT09IGN1cnJlbnRIb29rLm5leHQ7XG4gICAgICByZW5kZXJMYW5lcyA9IDA7XG4gICAgICBob29rVHlwZXNEZXYgPVxuICAgICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9XG4gICAgICAgIHdvcmtJblByb2dyZXNzSG9vayA9XG4gICAgICAgIGN1cnJlbnRIb29rID1cbiAgICAgICAgY3VycmVudGx5UmVuZGVyaW5nRmliZXIkMSA9XG4gICAgICAgICAgbnVsbDtcbiAgICAgIGhvb2tUeXBlc1VwZGF0ZUluZGV4RGV2ID0gLTE7XG4gICAgICBudWxsICE9PSBjdXJyZW50ICYmXG4gICAgICAgIChjdXJyZW50LmZsYWdzICYgMzE0NTcyODApICE9PSAod29ya0luUHJvZ3Jlc3MuZmxhZ3MgJiAzMTQ1NzI4MCkgJiZcbiAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICBcIkludGVybmFsIFJlYWN0IGVycm9yOiBFeHBlY3RlZCBzdGF0aWMgZmxhZyB3YXMgbWlzc2luZy4gUGxlYXNlIG5vdGlmeSB0aGUgUmVhY3QgdGVhbS5cIlxuICAgICAgICApO1xuICAgICAgZGlkU2NoZWR1bGVSZW5kZXJQaGFzZVVwZGF0ZSA9ICExO1xuICAgICAgdGhlbmFibGVJbmRleENvdW50ZXIgPSAwO1xuICAgICAgdGhlbmFibGVTdGF0ZSA9IG51bGw7XG4gICAgICBpZiAoZGlkUmVuZGVyVG9vRmV3SG9va3MpXG4gICAgICAgIHRocm93IEVycm9yKFxuICAgICAgICAgIFwiUmVuZGVyZWQgZmV3ZXIgaG9va3MgdGhhbiBleHBlY3RlZC4gVGhpcyBtYXkgYmUgY2F1c2VkIGJ5IGFuIGFjY2lkZW50YWwgZWFybHkgcmV0dXJuIHN0YXRlbWVudC5cIlxuICAgICAgICApO1xuICAgICAgbnVsbCA9PT0gY3VycmVudCB8fFxuICAgICAgICBkaWRSZWNlaXZlVXBkYXRlIHx8XG4gICAgICAgICgoY3VycmVudCA9IGN1cnJlbnQuZGVwZW5kZW5jaWVzKSxcbiAgICAgICAgbnVsbCAhPT0gY3VycmVudCAmJlxuICAgICAgICAgIGNoZWNrSWZDb250ZXh0Q2hhbmdlZChjdXJyZW50KSAmJlxuICAgICAgICAgIChkaWRSZWNlaXZlVXBkYXRlID0gITApKTtcbiAgICAgIG5lZWRzVG9SZXNldFN1c3BlbmRlZFRoZW5hYmxlREVWXG4gICAgICAgID8gKChuZWVkc1RvUmVzZXRTdXNwZW5kZWRUaGVuYWJsZURFViA9ICExKSwgKGN1cnJlbnQgPSAhMCkpXG4gICAgICAgIDogKGN1cnJlbnQgPSAhMSk7XG4gICAgICBjdXJyZW50ICYmXG4gICAgICAgICgod29ya0luUHJvZ3Jlc3MgPVxuICAgICAgICAgIGdldENvbXBvbmVudE5hbWVGcm9tRmliZXIod29ya0luUHJvZ3Jlc3MpIHx8IFwiVW5rbm93blwiKSxcbiAgICAgICAgZGlkV2FybkFib3V0VXNlV3JhcHBlZEluVHJ5Q2F0Y2guaGFzKHdvcmtJblByb2dyZXNzKSB8fFxuICAgICAgICAgIGRpZFdhcm5BYm91dEFzeW5jQ2xpZW50Q29tcG9uZW50Lmhhcyh3b3JrSW5Qcm9ncmVzcykgfHxcbiAgICAgICAgICAoZGlkV2FybkFib3V0VXNlV3JhcHBlZEluVHJ5Q2F0Y2guYWRkKHdvcmtJblByb2dyZXNzKSxcbiAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgXCJgdXNlYCB3YXMgY2FsbGVkIGZyb20gaW5zaWRlIGEgdHJ5L2NhdGNoIGJsb2NrLiBUaGlzIGlzIG5vdCBhbGxvd2VkIGFuZCBjYW4gbGVhZCB0byB1bmV4cGVjdGVkIGJlaGF2aW9yLiBUbyBoYW5kbGUgZXJyb3JzIHRyaWdnZXJlZCBieSBgdXNlYCwgd3JhcCB5b3VyIGNvbXBvbmVudCBpbiBhIGVycm9yIGJvdW5kYXJ5LlwiXG4gICAgICAgICAgKSkpO1xuICAgIH1cbiAgICBmdW5jdGlvbiByZW5kZXJXaXRoSG9va3NBZ2Fpbih3b3JrSW5Qcm9ncmVzcywgQ29tcG9uZW50LCBwcm9wcywgc2Vjb25kQXJnKSB7XG4gICAgICBjdXJyZW50bHlSZW5kZXJpbmdGaWJlciQxID0gd29ya0luUHJvZ3Jlc3M7XG4gICAgICB2YXIgbnVtYmVyT2ZSZVJlbmRlcnMgPSAwO1xuICAgICAgZG8ge1xuICAgICAgICBkaWRTY2hlZHVsZVJlbmRlclBoYXNlVXBkYXRlRHVyaW5nVGhpc1Bhc3MgJiYgKHRoZW5hYmxlU3RhdGUgPSBudWxsKTtcbiAgICAgICAgdGhlbmFibGVJbmRleENvdW50ZXIgPSAwO1xuICAgICAgICBkaWRTY2hlZHVsZVJlbmRlclBoYXNlVXBkYXRlRHVyaW5nVGhpc1Bhc3MgPSAhMTtcbiAgICAgICAgaWYgKG51bWJlck9mUmVSZW5kZXJzID49IFJFX1JFTkRFUl9MSU1JVClcbiAgICAgICAgICB0aHJvdyBFcnJvcihcbiAgICAgICAgICAgIFwiVG9vIG1hbnkgcmUtcmVuZGVycy4gUmVhY3QgbGltaXRzIHRoZSBudW1iZXIgb2YgcmVuZGVycyB0byBwcmV2ZW50IGFuIGluZmluaXRlIGxvb3AuXCJcbiAgICAgICAgICApO1xuICAgICAgICBudW1iZXJPZlJlUmVuZGVycyArPSAxO1xuICAgICAgICBpZ25vcmVQcmV2aW91c0RlcGVuZGVuY2llcyA9ICExO1xuICAgICAgICB3b3JrSW5Qcm9ncmVzc0hvb2sgPSBjdXJyZW50SG9vayA9IG51bGw7XG4gICAgICAgIGlmIChudWxsICE9IHdvcmtJblByb2dyZXNzLnVwZGF0ZVF1ZXVlKSB7XG4gICAgICAgICAgdmFyIGNoaWxkcmVuID0gd29ya0luUHJvZ3Jlc3MudXBkYXRlUXVldWU7XG4gICAgICAgICAgY2hpbGRyZW4ubGFzdEVmZmVjdCA9IG51bGw7XG4gICAgICAgICAgY2hpbGRyZW4uZXZlbnRzID0gbnVsbDtcbiAgICAgICAgICBjaGlsZHJlbi5zdG9yZXMgPSBudWxsO1xuICAgICAgICAgIG51bGwgIT0gY2hpbGRyZW4ubWVtb0NhY2hlICYmIChjaGlsZHJlbi5tZW1vQ2FjaGUuaW5kZXggPSAwKTtcbiAgICAgICAgfVxuICAgICAgICBob29rVHlwZXNVcGRhdGVJbmRleERldiA9IC0xO1xuICAgICAgICBSZWFjdFNoYXJlZEludGVybmFscy5IID0gSG9va3NEaXNwYXRjaGVyT25SZXJlbmRlckluREVWO1xuICAgICAgICBjaGlsZHJlbiA9IGNhbGxDb21wb25lbnRJbkRFVihDb21wb25lbnQsIHByb3BzLCBzZWNvbmRBcmcpO1xuICAgICAgfSB3aGlsZSAoZGlkU2NoZWR1bGVSZW5kZXJQaGFzZVVwZGF0ZUR1cmluZ1RoaXNQYXNzKTtcbiAgICAgIHJldHVybiBjaGlsZHJlbjtcbiAgICB9XG4gICAgZnVuY3Rpb24gVHJhbnNpdGlvbkF3YXJlSG9zdENvbXBvbmVudCgpIHtcbiAgICAgIHZhciBkaXNwYXRjaGVyID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuSCxcbiAgICAgICAgbWF5YmVUaGVuYWJsZSA9IGRpc3BhdGNoZXIudXNlU3RhdGUoKVswXTtcbiAgICAgIG1heWJlVGhlbmFibGUgPVxuICAgICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBtYXliZVRoZW5hYmxlLnRoZW5cbiAgICAgICAgICA/IHVzZVRoZW5hYmxlKG1heWJlVGhlbmFibGUpXG4gICAgICAgICAgOiBtYXliZVRoZW5hYmxlO1xuICAgICAgZGlzcGF0Y2hlciA9IGRpc3BhdGNoZXIudXNlU3RhdGUoKVswXTtcbiAgICAgIChudWxsICE9PSBjdXJyZW50SG9vayA/IGN1cnJlbnRIb29rLm1lbW9pemVkU3RhdGUgOiBudWxsKSAhPT1cbiAgICAgICAgZGlzcGF0Y2hlciAmJiAoY3VycmVudGx5UmVuZGVyaW5nRmliZXIkMS5mbGFncyB8PSAxMDI0KTtcbiAgICAgIHJldHVybiBtYXliZVRoZW5hYmxlO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjaGVja0RpZFJlbmRlcklkSG9vaygpIHtcbiAgICAgIHZhciBkaWRSZW5kZXJJZEhvb2sgPSAwICE9PSBsb2NhbElkQ291bnRlcjtcbiAgICAgIGxvY2FsSWRDb3VudGVyID0gMDtcbiAgICAgIHJldHVybiBkaWRSZW5kZXJJZEhvb2s7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGJhaWxvdXRIb29rcyhjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgbGFuZXMpIHtcbiAgICAgIHdvcmtJblByb2dyZXNzLnVwZGF0ZVF1ZXVlID0gY3VycmVudC51cGRhdGVRdWV1ZTtcbiAgICAgIHdvcmtJblByb2dyZXNzLmZsYWdzID1cbiAgICAgICAgKHdvcmtJblByb2dyZXNzLm1vZGUgJiAxNikgIT09IE5vTW9kZVxuICAgICAgICAgID8gd29ya0luUHJvZ3Jlc3MuZmxhZ3MgJiAtMjAxMzI4NjQ1XG4gICAgICAgICAgOiB3b3JrSW5Qcm9ncmVzcy5mbGFncyAmIC0yMDUzO1xuICAgICAgY3VycmVudC5sYW5lcyAmPSB+bGFuZXM7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlc2V0SG9va3NPblVud2luZCh3b3JrSW5Qcm9ncmVzcykge1xuICAgICAgaWYgKGRpZFNjaGVkdWxlUmVuZGVyUGhhc2VVcGRhdGUpIHtcbiAgICAgICAgZm9yIChcbiAgICAgICAgICB3b3JrSW5Qcm9ncmVzcyA9IHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGU7XG4gICAgICAgICAgbnVsbCAhPT0gd29ya0luUHJvZ3Jlc3M7XG5cbiAgICAgICAgKSB7XG4gICAgICAgICAgdmFyIHF1ZXVlID0gd29ya0luUHJvZ3Jlc3MucXVldWU7XG4gICAgICAgICAgbnVsbCAhPT0gcXVldWUgJiYgKHF1ZXVlLnBlbmRpbmcgPSBudWxsKTtcbiAgICAgICAgICB3b3JrSW5Qcm9ncmVzcyA9IHdvcmtJblByb2dyZXNzLm5leHQ7XG4gICAgICAgIH1cbiAgICAgICAgZGlkU2NoZWR1bGVSZW5kZXJQaGFzZVVwZGF0ZSA9ICExO1xuICAgICAgfVxuICAgICAgcmVuZGVyTGFuZXMgPSAwO1xuICAgICAgaG9va1R5cGVzRGV2ID1cbiAgICAgICAgd29ya0luUHJvZ3Jlc3NIb29rID1cbiAgICAgICAgY3VycmVudEhvb2sgPVxuICAgICAgICBjdXJyZW50bHlSZW5kZXJpbmdGaWJlciQxID1cbiAgICAgICAgICBudWxsO1xuICAgICAgaG9va1R5cGVzVXBkYXRlSW5kZXhEZXYgPSAtMTtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gbnVsbDtcbiAgICAgIGRpZFNjaGVkdWxlUmVuZGVyUGhhc2VVcGRhdGVEdXJpbmdUaGlzUGFzcyA9ICExO1xuICAgICAgdGhlbmFibGVJbmRleENvdW50ZXIgPSBsb2NhbElkQ291bnRlciA9IDA7XG4gICAgICB0aGVuYWJsZVN0YXRlID0gbnVsbDtcbiAgICB9XG4gICAgZnVuY3Rpb24gbW91bnRXb3JrSW5Qcm9ncmVzc0hvb2soKSB7XG4gICAgICB2YXIgaG9vayA9IHtcbiAgICAgICAgbWVtb2l6ZWRTdGF0ZTogbnVsbCxcbiAgICAgICAgYmFzZVN0YXRlOiBudWxsLFxuICAgICAgICBiYXNlUXVldWU6IG51bGwsXG4gICAgICAgIHF1ZXVlOiBudWxsLFxuICAgICAgICBuZXh0OiBudWxsXG4gICAgICB9O1xuICAgICAgbnVsbCA9PT0gd29ya0luUHJvZ3Jlc3NIb29rXG4gICAgICAgID8gKGN1cnJlbnRseVJlbmRlcmluZ0ZpYmVyJDEubWVtb2l6ZWRTdGF0ZSA9IHdvcmtJblByb2dyZXNzSG9vayA9IGhvb2spXG4gICAgICAgIDogKHdvcmtJblByb2dyZXNzSG9vayA9IHdvcmtJblByb2dyZXNzSG9vay5uZXh0ID0gaG9vayk7XG4gICAgICByZXR1cm4gd29ya0luUHJvZ3Jlc3NIb29rO1xuICAgIH1cbiAgICBmdW5jdGlvbiB1cGRhdGVXb3JrSW5Qcm9ncmVzc0hvb2soKSB7XG4gICAgICBpZiAobnVsbCA9PT0gY3VycmVudEhvb2spIHtcbiAgICAgICAgdmFyIG5leHRDdXJyZW50SG9vayA9IGN1cnJlbnRseVJlbmRlcmluZ0ZpYmVyJDEuYWx0ZXJuYXRlO1xuICAgICAgICBuZXh0Q3VycmVudEhvb2sgPVxuICAgICAgICAgIG51bGwgIT09IG5leHRDdXJyZW50SG9vayA/IG5leHRDdXJyZW50SG9vay5tZW1vaXplZFN0YXRlIDogbnVsbDtcbiAgICAgIH0gZWxzZSBuZXh0Q3VycmVudEhvb2sgPSBjdXJyZW50SG9vay5uZXh0O1xuICAgICAgdmFyIG5leHRXb3JrSW5Qcm9ncmVzc0hvb2sgPVxuICAgICAgICBudWxsID09PSB3b3JrSW5Qcm9ncmVzc0hvb2tcbiAgICAgICAgICA/IGN1cnJlbnRseVJlbmRlcmluZ0ZpYmVyJDEubWVtb2l6ZWRTdGF0ZVxuICAgICAgICAgIDogd29ya0luUHJvZ3Jlc3NIb29rLm5leHQ7XG4gICAgICBpZiAobnVsbCAhPT0gbmV4dFdvcmtJblByb2dyZXNzSG9vaylcbiAgICAgICAgKHdvcmtJblByb2dyZXNzSG9vayA9IG5leHRXb3JrSW5Qcm9ncmVzc0hvb2spLFxuICAgICAgICAgIChjdXJyZW50SG9vayA9IG5leHRDdXJyZW50SG9vayk7XG4gICAgICBlbHNlIHtcbiAgICAgICAgaWYgKG51bGwgPT09IG5leHRDdXJyZW50SG9vaykge1xuICAgICAgICAgIGlmIChudWxsID09PSBjdXJyZW50bHlSZW5kZXJpbmdGaWJlciQxLmFsdGVybmF0ZSlcbiAgICAgICAgICAgIHRocm93IEVycm9yKFxuICAgICAgICAgICAgICBcIlVwZGF0ZSBob29rIGNhbGxlZCBvbiBpbml0aWFsIHJlbmRlci4gVGhpcyBpcyBsaWtlbHkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLlwiXG4gICAgICAgICAgICApO1xuICAgICAgICAgIHRocm93IEVycm9yKFwiUmVuZGVyZWQgbW9yZSBob29rcyB0aGFuIGR1cmluZyB0aGUgcHJldmlvdXMgcmVuZGVyLlwiKTtcbiAgICAgICAgfVxuICAgICAgICBjdXJyZW50SG9vayA9IG5leHRDdXJyZW50SG9vaztcbiAgICAgICAgbmV4dEN1cnJlbnRIb29rID0ge1xuICAgICAgICAgIG1lbW9pemVkU3RhdGU6IGN1cnJlbnRIb29rLm1lbW9pemVkU3RhdGUsXG4gICAgICAgICAgYmFzZVN0YXRlOiBjdXJyZW50SG9vay5iYXNlU3RhdGUsXG4gICAgICAgICAgYmFzZVF1ZXVlOiBjdXJyZW50SG9vay5iYXNlUXVldWUsXG4gICAgICAgICAgcXVldWU6IGN1cnJlbnRIb29rLnF1ZXVlLFxuICAgICAgICAgIG5leHQ6IG51bGxcbiAgICAgICAgfTtcbiAgICAgICAgbnVsbCA9PT0gd29ya0luUHJvZ3Jlc3NIb29rXG4gICAgICAgICAgPyAoY3VycmVudGx5UmVuZGVyaW5nRmliZXIkMS5tZW1vaXplZFN0YXRlID0gd29ya0luUHJvZ3Jlc3NIb29rID1cbiAgICAgICAgICAgICAgbmV4dEN1cnJlbnRIb29rKVxuICAgICAgICAgIDogKHdvcmtJblByb2dyZXNzSG9vayA9IHdvcmtJblByb2dyZXNzSG9vay5uZXh0ID0gbmV4dEN1cnJlbnRIb29rKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB3b3JrSW5Qcm9ncmVzc0hvb2s7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHVzZVRoZW5hYmxlKHRoZW5hYmxlKSB7XG4gICAgICB2YXIgaW5kZXggPSB0aGVuYWJsZUluZGV4Q291bnRlcjtcbiAgICAgIHRoZW5hYmxlSW5kZXhDb3VudGVyICs9IDE7XG4gICAgICBudWxsID09PSB0aGVuYWJsZVN0YXRlICYmICh0aGVuYWJsZVN0YXRlID0gY3JlYXRlVGhlbmFibGVTdGF0ZSgpKTtcbiAgICAgIHRoZW5hYmxlID0gdHJhY2tVc2VkVGhlbmFibGUodGhlbmFibGVTdGF0ZSwgdGhlbmFibGUsIGluZGV4KTtcbiAgICAgIGluZGV4ID0gY3VycmVudGx5UmVuZGVyaW5nRmliZXIkMTtcbiAgICAgIG51bGwgPT09XG4gICAgICAgIChudWxsID09PSB3b3JrSW5Qcm9ncmVzc0hvb2tcbiAgICAgICAgICA/IGluZGV4Lm1lbW9pemVkU3RhdGVcbiAgICAgICAgICA6IHdvcmtJblByb2dyZXNzSG9vay5uZXh0KSAmJlxuICAgICAgICAoKGluZGV4ID0gaW5kZXguYWx0ZXJuYXRlKSxcbiAgICAgICAgKFJlYWN0U2hhcmVkSW50ZXJuYWxzLkggPVxuICAgICAgICAgIG51bGwgIT09IGluZGV4ICYmIG51bGwgIT09IGluZGV4Lm1lbW9pemVkU3RhdGVcbiAgICAgICAgICAgID8gSG9va3NEaXNwYXRjaGVyT25VcGRhdGVJbkRFVlxuICAgICAgICAgICAgOiBIb29rc0Rpc3BhdGNoZXJPbk1vdW50SW5ERVYpKTtcbiAgICAgIHJldHVybiB0aGVuYWJsZTtcbiAgICB9XG4gICAgZnVuY3Rpb24gdXNlKHVzYWJsZSkge1xuICAgICAgaWYgKG51bGwgIT09IHVzYWJsZSAmJiBcIm9iamVjdFwiID09PSB0eXBlb2YgdXNhYmxlKSB7XG4gICAgICAgIGlmIChcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiB1c2FibGUudGhlbikgcmV0dXJuIHVzZVRoZW5hYmxlKHVzYWJsZSk7XG4gICAgICAgIGlmICh1c2FibGUuJCR0eXBlb2YgPT09IFJFQUNUX0NPTlRFWFRfVFlQRSkgcmV0dXJuIHJlYWRDb250ZXh0KHVzYWJsZSk7XG4gICAgICB9XG4gICAgICB0aHJvdyBFcnJvcihcIkFuIHVuc3VwcG9ydGVkIHR5cGUgd2FzIHBhc3NlZCB0byB1c2UoKTogXCIgKyBTdHJpbmcodXNhYmxlKSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHVzZU1lbW9DYWNoZShzaXplKSB7XG4gICAgICB2YXIgbWVtb0NhY2hlID0gbnVsbCxcbiAgICAgICAgdXBkYXRlUXVldWUgPSBjdXJyZW50bHlSZW5kZXJpbmdGaWJlciQxLnVwZGF0ZVF1ZXVlO1xuICAgICAgbnVsbCAhPT0gdXBkYXRlUXVldWUgJiYgKG1lbW9DYWNoZSA9IHVwZGF0ZVF1ZXVlLm1lbW9DYWNoZSk7XG4gICAgICBpZiAobnVsbCA9PSBtZW1vQ2FjaGUpIHtcbiAgICAgICAgdmFyIGN1cnJlbnQgPSBjdXJyZW50bHlSZW5kZXJpbmdGaWJlciQxLmFsdGVybmF0ZTtcbiAgICAgICAgbnVsbCAhPT0gY3VycmVudCAmJlxuICAgICAgICAgICgoY3VycmVudCA9IGN1cnJlbnQudXBkYXRlUXVldWUpLFxuICAgICAgICAgIG51bGwgIT09IGN1cnJlbnQgJiZcbiAgICAgICAgICAgICgoY3VycmVudCA9IGN1cnJlbnQubWVtb0NhY2hlKSxcbiAgICAgICAgICAgIG51bGwgIT0gY3VycmVudCAmJlxuICAgICAgICAgICAgICAobWVtb0NhY2hlID0ge1xuICAgICAgICAgICAgICAgIGRhdGE6IGN1cnJlbnQuZGF0YS5tYXAoZnVuY3Rpb24gKGFycmF5KSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gYXJyYXkuc2xpY2UoKTtcbiAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICBpbmRleDogMFxuICAgICAgICAgICAgICB9KSkpO1xuICAgICAgfVxuICAgICAgbnVsbCA9PSBtZW1vQ2FjaGUgJiYgKG1lbW9DYWNoZSA9IHsgZGF0YTogW10sIGluZGV4OiAwIH0pO1xuICAgICAgbnVsbCA9PT0gdXBkYXRlUXVldWUgJiZcbiAgICAgICAgKCh1cGRhdGVRdWV1ZSA9IGNyZWF0ZUZ1bmN0aW9uQ29tcG9uZW50VXBkYXRlUXVldWUoKSksXG4gICAgICAgIChjdXJyZW50bHlSZW5kZXJpbmdGaWJlciQxLnVwZGF0ZVF1ZXVlID0gdXBkYXRlUXVldWUpKTtcbiAgICAgIHVwZGF0ZVF1ZXVlLm1lbW9DYWNoZSA9IG1lbW9DYWNoZTtcbiAgICAgIHVwZGF0ZVF1ZXVlID0gbWVtb0NhY2hlLmRhdGFbbWVtb0NhY2hlLmluZGV4XTtcbiAgICAgIGlmICh2b2lkIDAgPT09IHVwZGF0ZVF1ZXVlIHx8IGlnbm9yZVByZXZpb3VzRGVwZW5kZW5jaWVzKVxuICAgICAgICBmb3IgKFxuICAgICAgICAgIHVwZGF0ZVF1ZXVlID0gbWVtb0NhY2hlLmRhdGFbbWVtb0NhY2hlLmluZGV4XSA9IEFycmF5KHNpemUpLFxuICAgICAgICAgICAgY3VycmVudCA9IDA7XG4gICAgICAgICAgY3VycmVudCA8IHNpemU7XG4gICAgICAgICAgY3VycmVudCsrXG4gICAgICAgIClcbiAgICAgICAgICB1cGRhdGVRdWV1ZVtjdXJyZW50XSA9IFJFQUNUX01FTU9fQ0FDSEVfU0VOVElORUw7XG4gICAgICBlbHNlXG4gICAgICAgIHVwZGF0ZVF1ZXVlLmxlbmd0aCAhPT0gc2l6ZSAmJlxuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICBcIkV4cGVjdGVkIGEgY29uc3RhbnQgc2l6ZSBhcmd1bWVudCBmb3IgZWFjaCBpbnZvY2F0aW9uIG9mIHVzZU1lbW9DYWNoZS4gVGhlIHByZXZpb3VzIGNhY2hlIHdhcyBhbGxvY2F0ZWQgd2l0aCBzaXplICVzIGJ1dCBzaXplICVzIHdhcyByZXF1ZXN0ZWQuXCIsXG4gICAgICAgICAgICB1cGRhdGVRdWV1ZS5sZW5ndGgsXG4gICAgICAgICAgICBzaXplXG4gICAgICAgICAgKTtcbiAgICAgIG1lbW9DYWNoZS5pbmRleCsrO1xuICAgICAgcmV0dXJuIHVwZGF0ZVF1ZXVlO1xuICAgIH1cbiAgICBmdW5jdGlvbiBiYXNpY1N0YXRlUmVkdWNlcihzdGF0ZSwgYWN0aW9uKSB7XG4gICAgICByZXR1cm4gXCJmdW5jdGlvblwiID09PSB0eXBlb2YgYWN0aW9uID8gYWN0aW9uKHN0YXRlKSA6IGFjdGlvbjtcbiAgICB9XG4gICAgZnVuY3Rpb24gbW91bnRSZWR1Y2VyKHJlZHVjZXIsIGluaXRpYWxBcmcsIGluaXQpIHtcbiAgICAgIHZhciBob29rID0gbW91bnRXb3JrSW5Qcm9ncmVzc0hvb2soKTtcbiAgICAgIGlmICh2b2lkIDAgIT09IGluaXQpIHtcbiAgICAgICAgdmFyIGluaXRpYWxTdGF0ZSA9IGluaXQoaW5pdGlhbEFyZyk7XG4gICAgICAgIGlmIChzaG91bGREb3VibGVJbnZva2VVc2VyRm5zSW5Ib29rc0RFVikge1xuICAgICAgICAgIHNldElzU3RyaWN0TW9kZUZvckRldnRvb2xzKCEwKTtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgaW5pdChpbml0aWFsQXJnKTtcbiAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgc2V0SXNTdHJpY3RNb2RlRm9yRGV2dG9vbHMoITEpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGluaXRpYWxTdGF0ZSA9IGluaXRpYWxBcmc7XG4gICAgICBob29rLm1lbW9pemVkU3RhdGUgPSBob29rLmJhc2VTdGF0ZSA9IGluaXRpYWxTdGF0ZTtcbiAgICAgIHJlZHVjZXIgPSB7XG4gICAgICAgIHBlbmRpbmc6IG51bGwsXG4gICAgICAgIGxhbmVzOiAwLFxuICAgICAgICBkaXNwYXRjaDogbnVsbCxcbiAgICAgICAgbGFzdFJlbmRlcmVkUmVkdWNlcjogcmVkdWNlcixcbiAgICAgICAgbGFzdFJlbmRlcmVkU3RhdGU6IGluaXRpYWxTdGF0ZVxuICAgICAgfTtcbiAgICAgIGhvb2sucXVldWUgPSByZWR1Y2VyO1xuICAgICAgcmVkdWNlciA9IHJlZHVjZXIuZGlzcGF0Y2ggPSBkaXNwYXRjaFJlZHVjZXJBY3Rpb24uYmluZChcbiAgICAgICAgbnVsbCxcbiAgICAgICAgY3VycmVudGx5UmVuZGVyaW5nRmliZXIkMSxcbiAgICAgICAgcmVkdWNlclxuICAgICAgKTtcbiAgICAgIHJldHVybiBbaG9vay5tZW1vaXplZFN0YXRlLCByZWR1Y2VyXTtcbiAgICB9XG4gICAgZnVuY3Rpb24gdXBkYXRlUmVkdWNlcihyZWR1Y2VyKSB7XG4gICAgICB2YXIgaG9vayA9IHVwZGF0ZVdvcmtJblByb2dyZXNzSG9vaygpO1xuICAgICAgcmV0dXJuIHVwZGF0ZVJlZHVjZXJJbXBsKGhvb2ssIGN1cnJlbnRIb29rLCByZWR1Y2VyKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gdXBkYXRlUmVkdWNlckltcGwoaG9vaywgY3VycmVudCwgcmVkdWNlcikge1xuICAgICAgdmFyIHF1ZXVlID0gaG9vay5xdWV1ZTtcbiAgICAgIGlmIChudWxsID09PSBxdWV1ZSlcbiAgICAgICAgdGhyb3cgRXJyb3IoXG4gICAgICAgICAgXCJTaG91bGQgaGF2ZSBhIHF1ZXVlLiBZb3UgYXJlIGxpa2VseSBjYWxsaW5nIEhvb2tzIGNvbmRpdGlvbmFsbHksIHdoaWNoIGlzIG5vdCBhbGxvd2VkLiAoaHR0cHM6Ly9yZWFjdC5kZXYvbGluay9pbnZhbGlkLWhvb2stY2FsbClcIlxuICAgICAgICApO1xuICAgICAgcXVldWUubGFzdFJlbmRlcmVkUmVkdWNlciA9IHJlZHVjZXI7XG4gICAgICB2YXIgYmFzZVF1ZXVlID0gaG9vay5iYXNlUXVldWUsXG4gICAgICAgIHBlbmRpbmdRdWV1ZSA9IHF1ZXVlLnBlbmRpbmc7XG4gICAgICBpZiAobnVsbCAhPT0gcGVuZGluZ1F1ZXVlKSB7XG4gICAgICAgIGlmIChudWxsICE9PSBiYXNlUXVldWUpIHtcbiAgICAgICAgICB2YXIgYmFzZUZpcnN0ID0gYmFzZVF1ZXVlLm5leHQ7XG4gICAgICAgICAgYmFzZVF1ZXVlLm5leHQgPSBwZW5kaW5nUXVldWUubmV4dDtcbiAgICAgICAgICBwZW5kaW5nUXVldWUubmV4dCA9IGJhc2VGaXJzdDtcbiAgICAgICAgfVxuICAgICAgICBjdXJyZW50LmJhc2VRdWV1ZSAhPT0gYmFzZVF1ZXVlICYmXG4gICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgIFwiSW50ZXJuYWwgZXJyb3I6IEV4cGVjdGVkIHdvcmstaW4tcHJvZ3Jlc3MgcXVldWUgdG8gYmUgYSBjbG9uZS4gVGhpcyBpcyBhIGJ1ZyBpbiBSZWFjdC5cIlxuICAgICAgICAgICk7XG4gICAgICAgIGN1cnJlbnQuYmFzZVF1ZXVlID0gYmFzZVF1ZXVlID0gcGVuZGluZ1F1ZXVlO1xuICAgICAgICBxdWV1ZS5wZW5kaW5nID0gbnVsbDtcbiAgICAgIH1cbiAgICAgIHBlbmRpbmdRdWV1ZSA9IGhvb2suYmFzZVN0YXRlO1xuICAgICAgaWYgKG51bGwgPT09IGJhc2VRdWV1ZSkgaG9vay5tZW1vaXplZFN0YXRlID0gcGVuZGluZ1F1ZXVlO1xuICAgICAgZWxzZSB7XG4gICAgICAgIGN1cnJlbnQgPSBiYXNlUXVldWUubmV4dDtcbiAgICAgICAgdmFyIG5ld0Jhc2VRdWV1ZUZpcnN0ID0gKGJhc2VGaXJzdCA9IG51bGwpLFxuICAgICAgICAgIG5ld0Jhc2VRdWV1ZUxhc3QgPSBudWxsLFxuICAgICAgICAgIHVwZGF0ZSA9IGN1cnJlbnQsXG4gICAgICAgICAgZGlkUmVhZEZyb21FbnRhbmdsZWRBc3luY0FjdGlvbiA9ICExO1xuICAgICAgICBkbyB7XG4gICAgICAgICAgdmFyIHVwZGF0ZUxhbmUgPSB1cGRhdGUubGFuZSAmIC01MzY4NzA5MTM7XG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgdXBkYXRlTGFuZSAhPT0gdXBkYXRlLmxhbmVcbiAgICAgICAgICAgICAgPyAod29ya0luUHJvZ3Jlc3NSb290UmVuZGVyTGFuZXMgJiB1cGRhdGVMYW5lKSA9PT0gdXBkYXRlTGFuZVxuICAgICAgICAgICAgICA6IChyZW5kZXJMYW5lcyAmIHVwZGF0ZUxhbmUpID09PSB1cGRhdGVMYW5lXG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICB2YXIgcmV2ZXJ0TGFuZSA9IHVwZGF0ZS5yZXZlcnRMYW5lO1xuICAgICAgICAgICAgaWYgKDAgPT09IHJldmVydExhbmUpXG4gICAgICAgICAgICAgIG51bGwgIT09IG5ld0Jhc2VRdWV1ZUxhc3QgJiZcbiAgICAgICAgICAgICAgICAobmV3QmFzZVF1ZXVlTGFzdCA9IG5ld0Jhc2VRdWV1ZUxhc3QubmV4dCA9XG4gICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIGxhbmU6IDAsXG4gICAgICAgICAgICAgICAgICAgIHJldmVydExhbmU6IDAsXG4gICAgICAgICAgICAgICAgICAgIGFjdGlvbjogdXBkYXRlLmFjdGlvbixcbiAgICAgICAgICAgICAgICAgICAgaGFzRWFnZXJTdGF0ZTogdXBkYXRlLmhhc0VhZ2VyU3RhdGUsXG4gICAgICAgICAgICAgICAgICAgIGVhZ2VyU3RhdGU6IHVwZGF0ZS5lYWdlclN0YXRlLFxuICAgICAgICAgICAgICAgICAgICBuZXh0OiBudWxsXG4gICAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICB1cGRhdGVMYW5lID09PSBjdXJyZW50RW50YW5nbGVkTGFuZSAmJlxuICAgICAgICAgICAgICAgICAgKGRpZFJlYWRGcm9tRW50YW5nbGVkQXN5bmNBY3Rpb24gPSAhMCk7XG4gICAgICAgICAgICBlbHNlIGlmICgocmVuZGVyTGFuZXMgJiByZXZlcnRMYW5lKSA9PT0gcmV2ZXJ0TGFuZSkge1xuICAgICAgICAgICAgICB1cGRhdGUgPSB1cGRhdGUubmV4dDtcbiAgICAgICAgICAgICAgcmV2ZXJ0TGFuZSA9PT0gY3VycmVudEVudGFuZ2xlZExhbmUgJiZcbiAgICAgICAgICAgICAgICAoZGlkUmVhZEZyb21FbnRhbmdsZWRBc3luY0FjdGlvbiA9ICEwKTtcbiAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9IGVsc2VcbiAgICAgICAgICAgICAgKHVwZGF0ZUxhbmUgPSB7XG4gICAgICAgICAgICAgICAgbGFuZTogMCxcbiAgICAgICAgICAgICAgICByZXZlcnRMYW5lOiB1cGRhdGUucmV2ZXJ0TGFuZSxcbiAgICAgICAgICAgICAgICBhY3Rpb246IHVwZGF0ZS5hY3Rpb24sXG4gICAgICAgICAgICAgICAgaGFzRWFnZXJTdGF0ZTogdXBkYXRlLmhhc0VhZ2VyU3RhdGUsXG4gICAgICAgICAgICAgICAgZWFnZXJTdGF0ZTogdXBkYXRlLmVhZ2VyU3RhdGUsXG4gICAgICAgICAgICAgICAgbmV4dDogbnVsbFxuICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICBudWxsID09PSBuZXdCYXNlUXVldWVMYXN0XG4gICAgICAgICAgICAgICAgICA/ICgobmV3QmFzZVF1ZXVlRmlyc3QgPSBuZXdCYXNlUXVldWVMYXN0ID0gdXBkYXRlTGFuZSksXG4gICAgICAgICAgICAgICAgICAgIChiYXNlRmlyc3QgPSBwZW5kaW5nUXVldWUpKVxuICAgICAgICAgICAgICAgICAgOiAobmV3QmFzZVF1ZXVlTGFzdCA9IG5ld0Jhc2VRdWV1ZUxhc3QubmV4dCA9IHVwZGF0ZUxhbmUpLFxuICAgICAgICAgICAgICAgIChjdXJyZW50bHlSZW5kZXJpbmdGaWJlciQxLmxhbmVzIHw9IHJldmVydExhbmUpLFxuICAgICAgICAgICAgICAgICh3b3JrSW5Qcm9ncmVzc1Jvb3RTa2lwcGVkTGFuZXMgfD0gcmV2ZXJ0TGFuZSk7XG4gICAgICAgICAgICB1cGRhdGVMYW5lID0gdXBkYXRlLmFjdGlvbjtcbiAgICAgICAgICAgIHNob3VsZERvdWJsZUludm9rZVVzZXJGbnNJbkhvb2tzREVWICYmXG4gICAgICAgICAgICAgIHJlZHVjZXIocGVuZGluZ1F1ZXVlLCB1cGRhdGVMYW5lKTtcbiAgICAgICAgICAgIHBlbmRpbmdRdWV1ZSA9IHVwZGF0ZS5oYXNFYWdlclN0YXRlXG4gICAgICAgICAgICAgID8gdXBkYXRlLmVhZ2VyU3RhdGVcbiAgICAgICAgICAgICAgOiByZWR1Y2VyKHBlbmRpbmdRdWV1ZSwgdXBkYXRlTGFuZSk7XG4gICAgICAgICAgfSBlbHNlXG4gICAgICAgICAgICAocmV2ZXJ0TGFuZSA9IHtcbiAgICAgICAgICAgICAgbGFuZTogdXBkYXRlTGFuZSxcbiAgICAgICAgICAgICAgcmV2ZXJ0TGFuZTogdXBkYXRlLnJldmVydExhbmUsXG4gICAgICAgICAgICAgIGFjdGlvbjogdXBkYXRlLmFjdGlvbixcbiAgICAgICAgICAgICAgaGFzRWFnZXJTdGF0ZTogdXBkYXRlLmhhc0VhZ2VyU3RhdGUsXG4gICAgICAgICAgICAgIGVhZ2VyU3RhdGU6IHVwZGF0ZS5lYWdlclN0YXRlLFxuICAgICAgICAgICAgICBuZXh0OiBudWxsXG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgbnVsbCA9PT0gbmV3QmFzZVF1ZXVlTGFzdFxuICAgICAgICAgICAgICAgID8gKChuZXdCYXNlUXVldWVGaXJzdCA9IG5ld0Jhc2VRdWV1ZUxhc3QgPSByZXZlcnRMYW5lKSxcbiAgICAgICAgICAgICAgICAgIChiYXNlRmlyc3QgPSBwZW5kaW5nUXVldWUpKVxuICAgICAgICAgICAgICAgIDogKG5ld0Jhc2VRdWV1ZUxhc3QgPSBuZXdCYXNlUXVldWVMYXN0Lm5leHQgPSByZXZlcnRMYW5lKSxcbiAgICAgICAgICAgICAgKGN1cnJlbnRseVJlbmRlcmluZ0ZpYmVyJDEubGFuZXMgfD0gdXBkYXRlTGFuZSksXG4gICAgICAgICAgICAgICh3b3JrSW5Qcm9ncmVzc1Jvb3RTa2lwcGVkTGFuZXMgfD0gdXBkYXRlTGFuZSk7XG4gICAgICAgICAgdXBkYXRlID0gdXBkYXRlLm5leHQ7XG4gICAgICAgIH0gd2hpbGUgKG51bGwgIT09IHVwZGF0ZSAmJiB1cGRhdGUgIT09IGN1cnJlbnQpO1xuICAgICAgICBudWxsID09PSBuZXdCYXNlUXVldWVMYXN0XG4gICAgICAgICAgPyAoYmFzZUZpcnN0ID0gcGVuZGluZ1F1ZXVlKVxuICAgICAgICAgIDogKG5ld0Jhc2VRdWV1ZUxhc3QubmV4dCA9IG5ld0Jhc2VRdWV1ZUZpcnN0KTtcbiAgICAgICAgaWYgKFxuICAgICAgICAgICFvYmplY3RJcyhwZW5kaW5nUXVldWUsIGhvb2subWVtb2l6ZWRTdGF0ZSkgJiZcbiAgICAgICAgICAoKGRpZFJlY2VpdmVVcGRhdGUgPSAhMCksXG4gICAgICAgICAgZGlkUmVhZEZyb21FbnRhbmdsZWRBc3luY0FjdGlvbiAmJlxuICAgICAgICAgICAgKChyZWR1Y2VyID0gY3VycmVudEVudGFuZ2xlZEFjdGlvblRoZW5hYmxlKSwgbnVsbCAhPT0gcmVkdWNlcikpXG4gICAgICAgIClcbiAgICAgICAgICB0aHJvdyByZWR1Y2VyO1xuICAgICAgICBob29rLm1lbW9pemVkU3RhdGUgPSBwZW5kaW5nUXVldWU7XG4gICAgICAgIGhvb2suYmFzZVN0YXRlID0gYmFzZUZpcnN0O1xuICAgICAgICBob29rLmJhc2VRdWV1ZSA9IG5ld0Jhc2VRdWV1ZUxhc3Q7XG4gICAgICAgIHF1ZXVlLmxhc3RSZW5kZXJlZFN0YXRlID0gcGVuZGluZ1F1ZXVlO1xuICAgICAgfVxuICAgICAgbnVsbCA9PT0gYmFzZVF1ZXVlICYmIChxdWV1ZS5sYW5lcyA9IDApO1xuICAgICAgcmV0dXJuIFtob29rLm1lbW9pemVkU3RhdGUsIHF1ZXVlLmRpc3BhdGNoXTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcmVyZW5kZXJSZWR1Y2VyKHJlZHVjZXIpIHtcbiAgICAgIHZhciBob29rID0gdXBkYXRlV29ya0luUHJvZ3Jlc3NIb29rKCksXG4gICAgICAgIHF1ZXVlID0gaG9vay5xdWV1ZTtcbiAgICAgIGlmIChudWxsID09PSBxdWV1ZSlcbiAgICAgICAgdGhyb3cgRXJyb3IoXG4gICAgICAgICAgXCJTaG91bGQgaGF2ZSBhIHF1ZXVlLiBZb3UgYXJlIGxpa2VseSBjYWxsaW5nIEhvb2tzIGNvbmRpdGlvbmFsbHksIHdoaWNoIGlzIG5vdCBhbGxvd2VkLiAoaHR0cHM6Ly9yZWFjdC5kZXYvbGluay9pbnZhbGlkLWhvb2stY2FsbClcIlxuICAgICAgICApO1xuICAgICAgcXVldWUubGFzdFJlbmRlcmVkUmVkdWNlciA9IHJlZHVjZXI7XG4gICAgICB2YXIgZGlzcGF0Y2ggPSBxdWV1ZS5kaXNwYXRjaCxcbiAgICAgICAgbGFzdFJlbmRlclBoYXNlVXBkYXRlID0gcXVldWUucGVuZGluZyxcbiAgICAgICAgbmV3U3RhdGUgPSBob29rLm1lbW9pemVkU3RhdGU7XG4gICAgICBpZiAobnVsbCAhPT0gbGFzdFJlbmRlclBoYXNlVXBkYXRlKSB7XG4gICAgICAgIHF1ZXVlLnBlbmRpbmcgPSBudWxsO1xuICAgICAgICB2YXIgdXBkYXRlID0gKGxhc3RSZW5kZXJQaGFzZVVwZGF0ZSA9IGxhc3RSZW5kZXJQaGFzZVVwZGF0ZS5uZXh0KTtcbiAgICAgICAgZG9cbiAgICAgICAgICAobmV3U3RhdGUgPSByZWR1Y2VyKG5ld1N0YXRlLCB1cGRhdGUuYWN0aW9uKSksICh1cGRhdGUgPSB1cGRhdGUubmV4dCk7XG4gICAgICAgIHdoaWxlICh1cGRhdGUgIT09IGxhc3RSZW5kZXJQaGFzZVVwZGF0ZSk7XG4gICAgICAgIG9iamVjdElzKG5ld1N0YXRlLCBob29rLm1lbW9pemVkU3RhdGUpIHx8IChkaWRSZWNlaXZlVXBkYXRlID0gITApO1xuICAgICAgICBob29rLm1lbW9pemVkU3RhdGUgPSBuZXdTdGF0ZTtcbiAgICAgICAgbnVsbCA9PT0gaG9vay5iYXNlUXVldWUgJiYgKGhvb2suYmFzZVN0YXRlID0gbmV3U3RhdGUpO1xuICAgICAgICBxdWV1ZS5sYXN0UmVuZGVyZWRTdGF0ZSA9IG5ld1N0YXRlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIFtuZXdTdGF0ZSwgZGlzcGF0Y2hdO1xuICAgIH1cbiAgICBmdW5jdGlvbiBtb3VudFN5bmNFeHRlcm5hbFN0b3JlKHN1YnNjcmliZSwgZ2V0U25hcHNob3QsIGdldFNlcnZlclNuYXBzaG90KSB7XG4gICAgICB2YXIgZmliZXIgPSBjdXJyZW50bHlSZW5kZXJpbmdGaWJlciQxLFxuICAgICAgICBob29rID0gbW91bnRXb3JrSW5Qcm9ncmVzc0hvb2soKTtcbiAgICAgIGlmIChpc0h5ZHJhdGluZykge1xuICAgICAgICBpZiAodm9pZCAwID09PSBnZXRTZXJ2ZXJTbmFwc2hvdClcbiAgICAgICAgICB0aHJvdyBFcnJvcihcbiAgICAgICAgICAgIFwiTWlzc2luZyBnZXRTZXJ2ZXJTbmFwc2hvdCwgd2hpY2ggaXMgcmVxdWlyZWQgZm9yIHNlcnZlci1yZW5kZXJlZCBjb250ZW50LiBXaWxsIHJldmVydCB0byBjbGllbnQgcmVuZGVyaW5nLlwiXG4gICAgICAgICAgKTtcbiAgICAgICAgdmFyIG5leHRTbmFwc2hvdCA9IGdldFNlcnZlclNuYXBzaG90KCk7XG4gICAgICAgIGRpZFdhcm5VbmNhY2hlZEdldFNuYXBzaG90IHx8XG4gICAgICAgICAgbmV4dFNuYXBzaG90ID09PSBnZXRTZXJ2ZXJTbmFwc2hvdCgpIHx8XG4gICAgICAgICAgKGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICBcIlRoZSByZXN1bHQgb2YgZ2V0U2VydmVyU25hcHNob3Qgc2hvdWxkIGJlIGNhY2hlZCB0byBhdm9pZCBhbiBpbmZpbml0ZSBsb29wXCJcbiAgICAgICAgICApLFxuICAgICAgICAgIChkaWRXYXJuVW5jYWNoZWRHZXRTbmFwc2hvdCA9ICEwKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBuZXh0U25hcHNob3QgPSBnZXRTbmFwc2hvdCgpO1xuICAgICAgICBkaWRXYXJuVW5jYWNoZWRHZXRTbmFwc2hvdCB8fFxuICAgICAgICAgICgoZ2V0U2VydmVyU25hcHNob3QgPSBnZXRTbmFwc2hvdCgpKSxcbiAgICAgICAgICBvYmplY3RJcyhuZXh0U25hcHNob3QsIGdldFNlcnZlclNuYXBzaG90KSB8fFxuICAgICAgICAgICAgKGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgIFwiVGhlIHJlc3VsdCBvZiBnZXRTbmFwc2hvdCBzaG91bGQgYmUgY2FjaGVkIHRvIGF2b2lkIGFuIGluZmluaXRlIGxvb3BcIlxuICAgICAgICAgICAgKSxcbiAgICAgICAgICAgIChkaWRXYXJuVW5jYWNoZWRHZXRTbmFwc2hvdCA9ICEwKSkpO1xuICAgICAgICBpZiAobnVsbCA9PT0gd29ya0luUHJvZ3Jlc3NSb290KVxuICAgICAgICAgIHRocm93IEVycm9yKFxuICAgICAgICAgICAgXCJFeHBlY3RlZCBhIHdvcmstaW4tcHJvZ3Jlc3Mgcm9vdC4gVGhpcyBpcyBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuXCJcbiAgICAgICAgICApO1xuICAgICAgICAwICE9PSAod29ya0luUHJvZ3Jlc3NSb290UmVuZGVyTGFuZXMgJiA2MCkgfHxcbiAgICAgICAgICBwdXNoU3RvcmVDb25zaXN0ZW5jeUNoZWNrKGZpYmVyLCBnZXRTbmFwc2hvdCwgbmV4dFNuYXBzaG90KTtcbiAgICAgIH1cbiAgICAgIGhvb2subWVtb2l6ZWRTdGF0ZSA9IG5leHRTbmFwc2hvdDtcbiAgICAgIGdldFNlcnZlclNuYXBzaG90ID0geyB2YWx1ZTogbmV4dFNuYXBzaG90LCBnZXRTbmFwc2hvdDogZ2V0U25hcHNob3QgfTtcbiAgICAgIGhvb2sucXVldWUgPSBnZXRTZXJ2ZXJTbmFwc2hvdDtcbiAgICAgIG1vdW50RWZmZWN0KFxuICAgICAgICBzdWJzY3JpYmVUb1N0b3JlLmJpbmQobnVsbCwgZmliZXIsIGdldFNlcnZlclNuYXBzaG90LCBzdWJzY3JpYmUpLFxuICAgICAgICBbc3Vic2NyaWJlXVxuICAgICAgKTtcbiAgICAgIGZpYmVyLmZsYWdzIHw9IDIwNDg7XG4gICAgICBwdXNoRWZmZWN0KFxuICAgICAgICBIYXNFZmZlY3QgfCBQYXNzaXZlLFxuICAgICAgICB1cGRhdGVTdG9yZUluc3RhbmNlLmJpbmQoXG4gICAgICAgICAgbnVsbCxcbiAgICAgICAgICBmaWJlcixcbiAgICAgICAgICBnZXRTZXJ2ZXJTbmFwc2hvdCxcbiAgICAgICAgICBuZXh0U25hcHNob3QsXG4gICAgICAgICAgZ2V0U25hcHNob3RcbiAgICAgICAgKSxcbiAgICAgICAgeyBkZXN0cm95OiB2b2lkIDAgfSxcbiAgICAgICAgbnVsbFxuICAgICAgKTtcbiAgICAgIHJldHVybiBuZXh0U25hcHNob3Q7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHVwZGF0ZVN5bmNFeHRlcm5hbFN0b3JlKFxuICAgICAgc3Vic2NyaWJlLFxuICAgICAgZ2V0U25hcHNob3QsXG4gICAgICBnZXRTZXJ2ZXJTbmFwc2hvdFxuICAgICkge1xuICAgICAgdmFyIGZpYmVyID0gY3VycmVudGx5UmVuZGVyaW5nRmliZXIkMSxcbiAgICAgICAgaG9vayA9IHVwZGF0ZVdvcmtJblByb2dyZXNzSG9vaygpLFxuICAgICAgICBpc0h5ZHJhdGluZyRqc2NvbXAkMCA9IGlzSHlkcmF0aW5nO1xuICAgICAgaWYgKGlzSHlkcmF0aW5nJGpzY29tcCQwKSB7XG4gICAgICAgIGlmICh2b2lkIDAgPT09IGdldFNlcnZlclNuYXBzaG90KVxuICAgICAgICAgIHRocm93IEVycm9yKFxuICAgICAgICAgICAgXCJNaXNzaW5nIGdldFNlcnZlclNuYXBzaG90LCB3aGljaCBpcyByZXF1aXJlZCBmb3Igc2VydmVyLXJlbmRlcmVkIGNvbnRlbnQuIFdpbGwgcmV2ZXJ0IHRvIGNsaWVudCByZW5kZXJpbmcuXCJcbiAgICAgICAgICApO1xuICAgICAgICBnZXRTZXJ2ZXJTbmFwc2hvdCA9IGdldFNlcnZlclNuYXBzaG90KCk7XG4gICAgICB9IGVsc2UgaWYgKFxuICAgICAgICAoKGdldFNlcnZlclNuYXBzaG90ID0gZ2V0U25hcHNob3QoKSksICFkaWRXYXJuVW5jYWNoZWRHZXRTbmFwc2hvdClcbiAgICAgICkge1xuICAgICAgICB2YXIgY2FjaGVkU25hcHNob3QgPSBnZXRTbmFwc2hvdCgpO1xuICAgICAgICBvYmplY3RJcyhnZXRTZXJ2ZXJTbmFwc2hvdCwgY2FjaGVkU25hcHNob3QpIHx8XG4gICAgICAgICAgKGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICBcIlRoZSByZXN1bHQgb2YgZ2V0U25hcHNob3Qgc2hvdWxkIGJlIGNhY2hlZCB0byBhdm9pZCBhbiBpbmZpbml0ZSBsb29wXCJcbiAgICAgICAgICApLFxuICAgICAgICAgIChkaWRXYXJuVW5jYWNoZWRHZXRTbmFwc2hvdCA9ICEwKSk7XG4gICAgICB9XG4gICAgICBpZiAoXG4gICAgICAgIChjYWNoZWRTbmFwc2hvdCA9ICFvYmplY3RJcyhcbiAgICAgICAgICAoY3VycmVudEhvb2sgfHwgaG9vaykubWVtb2l6ZWRTdGF0ZSxcbiAgICAgICAgICBnZXRTZXJ2ZXJTbmFwc2hvdFxuICAgICAgICApKVxuICAgICAgKVxuICAgICAgICAoaG9vay5tZW1vaXplZFN0YXRlID0gZ2V0U2VydmVyU25hcHNob3QpLCAoZGlkUmVjZWl2ZVVwZGF0ZSA9ICEwKTtcbiAgICAgIGhvb2sgPSBob29rLnF1ZXVlO1xuICAgICAgdmFyIGNyZWF0ZSA9IHN1YnNjcmliZVRvU3RvcmUuYmluZChudWxsLCBmaWJlciwgaG9vaywgc3Vic2NyaWJlKTtcbiAgICAgIHVwZGF0ZUVmZmVjdEltcGwoMjA0OCwgUGFzc2l2ZSwgY3JlYXRlLCBbc3Vic2NyaWJlXSk7XG4gICAgICBpZiAoXG4gICAgICAgIGhvb2suZ2V0U25hcHNob3QgIT09IGdldFNuYXBzaG90IHx8XG4gICAgICAgIGNhY2hlZFNuYXBzaG90IHx8XG4gICAgICAgIChudWxsICE9PSB3b3JrSW5Qcm9ncmVzc0hvb2sgJiZcbiAgICAgICAgICB3b3JrSW5Qcm9ncmVzc0hvb2subWVtb2l6ZWRTdGF0ZS50YWcgJiBIYXNFZmZlY3QpXG4gICAgICApIHtcbiAgICAgICAgZmliZXIuZmxhZ3MgfD0gMjA0ODtcbiAgICAgICAgcHVzaEVmZmVjdChcbiAgICAgICAgICBIYXNFZmZlY3QgfCBQYXNzaXZlLFxuICAgICAgICAgIHVwZGF0ZVN0b3JlSW5zdGFuY2UuYmluZChcbiAgICAgICAgICAgIG51bGwsXG4gICAgICAgICAgICBmaWJlcixcbiAgICAgICAgICAgIGhvb2ssXG4gICAgICAgICAgICBnZXRTZXJ2ZXJTbmFwc2hvdCxcbiAgICAgICAgICAgIGdldFNuYXBzaG90XG4gICAgICAgICAgKSxcbiAgICAgICAgICB7IGRlc3Ryb3k6IHZvaWQgMCB9LFxuICAgICAgICAgIG51bGxcbiAgICAgICAgKTtcbiAgICAgICAgaWYgKG51bGwgPT09IHdvcmtJblByb2dyZXNzUm9vdClcbiAgICAgICAgICB0aHJvdyBFcnJvcihcbiAgICAgICAgICAgIFwiRXhwZWN0ZWQgYSB3b3JrLWluLXByb2dyZXNzIHJvb3QuIFRoaXMgaXMgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLlwiXG4gICAgICAgICAgKTtcbiAgICAgICAgaXNIeWRyYXRpbmckanNjb21wJDAgfHxcbiAgICAgICAgICAwICE9PSAocmVuZGVyTGFuZXMgJiA2MCkgfHxcbiAgICAgICAgICBwdXNoU3RvcmVDb25zaXN0ZW5jeUNoZWNrKGZpYmVyLCBnZXRTbmFwc2hvdCwgZ2V0U2VydmVyU25hcHNob3QpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGdldFNlcnZlclNuYXBzaG90O1xuICAgIH1cbiAgICBmdW5jdGlvbiBwdXNoU3RvcmVDb25zaXN0ZW5jeUNoZWNrKGZpYmVyLCBnZXRTbmFwc2hvdCwgcmVuZGVyZWRTbmFwc2hvdCkge1xuICAgICAgZmliZXIuZmxhZ3MgfD0gMTYzODQ7XG4gICAgICBmaWJlciA9IHsgZ2V0U25hcHNob3Q6IGdldFNuYXBzaG90LCB2YWx1ZTogcmVuZGVyZWRTbmFwc2hvdCB9O1xuICAgICAgZ2V0U25hcHNob3QgPSBjdXJyZW50bHlSZW5kZXJpbmdGaWJlciQxLnVwZGF0ZVF1ZXVlO1xuICAgICAgbnVsbCA9PT0gZ2V0U25hcHNob3RcbiAgICAgICAgPyAoKGdldFNuYXBzaG90ID0gY3JlYXRlRnVuY3Rpb25Db21wb25lbnRVcGRhdGVRdWV1ZSgpKSxcbiAgICAgICAgICAoY3VycmVudGx5UmVuZGVyaW5nRmliZXIkMS51cGRhdGVRdWV1ZSA9IGdldFNuYXBzaG90KSxcbiAgICAgICAgICAoZ2V0U25hcHNob3Quc3RvcmVzID0gW2ZpYmVyXSkpXG4gICAgICAgIDogKChyZW5kZXJlZFNuYXBzaG90ID0gZ2V0U25hcHNob3Quc3RvcmVzKSxcbiAgICAgICAgICBudWxsID09PSByZW5kZXJlZFNuYXBzaG90XG4gICAgICAgICAgICA/IChnZXRTbmFwc2hvdC5zdG9yZXMgPSBbZmliZXJdKVxuICAgICAgICAgICAgOiByZW5kZXJlZFNuYXBzaG90LnB1c2goZmliZXIpKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gdXBkYXRlU3RvcmVJbnN0YW5jZShmaWJlciwgaW5zdCwgbmV4dFNuYXBzaG90LCBnZXRTbmFwc2hvdCkge1xuICAgICAgaW5zdC52YWx1ZSA9IG5leHRTbmFwc2hvdDtcbiAgICAgIGluc3QuZ2V0U25hcHNob3QgPSBnZXRTbmFwc2hvdDtcbiAgICAgIGNoZWNrSWZTbmFwc2hvdENoYW5nZWQoaW5zdCkgJiYgZm9yY2VTdG9yZVJlcmVuZGVyKGZpYmVyKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gc3Vic2NyaWJlVG9TdG9yZShmaWJlciwgaW5zdCwgc3Vic2NyaWJlKSB7XG4gICAgICByZXR1cm4gc3Vic2NyaWJlKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY2hlY2tJZlNuYXBzaG90Q2hhbmdlZChpbnN0KSAmJiBmb3JjZVN0b3JlUmVyZW5kZXIoZmliZXIpO1xuICAgICAgfSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNoZWNrSWZTbmFwc2hvdENoYW5nZWQoaW5zdCkge1xuICAgICAgdmFyIGxhdGVzdEdldFNuYXBzaG90ID0gaW5zdC5nZXRTbmFwc2hvdDtcbiAgICAgIGluc3QgPSBpbnN0LnZhbHVlO1xuICAgICAgdHJ5IHtcbiAgICAgICAgdmFyIG5leHRWYWx1ZSA9IGxhdGVzdEdldFNuYXBzaG90KCk7XG4gICAgICAgIHJldHVybiAhb2JqZWN0SXMoaW5zdCwgbmV4dFZhbHVlKTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIHJldHVybiAhMDtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gZm9yY2VTdG9yZVJlcmVuZGVyKGZpYmVyKSB7XG4gICAgICB2YXIgcm9vdCA9IGVucXVldWVDb25jdXJyZW50UmVuZGVyRm9yTGFuZShmaWJlciwgMik7XG4gICAgICBudWxsICE9PSByb290ICYmIHNjaGVkdWxlVXBkYXRlT25GaWJlcihyb290LCBmaWJlciwgMik7XG4gICAgfVxuICAgIGZ1bmN0aW9uIG1vdW50U3RhdGVJbXBsKGluaXRpYWxTdGF0ZSkge1xuICAgICAgdmFyIGhvb2sgPSBtb3VudFdvcmtJblByb2dyZXNzSG9vaygpO1xuICAgICAgaWYgKFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIGluaXRpYWxTdGF0ZSkge1xuICAgICAgICB2YXIgaW5pdGlhbFN0YXRlSW5pdGlhbGl6ZXIgPSBpbml0aWFsU3RhdGU7XG4gICAgICAgIGluaXRpYWxTdGF0ZSA9IGluaXRpYWxTdGF0ZUluaXRpYWxpemVyKCk7XG4gICAgICAgIGlmIChzaG91bGREb3VibGVJbnZva2VVc2VyRm5zSW5Ib29rc0RFVikge1xuICAgICAgICAgIHNldElzU3RyaWN0TW9kZUZvckRldnRvb2xzKCEwKTtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgaW5pdGlhbFN0YXRlSW5pdGlhbGl6ZXIoKTtcbiAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgc2V0SXNTdHJpY3RNb2RlRm9yRGV2dG9vbHMoITEpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaG9vay5tZW1vaXplZFN0YXRlID0gaG9vay5iYXNlU3RhdGUgPSBpbml0aWFsU3RhdGU7XG4gICAgICBob29rLnF1ZXVlID0ge1xuICAgICAgICBwZW5kaW5nOiBudWxsLFxuICAgICAgICBsYW5lczogMCxcbiAgICAgICAgZGlzcGF0Y2g6IG51bGwsXG4gICAgICAgIGxhc3RSZW5kZXJlZFJlZHVjZXI6IGJhc2ljU3RhdGVSZWR1Y2VyLFxuICAgICAgICBsYXN0UmVuZGVyZWRTdGF0ZTogaW5pdGlhbFN0YXRlXG4gICAgICB9O1xuICAgICAgcmV0dXJuIGhvb2s7XG4gICAgfVxuICAgIGZ1bmN0aW9uIG1vdW50U3RhdGUoaW5pdGlhbFN0YXRlKSB7XG4gICAgICBpbml0aWFsU3RhdGUgPSBtb3VudFN0YXRlSW1wbChpbml0aWFsU3RhdGUpO1xuICAgICAgdmFyIHF1ZXVlID0gaW5pdGlhbFN0YXRlLnF1ZXVlLFxuICAgICAgICBkaXNwYXRjaCA9IGRpc3BhdGNoU2V0U3RhdGUuYmluZChcbiAgICAgICAgICBudWxsLFxuICAgICAgICAgIGN1cnJlbnRseVJlbmRlcmluZ0ZpYmVyJDEsXG4gICAgICAgICAgcXVldWVcbiAgICAgICAgKTtcbiAgICAgIHF1ZXVlLmRpc3BhdGNoID0gZGlzcGF0Y2g7XG4gICAgICByZXR1cm4gW2luaXRpYWxTdGF0ZS5tZW1vaXplZFN0YXRlLCBkaXNwYXRjaF07XG4gICAgfVxuICAgIGZ1bmN0aW9uIG1vdW50T3B0aW1pc3RpYyhwYXNzdGhyb3VnaCkge1xuICAgICAgdmFyIGhvb2sgPSBtb3VudFdvcmtJblByb2dyZXNzSG9vaygpO1xuICAgICAgaG9vay5tZW1vaXplZFN0YXRlID0gaG9vay5iYXNlU3RhdGUgPSBwYXNzdGhyb3VnaDtcbiAgICAgIHZhciBxdWV1ZSA9IHtcbiAgICAgICAgcGVuZGluZzogbnVsbCxcbiAgICAgICAgbGFuZXM6IDAsXG4gICAgICAgIGRpc3BhdGNoOiBudWxsLFxuICAgICAgICBsYXN0UmVuZGVyZWRSZWR1Y2VyOiBudWxsLFxuICAgICAgICBsYXN0UmVuZGVyZWRTdGF0ZTogbnVsbFxuICAgICAgfTtcbiAgICAgIGhvb2sucXVldWUgPSBxdWV1ZTtcbiAgICAgIGhvb2sgPSBkaXNwYXRjaE9wdGltaXN0aWNTZXRTdGF0ZS5iaW5kKFxuICAgICAgICBudWxsLFxuICAgICAgICBjdXJyZW50bHlSZW5kZXJpbmdGaWJlciQxLFxuICAgICAgICAhMCxcbiAgICAgICAgcXVldWVcbiAgICAgICk7XG4gICAgICBxdWV1ZS5kaXNwYXRjaCA9IGhvb2s7XG4gICAgICByZXR1cm4gW3Bhc3N0aHJvdWdoLCBob29rXTtcbiAgICB9XG4gICAgZnVuY3Rpb24gdXBkYXRlT3B0aW1pc3RpYyhwYXNzdGhyb3VnaCwgcmVkdWNlcikge1xuICAgICAgdmFyIGhvb2sgPSB1cGRhdGVXb3JrSW5Qcm9ncmVzc0hvb2soKTtcbiAgICAgIHJldHVybiB1cGRhdGVPcHRpbWlzdGljSW1wbChob29rLCBjdXJyZW50SG9vaywgcGFzc3Rocm91Z2gsIHJlZHVjZXIpO1xuICAgIH1cbiAgICBmdW5jdGlvbiB1cGRhdGVPcHRpbWlzdGljSW1wbChob29rLCBjdXJyZW50LCBwYXNzdGhyb3VnaCwgcmVkdWNlcikge1xuICAgICAgaG9vay5iYXNlU3RhdGUgPSBwYXNzdGhyb3VnaDtcbiAgICAgIHJldHVybiB1cGRhdGVSZWR1Y2VySW1wbChcbiAgICAgICAgaG9vayxcbiAgICAgICAgY3VycmVudEhvb2ssXG4gICAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIHJlZHVjZXIgPyByZWR1Y2VyIDogYmFzaWNTdGF0ZVJlZHVjZXJcbiAgICAgICk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlcmVuZGVyT3B0aW1pc3RpYyhwYXNzdGhyb3VnaCwgcmVkdWNlcikge1xuICAgICAgdmFyIGhvb2sgPSB1cGRhdGVXb3JrSW5Qcm9ncmVzc0hvb2soKTtcbiAgICAgIGlmIChudWxsICE9PSBjdXJyZW50SG9vaylcbiAgICAgICAgcmV0dXJuIHVwZGF0ZU9wdGltaXN0aWNJbXBsKGhvb2ssIGN1cnJlbnRIb29rLCBwYXNzdGhyb3VnaCwgcmVkdWNlcik7XG4gICAgICBob29rLmJhc2VTdGF0ZSA9IHBhc3N0aHJvdWdoO1xuICAgICAgcmV0dXJuIFtwYXNzdGhyb3VnaCwgaG9vay5xdWV1ZS5kaXNwYXRjaF07XG4gICAgfVxuICAgIGZ1bmN0aW9uIGRpc3BhdGNoQWN0aW9uU3RhdGUoXG4gICAgICBmaWJlcixcbiAgICAgIGFjdGlvblF1ZXVlLFxuICAgICAgc2V0UGVuZGluZ1N0YXRlLFxuICAgICAgc2V0U3RhdGUsXG4gICAgICBwYXlsb2FkXG4gICAgKSB7XG4gICAgICBpZiAoaXNSZW5kZXJQaGFzZVVwZGF0ZShmaWJlcikpXG4gICAgICAgIHRocm93IEVycm9yKFwiQ2Fubm90IHVwZGF0ZSBmb3JtIHN0YXRlIHdoaWxlIHJlbmRlcmluZy5cIik7XG4gICAgICBmaWJlciA9IGFjdGlvblF1ZXVlLmFjdGlvbjtcbiAgICAgIGlmIChudWxsICE9PSBmaWJlcikge1xuICAgICAgICB2YXIgYWN0aW9uTm9kZSA9IHtcbiAgICAgICAgICBwYXlsb2FkOiBwYXlsb2FkLFxuICAgICAgICAgIGFjdGlvbjogZmliZXIsXG4gICAgICAgICAgbmV4dDogbnVsbCxcbiAgICAgICAgICBpc1RyYW5zaXRpb246ICEwLFxuICAgICAgICAgIHN0YXR1czogXCJwZW5kaW5nXCIsXG4gICAgICAgICAgdmFsdWU6IG51bGwsXG4gICAgICAgICAgcmVhc29uOiBudWxsLFxuICAgICAgICAgIGxpc3RlbmVyczogW10sXG4gICAgICAgICAgdGhlbjogZnVuY3Rpb24gKGxpc3RlbmVyKSB7XG4gICAgICAgICAgICBhY3Rpb25Ob2RlLmxpc3RlbmVycy5wdXNoKGxpc3RlbmVyKTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIG51bGwgIT09IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlRcbiAgICAgICAgICA/IHNldFBlbmRpbmdTdGF0ZSghMClcbiAgICAgICAgICA6IChhY3Rpb25Ob2RlLmlzVHJhbnNpdGlvbiA9ICExKTtcbiAgICAgICAgc2V0U3RhdGUoYWN0aW9uTm9kZSk7XG4gICAgICAgIHNldFBlbmRpbmdTdGF0ZSA9IGFjdGlvblF1ZXVlLnBlbmRpbmc7XG4gICAgICAgIG51bGwgPT09IHNldFBlbmRpbmdTdGF0ZVxuICAgICAgICAgID8gKChhY3Rpb25Ob2RlLm5leHQgPSBhY3Rpb25RdWV1ZS5wZW5kaW5nID0gYWN0aW9uTm9kZSksXG4gICAgICAgICAgICBydW5BY3Rpb25TdGF0ZUFjdGlvbihhY3Rpb25RdWV1ZSwgYWN0aW9uTm9kZSkpXG4gICAgICAgICAgOiAoKGFjdGlvbk5vZGUubmV4dCA9IHNldFBlbmRpbmdTdGF0ZS5uZXh0KSxcbiAgICAgICAgICAgIChhY3Rpb25RdWV1ZS5wZW5kaW5nID0gc2V0UGVuZGluZ1N0YXRlLm5leHQgPSBhY3Rpb25Ob2RlKSk7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJ1bkFjdGlvblN0YXRlQWN0aW9uKGFjdGlvblF1ZXVlLCBub2RlKSB7XG4gICAgICB2YXIgYWN0aW9uID0gbm9kZS5hY3Rpb24sXG4gICAgICAgIHBheWxvYWQgPSBub2RlLnBheWxvYWQsXG4gICAgICAgIHByZXZTdGF0ZSA9IGFjdGlvblF1ZXVlLnN0YXRlO1xuICAgICAgaWYgKG5vZGUuaXNUcmFuc2l0aW9uKSB7XG4gICAgICAgIHZhciBwcmV2VHJhbnNpdGlvbiA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlQsXG4gICAgICAgICAgY3VycmVudFRyYW5zaXRpb24gPSB7fTtcbiAgICAgICAgUmVhY3RTaGFyZWRJbnRlcm5hbHMuVCA9IGN1cnJlbnRUcmFuc2l0aW9uO1xuICAgICAgICBSZWFjdFNoYXJlZEludGVybmFscy5ULl91cGRhdGVkRmliZXJzID0gbmV3IFNldCgpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHZhciByZXR1cm5WYWx1ZSA9IGFjdGlvbihwcmV2U3RhdGUsIHBheWxvYWQpLFxuICAgICAgICAgICAgb25TdGFydFRyYW5zaXRpb25GaW5pc2ggPSBSZWFjdFNoYXJlZEludGVybmFscy5TO1xuICAgICAgICAgIG51bGwgIT09IG9uU3RhcnRUcmFuc2l0aW9uRmluaXNoICYmXG4gICAgICAgICAgICBvblN0YXJ0VHJhbnNpdGlvbkZpbmlzaChjdXJyZW50VHJhbnNpdGlvbiwgcmV0dXJuVmFsdWUpO1xuICAgICAgICAgIGhhbmRsZUFjdGlvblJldHVyblZhbHVlKGFjdGlvblF1ZXVlLCBub2RlLCByZXR1cm5WYWx1ZSk7XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgb25BY3Rpb25FcnJvcihhY3Rpb25RdWV1ZSwgbm9kZSwgZXJyb3IpO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIChSZWFjdFNoYXJlZEludGVybmFscy5UID0gcHJldlRyYW5zaXRpb24pLFxuICAgICAgICAgICAgbnVsbCA9PT0gcHJldlRyYW5zaXRpb24gJiZcbiAgICAgICAgICAgICAgY3VycmVudFRyYW5zaXRpb24uX3VwZGF0ZWRGaWJlcnMgJiZcbiAgICAgICAgICAgICAgKChhY3Rpb25RdWV1ZSA9IGN1cnJlbnRUcmFuc2l0aW9uLl91cGRhdGVkRmliZXJzLnNpemUpLFxuICAgICAgICAgICAgICBjdXJyZW50VHJhbnNpdGlvbi5fdXBkYXRlZEZpYmVycy5jbGVhcigpLFxuICAgICAgICAgICAgICAxMCA8IGFjdGlvblF1ZXVlICYmXG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICAgICAgICAgICAgXCJEZXRlY3RlZCBhIGxhcmdlIG51bWJlciBvZiB1cGRhdGVzIGluc2lkZSBzdGFydFRyYW5zaXRpb24uIElmIHRoaXMgaXMgZHVlIHRvIGEgc3Vic2NyaXB0aW9uIHBsZWFzZSByZS13cml0ZSBpdCB0byB1c2UgUmVhY3QgcHJvdmlkZWQgaG9va3MuIE90aGVyd2lzZSBjb25jdXJyZW50IG1vZGUgZ3VhcmFudGVlcyBhcmUgb2ZmIHRoZSB0YWJsZS5cIlxuICAgICAgICAgICAgICAgICkpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2VcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAoY3VycmVudFRyYW5zaXRpb24gPSBhY3Rpb24ocHJldlN0YXRlLCBwYXlsb2FkKSksXG4gICAgICAgICAgICBoYW5kbGVBY3Rpb25SZXR1cm5WYWx1ZShhY3Rpb25RdWV1ZSwgbm9kZSwgY3VycmVudFRyYW5zaXRpb24pO1xuICAgICAgICB9IGNhdGNoIChlcnJvciQyKSB7XG4gICAgICAgICAgb25BY3Rpb25FcnJvcihhY3Rpb25RdWV1ZSwgbm9kZSwgZXJyb3IkMik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gaGFuZGxlQWN0aW9uUmV0dXJuVmFsdWUoYWN0aW9uUXVldWUsIG5vZGUsIHJldHVyblZhbHVlKSB7XG4gICAgICBudWxsICE9PSByZXR1cm5WYWx1ZSAmJlxuICAgICAgXCJvYmplY3RcIiA9PT0gdHlwZW9mIHJldHVyblZhbHVlICYmXG4gICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiByZXR1cm5WYWx1ZS50aGVuXG4gICAgICAgID8gKHJldHVyblZhbHVlLnRoZW4oXG4gICAgICAgICAgICBmdW5jdGlvbiAobmV4dFN0YXRlKSB7XG4gICAgICAgICAgICAgIG9uQWN0aW9uU3VjY2VzcyhhY3Rpb25RdWV1ZSwgbm9kZSwgbmV4dFN0YXRlKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIG9uQWN0aW9uRXJyb3IoYWN0aW9uUXVldWUsIG5vZGUsIGVycm9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICApLFxuICAgICAgICAgIG5vZGUuaXNUcmFuc2l0aW9uIHx8XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICBcIkFuIGFzeW5jIGZ1bmN0aW9uIHdhcyBwYXNzZWQgdG8gdXNlQWN0aW9uU3RhdGUsIGJ1dCBpdCB3YXMgZGlzcGF0Y2hlZCBvdXRzaWRlIG9mIGFuIGFjdGlvbiBjb250ZXh0LiBUaGlzIGlzIGxpa2VseSBub3Qgd2hhdCB5b3UgaW50ZW5kZWQuIEVpdGhlciBwYXNzIHRoZSBkaXNwYXRjaCBmdW5jdGlvbiB0byBhbiBgYWN0aW9uYCBwcm9wLCBvciBkaXNwYXRjaCBtYW51YWxseSBpbnNpZGUgYHN0YXJ0VHJhbnNpdGlvbmBcIlxuICAgICAgICAgICAgKSlcbiAgICAgICAgOiBvbkFjdGlvblN1Y2Nlc3MoYWN0aW9uUXVldWUsIG5vZGUsIHJldHVyblZhbHVlKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gb25BY3Rpb25TdWNjZXNzKGFjdGlvblF1ZXVlLCBhY3Rpb25Ob2RlLCBuZXh0U3RhdGUpIHtcbiAgICAgIGFjdGlvbk5vZGUuc3RhdHVzID0gXCJmdWxmaWxsZWRcIjtcbiAgICAgIGFjdGlvbk5vZGUudmFsdWUgPSBuZXh0U3RhdGU7XG4gICAgICBub3RpZnlBY3Rpb25MaXN0ZW5lcnMoYWN0aW9uTm9kZSk7XG4gICAgICBhY3Rpb25RdWV1ZS5zdGF0ZSA9IG5leHRTdGF0ZTtcbiAgICAgIGFjdGlvbk5vZGUgPSBhY3Rpb25RdWV1ZS5wZW5kaW5nO1xuICAgICAgbnVsbCAhPT0gYWN0aW9uTm9kZSAmJlxuICAgICAgICAoKG5leHRTdGF0ZSA9IGFjdGlvbk5vZGUubmV4dCksXG4gICAgICAgIG5leHRTdGF0ZSA9PT0gYWN0aW9uTm9kZVxuICAgICAgICAgID8gKGFjdGlvblF1ZXVlLnBlbmRpbmcgPSBudWxsKVxuICAgICAgICAgIDogKChuZXh0U3RhdGUgPSBuZXh0U3RhdGUubmV4dCksXG4gICAgICAgICAgICAoYWN0aW9uTm9kZS5uZXh0ID0gbmV4dFN0YXRlKSxcbiAgICAgICAgICAgIHJ1bkFjdGlvblN0YXRlQWN0aW9uKGFjdGlvblF1ZXVlLCBuZXh0U3RhdGUpKSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIG9uQWN0aW9uRXJyb3IoYWN0aW9uUXVldWUsIGFjdGlvbk5vZGUsIGVycm9yKSB7XG4gICAgICB2YXIgbGFzdCA9IGFjdGlvblF1ZXVlLnBlbmRpbmc7XG4gICAgICBhY3Rpb25RdWV1ZS5wZW5kaW5nID0gbnVsbDtcbiAgICAgIGlmIChudWxsICE9PSBsYXN0KSB7XG4gICAgICAgIGxhc3QgPSBsYXN0Lm5leHQ7XG4gICAgICAgIGRvXG4gICAgICAgICAgKGFjdGlvbk5vZGUuc3RhdHVzID0gXCJyZWplY3RlZFwiKSxcbiAgICAgICAgICAgIChhY3Rpb25Ob2RlLnJlYXNvbiA9IGVycm9yKSxcbiAgICAgICAgICAgIG5vdGlmeUFjdGlvbkxpc3RlbmVycyhhY3Rpb25Ob2RlKSxcbiAgICAgICAgICAgIChhY3Rpb25Ob2RlID0gYWN0aW9uTm9kZS5uZXh0KTtcbiAgICAgICAgd2hpbGUgKGFjdGlvbk5vZGUgIT09IGxhc3QpO1xuICAgICAgfVxuICAgICAgYWN0aW9uUXVldWUuYWN0aW9uID0gbnVsbDtcbiAgICB9XG4gICAgZnVuY3Rpb24gbm90aWZ5QWN0aW9uTGlzdGVuZXJzKGFjdGlvbk5vZGUpIHtcbiAgICAgIGFjdGlvbk5vZGUgPSBhY3Rpb25Ob2RlLmxpc3RlbmVycztcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYWN0aW9uTm9kZS5sZW5ndGg7IGkrKykgKDAsIGFjdGlvbk5vZGVbaV0pKCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGFjdGlvblN0YXRlUmVkdWNlcihvbGRTdGF0ZSwgbmV3U3RhdGUpIHtcbiAgICAgIHJldHVybiBuZXdTdGF0ZTtcbiAgICB9XG4gICAgZnVuY3Rpb24gbW91bnRBY3Rpb25TdGF0ZShhY3Rpb24sIGluaXRpYWxTdGF0ZVByb3ApIHtcbiAgICAgIGlmIChpc0h5ZHJhdGluZykge1xuICAgICAgICB2YXIgc3NyRm9ybVN0YXRlID0gd29ya0luUHJvZ3Jlc3NSb290LmZvcm1TdGF0ZTtcbiAgICAgICAgaWYgKG51bGwgIT09IHNzckZvcm1TdGF0ZSkge1xuICAgICAgICAgIGE6IHtcbiAgICAgICAgICAgIHZhciBpc01hdGNoaW5nID0gY3VycmVudGx5UmVuZGVyaW5nRmliZXIkMTtcbiAgICAgICAgICAgIGlmIChpc0h5ZHJhdGluZykge1xuICAgICAgICAgICAgICBpZiAobmV4dEh5ZHJhdGFibGVJbnN0YW5jZSkge1xuICAgICAgICAgICAgICAgIHZhciBtYXJrZXJJbnN0YW5jZSA9IGNhbkh5ZHJhdGVGb3JtU3RhdGVNYXJrZXIoXG4gICAgICAgICAgICAgICAgICBuZXh0SHlkcmF0YWJsZUluc3RhbmNlLFxuICAgICAgICAgICAgICAgICAgcm9vdE9yU2luZ2xldG9uQ29udGV4dFxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgaWYgKG1hcmtlckluc3RhbmNlKSB7XG4gICAgICAgICAgICAgICAgICBuZXh0SHlkcmF0YWJsZUluc3RhbmNlID1cbiAgICAgICAgICAgICAgICAgICAgZ2V0TmV4dEh5ZHJhdGFibGVTaWJsaW5nKG1hcmtlckluc3RhbmNlKTtcbiAgICAgICAgICAgICAgICAgIGlzTWF0Y2hpbmcgPSBpc0Zvcm1TdGF0ZU1hcmtlck1hdGNoaW5nKG1hcmtlckluc3RhbmNlKTtcbiAgICAgICAgICAgICAgICAgIGJyZWFrIGE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHRocm93T25IeWRyYXRpb25NaXNtYXRjaChpc01hdGNoaW5nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlzTWF0Y2hpbmcgPSAhMTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaXNNYXRjaGluZyAmJiAoaW5pdGlhbFN0YXRlUHJvcCA9IHNzckZvcm1TdGF0ZVswXSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHNzckZvcm1TdGF0ZSA9IG1vdW50V29ya0luUHJvZ3Jlc3NIb29rKCk7XG4gICAgICBzc3JGb3JtU3RhdGUubWVtb2l6ZWRTdGF0ZSA9IHNzckZvcm1TdGF0ZS5iYXNlU3RhdGUgPSBpbml0aWFsU3RhdGVQcm9wO1xuICAgICAgaXNNYXRjaGluZyA9IHtcbiAgICAgICAgcGVuZGluZzogbnVsbCxcbiAgICAgICAgbGFuZXM6IDAsXG4gICAgICAgIGRpc3BhdGNoOiBudWxsLFxuICAgICAgICBsYXN0UmVuZGVyZWRSZWR1Y2VyOiBhY3Rpb25TdGF0ZVJlZHVjZXIsXG4gICAgICAgIGxhc3RSZW5kZXJlZFN0YXRlOiBpbml0aWFsU3RhdGVQcm9wXG4gICAgICB9O1xuICAgICAgc3NyRm9ybVN0YXRlLnF1ZXVlID0gaXNNYXRjaGluZztcbiAgICAgIHNzckZvcm1TdGF0ZSA9IGRpc3BhdGNoU2V0U3RhdGUuYmluZChcbiAgICAgICAgbnVsbCxcbiAgICAgICAgY3VycmVudGx5UmVuZGVyaW5nRmliZXIkMSxcbiAgICAgICAgaXNNYXRjaGluZ1xuICAgICAgKTtcbiAgICAgIGlzTWF0Y2hpbmcuZGlzcGF0Y2ggPSBzc3JGb3JtU3RhdGU7XG4gICAgICBpc01hdGNoaW5nID0gbW91bnRTdGF0ZUltcGwoITEpO1xuICAgICAgdmFyIHNldFBlbmRpbmdTdGF0ZSA9IGRpc3BhdGNoT3B0aW1pc3RpY1NldFN0YXRlLmJpbmQoXG4gICAgICAgIG51bGwsXG4gICAgICAgIGN1cnJlbnRseVJlbmRlcmluZ0ZpYmVyJDEsXG4gICAgICAgICExLFxuICAgICAgICBpc01hdGNoaW5nLnF1ZXVlXG4gICAgICApO1xuICAgICAgaXNNYXRjaGluZyA9IG1vdW50V29ya0luUHJvZ3Jlc3NIb29rKCk7XG4gICAgICBtYXJrZXJJbnN0YW5jZSA9IHtcbiAgICAgICAgc3RhdGU6IGluaXRpYWxTdGF0ZVByb3AsXG4gICAgICAgIGRpc3BhdGNoOiBudWxsLFxuICAgICAgICBhY3Rpb246IGFjdGlvbixcbiAgICAgICAgcGVuZGluZzogbnVsbFxuICAgICAgfTtcbiAgICAgIGlzTWF0Y2hpbmcucXVldWUgPSBtYXJrZXJJbnN0YW5jZTtcbiAgICAgIHNzckZvcm1TdGF0ZSA9IGRpc3BhdGNoQWN0aW9uU3RhdGUuYmluZChcbiAgICAgICAgbnVsbCxcbiAgICAgICAgY3VycmVudGx5UmVuZGVyaW5nRmliZXIkMSxcbiAgICAgICAgbWFya2VySW5zdGFuY2UsXG4gICAgICAgIHNldFBlbmRpbmdTdGF0ZSxcbiAgICAgICAgc3NyRm9ybVN0YXRlXG4gICAgICApO1xuICAgICAgbWFya2VySW5zdGFuY2UuZGlzcGF0Y2ggPSBzc3JGb3JtU3RhdGU7XG4gICAgICBpc01hdGNoaW5nLm1lbW9pemVkU3RhdGUgPSBhY3Rpb247XG4gICAgICByZXR1cm4gW2luaXRpYWxTdGF0ZVByb3AsIHNzckZvcm1TdGF0ZSwgITFdO1xuICAgIH1cbiAgICBmdW5jdGlvbiB1cGRhdGVBY3Rpb25TdGF0ZShhY3Rpb24pIHtcbiAgICAgIHZhciBzdGF0ZUhvb2sgPSB1cGRhdGVXb3JrSW5Qcm9ncmVzc0hvb2soKTtcbiAgICAgIHJldHVybiB1cGRhdGVBY3Rpb25TdGF0ZUltcGwoc3RhdGVIb29rLCBjdXJyZW50SG9vaywgYWN0aW9uKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gdXBkYXRlQWN0aW9uU3RhdGVJbXBsKHN0YXRlSG9vaywgY3VycmVudFN0YXRlSG9vaywgYWN0aW9uKSB7XG4gICAgICBjdXJyZW50U3RhdGVIb29rID0gdXBkYXRlUmVkdWNlckltcGwoXG4gICAgICAgIHN0YXRlSG9vayxcbiAgICAgICAgY3VycmVudFN0YXRlSG9vayxcbiAgICAgICAgYWN0aW9uU3RhdGVSZWR1Y2VyXG4gICAgICApWzBdO1xuICAgICAgc3RhdGVIb29rID0gdXBkYXRlUmVkdWNlcihiYXNpY1N0YXRlUmVkdWNlcilbMF07XG4gICAgICBjdXJyZW50U3RhdGVIb29rID1cbiAgICAgICAgXCJvYmplY3RcIiA9PT0gdHlwZW9mIGN1cnJlbnRTdGF0ZUhvb2sgJiZcbiAgICAgICAgbnVsbCAhPT0gY3VycmVudFN0YXRlSG9vayAmJlxuICAgICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBjdXJyZW50U3RhdGVIb29rLnRoZW5cbiAgICAgICAgICA/IHVzZVRoZW5hYmxlKGN1cnJlbnRTdGF0ZUhvb2spXG4gICAgICAgICAgOiBjdXJyZW50U3RhdGVIb29rO1xuICAgICAgdmFyIGFjdGlvblF1ZXVlSG9vayA9IHVwZGF0ZVdvcmtJblByb2dyZXNzSG9vaygpLFxuICAgICAgICBhY3Rpb25RdWV1ZSA9IGFjdGlvblF1ZXVlSG9vay5xdWV1ZSxcbiAgICAgICAgZGlzcGF0Y2ggPSBhY3Rpb25RdWV1ZS5kaXNwYXRjaDtcbiAgICAgIGFjdGlvbiAhPT0gYWN0aW9uUXVldWVIb29rLm1lbW9pemVkU3RhdGUgJiZcbiAgICAgICAgKChjdXJyZW50bHlSZW5kZXJpbmdGaWJlciQxLmZsYWdzIHw9IDIwNDgpLFxuICAgICAgICBwdXNoRWZmZWN0KFxuICAgICAgICAgIEhhc0VmZmVjdCB8IFBhc3NpdmUsXG4gICAgICAgICAgYWN0aW9uU3RhdGVBY3Rpb25FZmZlY3QuYmluZChudWxsLCBhY3Rpb25RdWV1ZSwgYWN0aW9uKSxcbiAgICAgICAgICB7IGRlc3Ryb3k6IHZvaWQgMCB9LFxuICAgICAgICAgIG51bGxcbiAgICAgICAgKSk7XG4gICAgICByZXR1cm4gW2N1cnJlbnRTdGF0ZUhvb2ssIGRpc3BhdGNoLCBzdGF0ZUhvb2tdO1xuICAgIH1cbiAgICBmdW5jdGlvbiBhY3Rpb25TdGF0ZUFjdGlvbkVmZmVjdChhY3Rpb25RdWV1ZSwgYWN0aW9uKSB7XG4gICAgICBhY3Rpb25RdWV1ZS5hY3Rpb24gPSBhY3Rpb247XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlcmVuZGVyQWN0aW9uU3RhdGUoYWN0aW9uKSB7XG4gICAgICB2YXIgc3RhdGVIb29rID0gdXBkYXRlV29ya0luUHJvZ3Jlc3NIb29rKCksXG4gICAgICAgIGN1cnJlbnRTdGF0ZUhvb2sgPSBjdXJyZW50SG9vaztcbiAgICAgIGlmIChudWxsICE9PSBjdXJyZW50U3RhdGVIb29rKVxuICAgICAgICByZXR1cm4gdXBkYXRlQWN0aW9uU3RhdGVJbXBsKHN0YXRlSG9vaywgY3VycmVudFN0YXRlSG9vaywgYWN0aW9uKTtcbiAgICAgIHVwZGF0ZVdvcmtJblByb2dyZXNzSG9vaygpO1xuICAgICAgc3RhdGVIb29rID0gc3RhdGVIb29rLm1lbW9pemVkU3RhdGU7XG4gICAgICBjdXJyZW50U3RhdGVIb29rID0gdXBkYXRlV29ya0luUHJvZ3Jlc3NIb29rKCk7XG4gICAgICB2YXIgZGlzcGF0Y2ggPSBjdXJyZW50U3RhdGVIb29rLnF1ZXVlLmRpc3BhdGNoO1xuICAgICAgY3VycmVudFN0YXRlSG9vay5tZW1vaXplZFN0YXRlID0gYWN0aW9uO1xuICAgICAgcmV0dXJuIFtzdGF0ZUhvb2ssIGRpc3BhdGNoLCAhMV07XG4gICAgfVxuICAgIGZ1bmN0aW9uIHB1c2hFZmZlY3QodGFnLCBjcmVhdGUsIGluc3QsIGRlcHMpIHtcbiAgICAgIHRhZyA9IHsgdGFnOiB0YWcsIGNyZWF0ZTogY3JlYXRlLCBpbnN0OiBpbnN0LCBkZXBzOiBkZXBzLCBuZXh0OiBudWxsIH07XG4gICAgICBjcmVhdGUgPSBjdXJyZW50bHlSZW5kZXJpbmdGaWJlciQxLnVwZGF0ZVF1ZXVlO1xuICAgICAgbnVsbCA9PT0gY3JlYXRlICYmXG4gICAgICAgICgoY3JlYXRlID0gY3JlYXRlRnVuY3Rpb25Db21wb25lbnRVcGRhdGVRdWV1ZSgpKSxcbiAgICAgICAgKGN1cnJlbnRseVJlbmRlcmluZ0ZpYmVyJDEudXBkYXRlUXVldWUgPSBjcmVhdGUpKTtcbiAgICAgIGluc3QgPSBjcmVhdGUubGFzdEVmZmVjdDtcbiAgICAgIG51bGwgPT09IGluc3RcbiAgICAgICAgPyAoY3JlYXRlLmxhc3RFZmZlY3QgPSB0YWcubmV4dCA9IHRhZylcbiAgICAgICAgOiAoKGRlcHMgPSBpbnN0Lm5leHQpLFxuICAgICAgICAgIChpbnN0Lm5leHQgPSB0YWcpLFxuICAgICAgICAgICh0YWcubmV4dCA9IGRlcHMpLFxuICAgICAgICAgIChjcmVhdGUubGFzdEVmZmVjdCA9IHRhZykpO1xuICAgICAgcmV0dXJuIHRhZztcbiAgICB9XG4gICAgZnVuY3Rpb24gbW91bnRSZWYoaW5pdGlhbFZhbHVlKSB7XG4gICAgICB2YXIgaG9vayA9IG1vdW50V29ya0luUHJvZ3Jlc3NIb29rKCk7XG4gICAgICBpbml0aWFsVmFsdWUgPSB7IGN1cnJlbnQ6IGluaXRpYWxWYWx1ZSB9O1xuICAgICAgcmV0dXJuIChob29rLm1lbW9pemVkU3RhdGUgPSBpbml0aWFsVmFsdWUpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBtb3VudEVmZmVjdEltcGwoZmliZXJGbGFncywgaG9va0ZsYWdzLCBjcmVhdGUsIGRlcHMpIHtcbiAgICAgIHZhciBob29rID0gbW91bnRXb3JrSW5Qcm9ncmVzc0hvb2soKTtcbiAgICAgIGN1cnJlbnRseVJlbmRlcmluZ0ZpYmVyJDEuZmxhZ3MgfD0gZmliZXJGbGFncztcbiAgICAgIGhvb2subWVtb2l6ZWRTdGF0ZSA9IHB1c2hFZmZlY3QoXG4gICAgICAgIEhhc0VmZmVjdCB8IGhvb2tGbGFncyxcbiAgICAgICAgY3JlYXRlLFxuICAgICAgICB7IGRlc3Ryb3k6IHZvaWQgMCB9LFxuICAgICAgICB2b2lkIDAgPT09IGRlcHMgPyBudWxsIDogZGVwc1xuICAgICAgKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gdXBkYXRlRWZmZWN0SW1wbChmaWJlckZsYWdzLCBob29rRmxhZ3MsIGNyZWF0ZSwgZGVwcykge1xuICAgICAgdmFyIGhvb2sgPSB1cGRhdGVXb3JrSW5Qcm9ncmVzc0hvb2soKTtcbiAgICAgIGRlcHMgPSB2b2lkIDAgPT09IGRlcHMgPyBudWxsIDogZGVwcztcbiAgICAgIHZhciBpbnN0ID0gaG9vay5tZW1vaXplZFN0YXRlLmluc3Q7XG4gICAgICBudWxsICE9PSBjdXJyZW50SG9vayAmJlxuICAgICAgbnVsbCAhPT0gZGVwcyAmJlxuICAgICAgYXJlSG9va0lucHV0c0VxdWFsKGRlcHMsIGN1cnJlbnRIb29rLm1lbW9pemVkU3RhdGUuZGVwcylcbiAgICAgICAgPyAoaG9vay5tZW1vaXplZFN0YXRlID0gcHVzaEVmZmVjdChob29rRmxhZ3MsIGNyZWF0ZSwgaW5zdCwgZGVwcykpXG4gICAgICAgIDogKChjdXJyZW50bHlSZW5kZXJpbmdGaWJlciQxLmZsYWdzIHw9IGZpYmVyRmxhZ3MpLFxuICAgICAgICAgIChob29rLm1lbW9pemVkU3RhdGUgPSBwdXNoRWZmZWN0KFxuICAgICAgICAgICAgSGFzRWZmZWN0IHwgaG9va0ZsYWdzLFxuICAgICAgICAgICAgY3JlYXRlLFxuICAgICAgICAgICAgaW5zdCxcbiAgICAgICAgICAgIGRlcHNcbiAgICAgICAgICApKSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIG1vdW50RWZmZWN0KGNyZWF0ZSwgZGVwcykge1xuICAgICAgKGN1cnJlbnRseVJlbmRlcmluZ0ZpYmVyJDEubW9kZSAmIDE2KSAhPT0gTm9Nb2RlICYmXG4gICAgICAoY3VycmVudGx5UmVuZGVyaW5nRmliZXIkMS5tb2RlICYgNjQpID09PSBOb01vZGVcbiAgICAgICAgPyBtb3VudEVmZmVjdEltcGwoMTQyNjA4Mzg0LCBQYXNzaXZlLCBjcmVhdGUsIGRlcHMpXG4gICAgICAgIDogbW91bnRFZmZlY3RJbXBsKDgzOTA2NTYsIFBhc3NpdmUsIGNyZWF0ZSwgZGVwcyk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIG1vdW50TGF5b3V0RWZmZWN0KGNyZWF0ZSwgZGVwcykge1xuICAgICAgdmFyIGZpYmVyRmxhZ3MgPSA0MTk0MzA4O1xuICAgICAgKGN1cnJlbnRseVJlbmRlcmluZ0ZpYmVyJDEubW9kZSAmIDE2KSAhPT0gTm9Nb2RlICYmXG4gICAgICAgIChmaWJlckZsYWdzIHw9IDY3MTA4ODY0KTtcbiAgICAgIHJldHVybiBtb3VudEVmZmVjdEltcGwoZmliZXJGbGFncywgTGF5b3V0LCBjcmVhdGUsIGRlcHMpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBpbXBlcmF0aXZlSGFuZGxlRWZmZWN0KGNyZWF0ZSwgcmVmKSB7XG4gICAgICBpZiAoXCJmdW5jdGlvblwiID09PSB0eXBlb2YgcmVmKSB7XG4gICAgICAgIGNyZWF0ZSA9IGNyZWF0ZSgpO1xuICAgICAgICB2YXIgcmVmQ2xlYW51cCA9IHJlZihjcmVhdGUpO1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIHJlZkNsZWFudXAgPyByZWZDbGVhbnVwKCkgOiByZWYobnVsbCk7XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICBpZiAobnVsbCAhPT0gcmVmICYmIHZvaWQgMCAhPT0gcmVmKVxuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgIHJlZi5oYXNPd25Qcm9wZXJ0eShcImN1cnJlbnRcIikgfHxcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgIFwiRXhwZWN0ZWQgdXNlSW1wZXJhdGl2ZUhhbmRsZSgpIGZpcnN0IGFyZ3VtZW50IHRvIGVpdGhlciBiZSBhIHJlZiBjYWxsYmFjayBvciBSZWFjdC5jcmVhdGVSZWYoKSBvYmplY3QuIEluc3RlYWQgcmVjZWl2ZWQ6ICVzLlwiLFxuICAgICAgICAgICAgICBcImFuIG9iamVjdCB3aXRoIGtleXMge1wiICsgT2JqZWN0LmtleXMocmVmKS5qb2luKFwiLCBcIikgKyBcIn1cIlxuICAgICAgICAgICAgKSxcbiAgICAgICAgICAoY3JlYXRlID0gY3JlYXRlKCkpLFxuICAgICAgICAgIChyZWYuY3VycmVudCA9IGNyZWF0ZSksXG4gICAgICAgICAgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmVmLmN1cnJlbnQgPSBudWxsO1xuICAgICAgICAgIH1cbiAgICAgICAgKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gbW91bnRJbXBlcmF0aXZlSGFuZGxlKHJlZiwgY3JlYXRlLCBkZXBzKSB7XG4gICAgICBcImZ1bmN0aW9uXCIgIT09IHR5cGVvZiBjcmVhdGUgJiZcbiAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICBcIkV4cGVjdGVkIHVzZUltcGVyYXRpdmVIYW5kbGUoKSBzZWNvbmQgYXJndW1lbnQgdG8gYmUgYSBmdW5jdGlvbiB0aGF0IGNyZWF0ZXMgYSBoYW5kbGUuIEluc3RlYWQgcmVjZWl2ZWQ6ICVzLlwiLFxuICAgICAgICAgIG51bGwgIT09IGNyZWF0ZSA/IHR5cGVvZiBjcmVhdGUgOiBcIm51bGxcIlxuICAgICAgICApO1xuICAgICAgZGVwcyA9IG51bGwgIT09IGRlcHMgJiYgdm9pZCAwICE9PSBkZXBzID8gZGVwcy5jb25jYXQoW3JlZl0pIDogbnVsbDtcbiAgICAgIHZhciBmaWJlckZsYWdzID0gNDE5NDMwODtcbiAgICAgIChjdXJyZW50bHlSZW5kZXJpbmdGaWJlciQxLm1vZGUgJiAxNikgIT09IE5vTW9kZSAmJlxuICAgICAgICAoZmliZXJGbGFncyB8PSA2NzEwODg2NCk7XG4gICAgICBtb3VudEVmZmVjdEltcGwoXG4gICAgICAgIGZpYmVyRmxhZ3MsXG4gICAgICAgIExheW91dCxcbiAgICAgICAgaW1wZXJhdGl2ZUhhbmRsZUVmZmVjdC5iaW5kKG51bGwsIGNyZWF0ZSwgcmVmKSxcbiAgICAgICAgZGVwc1xuICAgICAgKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gdXBkYXRlSW1wZXJhdGl2ZUhhbmRsZShyZWYsIGNyZWF0ZSwgZGVwcykge1xuICAgICAgXCJmdW5jdGlvblwiICE9PSB0eXBlb2YgY3JlYXRlICYmXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgXCJFeHBlY3RlZCB1c2VJbXBlcmF0aXZlSGFuZGxlKCkgc2Vjb25kIGFyZ3VtZW50IHRvIGJlIGEgZnVuY3Rpb24gdGhhdCBjcmVhdGVzIGEgaGFuZGxlLiBJbnN0ZWFkIHJlY2VpdmVkOiAlcy5cIixcbiAgICAgICAgICBudWxsICE9PSBjcmVhdGUgPyB0eXBlb2YgY3JlYXRlIDogXCJudWxsXCJcbiAgICAgICAgKTtcbiAgICAgIGRlcHMgPSBudWxsICE9PSBkZXBzICYmIHZvaWQgMCAhPT0gZGVwcyA/IGRlcHMuY29uY2F0KFtyZWZdKSA6IG51bGw7XG4gICAgICB1cGRhdGVFZmZlY3RJbXBsKFxuICAgICAgICA0LFxuICAgICAgICBMYXlvdXQsXG4gICAgICAgIGltcGVyYXRpdmVIYW5kbGVFZmZlY3QuYmluZChudWxsLCBjcmVhdGUsIHJlZiksXG4gICAgICAgIGRlcHNcbiAgICAgICk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIG1vdW50Q2FsbGJhY2soY2FsbGJhY2ssIGRlcHMpIHtcbiAgICAgIG1vdW50V29ya0luUHJvZ3Jlc3NIb29rKCkubWVtb2l6ZWRTdGF0ZSA9IFtcbiAgICAgICAgY2FsbGJhY2ssXG4gICAgICAgIHZvaWQgMCA9PT0gZGVwcyA/IG51bGwgOiBkZXBzXG4gICAgICBdO1xuICAgICAgcmV0dXJuIGNhbGxiYWNrO1xuICAgIH1cbiAgICBmdW5jdGlvbiB1cGRhdGVDYWxsYmFjayhjYWxsYmFjaywgZGVwcykge1xuICAgICAgdmFyIGhvb2sgPSB1cGRhdGVXb3JrSW5Qcm9ncmVzc0hvb2soKTtcbiAgICAgIGRlcHMgPSB2b2lkIDAgPT09IGRlcHMgPyBudWxsIDogZGVwcztcbiAgICAgIHZhciBwcmV2U3RhdGUgPSBob29rLm1lbW9pemVkU3RhdGU7XG4gICAgICBpZiAobnVsbCAhPT0gZGVwcyAmJiBhcmVIb29rSW5wdXRzRXF1YWwoZGVwcywgcHJldlN0YXRlWzFdKSlcbiAgICAgICAgcmV0dXJuIHByZXZTdGF0ZVswXTtcbiAgICAgIGhvb2subWVtb2l6ZWRTdGF0ZSA9IFtjYWxsYmFjaywgZGVwc107XG4gICAgICByZXR1cm4gY2FsbGJhY2s7XG4gICAgfVxuICAgIGZ1bmN0aW9uIG1vdW50TWVtbyhuZXh0Q3JlYXRlLCBkZXBzKSB7XG4gICAgICB2YXIgaG9vayA9IG1vdW50V29ya0luUHJvZ3Jlc3NIb29rKCk7XG4gICAgICBkZXBzID0gdm9pZCAwID09PSBkZXBzID8gbnVsbCA6IGRlcHM7XG4gICAgICB2YXIgbmV4dFZhbHVlID0gbmV4dENyZWF0ZSgpO1xuICAgICAgaWYgKHNob3VsZERvdWJsZUludm9rZVVzZXJGbnNJbkhvb2tzREVWKSB7XG4gICAgICAgIHNldElzU3RyaWN0TW9kZUZvckRldnRvb2xzKCEwKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBuZXh0Q3JlYXRlKCk7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgc2V0SXNTdHJpY3RNb2RlRm9yRGV2dG9vbHMoITEpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBob29rLm1lbW9pemVkU3RhdGUgPSBbbmV4dFZhbHVlLCBkZXBzXTtcbiAgICAgIHJldHVybiBuZXh0VmFsdWU7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHVwZGF0ZU1lbW8obmV4dENyZWF0ZSwgZGVwcykge1xuICAgICAgdmFyIGhvb2sgPSB1cGRhdGVXb3JrSW5Qcm9ncmVzc0hvb2soKTtcbiAgICAgIGRlcHMgPSB2b2lkIDAgPT09IGRlcHMgPyBudWxsIDogZGVwcztcbiAgICAgIHZhciBwcmV2U3RhdGUgPSBob29rLm1lbW9pemVkU3RhdGU7XG4gICAgICBpZiAobnVsbCAhPT0gZGVwcyAmJiBhcmVIb29rSW5wdXRzRXF1YWwoZGVwcywgcHJldlN0YXRlWzFdKSlcbiAgICAgICAgcmV0dXJuIHByZXZTdGF0ZVswXTtcbiAgICAgIHByZXZTdGF0ZSA9IG5leHRDcmVhdGUoKTtcbiAgICAgIGlmIChzaG91bGREb3VibGVJbnZva2VVc2VyRm5zSW5Ib29rc0RFVikge1xuICAgICAgICBzZXRJc1N0cmljdE1vZGVGb3JEZXZ0b29scyghMCk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgbmV4dENyZWF0ZSgpO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIHNldElzU3RyaWN0TW9kZUZvckRldnRvb2xzKCExKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaG9vay5tZW1vaXplZFN0YXRlID0gW3ByZXZTdGF0ZSwgZGVwc107XG4gICAgICByZXR1cm4gcHJldlN0YXRlO1xuICAgIH1cbiAgICBmdW5jdGlvbiBtb3VudERlZmVycmVkVmFsdWUodmFsdWUsIGluaXRpYWxWYWx1ZSkge1xuICAgICAgdmFyIGhvb2sgPSBtb3VudFdvcmtJblByb2dyZXNzSG9vaygpO1xuICAgICAgcmV0dXJuIG1vdW50RGVmZXJyZWRWYWx1ZUltcGwoaG9vaywgdmFsdWUsIGluaXRpYWxWYWx1ZSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHVwZGF0ZURlZmVycmVkVmFsdWUodmFsdWUsIGluaXRpYWxWYWx1ZSkge1xuICAgICAgdmFyIGhvb2sgPSB1cGRhdGVXb3JrSW5Qcm9ncmVzc0hvb2soKTtcbiAgICAgIHJldHVybiB1cGRhdGVEZWZlcnJlZFZhbHVlSW1wbChcbiAgICAgICAgaG9vayxcbiAgICAgICAgY3VycmVudEhvb2subWVtb2l6ZWRTdGF0ZSxcbiAgICAgICAgdmFsdWUsXG4gICAgICAgIGluaXRpYWxWYWx1ZVxuICAgICAgKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcmVyZW5kZXJEZWZlcnJlZFZhbHVlKHZhbHVlLCBpbml0aWFsVmFsdWUpIHtcbiAgICAgIHZhciBob29rID0gdXBkYXRlV29ya0luUHJvZ3Jlc3NIb29rKCk7XG4gICAgICByZXR1cm4gbnVsbCA9PT0gY3VycmVudEhvb2tcbiAgICAgICAgPyBtb3VudERlZmVycmVkVmFsdWVJbXBsKGhvb2ssIHZhbHVlLCBpbml0aWFsVmFsdWUpXG4gICAgICAgIDogdXBkYXRlRGVmZXJyZWRWYWx1ZUltcGwoXG4gICAgICAgICAgICBob29rLFxuICAgICAgICAgICAgY3VycmVudEhvb2subWVtb2l6ZWRTdGF0ZSxcbiAgICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgICAgaW5pdGlhbFZhbHVlXG4gICAgICAgICAgKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gbW91bnREZWZlcnJlZFZhbHVlSW1wbChob29rLCB2YWx1ZSwgaW5pdGlhbFZhbHVlKSB7XG4gICAgICBpZiAodm9pZCAwID09PSBpbml0aWFsVmFsdWUgfHwgMCAhPT0gKHJlbmRlckxhbmVzICYgMTA3Mzc0MTgyNCkpXG4gICAgICAgIHJldHVybiAoaG9vay5tZW1vaXplZFN0YXRlID0gdmFsdWUpO1xuICAgICAgaG9vay5tZW1vaXplZFN0YXRlID0gaW5pdGlhbFZhbHVlO1xuICAgICAgaG9vayA9IHJlcXVlc3REZWZlcnJlZExhbmUoKTtcbiAgICAgIGN1cnJlbnRseVJlbmRlcmluZ0ZpYmVyJDEubGFuZXMgfD0gaG9vaztcbiAgICAgIHdvcmtJblByb2dyZXNzUm9vdFNraXBwZWRMYW5lcyB8PSBob29rO1xuICAgICAgcmV0dXJuIGluaXRpYWxWYWx1ZTtcbiAgICB9XG4gICAgZnVuY3Rpb24gdXBkYXRlRGVmZXJyZWRWYWx1ZUltcGwoaG9vaywgcHJldlZhbHVlLCB2YWx1ZSwgaW5pdGlhbFZhbHVlKSB7XG4gICAgICBpZiAob2JqZWN0SXModmFsdWUsIHByZXZWYWx1ZSkpIHJldHVybiB2YWx1ZTtcbiAgICAgIGlmIChudWxsICE9PSBjdXJyZW50VHJlZUhpZGRlblN0YWNrQ3Vyc29yLmN1cnJlbnQpXG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgKGhvb2sgPSBtb3VudERlZmVycmVkVmFsdWVJbXBsKGhvb2ssIHZhbHVlLCBpbml0aWFsVmFsdWUpKSxcbiAgICAgICAgICBvYmplY3RJcyhob29rLCBwcmV2VmFsdWUpIHx8IChkaWRSZWNlaXZlVXBkYXRlID0gITApLFxuICAgICAgICAgIGhvb2tcbiAgICAgICAgKTtcbiAgICAgIGlmICgwID09PSAocmVuZGVyTGFuZXMgJiA0MikpXG4gICAgICAgIHJldHVybiAoZGlkUmVjZWl2ZVVwZGF0ZSA9ICEwKSwgKGhvb2subWVtb2l6ZWRTdGF0ZSA9IHZhbHVlKTtcbiAgICAgIGhvb2sgPSByZXF1ZXN0RGVmZXJyZWRMYW5lKCk7XG4gICAgICBjdXJyZW50bHlSZW5kZXJpbmdGaWJlciQxLmxhbmVzIHw9IGhvb2s7XG4gICAgICB3b3JrSW5Qcm9ncmVzc1Jvb3RTa2lwcGVkTGFuZXMgfD0gaG9vaztcbiAgICAgIHJldHVybiBwcmV2VmFsdWU7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHN0YXJ0VHJhbnNpdGlvbihcbiAgICAgIGZpYmVyLFxuICAgICAgcXVldWUsXG4gICAgICBwZW5kaW5nU3RhdGUsXG4gICAgICBmaW5pc2hlZFN0YXRlLFxuICAgICAgY2FsbGJhY2tcbiAgICApIHtcbiAgICAgIHZhciBwcmV2aW91c1ByaW9yaXR5ID0gZ2V0Q3VycmVudFVwZGF0ZVByaW9yaXR5KCk7XG4gICAgICBzZXRDdXJyZW50VXBkYXRlUHJpb3JpdHkoXG4gICAgICAgIDAgIT09IHByZXZpb3VzUHJpb3JpdHkgJiYgOCA+IHByZXZpb3VzUHJpb3JpdHkgPyBwcmV2aW91c1ByaW9yaXR5IDogOFxuICAgICAgKTtcbiAgICAgIHZhciBwcmV2VHJhbnNpdGlvbiA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlQsXG4gICAgICAgIGN1cnJlbnRUcmFuc2l0aW9uID0ge307XG4gICAgICBSZWFjdFNoYXJlZEludGVybmFscy5UID0gY3VycmVudFRyYW5zaXRpb247XG4gICAgICBkaXNwYXRjaE9wdGltaXN0aWNTZXRTdGF0ZShmaWJlciwgITEsIHF1ZXVlLCBwZW5kaW5nU3RhdGUpO1xuICAgICAgY3VycmVudFRyYW5zaXRpb24uX3VwZGF0ZWRGaWJlcnMgPSBuZXcgU2V0KCk7XG4gICAgICB0cnkge1xuICAgICAgICB2YXIgcmV0dXJuVmFsdWUgPSBjYWxsYmFjaygpLFxuICAgICAgICAgIG9uU3RhcnRUcmFuc2l0aW9uRmluaXNoID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuUztcbiAgICAgICAgbnVsbCAhPT0gb25TdGFydFRyYW5zaXRpb25GaW5pc2ggJiZcbiAgICAgICAgICBvblN0YXJ0VHJhbnNpdGlvbkZpbmlzaChjdXJyZW50VHJhbnNpdGlvbiwgcmV0dXJuVmFsdWUpO1xuICAgICAgICBpZiAoXG4gICAgICAgICAgbnVsbCAhPT0gcmV0dXJuVmFsdWUgJiZcbiAgICAgICAgICBcIm9iamVjdFwiID09PSB0eXBlb2YgcmV0dXJuVmFsdWUgJiZcbiAgICAgICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiByZXR1cm5WYWx1ZS50aGVuXG4gICAgICAgICkge1xuICAgICAgICAgIHZhciB0aGVuYWJsZUZvckZpbmlzaGVkU3RhdGUgPSBjaGFpblRoZW5hYmxlVmFsdWUoXG4gICAgICAgICAgICByZXR1cm5WYWx1ZSxcbiAgICAgICAgICAgIGZpbmlzaGVkU3RhdGVcbiAgICAgICAgICApO1xuICAgICAgICAgIGRpc3BhdGNoU2V0U3RhdGVJbnRlcm5hbChcbiAgICAgICAgICAgIGZpYmVyLFxuICAgICAgICAgICAgcXVldWUsXG4gICAgICAgICAgICB0aGVuYWJsZUZvckZpbmlzaGVkU3RhdGUsXG4gICAgICAgICAgICByZXF1ZXN0VXBkYXRlTGFuZShmaWJlcilcbiAgICAgICAgICApO1xuICAgICAgICB9IGVsc2VcbiAgICAgICAgICBkaXNwYXRjaFNldFN0YXRlSW50ZXJuYWwoXG4gICAgICAgICAgICBmaWJlcixcbiAgICAgICAgICAgIHF1ZXVlLFxuICAgICAgICAgICAgZmluaXNoZWRTdGF0ZSxcbiAgICAgICAgICAgIHJlcXVlc3RVcGRhdGVMYW5lKGZpYmVyKVxuICAgICAgICAgICk7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBkaXNwYXRjaFNldFN0YXRlSW50ZXJuYWwoXG4gICAgICAgICAgZmliZXIsXG4gICAgICAgICAgcXVldWUsXG4gICAgICAgICAgeyB0aGVuOiBmdW5jdGlvbiAoKSB7fSwgc3RhdHVzOiBcInJlamVjdGVkXCIsIHJlYXNvbjogZXJyb3IgfSxcbiAgICAgICAgICByZXF1ZXN0VXBkYXRlTGFuZShmaWJlcilcbiAgICAgICAgKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIHNldEN1cnJlbnRVcGRhdGVQcmlvcml0eShwcmV2aW91c1ByaW9yaXR5KSxcbiAgICAgICAgICAoUmVhY3RTaGFyZWRJbnRlcm5hbHMuVCA9IHByZXZUcmFuc2l0aW9uKSxcbiAgICAgICAgICBudWxsID09PSBwcmV2VHJhbnNpdGlvbiAmJlxuICAgICAgICAgICAgY3VycmVudFRyYW5zaXRpb24uX3VwZGF0ZWRGaWJlcnMgJiZcbiAgICAgICAgICAgICgoZmliZXIgPSBjdXJyZW50VHJhbnNpdGlvbi5fdXBkYXRlZEZpYmVycy5zaXplKSxcbiAgICAgICAgICAgIGN1cnJlbnRUcmFuc2l0aW9uLl91cGRhdGVkRmliZXJzLmNsZWFyKCksXG4gICAgICAgICAgICAxMCA8IGZpYmVyICYmXG4gICAgICAgICAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgICAgICAgICBcIkRldGVjdGVkIGEgbGFyZ2UgbnVtYmVyIG9mIHVwZGF0ZXMgaW5zaWRlIHN0YXJ0VHJhbnNpdGlvbi4gSWYgdGhpcyBpcyBkdWUgdG8gYSBzdWJzY3JpcHRpb24gcGxlYXNlIHJlLXdyaXRlIGl0IHRvIHVzZSBSZWFjdCBwcm92aWRlZCBob29rcy4gT3RoZXJ3aXNlIGNvbmN1cnJlbnQgbW9kZSBndWFyYW50ZWVzIGFyZSBvZmYgdGhlIHRhYmxlLlwiXG4gICAgICAgICAgICAgICkpO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBlbnN1cmVGb3JtQ29tcG9uZW50SXNTdGF0ZWZ1bChmb3JtRmliZXIpIHtcbiAgICAgIHZhciBleGlzdGluZ1N0YXRlSG9vayA9IGZvcm1GaWJlci5tZW1vaXplZFN0YXRlO1xuICAgICAgaWYgKG51bGwgIT09IGV4aXN0aW5nU3RhdGVIb29rKSByZXR1cm4gZXhpc3RpbmdTdGF0ZUhvb2s7XG4gICAgICBleGlzdGluZ1N0YXRlSG9vayA9IHtcbiAgICAgICAgbWVtb2l6ZWRTdGF0ZTogTm90UGVuZGluZ1RyYW5zaXRpb24sXG4gICAgICAgIGJhc2VTdGF0ZTogTm90UGVuZGluZ1RyYW5zaXRpb24sXG4gICAgICAgIGJhc2VRdWV1ZTogbnVsbCxcbiAgICAgICAgcXVldWU6IHtcbiAgICAgICAgICBwZW5kaW5nOiBudWxsLFxuICAgICAgICAgIGxhbmVzOiAwLFxuICAgICAgICAgIGRpc3BhdGNoOiBudWxsLFxuICAgICAgICAgIGxhc3RSZW5kZXJlZFJlZHVjZXI6IGJhc2ljU3RhdGVSZWR1Y2VyLFxuICAgICAgICAgIGxhc3RSZW5kZXJlZFN0YXRlOiBOb3RQZW5kaW5nVHJhbnNpdGlvblxuICAgICAgICB9LFxuICAgICAgICBuZXh0OiBudWxsXG4gICAgICB9O1xuICAgICAgdmFyIGluaXRpYWxSZXNldFN0YXRlID0ge307XG4gICAgICBleGlzdGluZ1N0YXRlSG9vay5uZXh0ID0ge1xuICAgICAgICBtZW1vaXplZFN0YXRlOiBpbml0aWFsUmVzZXRTdGF0ZSxcbiAgICAgICAgYmFzZVN0YXRlOiBpbml0aWFsUmVzZXRTdGF0ZSxcbiAgICAgICAgYmFzZVF1ZXVlOiBudWxsLFxuICAgICAgICBxdWV1ZToge1xuICAgICAgICAgIHBlbmRpbmc6IG51bGwsXG4gICAgICAgICAgbGFuZXM6IDAsXG4gICAgICAgICAgZGlzcGF0Y2g6IG51bGwsXG4gICAgICAgICAgbGFzdFJlbmRlcmVkUmVkdWNlcjogYmFzaWNTdGF0ZVJlZHVjZXIsXG4gICAgICAgICAgbGFzdFJlbmRlcmVkU3RhdGU6IGluaXRpYWxSZXNldFN0YXRlXG4gICAgICAgIH0sXG4gICAgICAgIG5leHQ6IG51bGxcbiAgICAgIH07XG4gICAgICBmb3JtRmliZXIubWVtb2l6ZWRTdGF0ZSA9IGV4aXN0aW5nU3RhdGVIb29rO1xuICAgICAgZm9ybUZpYmVyID0gZm9ybUZpYmVyLmFsdGVybmF0ZTtcbiAgICAgIG51bGwgIT09IGZvcm1GaWJlciAmJiAoZm9ybUZpYmVyLm1lbW9pemVkU3RhdGUgPSBleGlzdGluZ1N0YXRlSG9vayk7XG4gICAgICByZXR1cm4gZXhpc3RpbmdTdGF0ZUhvb2s7XG4gICAgfVxuICAgIGZ1bmN0aW9uIG1vdW50VHJhbnNpdGlvbigpIHtcbiAgICAgIHZhciBzdGF0ZUhvb2sgPSBtb3VudFN0YXRlSW1wbCghMSk7XG4gICAgICBzdGF0ZUhvb2sgPSBzdGFydFRyYW5zaXRpb24uYmluZChcbiAgICAgICAgbnVsbCxcbiAgICAgICAgY3VycmVudGx5UmVuZGVyaW5nRmliZXIkMSxcbiAgICAgICAgc3RhdGVIb29rLnF1ZXVlLFxuICAgICAgICAhMCxcbiAgICAgICAgITFcbiAgICAgICk7XG4gICAgICBtb3VudFdvcmtJblByb2dyZXNzSG9vaygpLm1lbW9pemVkU3RhdGUgPSBzdGF0ZUhvb2s7XG4gICAgICByZXR1cm4gWyExLCBzdGF0ZUhvb2tdO1xuICAgIH1cbiAgICBmdW5jdGlvbiB1cGRhdGVUcmFuc2l0aW9uKCkge1xuICAgICAgdmFyIGJvb2xlYW5PclRoZW5hYmxlID0gdXBkYXRlUmVkdWNlcihiYXNpY1N0YXRlUmVkdWNlcilbMF0sXG4gICAgICAgIHN0YXJ0ID0gdXBkYXRlV29ya0luUHJvZ3Jlc3NIb29rKCkubWVtb2l6ZWRTdGF0ZTtcbiAgICAgIHJldHVybiBbXG4gICAgICAgIFwiYm9vbGVhblwiID09PSB0eXBlb2YgYm9vbGVhbk9yVGhlbmFibGVcbiAgICAgICAgICA/IGJvb2xlYW5PclRoZW5hYmxlXG4gICAgICAgICAgOiB1c2VUaGVuYWJsZShib29sZWFuT3JUaGVuYWJsZSksXG4gICAgICAgIHN0YXJ0XG4gICAgICBdO1xuICAgIH1cbiAgICBmdW5jdGlvbiByZXJlbmRlclRyYW5zaXRpb24oKSB7XG4gICAgICB2YXIgYm9vbGVhbk9yVGhlbmFibGUgPSByZXJlbmRlclJlZHVjZXIoYmFzaWNTdGF0ZVJlZHVjZXIpWzBdLFxuICAgICAgICBzdGFydCA9IHVwZGF0ZVdvcmtJblByb2dyZXNzSG9vaygpLm1lbW9pemVkU3RhdGU7XG4gICAgICByZXR1cm4gW1xuICAgICAgICBcImJvb2xlYW5cIiA9PT0gdHlwZW9mIGJvb2xlYW5PclRoZW5hYmxlXG4gICAgICAgICAgPyBib29sZWFuT3JUaGVuYWJsZVxuICAgICAgICAgIDogdXNlVGhlbmFibGUoYm9vbGVhbk9yVGhlbmFibGUpLFxuICAgICAgICBzdGFydFxuICAgICAgXTtcbiAgICB9XG4gICAgZnVuY3Rpb24gdXNlSG9zdFRyYW5zaXRpb25TdGF0dXMoKSB7XG4gICAgICByZXR1cm4gcmVhZENvbnRleHQoSG9zdFRyYW5zaXRpb25Db250ZXh0KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gbW91bnRJZCgpIHtcbiAgICAgIHZhciBob29rID0gbW91bnRXb3JrSW5Qcm9ncmVzc0hvb2soKSxcbiAgICAgICAgaWRlbnRpZmllclByZWZpeCA9IHdvcmtJblByb2dyZXNzUm9vdC5pZGVudGlmaWVyUHJlZml4O1xuICAgICAgaWYgKGlzSHlkcmF0aW5nKSB7XG4gICAgICAgIHZhciB0cmVlSWQgPSB0cmVlQ29udGV4dE92ZXJmbG93O1xuICAgICAgICB2YXIgaWRXaXRoTGVhZGluZ0JpdCA9IHRyZWVDb250ZXh0SWQ7XG4gICAgICAgIHRyZWVJZCA9XG4gICAgICAgICAgKFxuICAgICAgICAgICAgaWRXaXRoTGVhZGluZ0JpdCAmIH4oMSA8PCAoMzIgLSBjbHozMihpZFdpdGhMZWFkaW5nQml0KSAtIDEpKVxuICAgICAgICAgICkudG9TdHJpbmcoMzIpICsgdHJlZUlkO1xuICAgICAgICBpZGVudGlmaWVyUHJlZml4ID0gXCI6XCIgKyBpZGVudGlmaWVyUHJlZml4ICsgXCJSXCIgKyB0cmVlSWQ7XG4gICAgICAgIHRyZWVJZCA9IGxvY2FsSWRDb3VudGVyKys7XG4gICAgICAgIDAgPCB0cmVlSWQgJiYgKGlkZW50aWZpZXJQcmVmaXggKz0gXCJIXCIgKyB0cmVlSWQudG9TdHJpbmcoMzIpKTtcbiAgICAgICAgaWRlbnRpZmllclByZWZpeCArPSBcIjpcIjtcbiAgICAgIH0gZWxzZVxuICAgICAgICAodHJlZUlkID0gZ2xvYmFsQ2xpZW50SWRDb3VudGVyKyspLFxuICAgICAgICAgIChpZGVudGlmaWVyUHJlZml4ID1cbiAgICAgICAgICAgIFwiOlwiICsgaWRlbnRpZmllclByZWZpeCArIFwiclwiICsgdHJlZUlkLnRvU3RyaW5nKDMyKSArIFwiOlwiKTtcbiAgICAgIHJldHVybiAoaG9vay5tZW1vaXplZFN0YXRlID0gaWRlbnRpZmllclByZWZpeCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIG1vdW50UmVmcmVzaCgpIHtcbiAgICAgIHJldHVybiAobW91bnRXb3JrSW5Qcm9ncmVzc0hvb2soKS5tZW1vaXplZFN0YXRlID0gcmVmcmVzaENhY2hlLmJpbmQoXG4gICAgICAgIG51bGwsXG4gICAgICAgIGN1cnJlbnRseVJlbmRlcmluZ0ZpYmVyJDFcbiAgICAgICkpO1xuICAgIH1cbiAgICBmdW5jdGlvbiByZWZyZXNoQ2FjaGUoZmliZXIsIHNlZWRLZXkpIHtcbiAgICAgIGZvciAodmFyIHByb3ZpZGVyID0gZmliZXIucmV0dXJuOyBudWxsICE9PSBwcm92aWRlcjsgKSB7XG4gICAgICAgIHN3aXRjaCAocHJvdmlkZXIudGFnKSB7XG4gICAgICAgICAgY2FzZSAyNDpcbiAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICB2YXIgbGFuZSA9IHJlcXVlc3RVcGRhdGVMYW5lKHByb3ZpZGVyKTtcbiAgICAgICAgICAgIGZpYmVyID0gY3JlYXRlVXBkYXRlKGxhbmUpO1xuICAgICAgICAgICAgdmFyIHJvb3QgPSBlbnF1ZXVlVXBkYXRlKHByb3ZpZGVyLCBmaWJlciwgbGFuZSk7XG4gICAgICAgICAgICBudWxsICE9PSByb290ICYmXG4gICAgICAgICAgICAgIChzY2hlZHVsZVVwZGF0ZU9uRmliZXIocm9vdCwgcHJvdmlkZXIsIGxhbmUpLFxuICAgICAgICAgICAgICBlbnRhbmdsZVRyYW5zaXRpb25zKHJvb3QsIHByb3ZpZGVyLCBsYW5lKSk7XG4gICAgICAgICAgICBwcm92aWRlciA9IGNyZWF0ZUNhY2hlKCk7XG4gICAgICAgICAgICBudWxsICE9PSBzZWVkS2V5ICYmXG4gICAgICAgICAgICAgIHZvaWQgMCAhPT0gc2VlZEtleSAmJlxuICAgICAgICAgICAgICBudWxsICE9PSByb290ICYmXG4gICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgICAgXCJUaGUgc2VlZCBhcmd1bWVudCBpcyBub3QgZW5hYmxlZCBvdXRzaWRlIGV4cGVyaW1lbnRhbCBjaGFubmVscy5cIlxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgZmliZXIucGF5bG9hZCA9IHsgY2FjaGU6IHByb3ZpZGVyIH07XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgcHJvdmlkZXIgPSBwcm92aWRlci5yZXR1cm47XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGRpc3BhdGNoUmVkdWNlckFjdGlvbihcbiAgICAgIGZpYmVyLFxuICAgICAgcXVldWUsXG4gICAgICBhY3Rpb24sXG4gICAgICBKU0NvbXBpbGVyX09wdGltaXplQXJndW1lbnRzQXJyYXlfcDBcbiAgICApIHtcbiAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIEpTQ29tcGlsZXJfT3B0aW1pemVBcmd1bWVudHNBcnJheV9wMCAmJlxuICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgIFwiU3RhdGUgdXBkYXRlcyBmcm9tIHRoZSB1c2VTdGF0ZSgpIGFuZCB1c2VSZWR1Y2VyKCkgSG9va3MgZG9uJ3Qgc3VwcG9ydCB0aGUgc2Vjb25kIGNhbGxiYWNrIGFyZ3VtZW50LiBUbyBleGVjdXRlIGEgc2lkZSBlZmZlY3QgYWZ0ZXIgcmVuZGVyaW5nLCBkZWNsYXJlIGl0IGluIHRoZSBjb21wb25lbnQgYm9keSB3aXRoIHVzZUVmZmVjdCgpLlwiXG4gICAgICAgICk7XG4gICAgICBKU0NvbXBpbGVyX09wdGltaXplQXJndW1lbnRzQXJyYXlfcDAgPSByZXF1ZXN0VXBkYXRlTGFuZShmaWJlcik7XG4gICAgICBhY3Rpb24gPSB7XG4gICAgICAgIGxhbmU6IEpTQ29tcGlsZXJfT3B0aW1pemVBcmd1bWVudHNBcnJheV9wMCxcbiAgICAgICAgcmV2ZXJ0TGFuZTogMCxcbiAgICAgICAgYWN0aW9uOiBhY3Rpb24sXG4gICAgICAgIGhhc0VhZ2VyU3RhdGU6ICExLFxuICAgICAgICBlYWdlclN0YXRlOiBudWxsLFxuICAgICAgICBuZXh0OiBudWxsXG4gICAgICB9O1xuICAgICAgaXNSZW5kZXJQaGFzZVVwZGF0ZShmaWJlcilcbiAgICAgICAgPyBlbnF1ZXVlUmVuZGVyUGhhc2VVcGRhdGUocXVldWUsIGFjdGlvbilcbiAgICAgICAgOiAoKGFjdGlvbiA9IGVucXVldWVDb25jdXJyZW50SG9va1VwZGF0ZShcbiAgICAgICAgICAgIGZpYmVyLFxuICAgICAgICAgICAgcXVldWUsXG4gICAgICAgICAgICBhY3Rpb24sXG4gICAgICAgICAgICBKU0NvbXBpbGVyX09wdGltaXplQXJndW1lbnRzQXJyYXlfcDBcbiAgICAgICAgICApKSxcbiAgICAgICAgICBudWxsICE9PSBhY3Rpb24gJiZcbiAgICAgICAgICAgIChzY2hlZHVsZVVwZGF0ZU9uRmliZXIoXG4gICAgICAgICAgICAgIGFjdGlvbixcbiAgICAgICAgICAgICAgZmliZXIsXG4gICAgICAgICAgICAgIEpTQ29tcGlsZXJfT3B0aW1pemVBcmd1bWVudHNBcnJheV9wMFxuICAgICAgICAgICAgKSxcbiAgICAgICAgICAgIGVudGFuZ2xlVHJhbnNpdGlvblVwZGF0ZShcbiAgICAgICAgICAgICAgYWN0aW9uLFxuICAgICAgICAgICAgICBxdWV1ZSxcbiAgICAgICAgICAgICAgSlNDb21waWxlcl9PcHRpbWl6ZUFyZ3VtZW50c0FycmF5X3AwXG4gICAgICAgICAgICApKSk7XG4gICAgICBtYXJrU3RhdGVVcGRhdGVTY2hlZHVsZWQoZmliZXIsIEpTQ29tcGlsZXJfT3B0aW1pemVBcmd1bWVudHNBcnJheV9wMCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGRpc3BhdGNoU2V0U3RhdGUoXG4gICAgICBmaWJlcixcbiAgICAgIHF1ZXVlLFxuICAgICAgYWN0aW9uLFxuICAgICAgSlNDb21waWxlcl9PcHRpbWl6ZUFyZ3VtZW50c0FycmF5X3AxXG4gICAgKSB7XG4gICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBKU0NvbXBpbGVyX09wdGltaXplQXJndW1lbnRzQXJyYXlfcDEgJiZcbiAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICBcIlN0YXRlIHVwZGF0ZXMgZnJvbSB0aGUgdXNlU3RhdGUoKSBhbmQgdXNlUmVkdWNlcigpIEhvb2tzIGRvbid0IHN1cHBvcnQgdGhlIHNlY29uZCBjYWxsYmFjayBhcmd1bWVudC4gVG8gZXhlY3V0ZSBhIHNpZGUgZWZmZWN0IGFmdGVyIHJlbmRlcmluZywgZGVjbGFyZSBpdCBpbiB0aGUgY29tcG9uZW50IGJvZHkgd2l0aCB1c2VFZmZlY3QoKS5cIlxuICAgICAgICApO1xuICAgICAgSlNDb21waWxlcl9PcHRpbWl6ZUFyZ3VtZW50c0FycmF5X3AxID0gcmVxdWVzdFVwZGF0ZUxhbmUoZmliZXIpO1xuICAgICAgZGlzcGF0Y2hTZXRTdGF0ZUludGVybmFsKFxuICAgICAgICBmaWJlcixcbiAgICAgICAgcXVldWUsXG4gICAgICAgIGFjdGlvbixcbiAgICAgICAgSlNDb21waWxlcl9PcHRpbWl6ZUFyZ3VtZW50c0FycmF5X3AxXG4gICAgICApO1xuICAgICAgbWFya1N0YXRlVXBkYXRlU2NoZWR1bGVkKGZpYmVyLCBKU0NvbXBpbGVyX09wdGltaXplQXJndW1lbnRzQXJyYXlfcDEpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBkaXNwYXRjaFNldFN0YXRlSW50ZXJuYWwoZmliZXIsIHF1ZXVlLCBhY3Rpb24sIGxhbmUpIHtcbiAgICAgIHZhciB1cGRhdGUgPSB7XG4gICAgICAgIGxhbmU6IGxhbmUsXG4gICAgICAgIHJldmVydExhbmU6IDAsXG4gICAgICAgIGFjdGlvbjogYWN0aW9uLFxuICAgICAgICBoYXNFYWdlclN0YXRlOiAhMSxcbiAgICAgICAgZWFnZXJTdGF0ZTogbnVsbCxcbiAgICAgICAgbmV4dDogbnVsbFxuICAgICAgfTtcbiAgICAgIGlmIChpc1JlbmRlclBoYXNlVXBkYXRlKGZpYmVyKSkgZW5xdWV1ZVJlbmRlclBoYXNlVXBkYXRlKHF1ZXVlLCB1cGRhdGUpO1xuICAgICAgZWxzZSB7XG4gICAgICAgIHZhciBhbHRlcm5hdGUgPSBmaWJlci5hbHRlcm5hdGU7XG4gICAgICAgIGlmIChcbiAgICAgICAgICAwID09PSBmaWJlci5sYW5lcyAmJlxuICAgICAgICAgIChudWxsID09PSBhbHRlcm5hdGUgfHwgMCA9PT0gYWx0ZXJuYXRlLmxhbmVzKSAmJlxuICAgICAgICAgICgoYWx0ZXJuYXRlID0gcXVldWUubGFzdFJlbmRlcmVkUmVkdWNlciksIG51bGwgIT09IGFsdGVybmF0ZSlcbiAgICAgICAgKSB7XG4gICAgICAgICAgdmFyIHByZXZEaXNwYXRjaGVyID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuSDtcbiAgICAgICAgICBSZWFjdFNoYXJlZEludGVybmFscy5IID0gSW52YWxpZE5lc3RlZEhvb2tzRGlzcGF0Y2hlck9uVXBkYXRlSW5ERVY7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHZhciBjdXJyZW50U3RhdGUgPSBxdWV1ZS5sYXN0UmVuZGVyZWRTdGF0ZSxcbiAgICAgICAgICAgICAgZWFnZXJTdGF0ZSA9IGFsdGVybmF0ZShjdXJyZW50U3RhdGUsIGFjdGlvbik7XG4gICAgICAgICAgICB1cGRhdGUuaGFzRWFnZXJTdGF0ZSA9ICEwO1xuICAgICAgICAgICAgdXBkYXRlLmVhZ2VyU3RhdGUgPSBlYWdlclN0YXRlO1xuICAgICAgICAgICAgaWYgKG9iamVjdElzKGVhZ2VyU3RhdGUsIGN1cnJlbnRTdGF0ZSkpXG4gICAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAgICAgZW5xdWV1ZVVwZGF0ZSQxKGZpYmVyLCBxdWV1ZSwgdXBkYXRlLCAwKSxcbiAgICAgICAgICAgICAgICBudWxsID09PSB3b3JrSW5Qcm9ncmVzc1Jvb3QgJiZcbiAgICAgICAgICAgICAgICAgIGZpbmlzaFF1ZXVlaW5nQ29uY3VycmVudFVwZGF0ZXMoKSxcbiAgICAgICAgICAgICAgICAhMVxuICAgICAgICAgICAgICApO1xuICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIFJlYWN0U2hhcmVkSW50ZXJuYWxzLkggPSBwcmV2RGlzcGF0Y2hlcjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgYWN0aW9uID0gZW5xdWV1ZUNvbmN1cnJlbnRIb29rVXBkYXRlKGZpYmVyLCBxdWV1ZSwgdXBkYXRlLCBsYW5lKTtcbiAgICAgICAgaWYgKG51bGwgIT09IGFjdGlvbilcbiAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgc2NoZWR1bGVVcGRhdGVPbkZpYmVyKGFjdGlvbiwgZmliZXIsIGxhbmUpLFxuICAgICAgICAgICAgZW50YW5nbGVUcmFuc2l0aW9uVXBkYXRlKGFjdGlvbiwgcXVldWUsIGxhbmUpLFxuICAgICAgICAgICAgITBcbiAgICAgICAgICApO1xuICAgICAgfVxuICAgICAgcmV0dXJuICExO1xuICAgIH1cbiAgICBmdW5jdGlvbiBkaXNwYXRjaE9wdGltaXN0aWNTZXRTdGF0ZShcbiAgICAgIGZpYmVyLFxuICAgICAgdGhyb3dJZkR1cmluZ1JlbmRlcixcbiAgICAgIHF1ZXVlLFxuICAgICAgYWN0aW9uXG4gICAgKSB7XG4gICAgICBudWxsID09PSBSZWFjdFNoYXJlZEludGVybmFscy5UICYmXG4gICAgICAgIDAgPT09IGN1cnJlbnRFbnRhbmdsZWRMYW5lICYmXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgXCJBbiBvcHRpbWlzdGljIHN0YXRlIHVwZGF0ZSBvY2N1cnJlZCBvdXRzaWRlIGEgdHJhbnNpdGlvbiBvciBhY3Rpb24uIFRvIGZpeCwgbW92ZSB0aGUgdXBkYXRlIHRvIGFuIGFjdGlvbiwgb3Igd3JhcCB3aXRoIHN0YXJ0VHJhbnNpdGlvbi5cIlxuICAgICAgICApO1xuICAgICAgYWN0aW9uID0ge1xuICAgICAgICBsYW5lOiAyLFxuICAgICAgICByZXZlcnRMYW5lOiByZXF1ZXN0VHJhbnNpdGlvbkxhbmUoKSxcbiAgICAgICAgYWN0aW9uOiBhY3Rpb24sXG4gICAgICAgIGhhc0VhZ2VyU3RhdGU6ICExLFxuICAgICAgICBlYWdlclN0YXRlOiBudWxsLFxuICAgICAgICBuZXh0OiBudWxsXG4gICAgICB9O1xuICAgICAgaWYgKGlzUmVuZGVyUGhhc2VVcGRhdGUoZmliZXIpKSB7XG4gICAgICAgIGlmICh0aHJvd0lmRHVyaW5nUmVuZGVyKVxuICAgICAgICAgIHRocm93IEVycm9yKFwiQ2Fubm90IHVwZGF0ZSBvcHRpbWlzdGljIHN0YXRlIHdoaWxlIHJlbmRlcmluZy5cIik7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXCJDYW5ub3QgY2FsbCBzdGFydFRyYW5zaXRpb24gd2hpbGUgcmVuZGVyaW5nLlwiKTtcbiAgICAgIH0gZWxzZVxuICAgICAgICAodGhyb3dJZkR1cmluZ1JlbmRlciA9IGVucXVldWVDb25jdXJyZW50SG9va1VwZGF0ZShcbiAgICAgICAgICBmaWJlcixcbiAgICAgICAgICBxdWV1ZSxcbiAgICAgICAgICBhY3Rpb24sXG4gICAgICAgICAgMlxuICAgICAgICApKSxcbiAgICAgICAgICBudWxsICE9PSB0aHJvd0lmRHVyaW5nUmVuZGVyICYmXG4gICAgICAgICAgICBzY2hlZHVsZVVwZGF0ZU9uRmliZXIodGhyb3dJZkR1cmluZ1JlbmRlciwgZmliZXIsIDIpO1xuICAgICAgbWFya1N0YXRlVXBkYXRlU2NoZWR1bGVkKGZpYmVyLCAyKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gaXNSZW5kZXJQaGFzZVVwZGF0ZShmaWJlcikge1xuICAgICAgdmFyIGFsdGVybmF0ZSA9IGZpYmVyLmFsdGVybmF0ZTtcbiAgICAgIHJldHVybiAoXG4gICAgICAgIGZpYmVyID09PSBjdXJyZW50bHlSZW5kZXJpbmdGaWJlciQxIHx8XG4gICAgICAgIChudWxsICE9PSBhbHRlcm5hdGUgJiYgYWx0ZXJuYXRlID09PSBjdXJyZW50bHlSZW5kZXJpbmdGaWJlciQxKVxuICAgICAgKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZW5xdWV1ZVJlbmRlclBoYXNlVXBkYXRlKHF1ZXVlLCB1cGRhdGUpIHtcbiAgICAgIGRpZFNjaGVkdWxlUmVuZGVyUGhhc2VVcGRhdGVEdXJpbmdUaGlzUGFzcyA9XG4gICAgICAgIGRpZFNjaGVkdWxlUmVuZGVyUGhhc2VVcGRhdGUgPSAhMDtcbiAgICAgIHZhciBwZW5kaW5nID0gcXVldWUucGVuZGluZztcbiAgICAgIG51bGwgPT09IHBlbmRpbmdcbiAgICAgICAgPyAodXBkYXRlLm5leHQgPSB1cGRhdGUpXG4gICAgICAgIDogKCh1cGRhdGUubmV4dCA9IHBlbmRpbmcubmV4dCksIChwZW5kaW5nLm5leHQgPSB1cGRhdGUpKTtcbiAgICAgIHF1ZXVlLnBlbmRpbmcgPSB1cGRhdGU7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGVudGFuZ2xlVHJhbnNpdGlvblVwZGF0ZShyb290LCBxdWV1ZSwgbGFuZSkge1xuICAgICAgaWYgKDAgIT09IChsYW5lICYgNDE5NDE3NikpIHtcbiAgICAgICAgdmFyIHF1ZXVlTGFuZXMgPSBxdWV1ZS5sYW5lcztcbiAgICAgICAgcXVldWVMYW5lcyAmPSByb290LnBlbmRpbmdMYW5lcztcbiAgICAgICAgbGFuZSB8PSBxdWV1ZUxhbmVzO1xuICAgICAgICBxdWV1ZS5sYW5lcyA9IGxhbmU7XG4gICAgICAgIG1hcmtSb290RW50YW5nbGVkKHJvb3QsIGxhbmUpO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiB3YXJuT25JbnZhbGlkQ2FsbGJhY2soY2FsbGJhY2spIHtcbiAgICAgIGlmIChudWxsICE9PSBjYWxsYmFjayAmJiBcImZ1bmN0aW9uXCIgIT09IHR5cGVvZiBjYWxsYmFjaykge1xuICAgICAgICB2YXIga2V5ID0gU3RyaW5nKGNhbGxiYWNrKTtcbiAgICAgICAgZGlkV2Fybk9uSW52YWxpZENhbGxiYWNrLmhhcyhrZXkpIHx8XG4gICAgICAgICAgKGRpZFdhcm5PbkludmFsaWRDYWxsYmFjay5hZGQoa2V5KSxcbiAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgXCJFeHBlY3RlZCB0aGUgbGFzdCBvcHRpb25hbCBgY2FsbGJhY2tgIGFyZ3VtZW50IHRvIGJlIGEgZnVuY3Rpb24uIEluc3RlYWQgcmVjZWl2ZWQ6ICVzLlwiLFxuICAgICAgICAgICAgY2FsbGJhY2tcbiAgICAgICAgICApKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gYXBwbHlEZXJpdmVkU3RhdGVGcm9tUHJvcHMoXG4gICAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgICAgIGN0b3IsXG4gICAgICBnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMsXG4gICAgICBuZXh0UHJvcHNcbiAgICApIHtcbiAgICAgIHZhciBwcmV2U3RhdGUgPSB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlLFxuICAgICAgICBwYXJ0aWFsU3RhdGUgPSBnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMobmV4dFByb3BzLCBwcmV2U3RhdGUpO1xuICAgICAgaWYgKHdvcmtJblByb2dyZXNzLm1vZGUgJiA4KSB7XG4gICAgICAgIHNldElzU3RyaWN0TW9kZUZvckRldnRvb2xzKCEwKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBwYXJ0aWFsU3RhdGUgPSBnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMobmV4dFByb3BzLCBwcmV2U3RhdGUpO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIHNldElzU3RyaWN0TW9kZUZvckRldnRvb2xzKCExKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdm9pZCAwID09PSBwYXJ0aWFsU3RhdGUgJiZcbiAgICAgICAgKChjdG9yID0gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKGN0b3IpIHx8IFwiQ29tcG9uZW50XCIpLFxuICAgICAgICBkaWRXYXJuQWJvdXRVbmRlZmluZWREZXJpdmVkU3RhdGUuaGFzKGN0b3IpIHx8XG4gICAgICAgICAgKGRpZFdhcm5BYm91dFVuZGVmaW5lZERlcml2ZWRTdGF0ZS5hZGQoY3RvciksXG4gICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgIFwiJXMuZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzKCk6IEEgdmFsaWQgc3RhdGUgb2JqZWN0IChvciBudWxsKSBtdXN0IGJlIHJldHVybmVkLiBZb3UgaGF2ZSByZXR1cm5lZCB1bmRlZmluZWQuXCIsXG4gICAgICAgICAgICBjdG9yXG4gICAgICAgICAgKSkpO1xuICAgICAgcHJldlN0YXRlID1cbiAgICAgICAgbnVsbCA9PT0gcGFydGlhbFN0YXRlIHx8IHZvaWQgMCA9PT0gcGFydGlhbFN0YXRlXG4gICAgICAgICAgPyBwcmV2U3RhdGVcbiAgICAgICAgICA6IGFzc2lnbih7fSwgcHJldlN0YXRlLCBwYXJ0aWFsU3RhdGUpO1xuICAgICAgd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZSA9IHByZXZTdGF0ZTtcbiAgICAgIDAgPT09IHdvcmtJblByb2dyZXNzLmxhbmVzICYmXG4gICAgICAgICh3b3JrSW5Qcm9ncmVzcy51cGRhdGVRdWV1ZS5iYXNlU3RhdGUgPSBwcmV2U3RhdGUpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjaGVja1Nob3VsZENvbXBvbmVudFVwZGF0ZShcbiAgICAgIHdvcmtJblByb2dyZXNzLFxuICAgICAgY3RvcixcbiAgICAgIG9sZFByb3BzLFxuICAgICAgbmV3UHJvcHMsXG4gICAgICBvbGRTdGF0ZSxcbiAgICAgIG5ld1N0YXRlLFxuICAgICAgbmV4dENvbnRleHRcbiAgICApIHtcbiAgICAgIHZhciBpbnN0YW5jZSA9IHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZTtcbiAgICAgIGlmIChcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBpbnN0YW5jZS5zaG91bGRDb21wb25lbnRVcGRhdGUpIHtcbiAgICAgICAgb2xkUHJvcHMgPSBpbnN0YW5jZS5zaG91bGRDb21wb25lbnRVcGRhdGUoXG4gICAgICAgICAgbmV3UHJvcHMsXG4gICAgICAgICAgbmV3U3RhdGUsXG4gICAgICAgICAgbmV4dENvbnRleHRcbiAgICAgICAgKTtcbiAgICAgICAgaWYgKHdvcmtJblByb2dyZXNzLm1vZGUgJiA4KSB7XG4gICAgICAgICAgc2V0SXNTdHJpY3RNb2RlRm9yRGV2dG9vbHMoITApO1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBvbGRQcm9wcyA9IGluc3RhbmNlLnNob3VsZENvbXBvbmVudFVwZGF0ZShcbiAgICAgICAgICAgICAgbmV3UHJvcHMsXG4gICAgICAgICAgICAgIG5ld1N0YXRlLFxuICAgICAgICAgICAgICBuZXh0Q29udGV4dFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgc2V0SXNTdHJpY3RNb2RlRm9yRGV2dG9vbHMoITEpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB2b2lkIDAgPT09IG9sZFByb3BzICYmXG4gICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgIFwiJXMuc2hvdWxkQ29tcG9uZW50VXBkYXRlKCk6IFJldHVybmVkIHVuZGVmaW5lZCBpbnN0ZWFkIG9mIGEgYm9vbGVhbiB2YWx1ZS4gTWFrZSBzdXJlIHRvIHJldHVybiB0cnVlIG9yIGZhbHNlLlwiLFxuICAgICAgICAgICAgZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKGN0b3IpIHx8IFwiQ29tcG9uZW50XCJcbiAgICAgICAgICApO1xuICAgICAgICByZXR1cm4gb2xkUHJvcHM7XG4gICAgICB9XG4gICAgICByZXR1cm4gY3Rvci5wcm90b3R5cGUgJiYgY3Rvci5wcm90b3R5cGUuaXNQdXJlUmVhY3RDb21wb25lbnRcbiAgICAgICAgPyAhc2hhbGxvd0VxdWFsKG9sZFByb3BzLCBuZXdQcm9wcykgfHwgIXNoYWxsb3dFcXVhbChvbGRTdGF0ZSwgbmV3U3RhdGUpXG4gICAgICAgIDogITA7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNhbGxDb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzKFxuICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gICAgICBpbnN0YW5jZSxcbiAgICAgIG5ld1Byb3BzLFxuICAgICAgbmV4dENvbnRleHRcbiAgICApIHtcbiAgICAgIHZhciBvbGRTdGF0ZSA9IGluc3RhbmNlLnN0YXRlO1xuICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyAmJlxuICAgICAgICBpbnN0YW5jZS5jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzKG5ld1Byb3BzLCBuZXh0Q29udGV4dCk7XG4gICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBpbnN0YW5jZS5VTlNBRkVfY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyAmJlxuICAgICAgICBpbnN0YW5jZS5VTlNBRkVfY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyhuZXdQcm9wcywgbmV4dENvbnRleHQpO1xuICAgICAgaW5zdGFuY2Uuc3RhdGUgIT09IG9sZFN0YXRlICYmXG4gICAgICAgICgod29ya0luUHJvZ3Jlc3MgPVxuICAgICAgICAgIGdldENvbXBvbmVudE5hbWVGcm9tRmliZXIod29ya0luUHJvZ3Jlc3MpIHx8IFwiQ29tcG9uZW50XCIpLFxuICAgICAgICBkaWRXYXJuQWJvdXRTdGF0ZUFzc2lnbm1lbnRGb3JDb21wb25lbnQuaGFzKHdvcmtJblByb2dyZXNzKSB8fFxuICAgICAgICAgIChkaWRXYXJuQWJvdXRTdGF0ZUFzc2lnbm1lbnRGb3JDb21wb25lbnQuYWRkKHdvcmtJblByb2dyZXNzKSxcbiAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgXCIlcy5jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzKCk6IEFzc2lnbmluZyBkaXJlY3RseSB0byB0aGlzLnN0YXRlIGlzIGRlcHJlY2F0ZWQgKGV4Y2VwdCBpbnNpZGUgYSBjb21wb25lbnQncyBjb25zdHJ1Y3RvcikuIFVzZSBzZXRTdGF0ZSBpbnN0ZWFkLlwiLFxuICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3NcbiAgICAgICAgICApKSxcbiAgICAgICAgY2xhc3NDb21wb25lbnRVcGRhdGVyLmVucXVldWVSZXBsYWNlU3RhdGUoXG4gICAgICAgICAgaW5zdGFuY2UsXG4gICAgICAgICAgaW5zdGFuY2Uuc3RhdGUsXG4gICAgICAgICAgbnVsbFxuICAgICAgICApKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcmVzb2x2ZUNsYXNzQ29tcG9uZW50UHJvcHMoQ29tcG9uZW50LCBiYXNlUHJvcHMpIHtcbiAgICAgIHZhciBuZXdQcm9wcyA9IGJhc2VQcm9wcztcbiAgICAgIGlmIChcInJlZlwiIGluIGJhc2VQcm9wcykge1xuICAgICAgICBuZXdQcm9wcyA9IHt9O1xuICAgICAgICBmb3IgKHZhciBwcm9wTmFtZSBpbiBiYXNlUHJvcHMpXG4gICAgICAgICAgXCJyZWZcIiAhPT0gcHJvcE5hbWUgJiYgKG5ld1Byb3BzW3Byb3BOYW1lXSA9IGJhc2VQcm9wc1twcm9wTmFtZV0pO1xuICAgICAgfVxuICAgICAgaWYgKChDb21wb25lbnQgPSBDb21wb25lbnQuZGVmYXVsdFByb3BzKSkge1xuICAgICAgICBuZXdQcm9wcyA9PT0gYmFzZVByb3BzICYmIChuZXdQcm9wcyA9IGFzc2lnbih7fSwgbmV3UHJvcHMpKTtcbiAgICAgICAgZm9yICh2YXIgX3Byb3BOYW1lIGluIENvbXBvbmVudClcbiAgICAgICAgICB2b2lkIDAgPT09IG5ld1Byb3BzW19wcm9wTmFtZV0gJiZcbiAgICAgICAgICAgIChuZXdQcm9wc1tfcHJvcE5hbWVdID0gQ29tcG9uZW50W19wcm9wTmFtZV0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG5ld1Byb3BzO1xuICAgIH1cbiAgICBmdW5jdGlvbiBsb2dVbmNhdWdodEVycm9yKHJvb3QsIGVycm9ySW5mbykge1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29tcG9uZW50TmFtZSA9IGVycm9ySW5mby5zb3VyY2VcbiAgICAgICAgICA/IGdldENvbXBvbmVudE5hbWVGcm9tRmliZXIoZXJyb3JJbmZvLnNvdXJjZSlcbiAgICAgICAgICA6IG51bGw7XG4gICAgICAgIGVycm9yQm91bmRhcnlOYW1lID0gbnVsbDtcbiAgICAgICAgdmFyIGVycm9yID0gZXJyb3JJbmZvLnZhbHVlO1xuICAgICAgICBpZiAobnVsbCAhPT0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuYWN0UXVldWUpXG4gICAgICAgICAgUmVhY3RTaGFyZWRJbnRlcm5hbHMudGhyb3duRXJyb3JzLnB1c2goZXJyb3IpO1xuICAgICAgICBlbHNlIHtcbiAgICAgICAgICB2YXIgb25VbmNhdWdodEVycm9yID0gcm9vdC5vblVuY2F1Z2h0RXJyb3I7XG4gICAgICAgICAgb25VbmNhdWdodEVycm9yKGVycm9yLCB7IGNvbXBvbmVudFN0YWNrOiBlcnJvckluZm8uc3RhY2sgfSk7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGxvZ0NhdWdodEVycm9yKHJvb3QsIGJvdW5kYXJ5LCBlcnJvckluZm8pIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbXBvbmVudE5hbWUgPSBlcnJvckluZm8uc291cmNlXG4gICAgICAgICAgPyBnZXRDb21wb25lbnROYW1lRnJvbUZpYmVyKGVycm9ySW5mby5zb3VyY2UpXG4gICAgICAgICAgOiBudWxsO1xuICAgICAgICBlcnJvckJvdW5kYXJ5TmFtZSA9IGdldENvbXBvbmVudE5hbWVGcm9tRmliZXIoYm91bmRhcnkpO1xuICAgICAgICB2YXIgb25DYXVnaHRFcnJvciA9IHJvb3Qub25DYXVnaHRFcnJvcjtcbiAgICAgICAgb25DYXVnaHRFcnJvcihlcnJvckluZm8udmFsdWUsIHtcbiAgICAgICAgICBjb21wb25lbnRTdGFjazogZXJyb3JJbmZvLnN0YWNrLFxuICAgICAgICAgIGVycm9yQm91bmRhcnk6IDEgPT09IGJvdW5kYXJ5LnRhZyA/IGJvdW5kYXJ5LnN0YXRlTm9kZSA6IG51bGxcbiAgICAgICAgfSk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHRocm93IGU7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBjcmVhdGVSb290RXJyb3JVcGRhdGUocm9vdCwgZXJyb3JJbmZvLCBsYW5lKSB7XG4gICAgICBsYW5lID0gY3JlYXRlVXBkYXRlKGxhbmUpO1xuICAgICAgbGFuZS50YWcgPSBDYXB0dXJlVXBkYXRlO1xuICAgICAgbGFuZS5wYXlsb2FkID0geyBlbGVtZW50OiBudWxsIH07XG4gICAgICBsYW5lLmNhbGxiYWNrID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBydW5XaXRoRmliZXJJbkRFVihlcnJvckluZm8uc291cmNlLCBsb2dVbmNhdWdodEVycm9yLCByb290LCBlcnJvckluZm8pO1xuICAgICAgfTtcbiAgICAgIHJldHVybiBsYW5lO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjcmVhdGVDbGFzc0Vycm9yVXBkYXRlKGxhbmUpIHtcbiAgICAgIGxhbmUgPSBjcmVhdGVVcGRhdGUobGFuZSk7XG4gICAgICBsYW5lLnRhZyA9IENhcHR1cmVVcGRhdGU7XG4gICAgICByZXR1cm4gbGFuZTtcbiAgICB9XG4gICAgZnVuY3Rpb24gaW5pdGlhbGl6ZUNsYXNzRXJyb3JVcGRhdGUodXBkYXRlLCByb290LCBmaWJlciwgZXJyb3JJbmZvKSB7XG4gICAgICB2YXIgZ2V0RGVyaXZlZFN0YXRlRnJvbUVycm9yID0gZmliZXIudHlwZS5nZXREZXJpdmVkU3RhdGVGcm9tRXJyb3I7XG4gICAgICBpZiAoXCJmdW5jdGlvblwiID09PSB0eXBlb2YgZ2V0RGVyaXZlZFN0YXRlRnJvbUVycm9yKSB7XG4gICAgICAgIHZhciBlcnJvciA9IGVycm9ySW5mby52YWx1ZTtcbiAgICAgICAgdXBkYXRlLnBheWxvYWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIGdldERlcml2ZWRTdGF0ZUZyb21FcnJvcihlcnJvcik7XG4gICAgICAgIH07XG4gICAgICAgIHVwZGF0ZS5jYWxsYmFjayA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBtYXJrRmFpbGVkRXJyb3JCb3VuZGFyeUZvckhvdFJlbG9hZGluZyhmaWJlcik7XG4gICAgICAgICAgcnVuV2l0aEZpYmVySW5ERVYoXG4gICAgICAgICAgICBlcnJvckluZm8uc291cmNlLFxuICAgICAgICAgICAgbG9nQ2F1Z2h0RXJyb3IsXG4gICAgICAgICAgICByb290LFxuICAgICAgICAgICAgZmliZXIsXG4gICAgICAgICAgICBlcnJvckluZm9cbiAgICAgICAgICApO1xuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgdmFyIGluc3QgPSBmaWJlci5zdGF0ZU5vZGU7XG4gICAgICBudWxsICE9PSBpbnN0ICYmXG4gICAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIGluc3QuY29tcG9uZW50RGlkQ2F0Y2ggJiZcbiAgICAgICAgKHVwZGF0ZS5jYWxsYmFjayA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBtYXJrRmFpbGVkRXJyb3JCb3VuZGFyeUZvckhvdFJlbG9hZGluZyhmaWJlcik7XG4gICAgICAgICAgcnVuV2l0aEZpYmVySW5ERVYoXG4gICAgICAgICAgICBlcnJvckluZm8uc291cmNlLFxuICAgICAgICAgICAgbG9nQ2F1Z2h0RXJyb3IsXG4gICAgICAgICAgICByb290LFxuICAgICAgICAgICAgZmliZXIsXG4gICAgICAgICAgICBlcnJvckluZm9cbiAgICAgICAgICApO1xuICAgICAgICAgIFwiZnVuY3Rpb25cIiAhPT0gdHlwZW9mIGdldERlcml2ZWRTdGF0ZUZyb21FcnJvciAmJlxuICAgICAgICAgICAgKG51bGwgPT09IGxlZ2FjeUVycm9yQm91bmRhcmllc1RoYXRBbHJlYWR5RmFpbGVkXG4gICAgICAgICAgICAgID8gKGxlZ2FjeUVycm9yQm91bmRhcmllc1RoYXRBbHJlYWR5RmFpbGVkID0gbmV3IFNldChbdGhpc10pKVxuICAgICAgICAgICAgICA6IGxlZ2FjeUVycm9yQm91bmRhcmllc1RoYXRBbHJlYWR5RmFpbGVkLmFkZCh0aGlzKSk7XG4gICAgICAgICAgY2FsbENvbXBvbmVudERpZENhdGNoSW5ERVYodGhpcywgZXJyb3JJbmZvKTtcbiAgICAgICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBnZXREZXJpdmVkU3RhdGVGcm9tRXJyb3IgfHxcbiAgICAgICAgICAgICgwID09PSAoZmliZXIubGFuZXMgJiAyKSAmJlxuICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICAgIFwiJXM6IEVycm9yIGJvdW5kYXJpZXMgc2hvdWxkIGltcGxlbWVudCBnZXREZXJpdmVkU3RhdGVGcm9tRXJyb3IoKS4gSW4gdGhhdCBtZXRob2QsIHJldHVybiBhIHN0YXRlIHVwZGF0ZSB0byBkaXNwbGF5IGFuIGVycm9yIG1lc3NhZ2Ugb3IgZmFsbGJhY2sgVUkuXCIsXG4gICAgICAgICAgICAgICAgZ2V0Q29tcG9uZW50TmFtZUZyb21GaWJlcihmaWJlcikgfHwgXCJVbmtub3duXCJcbiAgICAgICAgICAgICAgKSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBmdW5jdGlvbiB0aHJvd0V4Y2VwdGlvbihcbiAgICAgIHJvb3QsXG4gICAgICByZXR1cm5GaWJlcixcbiAgICAgIHNvdXJjZUZpYmVyLFxuICAgICAgdmFsdWUsXG4gICAgICByb290UmVuZGVyTGFuZXNcbiAgICApIHtcbiAgICAgIHNvdXJjZUZpYmVyLmZsYWdzIHw9IDMyNzY4O1xuICAgICAgaXNEZXZUb29sc1ByZXNlbnQgJiYgcmVzdG9yZVBlbmRpbmdVcGRhdGVycyhyb290LCByb290UmVuZGVyTGFuZXMpO1xuICAgICAgaWYgKFxuICAgICAgICBudWxsICE9PSB2YWx1ZSAmJlxuICAgICAgICBcIm9iamVjdFwiID09PSB0eXBlb2YgdmFsdWUgJiZcbiAgICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgdmFsdWUudGhlblxuICAgICAgKSB7XG4gICAgICAgIHJldHVybkZpYmVyID0gc291cmNlRmliZXIuYWx0ZXJuYXRlO1xuICAgICAgICBudWxsICE9PSByZXR1cm5GaWJlciAmJlxuICAgICAgICAgIHByb3BhZ2F0ZVBhcmVudENvbnRleHRDaGFuZ2VzKFxuICAgICAgICAgICAgcmV0dXJuRmliZXIsXG4gICAgICAgICAgICBzb3VyY2VGaWJlcixcbiAgICAgICAgICAgIHJvb3RSZW5kZXJMYW5lcyxcbiAgICAgICAgICAgICEwXG4gICAgICAgICAgKTtcbiAgICAgICAgaXNIeWRyYXRpbmcgJiYgKGRpZFN1c3BlbmRPckVycm9yREVWID0gITApO1xuICAgICAgICBzb3VyY2VGaWJlciA9IHN1c3BlbnNlSGFuZGxlclN0YWNrQ3Vyc29yLmN1cnJlbnQ7XG4gICAgICAgIGlmIChudWxsICE9PSBzb3VyY2VGaWJlcikge1xuICAgICAgICAgIHN3aXRjaCAoc291cmNlRmliZXIudGFnKSB7XG4gICAgICAgICAgICBjYXNlIDEzOlxuICAgICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICAgIG51bGwgPT09IHNoZWxsQm91bmRhcnlcbiAgICAgICAgICAgICAgICAgID8gcmVuZGVyRGlkU3VzcGVuZERlbGF5SWZQb3NzaWJsZSgpXG4gICAgICAgICAgICAgICAgICA6IG51bGwgPT09IHNvdXJjZUZpYmVyLmFsdGVybmF0ZSAmJlxuICAgICAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzc1Jvb3RFeGl0U3RhdHVzID09PSBSb290SW5Qcm9ncmVzcyAmJlxuICAgICAgICAgICAgICAgICAgICAod29ya0luUHJvZ3Jlc3NSb290RXhpdFN0YXR1cyA9IFJvb3RTdXNwZW5kZWQpLFxuICAgICAgICAgICAgICAgIChzb3VyY2VGaWJlci5mbGFncyAmPSAtMjU3KSxcbiAgICAgICAgICAgICAgICAoc291cmNlRmliZXIuZmxhZ3MgfD0gNjU1MzYpLFxuICAgICAgICAgICAgICAgIChzb3VyY2VGaWJlci5sYW5lcyA9IHJvb3RSZW5kZXJMYW5lcyksXG4gICAgICAgICAgICAgICAgdmFsdWUgPT09IG5vb3BTdXNwZW5zZXlDb21taXRUaGVuYWJsZVxuICAgICAgICAgICAgICAgICAgPyAoc291cmNlRmliZXIuZmxhZ3MgfD0gMTYzODQpXG4gICAgICAgICAgICAgICAgICA6ICgocmV0dXJuRmliZXIgPSBzb3VyY2VGaWJlci51cGRhdGVRdWV1ZSksXG4gICAgICAgICAgICAgICAgICAgIG51bGwgPT09IHJldHVybkZpYmVyXG4gICAgICAgICAgICAgICAgICAgICAgPyAoc291cmNlRmliZXIudXBkYXRlUXVldWUgPSBuZXcgU2V0KFt2YWx1ZV0pKVxuICAgICAgICAgICAgICAgICAgICAgIDogcmV0dXJuRmliZXIuYWRkKHZhbHVlKSxcbiAgICAgICAgICAgICAgICAgICAgYXR0YWNoUGluZ0xpc3RlbmVyKHJvb3QsIHZhbHVlLCByb290UmVuZGVyTGFuZXMpKSxcbiAgICAgICAgICAgICAgICAhMVxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgY2FzZSAyMjpcbiAgICAgICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICAgICAoc291cmNlRmliZXIuZmxhZ3MgfD0gNjU1MzYpLFxuICAgICAgICAgICAgICAgIHZhbHVlID09PSBub29wU3VzcGVuc2V5Q29tbWl0VGhlbmFibGVcbiAgICAgICAgICAgICAgICAgID8gKHNvdXJjZUZpYmVyLmZsYWdzIHw9IDE2Mzg0KVxuICAgICAgICAgICAgICAgICAgOiAoKHJldHVybkZpYmVyID0gc291cmNlRmliZXIudXBkYXRlUXVldWUpLFxuICAgICAgICAgICAgICAgICAgICBudWxsID09PSByZXR1cm5GaWJlclxuICAgICAgICAgICAgICAgICAgICAgID8gKChyZXR1cm5GaWJlciA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgdHJhbnNpdGlvbnM6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIG1hcmtlckluc3RhbmNlczogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0cnlRdWV1ZTogbmV3IFNldChbdmFsdWVdKVxuICAgICAgICAgICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgICAgICAgICAoc291cmNlRmliZXIudXBkYXRlUXVldWUgPSByZXR1cm5GaWJlcikpXG4gICAgICAgICAgICAgICAgICAgICAgOiAoKHNvdXJjZUZpYmVyID0gcmV0dXJuRmliZXIucmV0cnlRdWV1ZSksXG4gICAgICAgICAgICAgICAgICAgICAgICBudWxsID09PSBzb3VyY2VGaWJlclxuICAgICAgICAgICAgICAgICAgICAgICAgICA/IChyZXR1cm5GaWJlci5yZXRyeVF1ZXVlID0gbmV3IFNldChbdmFsdWVdKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgOiBzb3VyY2VGaWJlci5hZGQodmFsdWUpKSxcbiAgICAgICAgICAgICAgICAgICAgYXR0YWNoUGluZ0xpc3RlbmVyKHJvb3QsIHZhbHVlLCByb290UmVuZGVyTGFuZXMpKSxcbiAgICAgICAgICAgICAgICAhMVxuICAgICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aHJvdyBFcnJvcihcbiAgICAgICAgICAgIFwiVW5leHBlY3RlZCBTdXNwZW5zZSBoYW5kbGVyIHRhZyAoXCIgK1xuICAgICAgICAgICAgICBzb3VyY2VGaWJlci50YWcgK1xuICAgICAgICAgICAgICBcIikuIFRoaXMgaXMgYSBidWcgaW4gUmVhY3QuXCJcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIGF0dGFjaFBpbmdMaXN0ZW5lcihyb290LCB2YWx1ZSwgcm9vdFJlbmRlckxhbmVzKTtcbiAgICAgICAgcmVuZGVyRGlkU3VzcGVuZERlbGF5SWZQb3NzaWJsZSgpO1xuICAgICAgICByZXR1cm4gITE7XG4gICAgICB9XG4gICAgICBpZiAoaXNIeWRyYXRpbmcpXG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgKGRpZFN1c3BlbmRPckVycm9yREVWID0gITApLFxuICAgICAgICAgIChyZXR1cm5GaWJlciA9IHN1c3BlbnNlSGFuZGxlclN0YWNrQ3Vyc29yLmN1cnJlbnQpLFxuICAgICAgICAgIG51bGwgIT09IHJldHVybkZpYmVyXG4gICAgICAgICAgICA/ICgwID09PSAocmV0dXJuRmliZXIuZmxhZ3MgJiA2NTUzNikgJiYgKHJldHVybkZpYmVyLmZsYWdzIHw9IDI1NiksXG4gICAgICAgICAgICAgIChyZXR1cm5GaWJlci5mbGFncyB8PSA2NTUzNiksXG4gICAgICAgICAgICAgIChyZXR1cm5GaWJlci5sYW5lcyA9IHJvb3RSZW5kZXJMYW5lcyksXG4gICAgICAgICAgICAgIHZhbHVlICE9PSBIeWRyYXRpb25NaXNtYXRjaEV4Y2VwdGlvbiAmJlxuICAgICAgICAgICAgICAgIHF1ZXVlSHlkcmF0aW9uRXJyb3IoXG4gICAgICAgICAgICAgICAgICBjcmVhdGVDYXB0dXJlZFZhbHVlQXRGaWJlcihcbiAgICAgICAgICAgICAgICAgICAgRXJyb3IoXG4gICAgICAgICAgICAgICAgICAgICAgXCJUaGVyZSB3YXMgYW4gZXJyb3Igd2hpbGUgaHlkcmF0aW5nIGJ1dCBSZWFjdCB3YXMgYWJsZSB0byByZWNvdmVyIGJ5IGluc3RlYWQgY2xpZW50IHJlbmRlcmluZyBmcm9tIHRoZSBuZWFyZXN0IFN1c3BlbnNlIGJvdW5kYXJ5LlwiLFxuICAgICAgICAgICAgICAgICAgICAgIHsgY2F1c2U6IHZhbHVlIH1cbiAgICAgICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICAgICAgc291cmNlRmliZXJcbiAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICApKVxuICAgICAgICAgICAgOiAodmFsdWUgIT09IEh5ZHJhdGlvbk1pc21hdGNoRXhjZXB0aW9uICYmXG4gICAgICAgICAgICAgICAgcXVldWVIeWRyYXRpb25FcnJvcihcbiAgICAgICAgICAgICAgICAgIGNyZWF0ZUNhcHR1cmVkVmFsdWVBdEZpYmVyKFxuICAgICAgICAgICAgICAgICAgICBFcnJvcihcbiAgICAgICAgICAgICAgICAgICAgICBcIlRoZXJlIHdhcyBhbiBlcnJvciB3aGlsZSBoeWRyYXRpbmcgYnV0IFJlYWN0IHdhcyBhYmxlIHRvIHJlY292ZXIgYnkgaW5zdGVhZCBjbGllbnQgcmVuZGVyaW5nIHRoZSBlbnRpcmUgcm9vdC5cIixcbiAgICAgICAgICAgICAgICAgICAgICB7IGNhdXNlOiB2YWx1ZSB9XG4gICAgICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgICAgIHNvdXJjZUZpYmVyXG4gICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgKHJvb3QgPSByb290LmN1cnJlbnQuYWx0ZXJuYXRlKSxcbiAgICAgICAgICAgICAgKHJvb3QuZmxhZ3MgfD0gNjU1MzYpLFxuICAgICAgICAgICAgICAocm9vdFJlbmRlckxhbmVzICY9IC1yb290UmVuZGVyTGFuZXMpLFxuICAgICAgICAgICAgICAocm9vdC5sYW5lcyB8PSByb290UmVuZGVyTGFuZXMpLFxuICAgICAgICAgICAgICAodmFsdWUgPSBjcmVhdGVDYXB0dXJlZFZhbHVlQXRGaWJlcih2YWx1ZSwgc291cmNlRmliZXIpKSxcbiAgICAgICAgICAgICAgKHJvb3RSZW5kZXJMYW5lcyA9IGNyZWF0ZVJvb3RFcnJvclVwZGF0ZShcbiAgICAgICAgICAgICAgICByb290LnN0YXRlTm9kZSxcbiAgICAgICAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICAgICAgICByb290UmVuZGVyTGFuZXNcbiAgICAgICAgICAgICAgKSksXG4gICAgICAgICAgICAgIGVucXVldWVDYXB0dXJlZFVwZGF0ZShyb290LCByb290UmVuZGVyTGFuZXMpLFxuICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzc1Jvb3RFeGl0U3RhdHVzICE9PSBSb290U3VzcGVuZGVkV2l0aERlbGF5ICYmXG4gICAgICAgICAgICAgICAgKHdvcmtJblByb2dyZXNzUm9vdEV4aXRTdGF0dXMgPSBSb290RXJyb3JlZCkpLFxuICAgICAgICAgICExXG4gICAgICAgICk7XG4gICAgICB2YXIgZXJyb3IgPSBjcmVhdGVDYXB0dXJlZFZhbHVlQXRGaWJlcihcbiAgICAgICAgRXJyb3IoXG4gICAgICAgICAgXCJUaGVyZSB3YXMgYW4gZXJyb3IgZHVyaW5nIGNvbmN1cnJlbnQgcmVuZGVyaW5nIGJ1dCBSZWFjdCB3YXMgYWJsZSB0byByZWNvdmVyIGJ5IGluc3RlYWQgc3luY2hyb25vdXNseSByZW5kZXJpbmcgdGhlIGVudGlyZSByb290LlwiLFxuICAgICAgICAgIHsgY2F1c2U6IHZhbHVlIH1cbiAgICAgICAgKSxcbiAgICAgICAgc291cmNlRmliZXJcbiAgICAgICk7XG4gICAgICBudWxsID09PSB3b3JrSW5Qcm9ncmVzc1Jvb3RDb25jdXJyZW50RXJyb3JzXG4gICAgICAgID8gKHdvcmtJblByb2dyZXNzUm9vdENvbmN1cnJlbnRFcnJvcnMgPSBbZXJyb3JdKVxuICAgICAgICA6IHdvcmtJblByb2dyZXNzUm9vdENvbmN1cnJlbnRFcnJvcnMucHVzaChlcnJvcik7XG4gICAgICB3b3JrSW5Qcm9ncmVzc1Jvb3RFeGl0U3RhdHVzICE9PSBSb290U3VzcGVuZGVkV2l0aERlbGF5ICYmXG4gICAgICAgICh3b3JrSW5Qcm9ncmVzc1Jvb3RFeGl0U3RhdHVzID0gUm9vdEVycm9yZWQpO1xuICAgICAgaWYgKG51bGwgPT09IHJldHVybkZpYmVyKSByZXR1cm4gITA7XG4gICAgICB2YWx1ZSA9IGNyZWF0ZUNhcHR1cmVkVmFsdWVBdEZpYmVyKHZhbHVlLCBzb3VyY2VGaWJlcik7XG4gICAgICBzb3VyY2VGaWJlciA9IHJldHVybkZpYmVyO1xuICAgICAgZG8ge1xuICAgICAgICBzd2l0Y2ggKHNvdXJjZUZpYmVyLnRhZykge1xuICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAgIChzb3VyY2VGaWJlci5mbGFncyB8PSA2NTUzNiksXG4gICAgICAgICAgICAgIChyb290ID0gcm9vdFJlbmRlckxhbmVzICYgLXJvb3RSZW5kZXJMYW5lcyksXG4gICAgICAgICAgICAgIChzb3VyY2VGaWJlci5sYW5lcyB8PSByb290KSxcbiAgICAgICAgICAgICAgKHJvb3QgPSBjcmVhdGVSb290RXJyb3JVcGRhdGUoXG4gICAgICAgICAgICAgICAgc291cmNlRmliZXIuc3RhdGVOb2RlLFxuICAgICAgICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgICAgICAgIHJvb3RcbiAgICAgICAgICAgICAgKSksXG4gICAgICAgICAgICAgIGVucXVldWVDYXB0dXJlZFVwZGF0ZShzb3VyY2VGaWJlciwgcm9vdCksXG4gICAgICAgICAgICAgICExXG4gICAgICAgICAgICApO1xuICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgKChyZXR1cm5GaWJlciA9IHNvdXJjZUZpYmVyLnR5cGUpLFxuICAgICAgICAgICAgICAoZXJyb3IgPSBzb3VyY2VGaWJlci5zdGF0ZU5vZGUpLFxuICAgICAgICAgICAgICAwID09PSAoc291cmNlRmliZXIuZmxhZ3MgJiAxMjgpICYmXG4gICAgICAgICAgICAgICAgKFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIHJldHVybkZpYmVyLmdldERlcml2ZWRTdGF0ZUZyb21FcnJvciB8fFxuICAgICAgICAgICAgICAgICAgKG51bGwgIT09IGVycm9yICYmXG4gICAgICAgICAgICAgICAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIGVycm9yLmNvbXBvbmVudERpZENhdGNoICYmXG4gICAgICAgICAgICAgICAgICAgIChudWxsID09PSBsZWdhY3lFcnJvckJvdW5kYXJpZXNUaGF0QWxyZWFkeUZhaWxlZCB8fFxuICAgICAgICAgICAgICAgICAgICAgICFsZWdhY3lFcnJvckJvdW5kYXJpZXNUaGF0QWxyZWFkeUZhaWxlZC5oYXMoZXJyb3IpKSkpKVxuICAgICAgICAgICAgKVxuICAgICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICAgIChzb3VyY2VGaWJlci5mbGFncyB8PSA2NTUzNiksXG4gICAgICAgICAgICAgICAgKHJvb3RSZW5kZXJMYW5lcyAmPSAtcm9vdFJlbmRlckxhbmVzKSxcbiAgICAgICAgICAgICAgICAoc291cmNlRmliZXIubGFuZXMgfD0gcm9vdFJlbmRlckxhbmVzKSxcbiAgICAgICAgICAgICAgICAocm9vdFJlbmRlckxhbmVzID0gY3JlYXRlQ2xhc3NFcnJvclVwZGF0ZShyb290UmVuZGVyTGFuZXMpKSxcbiAgICAgICAgICAgICAgICBpbml0aWFsaXplQ2xhc3NFcnJvclVwZGF0ZShcbiAgICAgICAgICAgICAgICAgIHJvb3RSZW5kZXJMYW5lcyxcbiAgICAgICAgICAgICAgICAgIHJvb3QsXG4gICAgICAgICAgICAgICAgICBzb3VyY2VGaWJlcixcbiAgICAgICAgICAgICAgICAgIHZhbHVlXG4gICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICBlbnF1ZXVlQ2FwdHVyZWRVcGRhdGUoc291cmNlRmliZXIsIHJvb3RSZW5kZXJMYW5lcyksXG4gICAgICAgICAgICAgICAgITFcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICBzb3VyY2VGaWJlciA9IHNvdXJjZUZpYmVyLnJldHVybjtcbiAgICAgIH0gd2hpbGUgKG51bGwgIT09IHNvdXJjZUZpYmVyKTtcbiAgICAgIHJldHVybiAhMTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcmVjb25jaWxlQ2hpbGRyZW4oXG4gICAgICBjdXJyZW50LFxuICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gICAgICBuZXh0Q2hpbGRyZW4sXG4gICAgICByZW5kZXJMYW5lc1xuICAgICkge1xuICAgICAgd29ya0luUHJvZ3Jlc3MuY2hpbGQgPVxuICAgICAgICBudWxsID09PSBjdXJyZW50XG4gICAgICAgICAgPyBtb3VudENoaWxkRmliZXJzKHdvcmtJblByb2dyZXNzLCBudWxsLCBuZXh0Q2hpbGRyZW4sIHJlbmRlckxhbmVzKVxuICAgICAgICAgIDogcmVjb25jaWxlQ2hpbGRGaWJlcnMoXG4gICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLFxuICAgICAgICAgICAgICBjdXJyZW50LmNoaWxkLFxuICAgICAgICAgICAgICBuZXh0Q2hpbGRyZW4sXG4gICAgICAgICAgICAgIHJlbmRlckxhbmVzXG4gICAgICAgICAgICApO1xuICAgIH1cbiAgICBmdW5jdGlvbiB1cGRhdGVGb3J3YXJkUmVmKFxuICAgICAgY3VycmVudCxcbiAgICAgIHdvcmtJblByb2dyZXNzLFxuICAgICAgQ29tcG9uZW50LFxuICAgICAgbmV4dFByb3BzLFxuICAgICAgcmVuZGVyTGFuZXNcbiAgICApIHtcbiAgICAgIENvbXBvbmVudCA9IENvbXBvbmVudC5yZW5kZXI7XG4gICAgICB2YXIgcmVmID0gd29ya0luUHJvZ3Jlc3MucmVmO1xuICAgICAgaWYgKFwicmVmXCIgaW4gbmV4dFByb3BzKSB7XG4gICAgICAgIHZhciBwcm9wc1dpdGhvdXRSZWYgPSB7fTtcbiAgICAgICAgZm9yICh2YXIga2V5IGluIG5leHRQcm9wcylcbiAgICAgICAgICBcInJlZlwiICE9PSBrZXkgJiYgKHByb3BzV2l0aG91dFJlZltrZXldID0gbmV4dFByb3BzW2tleV0pO1xuICAgICAgfSBlbHNlIHByb3BzV2l0aG91dFJlZiA9IG5leHRQcm9wcztcbiAgICAgIHByZXBhcmVUb1JlYWRDb250ZXh0KHdvcmtJblByb2dyZXNzKTtcbiAgICAgIG1hcmtDb21wb25lbnRSZW5kZXJTdGFydGVkKHdvcmtJblByb2dyZXNzKTtcbiAgICAgIG5leHRQcm9wcyA9IHJlbmRlcldpdGhIb29rcyhcbiAgICAgICAgY3VycmVudCxcbiAgICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gICAgICAgIENvbXBvbmVudCxcbiAgICAgICAgcHJvcHNXaXRob3V0UmVmLFxuICAgICAgICByZWYsXG4gICAgICAgIHJlbmRlckxhbmVzXG4gICAgICApO1xuICAgICAga2V5ID0gY2hlY2tEaWRSZW5kZXJJZEhvb2soKTtcbiAgICAgIG1hcmtDb21wb25lbnRSZW5kZXJTdG9wcGVkKCk7XG4gICAgICBpZiAobnVsbCAhPT0gY3VycmVudCAmJiAhZGlkUmVjZWl2ZVVwZGF0ZSlcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICBiYWlsb3V0SG9va3MoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckxhbmVzKSxcbiAgICAgICAgICBiYWlsb3V0T25BbHJlYWR5RmluaXNoZWRXb3JrKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCByZW5kZXJMYW5lcylcbiAgICAgICAgKTtcbiAgICAgIGlzSHlkcmF0aW5nICYmIGtleSAmJiBwdXNoTWF0ZXJpYWxpemVkVHJlZUlkKHdvcmtJblByb2dyZXNzKTtcbiAgICAgIHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IDE7XG4gICAgICByZWNvbmNpbGVDaGlsZHJlbihjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgbmV4dFByb3BzLCByZW5kZXJMYW5lcyk7XG4gICAgICByZXR1cm4gd29ya0luUHJvZ3Jlc3MuY2hpbGQ7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHVwZGF0ZU1lbW9Db21wb25lbnQoXG4gICAgICBjdXJyZW50LFxuICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gICAgICBDb21wb25lbnQsXG4gICAgICBuZXh0UHJvcHMsXG4gICAgICByZW5kZXJMYW5lc1xuICAgICkge1xuICAgICAgaWYgKG51bGwgPT09IGN1cnJlbnQpIHtcbiAgICAgICAgdmFyIHR5cGUgPSBDb21wb25lbnQudHlwZTtcbiAgICAgICAgaWYgKFxuICAgICAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIHR5cGUgJiZcbiAgICAgICAgICAhc2hvdWxkQ29uc3RydWN0KHR5cGUpICYmXG4gICAgICAgICAgdm9pZCAwID09PSB0eXBlLmRlZmF1bHRQcm9wcyAmJlxuICAgICAgICAgIG51bGwgPT09IENvbXBvbmVudC5jb21wYXJlXG4gICAgICAgIClcbiAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgKENvbXBvbmVudCA9IHJlc29sdmVGdW5jdGlvbkZvckhvdFJlbG9hZGluZyh0eXBlKSksXG4gICAgICAgICAgICAod29ya0luUHJvZ3Jlc3MudGFnID0gMTUpLFxuICAgICAgICAgICAgKHdvcmtJblByb2dyZXNzLnR5cGUgPSBDb21wb25lbnQpLFxuICAgICAgICAgICAgdmFsaWRhdGVGdW5jdGlvbkNvbXBvbmVudEluRGV2KHdvcmtJblByb2dyZXNzLCB0eXBlKSxcbiAgICAgICAgICAgIHVwZGF0ZVNpbXBsZU1lbW9Db21wb25lbnQoXG4gICAgICAgICAgICAgIGN1cnJlbnQsXG4gICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLFxuICAgICAgICAgICAgICBDb21wb25lbnQsXG4gICAgICAgICAgICAgIG5leHRQcm9wcyxcbiAgICAgICAgICAgICAgcmVuZGVyTGFuZXNcbiAgICAgICAgICAgIClcbiAgICAgICAgICApO1xuICAgICAgICBjdXJyZW50ID0gY3JlYXRlRmliZXJGcm9tVHlwZUFuZFByb3BzKFxuICAgICAgICAgIENvbXBvbmVudC50eXBlLFxuICAgICAgICAgIG51bGwsXG4gICAgICAgICAgbmV4dFByb3BzLFxuICAgICAgICAgIHdvcmtJblByb2dyZXNzLFxuICAgICAgICAgIHdvcmtJblByb2dyZXNzLm1vZGUsXG4gICAgICAgICAgcmVuZGVyTGFuZXNcbiAgICAgICAgKTtcbiAgICAgICAgY3VycmVudC5yZWYgPSB3b3JrSW5Qcm9ncmVzcy5yZWY7XG4gICAgICAgIGN1cnJlbnQucmV0dXJuID0gd29ya0luUHJvZ3Jlc3M7XG4gICAgICAgIHJldHVybiAod29ya0luUHJvZ3Jlc3MuY2hpbGQgPSBjdXJyZW50KTtcbiAgICAgIH1cbiAgICAgIHR5cGUgPSBjdXJyZW50LmNoaWxkO1xuICAgICAgaWYgKCFjaGVja1NjaGVkdWxlZFVwZGF0ZU9yQ29udGV4dChjdXJyZW50LCByZW5kZXJMYW5lcykpIHtcbiAgICAgICAgdmFyIHByZXZQcm9wcyA9IHR5cGUubWVtb2l6ZWRQcm9wcztcbiAgICAgICAgQ29tcG9uZW50ID0gQ29tcG9uZW50LmNvbXBhcmU7XG4gICAgICAgIENvbXBvbmVudCA9IG51bGwgIT09IENvbXBvbmVudCA/IENvbXBvbmVudCA6IHNoYWxsb3dFcXVhbDtcbiAgICAgICAgaWYgKFxuICAgICAgICAgIENvbXBvbmVudChwcmV2UHJvcHMsIG5leHRQcm9wcykgJiZcbiAgICAgICAgICBjdXJyZW50LnJlZiA9PT0gd29ya0luUHJvZ3Jlc3MucmVmXG4gICAgICAgIClcbiAgICAgICAgICByZXR1cm4gYmFpbG91dE9uQWxyZWFkeUZpbmlzaGVkV29yayhcbiAgICAgICAgICAgIGN1cnJlbnQsXG4gICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgICAgICAgICAgIHJlbmRlckxhbmVzXG4gICAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IDE7XG4gICAgICBjdXJyZW50ID0gY3JlYXRlV29ya0luUHJvZ3Jlc3ModHlwZSwgbmV4dFByb3BzKTtcbiAgICAgIGN1cnJlbnQucmVmID0gd29ya0luUHJvZ3Jlc3MucmVmO1xuICAgICAgY3VycmVudC5yZXR1cm4gPSB3b3JrSW5Qcm9ncmVzcztcbiAgICAgIHJldHVybiAod29ya0luUHJvZ3Jlc3MuY2hpbGQgPSBjdXJyZW50KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gdXBkYXRlU2ltcGxlTWVtb0NvbXBvbmVudChcbiAgICAgIGN1cnJlbnQsXG4gICAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgICAgIENvbXBvbmVudCxcbiAgICAgIG5leHRQcm9wcyxcbiAgICAgIHJlbmRlckxhbmVzXG4gICAgKSB7XG4gICAgICBpZiAobnVsbCAhPT0gY3VycmVudCkge1xuICAgICAgICB2YXIgcHJldlByb3BzID0gY3VycmVudC5tZW1vaXplZFByb3BzO1xuICAgICAgICBpZiAoXG4gICAgICAgICAgc2hhbGxvd0VxdWFsKHByZXZQcm9wcywgbmV4dFByb3BzKSAmJlxuICAgICAgICAgIGN1cnJlbnQucmVmID09PSB3b3JrSW5Qcm9ncmVzcy5yZWYgJiZcbiAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy50eXBlID09PSBjdXJyZW50LnR5cGVcbiAgICAgICAgKVxuICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICgoZGlkUmVjZWl2ZVVwZGF0ZSA9ICExKSxcbiAgICAgICAgICAgICh3b3JrSW5Qcm9ncmVzcy5wZW5kaW5nUHJvcHMgPSBuZXh0UHJvcHMgPSBwcmV2UHJvcHMpLFxuICAgICAgICAgICAgY2hlY2tTY2hlZHVsZWRVcGRhdGVPckNvbnRleHQoY3VycmVudCwgcmVuZGVyTGFuZXMpKVxuICAgICAgICAgIClcbiAgICAgICAgICAgIDAgIT09IChjdXJyZW50LmZsYWdzICYgMTMxMDcyKSAmJiAoZGlkUmVjZWl2ZVVwZGF0ZSA9ICEwKTtcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICAod29ya0luUHJvZ3Jlc3MubGFuZXMgPSBjdXJyZW50LmxhbmVzKSxcbiAgICAgICAgICAgICAgYmFpbG91dE9uQWxyZWFkeUZpbmlzaGVkV29yayhjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyTGFuZXMpXG4gICAgICAgICAgICApO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHVwZGF0ZUZ1bmN0aW9uQ29tcG9uZW50KFxuICAgICAgICBjdXJyZW50LFxuICAgICAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgICAgICAgQ29tcG9uZW50LFxuICAgICAgICBuZXh0UHJvcHMsXG4gICAgICAgIHJlbmRlckxhbmVzXG4gICAgICApO1xuICAgIH1cbiAgICBmdW5jdGlvbiB1cGRhdGVPZmZzY3JlZW5Db21wb25lbnQoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckxhbmVzKSB7XG4gICAgICB2YXIgbmV4dFByb3BzID0gd29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzLFxuICAgICAgICBuZXh0Q2hpbGRyZW4gPSBuZXh0UHJvcHMuY2hpbGRyZW4sXG4gICAgICAgIG5leHRJc0RldGFjaGVkID1cbiAgICAgICAgICAwICE9PSAod29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlLl9wZW5kaW5nVmlzaWJpbGl0eSAmIDIpLFxuICAgICAgICBwcmV2U3RhdGUgPSBudWxsICE9PSBjdXJyZW50ID8gY3VycmVudC5tZW1vaXplZFN0YXRlIDogbnVsbDtcbiAgICAgIG1hcmtSZWYoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MpO1xuICAgICAgaWYgKFwiaGlkZGVuXCIgPT09IG5leHRQcm9wcy5tb2RlIHx8IG5leHRJc0RldGFjaGVkKSB7XG4gICAgICAgIGlmICgwICE9PSAod29ya0luUHJvZ3Jlc3MuZmxhZ3MgJiAxMjgpKSB7XG4gICAgICAgICAgbmV4dFByb3BzID1cbiAgICAgICAgICAgIG51bGwgIT09IHByZXZTdGF0ZVxuICAgICAgICAgICAgICA/IHByZXZTdGF0ZS5iYXNlTGFuZXMgfCByZW5kZXJMYW5lc1xuICAgICAgICAgICAgICA6IHJlbmRlckxhbmVzO1xuICAgICAgICAgIGlmIChudWxsICE9PSBjdXJyZW50KSB7XG4gICAgICAgICAgICBuZXh0Q2hpbGRyZW4gPSB3b3JrSW5Qcm9ncmVzcy5jaGlsZCA9IGN1cnJlbnQuY2hpbGQ7XG4gICAgICAgICAgICBmb3IgKG5leHRJc0RldGFjaGVkID0gMDsgbnVsbCAhPT0gbmV4dENoaWxkcmVuOyApXG4gICAgICAgICAgICAgIChuZXh0SXNEZXRhY2hlZCA9XG4gICAgICAgICAgICAgICAgbmV4dElzRGV0YWNoZWQgfCBuZXh0Q2hpbGRyZW4ubGFuZXMgfCBuZXh0Q2hpbGRyZW4uY2hpbGRMYW5lcyksXG4gICAgICAgICAgICAgICAgKG5leHRDaGlsZHJlbiA9IG5leHRDaGlsZHJlbi5zaWJsaW5nKTtcbiAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLmNoaWxkTGFuZXMgPSBuZXh0SXNEZXRhY2hlZCAmIH5uZXh0UHJvcHM7XG4gICAgICAgICAgfSBlbHNlICh3b3JrSW5Qcm9ncmVzcy5jaGlsZExhbmVzID0gMCksICh3b3JrSW5Qcm9ncmVzcy5jaGlsZCA9IG51bGwpO1xuICAgICAgICAgIHJldHVybiBkZWZlckhpZGRlbk9mZnNjcmVlbkNvbXBvbmVudChcbiAgICAgICAgICAgIGN1cnJlbnQsXG4gICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgICAgICAgICAgIG5leHRQcm9wcyxcbiAgICAgICAgICAgIHJlbmRlckxhbmVzXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoMCAhPT0gKHJlbmRlckxhbmVzICYgNTM2ODcwOTEyKSlcbiAgICAgICAgICAod29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZSA9IHsgYmFzZUxhbmVzOiAwLCBjYWNoZVBvb2w6IG51bGwgfSksXG4gICAgICAgICAgICBudWxsICE9PSBjdXJyZW50ICYmXG4gICAgICAgICAgICAgIHB1c2hUcmFuc2l0aW9uKFxuICAgICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLFxuICAgICAgICAgICAgICAgIG51bGwgIT09IHByZXZTdGF0ZSA/IHByZXZTdGF0ZS5jYWNoZVBvb2wgOiBudWxsXG4gICAgICAgICAgICAgICksXG4gICAgICAgICAgICBudWxsICE9PSBwcmV2U3RhdGVcbiAgICAgICAgICAgICAgPyBwdXNoSGlkZGVuQ29udGV4dCh3b3JrSW5Qcm9ncmVzcywgcHJldlN0YXRlKVxuICAgICAgICAgICAgICA6IHJldXNlSGlkZGVuQ29udGV4dE9uU3RhY2sod29ya0luUHJvZ3Jlc3MpLFxuICAgICAgICAgICAgcHVzaE9mZnNjcmVlblN1c3BlbnNlSGFuZGxlcih3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgKHdvcmtJblByb2dyZXNzLmxhbmVzID0gd29ya0luUHJvZ3Jlc3MuY2hpbGRMYW5lcyA9IDUzNjg3MDkxMiksXG4gICAgICAgICAgICBkZWZlckhpZGRlbk9mZnNjcmVlbkNvbXBvbmVudChcbiAgICAgICAgICAgICAgY3VycmVudCxcbiAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gICAgICAgICAgICAgIG51bGwgIT09IHByZXZTdGF0ZVxuICAgICAgICAgICAgICAgID8gcHJldlN0YXRlLmJhc2VMYW5lcyB8IHJlbmRlckxhbmVzXG4gICAgICAgICAgICAgICAgOiByZW5kZXJMYW5lcyxcbiAgICAgICAgICAgICAgcmVuZGVyTGFuZXNcbiAgICAgICAgICAgIClcbiAgICAgICAgICApO1xuICAgICAgfSBlbHNlXG4gICAgICAgIG51bGwgIT09IHByZXZTdGF0ZVxuICAgICAgICAgID8gKHB1c2hUcmFuc2l0aW9uKHdvcmtJblByb2dyZXNzLCBwcmV2U3RhdGUuY2FjaGVQb29sKSxcbiAgICAgICAgICAgIHB1c2hIaWRkZW5Db250ZXh0KHdvcmtJblByb2dyZXNzLCBwcmV2U3RhdGUpLFxuICAgICAgICAgICAgcmV1c2VTdXNwZW5zZUhhbmRsZXJPblN0YWNrKHdvcmtJblByb2dyZXNzKSxcbiAgICAgICAgICAgICh3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlID0gbnVsbCkpXG4gICAgICAgICAgOiAobnVsbCAhPT0gY3VycmVudCAmJiBwdXNoVHJhbnNpdGlvbih3b3JrSW5Qcm9ncmVzcywgbnVsbCksXG4gICAgICAgICAgICByZXVzZUhpZGRlbkNvbnRleHRPblN0YWNrKHdvcmtJblByb2dyZXNzKSxcbiAgICAgICAgICAgIHJldXNlU3VzcGVuc2VIYW5kbGVyT25TdGFjayh3b3JrSW5Qcm9ncmVzcykpO1xuICAgICAgcmVjb25jaWxlQ2hpbGRyZW4oY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIG5leHRDaGlsZHJlbiwgcmVuZGVyTGFuZXMpO1xuICAgICAgcmV0dXJuIHdvcmtJblByb2dyZXNzLmNoaWxkO1xuICAgIH1cbiAgICBmdW5jdGlvbiBkZWZlckhpZGRlbk9mZnNjcmVlbkNvbXBvbmVudChcbiAgICAgIGN1cnJlbnQsXG4gICAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgICAgIG5leHRCYXNlTGFuZXMsXG4gICAgICByZW5kZXJMYW5lc1xuICAgICkge1xuICAgICAgdmFyIEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCA9IHBlZWtDYWNoZUZyb21Qb29sKCk7XG4gICAgICBKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQgPVxuICAgICAgICBudWxsID09PSBKU0NvbXBpbGVyX2lubGluZV9yZXN1bHRcbiAgICAgICAgICA/IG51bGxcbiAgICAgICAgICA6IHtcbiAgICAgICAgICAgICAgcGFyZW50OiBpc1ByaW1hcnlSZW5kZXJlclxuICAgICAgICAgICAgICAgID8gQ2FjaGVDb250ZXh0Ll9jdXJyZW50VmFsdWVcbiAgICAgICAgICAgICAgICA6IENhY2hlQ29udGV4dC5fY3VycmVudFZhbHVlMixcbiAgICAgICAgICAgICAgcG9vbDogSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0XG4gICAgICAgICAgICB9O1xuICAgICAgd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZSA9IHtcbiAgICAgICAgYmFzZUxhbmVzOiBuZXh0QmFzZUxhbmVzLFxuICAgICAgICBjYWNoZVBvb2w6IEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdFxuICAgICAgfTtcbiAgICAgIG51bGwgIT09IGN1cnJlbnQgJiYgcHVzaFRyYW5zaXRpb24od29ya0luUHJvZ3Jlc3MsIG51bGwpO1xuICAgICAgcmV1c2VIaWRkZW5Db250ZXh0T25TdGFjayh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICBwdXNoT2Zmc2NyZWVuU3VzcGVuc2VIYW5kbGVyKHdvcmtJblByb2dyZXNzKTtcbiAgICAgIG51bGwgIT09IGN1cnJlbnQgJiZcbiAgICAgICAgcHJvcGFnYXRlUGFyZW50Q29udGV4dENoYW5nZXMoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckxhbmVzLCAhMCk7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgZnVuY3Rpb24gbWFya1JlZihjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcykge1xuICAgICAgdmFyIHJlZiA9IHdvcmtJblByb2dyZXNzLnJlZjtcbiAgICAgIGlmIChudWxsID09PSByZWYpXG4gICAgICAgIG51bGwgIT09IGN1cnJlbnQgJiZcbiAgICAgICAgICBudWxsICE9PSBjdXJyZW50LnJlZiAmJlxuICAgICAgICAgICh3b3JrSW5Qcm9ncmVzcy5mbGFncyB8PSAyMDk3NjY0KTtcbiAgICAgIGVsc2Uge1xuICAgICAgICBpZiAoXCJmdW5jdGlvblwiICE9PSB0eXBlb2YgcmVmICYmIFwib2JqZWN0XCIgIT09IHR5cGVvZiByZWYpXG4gICAgICAgICAgdGhyb3cgRXJyb3IoXG4gICAgICAgICAgICBcIkV4cGVjdGVkIHJlZiB0byBiZSBhIGZ1bmN0aW9uLCBhbiBvYmplY3QgcmV0dXJuZWQgYnkgUmVhY3QuY3JlYXRlUmVmKCksIG9yIHVuZGVmaW5lZC9udWxsLlwiXG4gICAgICAgICAgKTtcbiAgICAgICAgaWYgKG51bGwgPT09IGN1cnJlbnQgfHwgY3VycmVudC5yZWYgIT09IHJlZilcbiAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5mbGFncyB8PSAyMDk3NjY0O1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiB1cGRhdGVGdW5jdGlvbkNvbXBvbmVudChcbiAgICAgIGN1cnJlbnQsXG4gICAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgICAgIENvbXBvbmVudCxcbiAgICAgIG5leHRQcm9wcyxcbiAgICAgIHJlbmRlckxhbmVzXG4gICAgKSB7XG4gICAgICBpZiAoXG4gICAgICAgIENvbXBvbmVudC5wcm90b3R5cGUgJiZcbiAgICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgQ29tcG9uZW50LnByb3RvdHlwZS5yZW5kZXJcbiAgICAgICkge1xuICAgICAgICB2YXIgY29tcG9uZW50TmFtZSA9IGdldENvbXBvbmVudE5hbWVGcm9tVHlwZShDb21wb25lbnQpIHx8IFwiVW5rbm93blwiO1xuICAgICAgICBkaWRXYXJuQWJvdXRCYWRDbGFzc1tjb21wb25lbnROYW1lXSB8fFxuICAgICAgICAgIChjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgXCJUaGUgPCVzIC8+IGNvbXBvbmVudCBhcHBlYXJzIHRvIGhhdmUgYSByZW5kZXIgbWV0aG9kLCBidXQgZG9lc24ndCBleHRlbmQgUmVhY3QuQ29tcG9uZW50LiBUaGlzIGlzIGxpa2VseSB0byBjYXVzZSBlcnJvcnMuIENoYW5nZSAlcyB0byBleHRlbmQgUmVhY3QuQ29tcG9uZW50IGluc3RlYWQuXCIsXG4gICAgICAgICAgICBjb21wb25lbnROYW1lLFxuICAgICAgICAgICAgY29tcG9uZW50TmFtZVxuICAgICAgICAgICksXG4gICAgICAgICAgKGRpZFdhcm5BYm91dEJhZENsYXNzW2NvbXBvbmVudE5hbWVdID0gITApKTtcbiAgICAgIH1cbiAgICAgIHdvcmtJblByb2dyZXNzLm1vZGUgJiA4ICYmXG4gICAgICAgIFJlYWN0U3RyaWN0TW9kZVdhcm5pbmdzLnJlY29yZExlZ2FjeUNvbnRleHRXYXJuaW5nKFxuICAgICAgICAgIHdvcmtJblByb2dyZXNzLFxuICAgICAgICAgIG51bGxcbiAgICAgICAgKTtcbiAgICAgIG51bGwgPT09IGN1cnJlbnQgJiZcbiAgICAgICAgKHZhbGlkYXRlRnVuY3Rpb25Db21wb25lbnRJbkRldih3b3JrSW5Qcm9ncmVzcywgd29ya0luUHJvZ3Jlc3MudHlwZSksXG4gICAgICAgIENvbXBvbmVudC5jb250ZXh0VHlwZXMgJiZcbiAgICAgICAgICAoKGNvbXBvbmVudE5hbWUgPSBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoQ29tcG9uZW50KSB8fCBcIlVua25vd25cIiksXG4gICAgICAgICAgZGlkV2FybkFib3V0Q29udGV4dFR5cGVzW2NvbXBvbmVudE5hbWVdIHx8XG4gICAgICAgICAgICAoKGRpZFdhcm5BYm91dENvbnRleHRUeXBlc1tjb21wb25lbnROYW1lXSA9ICEwKSxcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgIFwiJXMgdXNlcyB0aGUgbGVnYWN5IGNvbnRleHRUeXBlcyBBUEkgd2hpY2ggd2FzIHJlbW92ZWQgaW4gUmVhY3QgMTkuIFVzZSBSZWFjdC5jcmVhdGVDb250ZXh0KCkgd2l0aCBSZWFjdC51c2VDb250ZXh0KCkgaW5zdGVhZC4gKGh0dHBzOi8vcmVhY3QuZGV2L2xpbmsvbGVnYWN5LWNvbnRleHQpXCIsXG4gICAgICAgICAgICAgIGNvbXBvbmVudE5hbWVcbiAgICAgICAgICAgICkpKSk7XG4gICAgICBwcmVwYXJlVG9SZWFkQ29udGV4dCh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICBtYXJrQ29tcG9uZW50UmVuZGVyU3RhcnRlZCh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICBDb21wb25lbnQgPSByZW5kZXJXaXRoSG9va3MoXG4gICAgICAgIGN1cnJlbnQsXG4gICAgICAgIHdvcmtJblByb2dyZXNzLFxuICAgICAgICBDb21wb25lbnQsXG4gICAgICAgIG5leHRQcm9wcyxcbiAgICAgICAgdm9pZCAwLFxuICAgICAgICByZW5kZXJMYW5lc1xuICAgICAgKTtcbiAgICAgIG5leHRQcm9wcyA9IGNoZWNrRGlkUmVuZGVySWRIb29rKCk7XG4gICAgICBtYXJrQ29tcG9uZW50UmVuZGVyU3RvcHBlZCgpO1xuICAgICAgaWYgKG51bGwgIT09IGN1cnJlbnQgJiYgIWRpZFJlY2VpdmVVcGRhdGUpXG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgYmFpbG91dEhvb2tzKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCByZW5kZXJMYW5lcyksXG4gICAgICAgICAgYmFpbG91dE9uQWxyZWFkeUZpbmlzaGVkV29yayhjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyTGFuZXMpXG4gICAgICAgICk7XG4gICAgICBpc0h5ZHJhdGluZyAmJiBuZXh0UHJvcHMgJiYgcHVzaE1hdGVyaWFsaXplZFRyZWVJZCh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICB3b3JrSW5Qcm9ncmVzcy5mbGFncyB8PSAxO1xuICAgICAgcmVjb25jaWxlQ2hpbGRyZW4oY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIENvbXBvbmVudCwgcmVuZGVyTGFuZXMpO1xuICAgICAgcmV0dXJuIHdvcmtJblByb2dyZXNzLmNoaWxkO1xuICAgIH1cbiAgICBmdW5jdGlvbiByZXBsYXlGdW5jdGlvbkNvbXBvbmVudChcbiAgICAgIGN1cnJlbnQsXG4gICAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgICAgIG5leHRQcm9wcyxcbiAgICAgIENvbXBvbmVudCxcbiAgICAgIHNlY29uZEFyZyxcbiAgICAgIHJlbmRlckxhbmVzXG4gICAgKSB7XG4gICAgICBwcmVwYXJlVG9SZWFkQ29udGV4dCh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICBtYXJrQ29tcG9uZW50UmVuZGVyU3RhcnRlZCh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICBob29rVHlwZXNVcGRhdGVJbmRleERldiA9IC0xO1xuICAgICAgaWdub3JlUHJldmlvdXNEZXBlbmRlbmNpZXMgPVxuICAgICAgICBudWxsICE9PSBjdXJyZW50ICYmIGN1cnJlbnQudHlwZSAhPT0gd29ya0luUHJvZ3Jlc3MudHlwZTtcbiAgICAgIHdvcmtJblByb2dyZXNzLnVwZGF0ZVF1ZXVlID0gbnVsbDtcbiAgICAgIG5leHRQcm9wcyA9IHJlbmRlcldpdGhIb29rc0FnYWluKFxuICAgICAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgICAgICAgQ29tcG9uZW50LFxuICAgICAgICBuZXh0UHJvcHMsXG4gICAgICAgIHNlY29uZEFyZ1xuICAgICAgKTtcbiAgICAgIGZpbmlzaFJlbmRlcmluZ0hvb2tzKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzKTtcbiAgICAgIENvbXBvbmVudCA9IGNoZWNrRGlkUmVuZGVySWRIb29rKCk7XG4gICAgICBtYXJrQ29tcG9uZW50UmVuZGVyU3RvcHBlZCgpO1xuICAgICAgaWYgKG51bGwgIT09IGN1cnJlbnQgJiYgIWRpZFJlY2VpdmVVcGRhdGUpXG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgYmFpbG91dEhvb2tzKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCByZW5kZXJMYW5lcyksXG4gICAgICAgICAgYmFpbG91dE9uQWxyZWFkeUZpbmlzaGVkV29yayhjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyTGFuZXMpXG4gICAgICAgICk7XG4gICAgICBpc0h5ZHJhdGluZyAmJiBDb21wb25lbnQgJiYgcHVzaE1hdGVyaWFsaXplZFRyZWVJZCh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICB3b3JrSW5Qcm9ncmVzcy5mbGFncyB8PSAxO1xuICAgICAgcmVjb25jaWxlQ2hpbGRyZW4oY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIG5leHRQcm9wcywgcmVuZGVyTGFuZXMpO1xuICAgICAgcmV0dXJuIHdvcmtJblByb2dyZXNzLmNoaWxkO1xuICAgIH1cbiAgICBmdW5jdGlvbiB1cGRhdGVDbGFzc0NvbXBvbmVudChcbiAgICAgIGN1cnJlbnQkanNjb21wJDAsXG4gICAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgICAgIENvbXBvbmVudCxcbiAgICAgIG5leHRQcm9wcyxcbiAgICAgIHJlbmRlckxhbmVzXG4gICAgKSB7XG4gICAgICBzd2l0Y2ggKHNob3VsZEVycm9ySW1wbCh3b3JrSW5Qcm9ncmVzcykpIHtcbiAgICAgICAgY2FzZSAhMTpcbiAgICAgICAgICB2YXIgX2luc3RhbmNlID0gd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlLFxuICAgICAgICAgICAgc3RhdGUgPSBuZXcgd29ya0luUHJvZ3Jlc3MudHlwZShcbiAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRQcm9wcyxcbiAgICAgICAgICAgICAgX2luc3RhbmNlLmNvbnRleHRcbiAgICAgICAgICAgICkuc3RhdGU7XG4gICAgICAgICAgX2luc3RhbmNlLnVwZGF0ZXIuZW5xdWV1ZVNldFN0YXRlKF9pbnN0YW5jZSwgc3RhdGUsIG51bGwpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICEwOlxuICAgICAgICAgIHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IDEyODtcbiAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5mbGFncyB8PSA2NTUzNjtcbiAgICAgICAgICBfaW5zdGFuY2UgPSBFcnJvcihcIlNpbXVsYXRlZCBlcnJvciBjb21pbmcgZnJvbSBEZXZUb29sc1wiKTtcbiAgICAgICAgICB2YXIgbGFuZSA9IHJlbmRlckxhbmVzICYgLXJlbmRlckxhbmVzO1xuICAgICAgICAgIHdvcmtJblByb2dyZXNzLmxhbmVzIHw9IGxhbmU7XG4gICAgICAgICAgc3RhdGUgPSB3b3JrSW5Qcm9ncmVzc1Jvb3Q7XG4gICAgICAgICAgaWYgKG51bGwgPT09IHN0YXRlKVxuICAgICAgICAgICAgdGhyb3cgRXJyb3IoXG4gICAgICAgICAgICAgIFwiRXhwZWN0ZWQgYSB3b3JrLWluLXByb2dyZXNzIHJvb3QuIFRoaXMgaXMgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLlwiXG4gICAgICAgICAgICApO1xuICAgICAgICAgIGxhbmUgPSBjcmVhdGVDbGFzc0Vycm9yVXBkYXRlKGxhbmUpO1xuICAgICAgICAgIGluaXRpYWxpemVDbGFzc0Vycm9yVXBkYXRlKFxuICAgICAgICAgICAgbGFuZSxcbiAgICAgICAgICAgIHN0YXRlLFxuICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gICAgICAgICAgICBjcmVhdGVDYXB0dXJlZFZhbHVlQXRGaWJlcihfaW5zdGFuY2UsIHdvcmtJblByb2dyZXNzKVxuICAgICAgICAgICk7XG4gICAgICAgICAgZW5xdWV1ZUNhcHR1cmVkVXBkYXRlKHdvcmtJblByb2dyZXNzLCBsYW5lKTtcbiAgICAgIH1cbiAgICAgIHByZXBhcmVUb1JlYWRDb250ZXh0KHdvcmtJblByb2dyZXNzKTtcbiAgICAgIGlmIChudWxsID09PSB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGUpIHtcbiAgICAgICAgc3RhdGUgPSBlbXB0eUNvbnRleHRPYmplY3Q7XG4gICAgICAgIF9pbnN0YW5jZSA9IENvbXBvbmVudC5jb250ZXh0VHlwZTtcbiAgICAgICAgXCJjb250ZXh0VHlwZVwiIGluIENvbXBvbmVudCAmJlxuICAgICAgICAgIG51bGwgIT09IF9pbnN0YW5jZSAmJlxuICAgICAgICAgICh2b2lkIDAgPT09IF9pbnN0YW5jZSB8fCBfaW5zdGFuY2UuJCR0eXBlb2YgIT09IFJFQUNUX0NPTlRFWFRfVFlQRSkgJiZcbiAgICAgICAgICAhZGlkV2FybkFib3V0SW52YWxpZGF0ZUNvbnRleHRUeXBlLmhhcyhDb21wb25lbnQpICYmXG4gICAgICAgICAgKGRpZFdhcm5BYm91dEludmFsaWRhdGVDb250ZXh0VHlwZS5hZGQoQ29tcG9uZW50KSxcbiAgICAgICAgICAobGFuZSA9XG4gICAgICAgICAgICB2b2lkIDAgPT09IF9pbnN0YW5jZVxuICAgICAgICAgICAgICA/IFwiIEhvd2V2ZXIsIGl0IGlzIHNldCB0byB1bmRlZmluZWQuIFRoaXMgY2FuIGJlIGNhdXNlZCBieSBhIHR5cG8gb3IgYnkgbWl4aW5nIHVwIG5hbWVkIGFuZCBkZWZhdWx0IGltcG9ydHMuIFRoaXMgY2FuIGFsc28gaGFwcGVuIGR1ZSB0byBhIGNpcmN1bGFyIGRlcGVuZGVuY3ksIHNvIHRyeSBtb3ZpbmcgdGhlIGNyZWF0ZUNvbnRleHQoKSBjYWxsIHRvIGEgc2VwYXJhdGUgZmlsZS5cIlxuICAgICAgICAgICAgICA6IFwib2JqZWN0XCIgIT09IHR5cGVvZiBfaW5zdGFuY2VcbiAgICAgICAgICAgICAgICA/IFwiIEhvd2V2ZXIsIGl0IGlzIHNldCB0byBhIFwiICsgdHlwZW9mIF9pbnN0YW5jZSArIFwiLlwiXG4gICAgICAgICAgICAgICAgOiBfaW5zdGFuY2UuJCR0eXBlb2YgPT09IFJFQUNUX0NPTlNVTUVSX1RZUEVcbiAgICAgICAgICAgICAgICAgID8gXCIgRGlkIHlvdSBhY2NpZGVudGFsbHkgcGFzcyB0aGUgQ29udGV4dC5Db25zdW1lciBpbnN0ZWFkP1wiXG4gICAgICAgICAgICAgICAgICA6IFwiIEhvd2V2ZXIsIGl0IGlzIHNldCB0byBhbiBvYmplY3Qgd2l0aCBrZXlzIHtcIiArXG4gICAgICAgICAgICAgICAgICAgIE9iamVjdC5rZXlzKF9pbnN0YW5jZSkuam9pbihcIiwgXCIpICtcbiAgICAgICAgICAgICAgICAgICAgXCJ9LlwiKSxcbiAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgXCIlcyBkZWZpbmVzIGFuIGludmFsaWQgY29udGV4dFR5cGUuIGNvbnRleHRUeXBlIHNob3VsZCBwb2ludCB0byB0aGUgQ29udGV4dCBvYmplY3QgcmV0dXJuZWQgYnkgUmVhY3QuY3JlYXRlQ29udGV4dCgpLiVzXCIsXG4gICAgICAgICAgICBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoQ29tcG9uZW50KSB8fCBcIkNvbXBvbmVudFwiLFxuICAgICAgICAgICAgbGFuZVxuICAgICAgICAgICkpO1xuICAgICAgICBcIm9iamVjdFwiID09PSB0eXBlb2YgX2luc3RhbmNlICYmXG4gICAgICAgICAgbnVsbCAhPT0gX2luc3RhbmNlICYmXG4gICAgICAgICAgKHN0YXRlID0gcmVhZENvbnRleHQoX2luc3RhbmNlKSk7XG4gICAgICAgIF9pbnN0YW5jZSA9IG5ldyBDb21wb25lbnQobmV4dFByb3BzLCBzdGF0ZSk7XG4gICAgICAgIGlmICh3b3JrSW5Qcm9ncmVzcy5tb2RlICYgOCkge1xuICAgICAgICAgIHNldElzU3RyaWN0TW9kZUZvckRldnRvb2xzKCEwKTtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgX2luc3RhbmNlID0gbmV3IENvbXBvbmVudChuZXh0UHJvcHMsIHN0YXRlKTtcbiAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgc2V0SXNTdHJpY3RNb2RlRm9yRGV2dG9vbHMoITEpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBzdGF0ZSA9IHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGUgPVxuICAgICAgICAgIG51bGwgIT09IF9pbnN0YW5jZS5zdGF0ZSAmJiB2b2lkIDAgIT09IF9pbnN0YW5jZS5zdGF0ZVxuICAgICAgICAgICAgPyBfaW5zdGFuY2Uuc3RhdGVcbiAgICAgICAgICAgIDogbnVsbDtcbiAgICAgICAgX2luc3RhbmNlLnVwZGF0ZXIgPSBjbGFzc0NvbXBvbmVudFVwZGF0ZXI7XG4gICAgICAgIHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZSA9IF9pbnN0YW5jZTtcbiAgICAgICAgX2luc3RhbmNlLl9yZWFjdEludGVybmFscyA9IHdvcmtJblByb2dyZXNzO1xuICAgICAgICBfaW5zdGFuY2UuX3JlYWN0SW50ZXJuYWxJbnN0YW5jZSA9IGZha2VJbnRlcm5hbEluc3RhbmNlO1xuICAgICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBDb21wb25lbnQuZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzICYmXG4gICAgICAgICAgbnVsbCA9PT0gc3RhdGUgJiZcbiAgICAgICAgICAoKHN0YXRlID0gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKENvbXBvbmVudCkgfHwgXCJDb21wb25lbnRcIiksXG4gICAgICAgICAgZGlkV2FybkFib3V0VW5pbml0aWFsaXplZFN0YXRlLmhhcyhzdGF0ZSkgfHxcbiAgICAgICAgICAgIChkaWRXYXJuQWJvdXRVbmluaXRpYWxpemVkU3RhdGUuYWRkKHN0YXRlKSxcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgIFwiYCVzYCB1c2VzIGBnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHNgIGJ1dCBpdHMgaW5pdGlhbCBzdGF0ZSBpcyAlcy4gVGhpcyBpcyBub3QgcmVjb21tZW5kZWQuIEluc3RlYWQsIGRlZmluZSB0aGUgaW5pdGlhbCBzdGF0ZSBieSBhc3NpZ25pbmcgYW4gb2JqZWN0IHRvIGB0aGlzLnN0YXRlYCBpbiB0aGUgY29uc3RydWN0b3Igb2YgYCVzYC4gVGhpcyBlbnN1cmVzIHRoYXQgYGdldERlcml2ZWRTdGF0ZUZyb21Qcm9wc2AgYXJndW1lbnRzIGhhdmUgYSBjb25zaXN0ZW50IHNoYXBlLlwiLFxuICAgICAgICAgICAgICBzdGF0ZSxcbiAgICAgICAgICAgICAgbnVsbCA9PT0gX2luc3RhbmNlLnN0YXRlID8gXCJudWxsXCIgOiBcInVuZGVmaW5lZFwiLFxuICAgICAgICAgICAgICBzdGF0ZVxuICAgICAgICAgICAgKSkpO1xuICAgICAgICBpZiAoXG4gICAgICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgQ29tcG9uZW50LmdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyB8fFxuICAgICAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIF9pbnN0YW5jZS5nZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZVxuICAgICAgICApIHtcbiAgICAgICAgICB2YXIgZm91bmRXaWxsVXBkYXRlTmFtZSA9IChsYW5lID0gc3RhdGUgPSBudWxsKTtcbiAgICAgICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBfaW5zdGFuY2UuY29tcG9uZW50V2lsbE1vdW50ICYmXG4gICAgICAgICAgITAgIT09IF9pbnN0YW5jZS5jb21wb25lbnRXaWxsTW91bnQuX19zdXBwcmVzc0RlcHJlY2F0aW9uV2FybmluZ1xuICAgICAgICAgICAgPyAoc3RhdGUgPSBcImNvbXBvbmVudFdpbGxNb3VudFwiKVxuICAgICAgICAgICAgOiBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBfaW5zdGFuY2UuVU5TQUZFX2NvbXBvbmVudFdpbGxNb3VudCAmJlxuICAgICAgICAgICAgICAoc3RhdGUgPSBcIlVOU0FGRV9jb21wb25lbnRXaWxsTW91bnRcIik7XG4gICAgICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgX2luc3RhbmNlLmNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMgJiZcbiAgICAgICAgICAhMCAhPT1cbiAgICAgICAgICAgIF9pbnN0YW5jZS5jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzLl9fc3VwcHJlc3NEZXByZWNhdGlvbldhcm5pbmdcbiAgICAgICAgICAgID8gKGxhbmUgPSBcImNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHNcIilcbiAgICAgICAgICAgIDogXCJmdW5jdGlvblwiID09PVxuICAgICAgICAgICAgICAgIHR5cGVvZiBfaW5zdGFuY2UuVU5TQUZFX2NvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMgJiZcbiAgICAgICAgICAgICAgKGxhbmUgPSBcIlVOU0FGRV9jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzXCIpO1xuICAgICAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIF9pbnN0YW5jZS5jb21wb25lbnRXaWxsVXBkYXRlICYmXG4gICAgICAgICAgITAgIT09IF9pbnN0YW5jZS5jb21wb25lbnRXaWxsVXBkYXRlLl9fc3VwcHJlc3NEZXByZWNhdGlvbldhcm5pbmdcbiAgICAgICAgICAgID8gKGZvdW5kV2lsbFVwZGF0ZU5hbWUgPSBcImNvbXBvbmVudFdpbGxVcGRhdGVcIilcbiAgICAgICAgICAgIDogXCJmdW5jdGlvblwiID09PSB0eXBlb2YgX2luc3RhbmNlLlVOU0FGRV9jb21wb25lbnRXaWxsVXBkYXRlICYmXG4gICAgICAgICAgICAgIChmb3VuZFdpbGxVcGRhdGVOYW1lID0gXCJVTlNBRkVfY29tcG9uZW50V2lsbFVwZGF0ZVwiKTtcbiAgICAgICAgICBpZiAobnVsbCAhPT0gc3RhdGUgfHwgbnVsbCAhPT0gbGFuZSB8fCBudWxsICE9PSBmb3VuZFdpbGxVcGRhdGVOYW1lKSB7XG4gICAgICAgICAgICBfaW5zdGFuY2UgPSBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoQ29tcG9uZW50KSB8fCBcIkNvbXBvbmVudFwiO1xuICAgICAgICAgICAgdmFyIG5ld0FwaU5hbWUgPVxuICAgICAgICAgICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBDb21wb25lbnQuZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzXG4gICAgICAgICAgICAgICAgPyBcImdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcygpXCJcbiAgICAgICAgICAgICAgICA6IFwiZ2V0U25hcHNob3RCZWZvcmVVcGRhdGUoKVwiO1xuICAgICAgICAgICAgZGlkV2FybkFib3V0TGVnYWN5TGlmZWN5Y2xlc0FuZERlcml2ZWRTdGF0ZS5oYXMoX2luc3RhbmNlKSB8fFxuICAgICAgICAgICAgICAoZGlkV2FybkFib3V0TGVnYWN5TGlmZWN5Y2xlc0FuZERlcml2ZWRTdGF0ZS5hZGQoX2luc3RhbmNlKSxcbiAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgICBcIlVuc2FmZSBsZWdhY3kgbGlmZWN5Y2xlcyB3aWxsIG5vdCBiZSBjYWxsZWQgZm9yIGNvbXBvbmVudHMgdXNpbmcgbmV3IGNvbXBvbmVudCBBUElzLlxcblxcbiVzIHVzZXMgJXMgYnV0IGFsc28gY29udGFpbnMgdGhlIGZvbGxvd2luZyBsZWdhY3kgbGlmZWN5Y2xlczolcyVzJXNcXG5cXG5UaGUgYWJvdmUgbGlmZWN5Y2xlcyBzaG91bGQgYmUgcmVtb3ZlZC4gTGVhcm4gbW9yZSBhYm91dCB0aGlzIHdhcm5pbmcgaGVyZTpcXG5odHRwczovL3JlYWN0LmRldi9saW5rL3Vuc2FmZS1jb21wb25lbnQtbGlmZWN5Y2xlc1wiLFxuICAgICAgICAgICAgICAgIF9pbnN0YW5jZSxcbiAgICAgICAgICAgICAgICBuZXdBcGlOYW1lLFxuICAgICAgICAgICAgICAgIG51bGwgIT09IHN0YXRlID8gXCJcXG4gIFwiICsgc3RhdGUgOiBcIlwiLFxuICAgICAgICAgICAgICAgIG51bGwgIT09IGxhbmUgPyBcIlxcbiAgXCIgKyBsYW5lIDogXCJcIixcbiAgICAgICAgICAgICAgICBudWxsICE9PSBmb3VuZFdpbGxVcGRhdGVOYW1lID8gXCJcXG4gIFwiICsgZm91bmRXaWxsVXBkYXRlTmFtZSA6IFwiXCJcbiAgICAgICAgICAgICAgKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIF9pbnN0YW5jZSA9IHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZTtcbiAgICAgICAgc3RhdGUgPSBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoQ29tcG9uZW50KSB8fCBcIkNvbXBvbmVudFwiO1xuICAgICAgICBfaW5zdGFuY2UucmVuZGVyIHx8XG4gICAgICAgICAgKENvbXBvbmVudC5wcm90b3R5cGUgJiZcbiAgICAgICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBDb21wb25lbnQucHJvdG90eXBlLnJlbmRlclxuICAgICAgICAgICAgPyBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICAgIFwiTm8gYHJlbmRlcmAgbWV0aG9kIGZvdW5kIG9uIHRoZSAlcyBpbnN0YW5jZTogZGlkIHlvdSBhY2NpZGVudGFsbHkgcmV0dXJuIGFuIG9iamVjdCBmcm9tIHRoZSBjb25zdHJ1Y3Rvcj9cIixcbiAgICAgICAgICAgICAgICBzdGF0ZVxuICAgICAgICAgICAgICApXG4gICAgICAgICAgICA6IGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgICAgXCJObyBgcmVuZGVyYCBtZXRob2QgZm91bmQgb24gdGhlICVzIGluc3RhbmNlOiB5b3UgbWF5IGhhdmUgZm9yZ290dGVuIHRvIGRlZmluZSBgcmVuZGVyYC5cIixcbiAgICAgICAgICAgICAgICBzdGF0ZVxuICAgICAgICAgICAgICApKTtcbiAgICAgICAgIV9pbnN0YW5jZS5nZXRJbml0aWFsU3RhdGUgfHxcbiAgICAgICAgICBfaW5zdGFuY2UuZ2V0SW5pdGlhbFN0YXRlLmlzUmVhY3RDbGFzc0FwcHJvdmVkIHx8XG4gICAgICAgICAgX2luc3RhbmNlLnN0YXRlIHx8XG4gICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgIFwiZ2V0SW5pdGlhbFN0YXRlIHdhcyBkZWZpbmVkIG9uICVzLCBhIHBsYWluIEphdmFTY3JpcHQgY2xhc3MuIFRoaXMgaXMgb25seSBzdXBwb3J0ZWQgZm9yIGNsYXNzZXMgY3JlYXRlZCB1c2luZyBSZWFjdC5jcmVhdGVDbGFzcy4gRGlkIHlvdSBtZWFuIHRvIGRlZmluZSBhIHN0YXRlIHByb3BlcnR5IGluc3RlYWQ/XCIsXG4gICAgICAgICAgICBzdGF0ZVxuICAgICAgICAgICk7XG4gICAgICAgIF9pbnN0YW5jZS5nZXREZWZhdWx0UHJvcHMgJiZcbiAgICAgICAgICAhX2luc3RhbmNlLmdldERlZmF1bHRQcm9wcy5pc1JlYWN0Q2xhc3NBcHByb3ZlZCAmJlxuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICBcImdldERlZmF1bHRQcm9wcyB3YXMgZGVmaW5lZCBvbiAlcywgYSBwbGFpbiBKYXZhU2NyaXB0IGNsYXNzLiBUaGlzIGlzIG9ubHkgc3VwcG9ydGVkIGZvciBjbGFzc2VzIGNyZWF0ZWQgdXNpbmcgUmVhY3QuY3JlYXRlQ2xhc3MuIFVzZSBhIHN0YXRpYyBwcm9wZXJ0eSB0byBkZWZpbmUgZGVmYXVsdFByb3BzIGluc3RlYWQuXCIsXG4gICAgICAgICAgICBzdGF0ZVxuICAgICAgICAgICk7XG4gICAgICAgIF9pbnN0YW5jZS5jb250ZXh0VHlwZSAmJlxuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICBcImNvbnRleHRUeXBlIHdhcyBkZWZpbmVkIGFzIGFuIGluc3RhbmNlIHByb3BlcnR5IG9uICVzLiBVc2UgYSBzdGF0aWMgcHJvcGVydHkgdG8gZGVmaW5lIGNvbnRleHRUeXBlIGluc3RlYWQuXCIsXG4gICAgICAgICAgICBzdGF0ZVxuICAgICAgICAgICk7XG4gICAgICAgIENvbXBvbmVudC5jaGlsZENvbnRleHRUeXBlcyAmJlxuICAgICAgICAgICFkaWRXYXJuQWJvdXRDaGlsZENvbnRleHRUeXBlcy5oYXMoQ29tcG9uZW50KSAmJlxuICAgICAgICAgIChkaWRXYXJuQWJvdXRDaGlsZENvbnRleHRUeXBlcy5hZGQoQ29tcG9uZW50KSxcbiAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgXCIlcyB1c2VzIHRoZSBsZWdhY3kgY2hpbGRDb250ZXh0VHlwZXMgQVBJIHdoaWNoIHdhcyByZW1vdmVkIGluIFJlYWN0IDE5LiBVc2UgUmVhY3QuY3JlYXRlQ29udGV4dCgpIGluc3RlYWQuIChodHRwczovL3JlYWN0LmRldi9saW5rL2xlZ2FjeS1jb250ZXh0KVwiLFxuICAgICAgICAgICAgc3RhdGVcbiAgICAgICAgICApKTtcbiAgICAgICAgQ29tcG9uZW50LmNvbnRleHRUeXBlcyAmJlxuICAgICAgICAgICFkaWRXYXJuQWJvdXRDb250ZXh0VHlwZXMkMS5oYXMoQ29tcG9uZW50KSAmJlxuICAgICAgICAgIChkaWRXYXJuQWJvdXRDb250ZXh0VHlwZXMkMS5hZGQoQ29tcG9uZW50KSxcbiAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgXCIlcyB1c2VzIHRoZSBsZWdhY3kgY29udGV4dFR5cGVzIEFQSSB3aGljaCB3YXMgcmVtb3ZlZCBpbiBSZWFjdCAxOS4gVXNlIFJlYWN0LmNyZWF0ZUNvbnRleHQoKSB3aXRoIHN0YXRpYyBjb250ZXh0VHlwZSBpbnN0ZWFkLiAoaHR0cHM6Ly9yZWFjdC5kZXYvbGluay9sZWdhY3ktY29udGV4dClcIixcbiAgICAgICAgICAgIHN0YXRlXG4gICAgICAgICAgKSk7XG4gICAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIF9pbnN0YW5jZS5jb21wb25lbnRTaG91bGRVcGRhdGUgJiZcbiAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgXCIlcyBoYXMgYSBtZXRob2QgY2FsbGVkIGNvbXBvbmVudFNob3VsZFVwZGF0ZSgpLiBEaWQgeW91IG1lYW4gc2hvdWxkQ29tcG9uZW50VXBkYXRlKCk/IFRoZSBuYW1lIGlzIHBocmFzZWQgYXMgYSBxdWVzdGlvbiBiZWNhdXNlIHRoZSBmdW5jdGlvbiBpcyBleHBlY3RlZCB0byByZXR1cm4gYSB2YWx1ZS5cIixcbiAgICAgICAgICAgIHN0YXRlXG4gICAgICAgICAgKTtcbiAgICAgICAgQ29tcG9uZW50LnByb3RvdHlwZSAmJlxuICAgICAgICAgIENvbXBvbmVudC5wcm90b3R5cGUuaXNQdXJlUmVhY3RDb21wb25lbnQgJiZcbiAgICAgICAgICBcInVuZGVmaW5lZFwiICE9PSB0eXBlb2YgX2luc3RhbmNlLnNob3VsZENvbXBvbmVudFVwZGF0ZSAmJlxuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICBcIiVzIGhhcyBhIG1ldGhvZCBjYWxsZWQgc2hvdWxkQ29tcG9uZW50VXBkYXRlKCkuIHNob3VsZENvbXBvbmVudFVwZGF0ZSBzaG91bGQgbm90IGJlIHVzZWQgd2hlbiBleHRlbmRpbmcgUmVhY3QuUHVyZUNvbXBvbmVudC4gUGxlYXNlIGV4dGVuZCBSZWFjdC5Db21wb25lbnQgaWYgc2hvdWxkQ29tcG9uZW50VXBkYXRlIGlzIHVzZWQuXCIsXG4gICAgICAgICAgICBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoQ29tcG9uZW50KSB8fCBcIkEgcHVyZSBjb21wb25lbnRcIlxuICAgICAgICAgICk7XG4gICAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIF9pbnN0YW5jZS5jb21wb25lbnREaWRVbm1vdW50ICYmXG4gICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgIFwiJXMgaGFzIGEgbWV0aG9kIGNhbGxlZCBjb21wb25lbnREaWRVbm1vdW50KCkuIEJ1dCB0aGVyZSBpcyBubyBzdWNoIGxpZmVjeWNsZSBtZXRob2QuIERpZCB5b3UgbWVhbiBjb21wb25lbnRXaWxsVW5tb3VudCgpP1wiLFxuICAgICAgICAgICAgc3RhdGVcbiAgICAgICAgICApO1xuICAgICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBfaW5zdGFuY2UuY29tcG9uZW50RGlkUmVjZWl2ZVByb3BzICYmXG4gICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgIFwiJXMgaGFzIGEgbWV0aG9kIGNhbGxlZCBjb21wb25lbnREaWRSZWNlaXZlUHJvcHMoKS4gQnV0IHRoZXJlIGlzIG5vIHN1Y2ggbGlmZWN5Y2xlIG1ldGhvZC4gSWYgeW91IG1lYW50IHRvIHVwZGF0ZSB0aGUgc3RhdGUgaW4gcmVzcG9uc2UgdG8gY2hhbmdpbmcgcHJvcHMsIHVzZSBjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzKCkuIElmIHlvdSBtZWFudCB0byBmZXRjaCBkYXRhIG9yIHJ1biBzaWRlLWVmZmVjdHMgb3IgbXV0YXRpb25zIGFmdGVyIFJlYWN0IGhhcyB1cGRhdGVkIHRoZSBVSSwgdXNlIGNvbXBvbmVudERpZFVwZGF0ZSgpLlwiLFxuICAgICAgICAgICAgc3RhdGVcbiAgICAgICAgICApO1xuICAgICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBfaW5zdGFuY2UuY29tcG9uZW50V2lsbFJlY2lldmVQcm9wcyAmJlxuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICBcIiVzIGhhcyBhIG1ldGhvZCBjYWxsZWQgY29tcG9uZW50V2lsbFJlY2lldmVQcm9wcygpLiBEaWQgeW91IG1lYW4gY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcygpP1wiLFxuICAgICAgICAgICAgc3RhdGVcbiAgICAgICAgICApO1xuICAgICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBfaW5zdGFuY2UuVU5TQUZFX2NvbXBvbmVudFdpbGxSZWNpZXZlUHJvcHMgJiZcbiAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgXCIlcyBoYXMgYSBtZXRob2QgY2FsbGVkIFVOU0FGRV9jb21wb25lbnRXaWxsUmVjaWV2ZVByb3BzKCkuIERpZCB5b3UgbWVhbiBVTlNBRkVfY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcygpP1wiLFxuICAgICAgICAgICAgc3RhdGVcbiAgICAgICAgICApO1xuICAgICAgICBsYW5lID0gX2luc3RhbmNlLnByb3BzICE9PSBuZXh0UHJvcHM7XG4gICAgICAgIHZvaWQgMCAhPT0gX2luc3RhbmNlLnByb3BzICYmXG4gICAgICAgICAgbGFuZSAmJlxuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICBcIldoZW4gY2FsbGluZyBzdXBlcigpIGluIGAlc2AsIG1ha2Ugc3VyZSB0byBwYXNzIHVwIHRoZSBzYW1lIHByb3BzIHRoYXQgeW91ciBjb21wb25lbnQncyBjb25zdHJ1Y3RvciB3YXMgcGFzc2VkLlwiLFxuICAgICAgICAgICAgc3RhdGVcbiAgICAgICAgICApO1xuICAgICAgICBfaW5zdGFuY2UuZGVmYXVsdFByb3BzICYmXG4gICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgIFwiU2V0dGluZyBkZWZhdWx0UHJvcHMgYXMgYW4gaW5zdGFuY2UgcHJvcGVydHkgb24gJXMgaXMgbm90IHN1cHBvcnRlZCBhbmQgd2lsbCBiZSBpZ25vcmVkLiBJbnN0ZWFkLCBkZWZpbmUgZGVmYXVsdFByb3BzIGFzIGEgc3RhdGljIHByb3BlcnR5IG9uICVzLlwiLFxuICAgICAgICAgICAgc3RhdGUsXG4gICAgICAgICAgICBzdGF0ZVxuICAgICAgICAgICk7XG4gICAgICAgIFwiZnVuY3Rpb25cIiAhPT0gdHlwZW9mIF9pbnN0YW5jZS5nZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZSB8fFxuICAgICAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIF9pbnN0YW5jZS5jb21wb25lbnREaWRVcGRhdGUgfHxcbiAgICAgICAgICBkaWRXYXJuQWJvdXRHZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZVdpdGhvdXREaWRVcGRhdGUuaGFzKENvbXBvbmVudCkgfHxcbiAgICAgICAgICAoZGlkV2FybkFib3V0R2V0U25hcHNob3RCZWZvcmVVcGRhdGVXaXRob3V0RGlkVXBkYXRlLmFkZChDb21wb25lbnQpLFxuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICBcIiVzOiBnZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZSgpIHNob3VsZCBiZSB1c2VkIHdpdGggY29tcG9uZW50RGlkVXBkYXRlKCkuIFRoaXMgY29tcG9uZW50IGRlZmluZXMgZ2V0U25hcHNob3RCZWZvcmVVcGRhdGUoKSBvbmx5LlwiLFxuICAgICAgICAgICAgZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKENvbXBvbmVudClcbiAgICAgICAgICApKTtcbiAgICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgX2luc3RhbmNlLmdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyAmJlxuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICBcIiVzOiBnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMoKSBpcyBkZWZpbmVkIGFzIGFuIGluc3RhbmNlIG1ldGhvZCBhbmQgd2lsbCBiZSBpZ25vcmVkLiBJbnN0ZWFkLCBkZWNsYXJlIGl0IGFzIGEgc3RhdGljIG1ldGhvZC5cIixcbiAgICAgICAgICAgIHN0YXRlXG4gICAgICAgICAgKTtcbiAgICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgX2luc3RhbmNlLmdldERlcml2ZWRTdGF0ZUZyb21FcnJvciAmJlxuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICBcIiVzOiBnZXREZXJpdmVkU3RhdGVGcm9tRXJyb3IoKSBpcyBkZWZpbmVkIGFzIGFuIGluc3RhbmNlIG1ldGhvZCBhbmQgd2lsbCBiZSBpZ25vcmVkLiBJbnN0ZWFkLCBkZWNsYXJlIGl0IGFzIGEgc3RhdGljIG1ldGhvZC5cIixcbiAgICAgICAgICAgIHN0YXRlXG4gICAgICAgICAgKTtcbiAgICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgQ29tcG9uZW50LmdldFNuYXBzaG90QmVmb3JlVXBkYXRlICYmXG4gICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgIFwiJXM6IGdldFNuYXBzaG90QmVmb3JlVXBkYXRlKCkgaXMgZGVmaW5lZCBhcyBhIHN0YXRpYyBtZXRob2QgYW5kIHdpbGwgYmUgaWdub3JlZC4gSW5zdGVhZCwgZGVjbGFyZSBpdCBhcyBhbiBpbnN0YW5jZSBtZXRob2QuXCIsXG4gICAgICAgICAgICBzdGF0ZVxuICAgICAgICAgICk7XG4gICAgICAgIChsYW5lID0gX2luc3RhbmNlLnN0YXRlKSAmJlxuICAgICAgICAgIChcIm9iamVjdFwiICE9PSB0eXBlb2YgbGFuZSB8fCBpc0FycmF5SW1wbChsYW5lKSkgJiZcbiAgICAgICAgICBjb25zb2xlLmVycm9yKFwiJXMuc3RhdGU6IG11c3QgYmUgc2V0IHRvIGFuIG9iamVjdCBvciBudWxsXCIsIHN0YXRlKTtcbiAgICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgX2luc3RhbmNlLmdldENoaWxkQ29udGV4dCAmJlxuICAgICAgICAgIFwib2JqZWN0XCIgIT09IHR5cGVvZiBDb21wb25lbnQuY2hpbGRDb250ZXh0VHlwZXMgJiZcbiAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgXCIlcy5nZXRDaGlsZENvbnRleHQoKTogY2hpbGRDb250ZXh0VHlwZXMgbXVzdCBiZSBkZWZpbmVkIGluIG9yZGVyIHRvIHVzZSBnZXRDaGlsZENvbnRleHQoKS5cIixcbiAgICAgICAgICAgIHN0YXRlXG4gICAgICAgICAgKTtcbiAgICAgICAgX2luc3RhbmNlID0gd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlO1xuICAgICAgICBfaW5zdGFuY2UucHJvcHMgPSBuZXh0UHJvcHM7XG4gICAgICAgIF9pbnN0YW5jZS5zdGF0ZSA9IHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGU7XG4gICAgICAgIF9pbnN0YW5jZS5yZWZzID0ge307XG4gICAgICAgIGluaXRpYWxpemVVcGRhdGVRdWV1ZSh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgIHN0YXRlID0gQ29tcG9uZW50LmNvbnRleHRUeXBlO1xuICAgICAgICBfaW5zdGFuY2UuY29udGV4dCA9XG4gICAgICAgICAgXCJvYmplY3RcIiA9PT0gdHlwZW9mIHN0YXRlICYmIG51bGwgIT09IHN0YXRlXG4gICAgICAgICAgICA/IHJlYWRDb250ZXh0KHN0YXRlKVxuICAgICAgICAgICAgOiBlbXB0eUNvbnRleHRPYmplY3Q7XG4gICAgICAgIF9pbnN0YW5jZS5zdGF0ZSA9PT0gbmV4dFByb3BzICYmXG4gICAgICAgICAgKChzdGF0ZSA9IGdldENvbXBvbmVudE5hbWVGcm9tVHlwZShDb21wb25lbnQpIHx8IFwiQ29tcG9uZW50XCIpLFxuICAgICAgICAgIGRpZFdhcm5BYm91dERpcmVjdGx5QXNzaWduaW5nUHJvcHNUb1N0YXRlLmhhcyhzdGF0ZSkgfHxcbiAgICAgICAgICAgIChkaWRXYXJuQWJvdXREaXJlY3RseUFzc2lnbmluZ1Byb3BzVG9TdGF0ZS5hZGQoc3RhdGUpLFxuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgXCIlczogSXQgaXMgbm90IHJlY29tbWVuZGVkIHRvIGFzc2lnbiBwcm9wcyBkaXJlY3RseSB0byBzdGF0ZSBiZWNhdXNlIHVwZGF0ZXMgdG8gcHJvcHMgd29uJ3QgYmUgcmVmbGVjdGVkIGluIHN0YXRlLiBJbiBtb3N0IGNhc2VzLCBpdCBpcyBiZXR0ZXIgdG8gdXNlIHByb3BzIGRpcmVjdGx5LlwiLFxuICAgICAgICAgICAgICBzdGF0ZVxuICAgICAgICAgICAgKSkpO1xuICAgICAgICB3b3JrSW5Qcm9ncmVzcy5tb2RlICYgOCAmJlxuICAgICAgICAgIFJlYWN0U3RyaWN0TW9kZVdhcm5pbmdzLnJlY29yZExlZ2FjeUNvbnRleHRXYXJuaW5nKFxuICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gICAgICAgICAgICBfaW5zdGFuY2VcbiAgICAgICAgICApO1xuICAgICAgICBSZWFjdFN0cmljdE1vZGVXYXJuaW5ncy5yZWNvcmRVbnNhZmVMaWZlY3ljbGVXYXJuaW5ncyhcbiAgICAgICAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgICAgICAgICBfaW5zdGFuY2VcbiAgICAgICAgKTtcbiAgICAgICAgX2luc3RhbmNlLnN0YXRlID0gd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZTtcbiAgICAgICAgc3RhdGUgPSBDb21wb25lbnQuZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzO1xuICAgICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBzdGF0ZSAmJlxuICAgICAgICAgIChhcHBseURlcml2ZWRTdGF0ZUZyb21Qcm9wcyhcbiAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLFxuICAgICAgICAgICAgQ29tcG9uZW50LFxuICAgICAgICAgICAgc3RhdGUsXG4gICAgICAgICAgICBuZXh0UHJvcHNcbiAgICAgICAgICApLFxuICAgICAgICAgIChfaW5zdGFuY2Uuc3RhdGUgPSB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlKSk7XG4gICAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIENvbXBvbmVudC5nZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMgfHxcbiAgICAgICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBfaW5zdGFuY2UuZ2V0U25hcHNob3RCZWZvcmVVcGRhdGUgfHxcbiAgICAgICAgICAoXCJmdW5jdGlvblwiICE9PSB0eXBlb2YgX2luc3RhbmNlLlVOU0FGRV9jb21wb25lbnRXaWxsTW91bnQgJiZcbiAgICAgICAgICAgIFwiZnVuY3Rpb25cIiAhPT0gdHlwZW9mIF9pbnN0YW5jZS5jb21wb25lbnRXaWxsTW91bnQpIHx8XG4gICAgICAgICAgKChzdGF0ZSA9IF9pbnN0YW5jZS5zdGF0ZSksXG4gICAgICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgX2luc3RhbmNlLmNvbXBvbmVudFdpbGxNb3VudCAmJlxuICAgICAgICAgICAgX2luc3RhbmNlLmNvbXBvbmVudFdpbGxNb3VudCgpLFxuICAgICAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIF9pbnN0YW5jZS5VTlNBRkVfY29tcG9uZW50V2lsbE1vdW50ICYmXG4gICAgICAgICAgICBfaW5zdGFuY2UuVU5TQUZFX2NvbXBvbmVudFdpbGxNb3VudCgpLFxuICAgICAgICAgIHN0YXRlICE9PSBfaW5zdGFuY2Uuc3RhdGUgJiZcbiAgICAgICAgICAgIChjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICBcIiVzLmNvbXBvbmVudFdpbGxNb3VudCgpOiBBc3NpZ25pbmcgZGlyZWN0bHkgdG8gdGhpcy5zdGF0ZSBpcyBkZXByZWNhdGVkIChleGNlcHQgaW5zaWRlIGEgY29tcG9uZW50J3MgY29uc3RydWN0b3IpLiBVc2Ugc2V0U3RhdGUgaW5zdGVhZC5cIixcbiAgICAgICAgICAgICAgZ2V0Q29tcG9uZW50TmFtZUZyb21GaWJlcih3b3JrSW5Qcm9ncmVzcykgfHwgXCJDb21wb25lbnRcIlxuICAgICAgICAgICAgKSxcbiAgICAgICAgICAgIGNsYXNzQ29tcG9uZW50VXBkYXRlci5lbnF1ZXVlUmVwbGFjZVN0YXRlKFxuICAgICAgICAgICAgICBfaW5zdGFuY2UsXG4gICAgICAgICAgICAgIF9pbnN0YW5jZS5zdGF0ZSxcbiAgICAgICAgICAgICAgbnVsbFxuICAgICAgICAgICAgKSksXG4gICAgICAgICAgcHJvY2Vzc1VwZGF0ZVF1ZXVlKHdvcmtJblByb2dyZXNzLCBuZXh0UHJvcHMsIF9pbnN0YW5jZSwgcmVuZGVyTGFuZXMpLFxuICAgICAgICAgIHN1c3BlbmRJZlVwZGF0ZVJlYWRGcm9tRW50YW5nbGVkQXN5bmNBY3Rpb24oKSxcbiAgICAgICAgICAoX2luc3RhbmNlLnN0YXRlID0gd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZSkpO1xuICAgICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBfaW5zdGFuY2UuY29tcG9uZW50RGlkTW91bnQgJiZcbiAgICAgICAgICAod29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gNDE5NDMwOCk7XG4gICAgICAgICh3b3JrSW5Qcm9ncmVzcy5tb2RlICYgMTYpICE9PSBOb01vZGUgJiZcbiAgICAgICAgICAod29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gNjcxMDg4NjQpO1xuICAgICAgICBfaW5zdGFuY2UgPSAhMDtcbiAgICAgIH0gZWxzZSBpZiAobnVsbCA9PT0gY3VycmVudCRqc2NvbXAkMCkge1xuICAgICAgICBfaW5zdGFuY2UgPSB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGU7XG4gICAgICAgIHZhciB1bnJlc29sdmVkT2xkUHJvcHMgPSB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFByb3BzO1xuICAgICAgICBsYW5lID0gcmVzb2x2ZUNsYXNzQ29tcG9uZW50UHJvcHMoQ29tcG9uZW50LCB1bnJlc29sdmVkT2xkUHJvcHMpO1xuICAgICAgICBfaW5zdGFuY2UucHJvcHMgPSBsYW5lO1xuICAgICAgICB2YXIgb2xkQ29udGV4dCA9IF9pbnN0YW5jZS5jb250ZXh0O1xuICAgICAgICBmb3VuZFdpbGxVcGRhdGVOYW1lID0gQ29tcG9uZW50LmNvbnRleHRUeXBlO1xuICAgICAgICBzdGF0ZSA9IGVtcHR5Q29udGV4dE9iamVjdDtcbiAgICAgICAgXCJvYmplY3RcIiA9PT0gdHlwZW9mIGZvdW5kV2lsbFVwZGF0ZU5hbWUgJiZcbiAgICAgICAgICBudWxsICE9PSBmb3VuZFdpbGxVcGRhdGVOYW1lICYmXG4gICAgICAgICAgKHN0YXRlID0gcmVhZENvbnRleHQoZm91bmRXaWxsVXBkYXRlTmFtZSkpO1xuICAgICAgICBuZXdBcGlOYW1lID0gQ29tcG9uZW50LmdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcztcbiAgICAgICAgZm91bmRXaWxsVXBkYXRlTmFtZSA9XG4gICAgICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgbmV3QXBpTmFtZSB8fFxuICAgICAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIF9pbnN0YW5jZS5nZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZTtcbiAgICAgICAgdW5yZXNvbHZlZE9sZFByb3BzID0gd29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzICE9PSB1bnJlc29sdmVkT2xkUHJvcHM7XG4gICAgICAgIGZvdW5kV2lsbFVwZGF0ZU5hbWUgfHxcbiAgICAgICAgICAoXCJmdW5jdGlvblwiICE9PSB0eXBlb2YgX2luc3RhbmNlLlVOU0FGRV9jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzICYmXG4gICAgICAgICAgICBcImZ1bmN0aW9uXCIgIT09IHR5cGVvZiBfaW5zdGFuY2UuY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcykgfHxcbiAgICAgICAgICAoKHVucmVzb2x2ZWRPbGRQcm9wcyB8fCBvbGRDb250ZXh0ICE9PSBzdGF0ZSkgJiZcbiAgICAgICAgICAgIGNhbGxDb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzKFxuICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgICAgICAgICAgICAgX2luc3RhbmNlLFxuICAgICAgICAgICAgICBuZXh0UHJvcHMsXG4gICAgICAgICAgICAgIHN0YXRlXG4gICAgICAgICAgICApKTtcbiAgICAgICAgaGFzRm9yY2VVcGRhdGUgPSAhMTtcbiAgICAgICAgdmFyIG9sZFN0YXRlID0gd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZTtcbiAgICAgICAgX2luc3RhbmNlLnN0YXRlID0gb2xkU3RhdGU7XG4gICAgICAgIHByb2Nlc3NVcGRhdGVRdWV1ZSh3b3JrSW5Qcm9ncmVzcywgbmV4dFByb3BzLCBfaW5zdGFuY2UsIHJlbmRlckxhbmVzKTtcbiAgICAgICAgc3VzcGVuZElmVXBkYXRlUmVhZEZyb21FbnRhbmdsZWRBc3luY0FjdGlvbigpO1xuICAgICAgICBvbGRDb250ZXh0ID0gd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZTtcbiAgICAgICAgdW5yZXNvbHZlZE9sZFByb3BzIHx8IG9sZFN0YXRlICE9PSBvbGRDb250ZXh0IHx8IGhhc0ZvcmNlVXBkYXRlXG4gICAgICAgICAgPyAoXCJmdW5jdGlvblwiID09PSB0eXBlb2YgbmV3QXBpTmFtZSAmJlxuICAgICAgICAgICAgICAoYXBwbHlEZXJpdmVkU3RhdGVGcm9tUHJvcHMoXG4gICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gICAgICAgICAgICAgICAgQ29tcG9uZW50LFxuICAgICAgICAgICAgICAgIG5ld0FwaU5hbWUsXG4gICAgICAgICAgICAgICAgbmV4dFByb3BzXG4gICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgIChvbGRDb250ZXh0ID0gd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZSkpLFxuICAgICAgICAgICAgKGxhbmUgPVxuICAgICAgICAgICAgICBoYXNGb3JjZVVwZGF0ZSB8fFxuICAgICAgICAgICAgICBjaGVja1Nob3VsZENvbXBvbmVudFVwZGF0ZShcbiAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgICAgICAgICAgICAgICBDb21wb25lbnQsXG4gICAgICAgICAgICAgICAgbGFuZSxcbiAgICAgICAgICAgICAgICBuZXh0UHJvcHMsXG4gICAgICAgICAgICAgICAgb2xkU3RhdGUsXG4gICAgICAgICAgICAgICAgb2xkQ29udGV4dCxcbiAgICAgICAgICAgICAgICBzdGF0ZVxuICAgICAgICAgICAgICApKVxuICAgICAgICAgICAgICA/IChmb3VuZFdpbGxVcGRhdGVOYW1lIHx8XG4gICAgICAgICAgICAgICAgICAoXCJmdW5jdGlvblwiICE9PSB0eXBlb2YgX2luc3RhbmNlLlVOU0FGRV9jb21wb25lbnRXaWxsTW91bnQgJiZcbiAgICAgICAgICAgICAgICAgICAgXCJmdW5jdGlvblwiICE9PSB0eXBlb2YgX2luc3RhbmNlLmNvbXBvbmVudFdpbGxNb3VudCkgfHxcbiAgICAgICAgICAgICAgICAgIChcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBfaW5zdGFuY2UuY29tcG9uZW50V2lsbE1vdW50ICYmXG4gICAgICAgICAgICAgICAgICAgIF9pbnN0YW5jZS5jb21wb25lbnRXaWxsTW91bnQoKSxcbiAgICAgICAgICAgICAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIF9pbnN0YW5jZS5VTlNBRkVfY29tcG9uZW50V2lsbE1vdW50ICYmXG4gICAgICAgICAgICAgICAgICAgIF9pbnN0YW5jZS5VTlNBRkVfY29tcG9uZW50V2lsbE1vdW50KCkpLFxuICAgICAgICAgICAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIF9pbnN0YW5jZS5jb21wb25lbnREaWRNb3VudCAmJlxuICAgICAgICAgICAgICAgICAgKHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IDQxOTQzMDgpLFxuICAgICAgICAgICAgICAgICh3b3JrSW5Qcm9ncmVzcy5tb2RlICYgMTYpICE9PSBOb01vZGUgJiZcbiAgICAgICAgICAgICAgICAgICh3b3JrSW5Qcm9ncmVzcy5mbGFncyB8PSA2NzEwODg2NCkpXG4gICAgICAgICAgICAgIDogKFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIF9pbnN0YW5jZS5jb21wb25lbnREaWRNb3VudCAmJlxuICAgICAgICAgICAgICAgICAgKHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IDQxOTQzMDgpLFxuICAgICAgICAgICAgICAgICh3b3JrSW5Qcm9ncmVzcy5tb2RlICYgMTYpICE9PSBOb01vZGUgJiZcbiAgICAgICAgICAgICAgICAgICh3b3JrSW5Qcm9ncmVzcy5mbGFncyB8PSA2NzEwODg2NCksXG4gICAgICAgICAgICAgICAgKHdvcmtJblByb2dyZXNzLm1lbW9pemVkUHJvcHMgPSBuZXh0UHJvcHMpLFxuICAgICAgICAgICAgICAgICh3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlID0gb2xkQ29udGV4dCkpLFxuICAgICAgICAgICAgKF9pbnN0YW5jZS5wcm9wcyA9IG5leHRQcm9wcyksXG4gICAgICAgICAgICAoX2luc3RhbmNlLnN0YXRlID0gb2xkQ29udGV4dCksXG4gICAgICAgICAgICAoX2luc3RhbmNlLmNvbnRleHQgPSBzdGF0ZSksXG4gICAgICAgICAgICAoX2luc3RhbmNlID0gbGFuZSkpXG4gICAgICAgICAgOiAoXCJmdW5jdGlvblwiID09PSB0eXBlb2YgX2luc3RhbmNlLmNvbXBvbmVudERpZE1vdW50ICYmXG4gICAgICAgICAgICAgICh3b3JrSW5Qcm9ncmVzcy5mbGFncyB8PSA0MTk0MzA4KSxcbiAgICAgICAgICAgICh3b3JrSW5Qcm9ncmVzcy5tb2RlICYgMTYpICE9PSBOb01vZGUgJiZcbiAgICAgICAgICAgICAgKHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IDY3MTA4ODY0KSxcbiAgICAgICAgICAgIChfaW5zdGFuY2UgPSAhMSkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgX2luc3RhbmNlID0gd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlO1xuICAgICAgICBjbG9uZVVwZGF0ZVF1ZXVlKGN1cnJlbnQkanNjb21wJDAsIHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgc3RhdGUgPSB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFByb3BzO1xuICAgICAgICBmb3VuZFdpbGxVcGRhdGVOYW1lID0gcmVzb2x2ZUNsYXNzQ29tcG9uZW50UHJvcHMoQ29tcG9uZW50LCBzdGF0ZSk7XG4gICAgICAgIF9pbnN0YW5jZS5wcm9wcyA9IGZvdW5kV2lsbFVwZGF0ZU5hbWU7XG4gICAgICAgIG5ld0FwaU5hbWUgPSB3b3JrSW5Qcm9ncmVzcy5wZW5kaW5nUHJvcHM7XG4gICAgICAgIG9sZFN0YXRlID0gX2luc3RhbmNlLmNvbnRleHQ7XG4gICAgICAgIG9sZENvbnRleHQgPSBDb21wb25lbnQuY29udGV4dFR5cGU7XG4gICAgICAgIGxhbmUgPSBlbXB0eUNvbnRleHRPYmplY3Q7XG4gICAgICAgIFwib2JqZWN0XCIgPT09IHR5cGVvZiBvbGRDb250ZXh0ICYmXG4gICAgICAgICAgbnVsbCAhPT0gb2xkQ29udGV4dCAmJlxuICAgICAgICAgIChsYW5lID0gcmVhZENvbnRleHQob2xkQ29udGV4dCkpO1xuICAgICAgICB1bnJlc29sdmVkT2xkUHJvcHMgPSBDb21wb25lbnQuZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzO1xuICAgICAgICAob2xkQ29udGV4dCA9XG4gICAgICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgdW5yZXNvbHZlZE9sZFByb3BzIHx8XG4gICAgICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgX2luc3RhbmNlLmdldFNuYXBzaG90QmVmb3JlVXBkYXRlKSB8fFxuICAgICAgICAgIChcImZ1bmN0aW9uXCIgIT09IHR5cGVvZiBfaW5zdGFuY2UuVU5TQUZFX2NvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMgJiZcbiAgICAgICAgICAgIFwiZnVuY3Rpb25cIiAhPT0gdHlwZW9mIF9pbnN0YW5jZS5jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzKSB8fFxuICAgICAgICAgICgoc3RhdGUgIT09IG5ld0FwaU5hbWUgfHwgb2xkU3RhdGUgIT09IGxhbmUpICYmXG4gICAgICAgICAgICBjYWxsQ29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyhcbiAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gICAgICAgICAgICAgIF9pbnN0YW5jZSxcbiAgICAgICAgICAgICAgbmV4dFByb3BzLFxuICAgICAgICAgICAgICBsYW5lXG4gICAgICAgICAgICApKTtcbiAgICAgICAgaGFzRm9yY2VVcGRhdGUgPSAhMTtcbiAgICAgICAgb2xkU3RhdGUgPSB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlO1xuICAgICAgICBfaW5zdGFuY2Uuc3RhdGUgPSBvbGRTdGF0ZTtcbiAgICAgICAgcHJvY2Vzc1VwZGF0ZVF1ZXVlKHdvcmtJblByb2dyZXNzLCBuZXh0UHJvcHMsIF9pbnN0YW5jZSwgcmVuZGVyTGFuZXMpO1xuICAgICAgICBzdXNwZW5kSWZVcGRhdGVSZWFkRnJvbUVudGFuZ2xlZEFzeW5jQWN0aW9uKCk7XG4gICAgICAgIHZhciBuZXdTdGF0ZSA9IHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGU7XG4gICAgICAgIHN0YXRlICE9PSBuZXdBcGlOYW1lIHx8XG4gICAgICAgIG9sZFN0YXRlICE9PSBuZXdTdGF0ZSB8fFxuICAgICAgICBoYXNGb3JjZVVwZGF0ZSB8fFxuICAgICAgICAobnVsbCAhPT0gY3VycmVudCRqc2NvbXAkMCAmJlxuICAgICAgICAgIG51bGwgIT09IGN1cnJlbnQkanNjb21wJDAuZGVwZW5kZW5jaWVzICYmXG4gICAgICAgICAgY2hlY2tJZkNvbnRleHRDaGFuZ2VkKGN1cnJlbnQkanNjb21wJDAuZGVwZW5kZW5jaWVzKSlcbiAgICAgICAgICA/IChcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiB1bnJlc29sdmVkT2xkUHJvcHMgJiZcbiAgICAgICAgICAgICAgKGFwcGx5RGVyaXZlZFN0YXRlRnJvbVByb3BzKFxuICAgICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLFxuICAgICAgICAgICAgICAgIENvbXBvbmVudCxcbiAgICAgICAgICAgICAgICB1bnJlc29sdmVkT2xkUHJvcHMsXG4gICAgICAgICAgICAgICAgbmV4dFByb3BzXG4gICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgIChuZXdTdGF0ZSA9IHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGUpKSxcbiAgICAgICAgICAgIChmb3VuZFdpbGxVcGRhdGVOYW1lID1cbiAgICAgICAgICAgICAgaGFzRm9yY2VVcGRhdGUgfHxcbiAgICAgICAgICAgICAgY2hlY2tTaG91bGRDb21wb25lbnRVcGRhdGUoXG4gICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gICAgICAgICAgICAgICAgQ29tcG9uZW50LFxuICAgICAgICAgICAgICAgIGZvdW5kV2lsbFVwZGF0ZU5hbWUsXG4gICAgICAgICAgICAgICAgbmV4dFByb3BzLFxuICAgICAgICAgICAgICAgIG9sZFN0YXRlLFxuICAgICAgICAgICAgICAgIG5ld1N0YXRlLFxuICAgICAgICAgICAgICAgIGxhbmVcbiAgICAgICAgICAgICAgKSB8fFxuICAgICAgICAgICAgICAobnVsbCAhPT0gY3VycmVudCRqc2NvbXAkMCAmJlxuICAgICAgICAgICAgICAgIG51bGwgIT09IGN1cnJlbnQkanNjb21wJDAuZGVwZW5kZW5jaWVzICYmXG4gICAgICAgICAgICAgICAgY2hlY2tJZkNvbnRleHRDaGFuZ2VkKGN1cnJlbnQkanNjb21wJDAuZGVwZW5kZW5jaWVzKSkpXG4gICAgICAgICAgICAgID8gKG9sZENvbnRleHQgfHxcbiAgICAgICAgICAgICAgICAgIChcImZ1bmN0aW9uXCIgIT09IHR5cGVvZiBfaW5zdGFuY2UuVU5TQUZFX2NvbXBvbmVudFdpbGxVcGRhdGUgJiZcbiAgICAgICAgICAgICAgICAgICAgXCJmdW5jdGlvblwiICE9PSB0eXBlb2YgX2luc3RhbmNlLmNvbXBvbmVudFdpbGxVcGRhdGUpIHx8XG4gICAgICAgICAgICAgICAgICAoXCJmdW5jdGlvblwiID09PSB0eXBlb2YgX2luc3RhbmNlLmNvbXBvbmVudFdpbGxVcGRhdGUgJiZcbiAgICAgICAgICAgICAgICAgICAgX2luc3RhbmNlLmNvbXBvbmVudFdpbGxVcGRhdGUobmV4dFByb3BzLCBuZXdTdGF0ZSwgbGFuZSksXG4gICAgICAgICAgICAgICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBfaW5zdGFuY2UuVU5TQUZFX2NvbXBvbmVudFdpbGxVcGRhdGUgJiZcbiAgICAgICAgICAgICAgICAgICAgX2luc3RhbmNlLlVOU0FGRV9jb21wb25lbnRXaWxsVXBkYXRlKFxuICAgICAgICAgICAgICAgICAgICAgIG5leHRQcm9wcyxcbiAgICAgICAgICAgICAgICAgICAgICBuZXdTdGF0ZSxcbiAgICAgICAgICAgICAgICAgICAgICBsYW5lXG4gICAgICAgICAgICAgICAgICAgICkpLFxuICAgICAgICAgICAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIF9pbnN0YW5jZS5jb21wb25lbnREaWRVcGRhdGUgJiZcbiAgICAgICAgICAgICAgICAgICh3b3JrSW5Qcm9ncmVzcy5mbGFncyB8PSA0KSxcbiAgICAgICAgICAgICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBfaW5zdGFuY2UuZ2V0U25hcHNob3RCZWZvcmVVcGRhdGUgJiZcbiAgICAgICAgICAgICAgICAgICh3b3JrSW5Qcm9ncmVzcy5mbGFncyB8PSAxMDI0KSlcbiAgICAgICAgICAgICAgOiAoXCJmdW5jdGlvblwiICE9PSB0eXBlb2YgX2luc3RhbmNlLmNvbXBvbmVudERpZFVwZGF0ZSB8fFxuICAgICAgICAgICAgICAgICAgKHN0YXRlID09PSBjdXJyZW50JGpzY29tcCQwLm1lbW9pemVkUHJvcHMgJiZcbiAgICAgICAgICAgICAgICAgICAgb2xkU3RhdGUgPT09IGN1cnJlbnQkanNjb21wJDAubWVtb2l6ZWRTdGF0ZSkgfHxcbiAgICAgICAgICAgICAgICAgICh3b3JrSW5Qcm9ncmVzcy5mbGFncyB8PSA0KSxcbiAgICAgICAgICAgICAgICBcImZ1bmN0aW9uXCIgIT09IHR5cGVvZiBfaW5zdGFuY2UuZ2V0U25hcHNob3RCZWZvcmVVcGRhdGUgfHxcbiAgICAgICAgICAgICAgICAgIChzdGF0ZSA9PT0gY3VycmVudCRqc2NvbXAkMC5tZW1vaXplZFByb3BzICYmXG4gICAgICAgICAgICAgICAgICAgIG9sZFN0YXRlID09PSBjdXJyZW50JGpzY29tcCQwLm1lbW9pemVkU3RhdGUpIHx8XG4gICAgICAgICAgICAgICAgICAod29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gMTAyNCksXG4gICAgICAgICAgICAgICAgKHdvcmtJblByb2dyZXNzLm1lbW9pemVkUHJvcHMgPSBuZXh0UHJvcHMpLFxuICAgICAgICAgICAgICAgICh3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlID0gbmV3U3RhdGUpKSxcbiAgICAgICAgICAgIChfaW5zdGFuY2UucHJvcHMgPSBuZXh0UHJvcHMpLFxuICAgICAgICAgICAgKF9pbnN0YW5jZS5zdGF0ZSA9IG5ld1N0YXRlKSxcbiAgICAgICAgICAgIChfaW5zdGFuY2UuY29udGV4dCA9IGxhbmUpLFxuICAgICAgICAgICAgKF9pbnN0YW5jZSA9IGZvdW5kV2lsbFVwZGF0ZU5hbWUpKVxuICAgICAgICAgIDogKFwiZnVuY3Rpb25cIiAhPT0gdHlwZW9mIF9pbnN0YW5jZS5jb21wb25lbnREaWRVcGRhdGUgfHxcbiAgICAgICAgICAgICAgKHN0YXRlID09PSBjdXJyZW50JGpzY29tcCQwLm1lbW9pemVkUHJvcHMgJiZcbiAgICAgICAgICAgICAgICBvbGRTdGF0ZSA9PT0gY3VycmVudCRqc2NvbXAkMC5tZW1vaXplZFN0YXRlKSB8fFxuICAgICAgICAgICAgICAod29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gNCksXG4gICAgICAgICAgICBcImZ1bmN0aW9uXCIgIT09IHR5cGVvZiBfaW5zdGFuY2UuZ2V0U25hcHNob3RCZWZvcmVVcGRhdGUgfHxcbiAgICAgICAgICAgICAgKHN0YXRlID09PSBjdXJyZW50JGpzY29tcCQwLm1lbW9pemVkUHJvcHMgJiZcbiAgICAgICAgICAgICAgICBvbGRTdGF0ZSA9PT0gY3VycmVudCRqc2NvbXAkMC5tZW1vaXplZFN0YXRlKSB8fFxuICAgICAgICAgICAgICAod29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gMTAyNCksXG4gICAgICAgICAgICAoX2luc3RhbmNlID0gITEpKTtcbiAgICAgIH1cbiAgICAgIGxhbmUgPSBfaW5zdGFuY2U7XG4gICAgICBtYXJrUmVmKGN1cnJlbnQkanNjb21wJDAsIHdvcmtJblByb2dyZXNzKTtcbiAgICAgIHN0YXRlID0gMCAhPT0gKHdvcmtJblByb2dyZXNzLmZsYWdzICYgMTI4KTtcbiAgICAgIGlmIChsYW5lIHx8IHN0YXRlKSB7XG4gICAgICAgIGxhbmUgPSB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGU7XG4gICAgICAgIFJlYWN0U2hhcmVkSW50ZXJuYWxzLmdldEN1cnJlbnRTdGFjayA9XG4gICAgICAgICAgbnVsbCA9PT0gd29ya0luUHJvZ3Jlc3MgPyBudWxsIDogZ2V0Q3VycmVudEZpYmVyU3RhY2tJbkRldjtcbiAgICAgICAgaXNSZW5kZXJpbmcgPSAhMTtcbiAgICAgICAgY3VycmVudCA9IHdvcmtJblByb2dyZXNzO1xuICAgICAgICBpZiAoc3RhdGUgJiYgXCJmdW5jdGlvblwiICE9PSB0eXBlb2YgQ29tcG9uZW50LmdldERlcml2ZWRTdGF0ZUZyb21FcnJvcilcbiAgICAgICAgICAoQ29tcG9uZW50ID0gbnVsbCksIChwcm9maWxlclN0YXJ0VGltZSA9IC0xKTtcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgbWFya0NvbXBvbmVudFJlbmRlclN0YXJ0ZWQod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICAgIENvbXBvbmVudCA9IGNhbGxSZW5kZXJJbkRFVihsYW5lKTtcbiAgICAgICAgICBpZiAod29ya0luUHJvZ3Jlc3MubW9kZSAmIDgpIHtcbiAgICAgICAgICAgIHNldElzU3RyaWN0TW9kZUZvckRldnRvb2xzKCEwKTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIGNhbGxSZW5kZXJJbkRFVihsYW5lKTtcbiAgICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICAgIHNldElzU3RyaWN0TW9kZUZvckRldnRvb2xzKCExKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgbWFya0NvbXBvbmVudFJlbmRlclN0b3BwZWQoKTtcbiAgICAgICAgfVxuICAgICAgICB3b3JrSW5Qcm9ncmVzcy5mbGFncyB8PSAxO1xuICAgICAgICBudWxsICE9PSBjdXJyZW50JGpzY29tcCQwICYmIHN0YXRlXG4gICAgICAgICAgPyAoKHdvcmtJblByb2dyZXNzLmNoaWxkID0gcmVjb25jaWxlQ2hpbGRGaWJlcnMoXG4gICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLFxuICAgICAgICAgICAgICBjdXJyZW50JGpzY29tcCQwLmNoaWxkLFxuICAgICAgICAgICAgICBudWxsLFxuICAgICAgICAgICAgICByZW5kZXJMYW5lc1xuICAgICAgICAgICAgKSksXG4gICAgICAgICAgICAod29ya0luUHJvZ3Jlc3MuY2hpbGQgPSByZWNvbmNpbGVDaGlsZEZpYmVycyhcbiAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gICAgICAgICAgICAgIG51bGwsXG4gICAgICAgICAgICAgIENvbXBvbmVudCxcbiAgICAgICAgICAgICAgcmVuZGVyTGFuZXNcbiAgICAgICAgICAgICkpKVxuICAgICAgICAgIDogcmVjb25jaWxlQ2hpbGRyZW4oXG4gICAgICAgICAgICAgIGN1cnJlbnQkanNjb21wJDAsXG4gICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLFxuICAgICAgICAgICAgICBDb21wb25lbnQsXG4gICAgICAgICAgICAgIHJlbmRlckxhbmVzXG4gICAgICAgICAgICApO1xuICAgICAgICB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlID0gbGFuZS5zdGF0ZTtcbiAgICAgICAgY3VycmVudCRqc2NvbXAkMCA9IHdvcmtJblByb2dyZXNzLmNoaWxkO1xuICAgICAgfSBlbHNlXG4gICAgICAgIGN1cnJlbnQkanNjb21wJDAgPSBiYWlsb3V0T25BbHJlYWR5RmluaXNoZWRXb3JrKFxuICAgICAgICAgIGN1cnJlbnQkanNjb21wJDAsXG4gICAgICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gICAgICAgICAgcmVuZGVyTGFuZXNcbiAgICAgICAgKTtcbiAgICAgIHJlbmRlckxhbmVzID0gd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlO1xuICAgICAgX2luc3RhbmNlICYmXG4gICAgICAgIHJlbmRlckxhbmVzLnByb3BzICE9PSBuZXh0UHJvcHMgJiZcbiAgICAgICAgKGRpZFdhcm5BYm91dFJlYXNzaWduaW5nUHJvcHMgfHxcbiAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgXCJJdCBsb29rcyBsaWtlICVzIGlzIHJlYXNzaWduaW5nIGl0cyBvd24gYHRoaXMucHJvcHNgIHdoaWxlIHJlbmRlcmluZy4gVGhpcyBpcyBub3Qgc3VwcG9ydGVkIGFuZCBjYW4gbGVhZCB0byBjb25mdXNpbmcgYnVncy5cIixcbiAgICAgICAgICAgIGdldENvbXBvbmVudE5hbWVGcm9tRmliZXIod29ya0luUHJvZ3Jlc3MpIHx8IFwiYSBjb21wb25lbnRcIlxuICAgICAgICAgICksXG4gICAgICAgIChkaWRXYXJuQWJvdXRSZWFzc2lnbmluZ1Byb3BzID0gITApKTtcbiAgICAgIHJldHVybiBjdXJyZW50JGpzY29tcCQwO1xuICAgIH1cbiAgICBmdW5jdGlvbiBtb3VudEhvc3RSb290V2l0aG91dEh5ZHJhdGluZyhcbiAgICAgIGN1cnJlbnQsXG4gICAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgICAgIG5leHRDaGlsZHJlbixcbiAgICAgIHJlbmRlckxhbmVzXG4gICAgKSB7XG4gICAgICByZXNldEh5ZHJhdGlvblN0YXRlKCk7XG4gICAgICB3b3JrSW5Qcm9ncmVzcy5mbGFncyB8PSAyNTY7XG4gICAgICByZWNvbmNpbGVDaGlsZHJlbihjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgbmV4dENoaWxkcmVuLCByZW5kZXJMYW5lcyk7XG4gICAgICByZXR1cm4gd29ya0luUHJvZ3Jlc3MuY2hpbGQ7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHZhbGlkYXRlRnVuY3Rpb25Db21wb25lbnRJbkRldih3b3JrSW5Qcm9ncmVzcywgQ29tcG9uZW50KSB7XG4gICAgICBDb21wb25lbnQgJiZcbiAgICAgICAgQ29tcG9uZW50LmNoaWxkQ29udGV4dFR5cGVzICYmXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgXCJjaGlsZENvbnRleHRUeXBlcyBjYW5ub3QgYmUgZGVmaW5lZCBvbiBhIGZ1bmN0aW9uIGNvbXBvbmVudC5cXG4gICVzLmNoaWxkQ29udGV4dFR5cGVzID0gLi4uXCIsXG4gICAgICAgICAgQ29tcG9uZW50LmRpc3BsYXlOYW1lIHx8IENvbXBvbmVudC5uYW1lIHx8IFwiQ29tcG9uZW50XCJcbiAgICAgICAgKTtcbiAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIENvbXBvbmVudC5nZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMgJiZcbiAgICAgICAgKCh3b3JrSW5Qcm9ncmVzcyA9IGdldENvbXBvbmVudE5hbWVGcm9tVHlwZShDb21wb25lbnQpIHx8IFwiVW5rbm93blwiKSxcbiAgICAgICAgZGlkV2FybkFib3V0R2V0RGVyaXZlZFN0YXRlT25GdW5jdGlvbkNvbXBvbmVudFt3b3JrSW5Qcm9ncmVzc10gfHxcbiAgICAgICAgICAoY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgIFwiJXM6IEZ1bmN0aW9uIGNvbXBvbmVudHMgZG8gbm90IHN1cHBvcnQgZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzLlwiLFxuICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3NcbiAgICAgICAgICApLFxuICAgICAgICAgIChkaWRXYXJuQWJvdXRHZXREZXJpdmVkU3RhdGVPbkZ1bmN0aW9uQ29tcG9uZW50W3dvcmtJblByb2dyZXNzXSA9XG4gICAgICAgICAgICAhMCkpKTtcbiAgICAgIFwib2JqZWN0XCIgPT09IHR5cGVvZiBDb21wb25lbnQuY29udGV4dFR5cGUgJiZcbiAgICAgICAgbnVsbCAhPT0gQ29tcG9uZW50LmNvbnRleHRUeXBlICYmXG4gICAgICAgICgoQ29tcG9uZW50ID0gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKENvbXBvbmVudCkgfHwgXCJVbmtub3duXCIpLFxuICAgICAgICBkaWRXYXJuQWJvdXRDb250ZXh0VHlwZU9uRnVuY3Rpb25Db21wb25lbnRbQ29tcG9uZW50XSB8fFxuICAgICAgICAgIChjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgXCIlczogRnVuY3Rpb24gY29tcG9uZW50cyBkbyBub3Qgc3VwcG9ydCBjb250ZXh0VHlwZS5cIixcbiAgICAgICAgICAgIENvbXBvbmVudFxuICAgICAgICAgICksXG4gICAgICAgICAgKGRpZFdhcm5BYm91dENvbnRleHRUeXBlT25GdW5jdGlvbkNvbXBvbmVudFtDb21wb25lbnRdID0gITApKSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIG1vdW50U3VzcGVuc2VPZmZzY3JlZW5TdGF0ZShyZW5kZXJMYW5lcykge1xuICAgICAgcmV0dXJuIHsgYmFzZUxhbmVzOiByZW5kZXJMYW5lcywgY2FjaGVQb29sOiBnZXRTdXNwZW5kZWRDYWNoZSgpIH07XG4gICAgfVxuICAgIGZ1bmN0aW9uIGdldFJlbWFpbmluZ1dvcmtJblByaW1hcnlUcmVlKFxuICAgICAgY3VycmVudCxcbiAgICAgIHByaW1hcnlUcmVlRGlkRGVmZXIsXG4gICAgICByZW5kZXJMYW5lc1xuICAgICkge1xuICAgICAgY3VycmVudCA9IG51bGwgIT09IGN1cnJlbnQgPyBjdXJyZW50LmNoaWxkTGFuZXMgJiB+cmVuZGVyTGFuZXMgOiAwO1xuICAgICAgcHJpbWFyeVRyZWVEaWREZWZlciAmJiAoY3VycmVudCB8PSB3b3JrSW5Qcm9ncmVzc0RlZmVycmVkTGFuZSk7XG4gICAgICByZXR1cm4gY3VycmVudDtcbiAgICB9XG4gICAgZnVuY3Rpb24gdXBkYXRlU3VzcGVuc2VDb21wb25lbnQoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckxhbmVzKSB7XG4gICAgICB2YXIgbmV4dFByb3BzID0gd29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzO1xuICAgICAgc2hvdWxkU3VzcGVuZEltcGwod29ya0luUHJvZ3Jlc3MpICYmICh3b3JrSW5Qcm9ncmVzcy5mbGFncyB8PSAxMjgpO1xuICAgICAgdmFyIHNob3dGYWxsYmFjayA9ICExLFxuICAgICAgICBkaWRTdXNwZW5kID0gMCAhPT0gKHdvcmtJblByb2dyZXNzLmZsYWdzICYgMTI4KSxcbiAgICAgICAgSlNDb21waWxlcl90ZW1wO1xuICAgICAgKEpTQ29tcGlsZXJfdGVtcCA9IGRpZFN1c3BlbmQpIHx8XG4gICAgICAgIChKU0NvbXBpbGVyX3RlbXAgPVxuICAgICAgICAgIG51bGwgIT09IGN1cnJlbnQgJiYgbnVsbCA9PT0gY3VycmVudC5tZW1vaXplZFN0YXRlXG4gICAgICAgICAgICA/ICExXG4gICAgICAgICAgICA6IDAgIT09IChzdXNwZW5zZVN0YWNrQ3Vyc29yLmN1cnJlbnQgJiBGb3JjZVN1c3BlbnNlRmFsbGJhY2spKTtcbiAgICAgIEpTQ29tcGlsZXJfdGVtcCAmJiAoKHNob3dGYWxsYmFjayA9ICEwKSwgKHdvcmtJblByb2dyZXNzLmZsYWdzICY9IC0xMjkpKTtcbiAgICAgIEpTQ29tcGlsZXJfdGVtcCA9IDAgIT09ICh3b3JrSW5Qcm9ncmVzcy5mbGFncyAmIDMyKTtcbiAgICAgIHdvcmtJblByb2dyZXNzLmZsYWdzICY9IC0zMztcbiAgICAgIGlmIChudWxsID09PSBjdXJyZW50KSB7XG4gICAgICAgIGlmIChpc0h5ZHJhdGluZykge1xuICAgICAgICAgIHNob3dGYWxsYmFja1xuICAgICAgICAgICAgPyBwdXNoUHJpbWFyeVRyZWVTdXNwZW5zZUhhbmRsZXIod29ya0luUHJvZ3Jlc3MpXG4gICAgICAgICAgICA6IHJldXNlU3VzcGVuc2VIYW5kbGVyT25TdGFjayh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgICAgaWYgKGlzSHlkcmF0aW5nKSB7XG4gICAgICAgICAgICB2YXIgbmV4dEluc3RhbmNlID0gbmV4dEh5ZHJhdGFibGVJbnN0YW5jZSxcbiAgICAgICAgICAgICAgSlNDb21waWxlcl90ZW1wJGpzY29tcCQwO1xuICAgICAgICAgICAgKEpTQ29tcGlsZXJfdGVtcCRqc2NvbXAkMCA9ICFuZXh0SW5zdGFuY2UpIHx8XG4gICAgICAgICAgICAgICgoSlNDb21waWxlcl90ZW1wJGpzY29tcCQwID0gY2FuSHlkcmF0ZVN1c3BlbnNlSW5zdGFuY2UoXG4gICAgICAgICAgICAgICAgbmV4dEluc3RhbmNlLFxuICAgICAgICAgICAgICAgIHJvb3RPclNpbmdsZXRvbkNvbnRleHRcbiAgICAgICAgICAgICAgKSksXG4gICAgICAgICAgICAgIG51bGwgIT09IEpTQ29tcGlsZXJfdGVtcCRqc2NvbXAkMFxuICAgICAgICAgICAgICAgID8gKHdhcm5JZk5vdEh5ZHJhdGluZygpLFxuICAgICAgICAgICAgICAgICAgKHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGUgPSB7XG4gICAgICAgICAgICAgICAgICAgIGRlaHlkcmF0ZWQ6IEpTQ29tcGlsZXJfdGVtcCRqc2NvbXAkMCxcbiAgICAgICAgICAgICAgICAgICAgdHJlZUNvbnRleHQ6XG4gICAgICAgICAgICAgICAgICAgICAgbnVsbCAhPT0gdHJlZUNvbnRleHRQcm92aWRlclxuICAgICAgICAgICAgICAgICAgICAgICAgPyB7IGlkOiB0cmVlQ29udGV4dElkLCBvdmVyZmxvdzogdHJlZUNvbnRleHRPdmVyZmxvdyB9XG4gICAgICAgICAgICAgICAgICAgICAgICA6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgIHJldHJ5TGFuZTogNTM2ODcwOTEyXG4gICAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICAgIChkaWRTdXNwZW5kID0gY3JlYXRlRmliZXIoMTgsIG51bGwsIG51bGwsIE5vTW9kZSkpLFxuICAgICAgICAgICAgICAgICAgKGRpZFN1c3BlbmQuc3RhdGVOb2RlID0gSlNDb21waWxlcl90ZW1wJGpzY29tcCQwKSxcbiAgICAgICAgICAgICAgICAgIChkaWRTdXNwZW5kLnJldHVybiA9IHdvcmtJblByb2dyZXNzKSxcbiAgICAgICAgICAgICAgICAgICh3b3JrSW5Qcm9ncmVzcy5jaGlsZCA9IGRpZFN1c3BlbmQpLFxuICAgICAgICAgICAgICAgICAgKGh5ZHJhdGlvblBhcmVudEZpYmVyID0gd29ya0luUHJvZ3Jlc3MpLFxuICAgICAgICAgICAgICAgICAgKG5leHRIeWRyYXRhYmxlSW5zdGFuY2UgPSBudWxsKSxcbiAgICAgICAgICAgICAgICAgIChKU0NvbXBpbGVyX3RlbXAkanNjb21wJDAgPSAhMCkpXG4gICAgICAgICAgICAgICAgOiAoSlNDb21waWxlcl90ZW1wJGpzY29tcCQwID0gITEpLFxuICAgICAgICAgICAgICAoSlNDb21waWxlcl90ZW1wJGpzY29tcCQwID0gIUpTQ29tcGlsZXJfdGVtcCRqc2NvbXAkMCkpO1xuICAgICAgICAgICAgSlNDb21waWxlcl90ZW1wJGpzY29tcCQwICYmXG4gICAgICAgICAgICAgICh3YXJuTm9uSHlkcmF0ZWRJbnN0YW5jZSh3b3JrSW5Qcm9ncmVzcywgbmV4dEluc3RhbmNlKSxcbiAgICAgICAgICAgICAgdGhyb3dPbkh5ZHJhdGlvbk1pc21hdGNoKHdvcmtJblByb2dyZXNzKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIG5leHRJbnN0YW5jZSA9IHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGU7XG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgbnVsbCAhPT0gbmV4dEluc3RhbmNlICYmXG4gICAgICAgICAgICAoKG5leHRJbnN0YW5jZSA9IG5leHRJbnN0YW5jZS5kZWh5ZHJhdGVkKSwgbnVsbCAhPT0gbmV4dEluc3RhbmNlKVxuICAgICAgICAgIClcbiAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAgIGlzU3VzcGVuc2VJbnN0YW5jZUZhbGxiYWNrKG5leHRJbnN0YW5jZSlcbiAgICAgICAgICAgICAgICA/ICh3b3JrSW5Qcm9ncmVzcy5sYW5lcyA9IDE2KVxuICAgICAgICAgICAgICAgIDogKHdvcmtJblByb2dyZXNzLmxhbmVzID0gNTM2ODcwOTEyKSxcbiAgICAgICAgICAgICAgbnVsbFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICBwb3BTdXNwZW5zZUhhbmRsZXIod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICB9XG4gICAgICAgIG5leHRJbnN0YW5jZSA9IG5leHRQcm9wcy5jaGlsZHJlbjtcbiAgICAgICAgbmV4dFByb3BzID0gbmV4dFByb3BzLmZhbGxiYWNrO1xuICAgICAgICBpZiAoc2hvd0ZhbGxiYWNrKVxuICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICByZXVzZVN1c3BlbnNlSGFuZGxlck9uU3RhY2sod29ya0luUHJvZ3Jlc3MpLFxuICAgICAgICAgICAgKHNob3dGYWxsYmFjayA9IHdvcmtJblByb2dyZXNzLm1vZGUpLFxuICAgICAgICAgICAgKG5leHRJbnN0YW5jZSA9IG1vdW50V29ya0luUHJvZ3Jlc3NPZmZzY3JlZW5GaWJlcihcbiAgICAgICAgICAgICAgeyBtb2RlOiBcImhpZGRlblwiLCBjaGlsZHJlbjogbmV4dEluc3RhbmNlIH0sXG4gICAgICAgICAgICAgIHNob3dGYWxsYmFja1xuICAgICAgICAgICAgKSksXG4gICAgICAgICAgICAobmV4dFByb3BzID0gY3JlYXRlRmliZXJGcm9tRnJhZ21lbnQoXG4gICAgICAgICAgICAgIG5leHRQcm9wcyxcbiAgICAgICAgICAgICAgc2hvd0ZhbGxiYWNrLFxuICAgICAgICAgICAgICByZW5kZXJMYW5lcyxcbiAgICAgICAgICAgICAgbnVsbFxuICAgICAgICAgICAgKSksXG4gICAgICAgICAgICAobmV4dEluc3RhbmNlLnJldHVybiA9IHdvcmtJblByb2dyZXNzKSxcbiAgICAgICAgICAgIChuZXh0UHJvcHMucmV0dXJuID0gd29ya0luUHJvZ3Jlc3MpLFxuICAgICAgICAgICAgKG5leHRJbnN0YW5jZS5zaWJsaW5nID0gbmV4dFByb3BzKSxcbiAgICAgICAgICAgICh3b3JrSW5Qcm9ncmVzcy5jaGlsZCA9IG5leHRJbnN0YW5jZSksXG4gICAgICAgICAgICAoc2hvd0ZhbGxiYWNrID0gd29ya0luUHJvZ3Jlc3MuY2hpbGQpLFxuICAgICAgICAgICAgKHNob3dGYWxsYmFjay5tZW1vaXplZFN0YXRlID1cbiAgICAgICAgICAgICAgbW91bnRTdXNwZW5zZU9mZnNjcmVlblN0YXRlKHJlbmRlckxhbmVzKSksXG4gICAgICAgICAgICAoc2hvd0ZhbGxiYWNrLmNoaWxkTGFuZXMgPSBnZXRSZW1haW5pbmdXb3JrSW5QcmltYXJ5VHJlZShcbiAgICAgICAgICAgICAgY3VycmVudCxcbiAgICAgICAgICAgICAgSlNDb21waWxlcl90ZW1wLFxuICAgICAgICAgICAgICByZW5kZXJMYW5lc1xuICAgICAgICAgICAgKSksXG4gICAgICAgICAgICAod29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZSA9IFNVU1BFTkRFRF9NQVJLRVIpLFxuICAgICAgICAgICAgbmV4dFByb3BzXG4gICAgICAgICAgKTtcbiAgICAgICAgcHVzaFByaW1hcnlUcmVlU3VzcGVuc2VIYW5kbGVyKHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgcmV0dXJuIG1vdW50U3VzcGVuc2VQcmltYXJ5Q2hpbGRyZW4od29ya0luUHJvZ3Jlc3MsIG5leHRJbnN0YW5jZSk7XG4gICAgICB9XG4gICAgICBKU0NvbXBpbGVyX3RlbXAkanNjb21wJDAgPSBjdXJyZW50Lm1lbW9pemVkU3RhdGU7XG4gICAgICBpZiAoXG4gICAgICAgIG51bGwgIT09IEpTQ29tcGlsZXJfdGVtcCRqc2NvbXAkMCAmJlxuICAgICAgICAoKG5leHRJbnN0YW5jZSA9IEpTQ29tcGlsZXJfdGVtcCRqc2NvbXAkMC5kZWh5ZHJhdGVkKSxcbiAgICAgICAgbnVsbCAhPT0gbmV4dEluc3RhbmNlKVxuICAgICAgKSB7XG4gICAgICAgIGlmIChkaWRTdXNwZW5kKVxuICAgICAgICAgIHdvcmtJblByb2dyZXNzLmZsYWdzICYgMjU2XG4gICAgICAgICAgICA/IChwdXNoUHJpbWFyeVRyZWVTdXNwZW5zZUhhbmRsZXIod29ya0luUHJvZ3Jlc3MpLFxuICAgICAgICAgICAgICAod29ya0luUHJvZ3Jlc3MuZmxhZ3MgJj0gLTI1NyksXG4gICAgICAgICAgICAgICh3b3JrSW5Qcm9ncmVzcyA9IHJldHJ5U3VzcGVuc2VDb21wb25lbnRXaXRob3V0SHlkcmF0aW5nKFxuICAgICAgICAgICAgICAgIGN1cnJlbnQsXG4gICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gICAgICAgICAgICAgICAgcmVuZGVyTGFuZXNcbiAgICAgICAgICAgICAgKSkpXG4gICAgICAgICAgICA6IG51bGwgIT09IHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGVcbiAgICAgICAgICAgICAgPyAocmV1c2VTdXNwZW5zZUhhbmRsZXJPblN0YWNrKHdvcmtJblByb2dyZXNzKSxcbiAgICAgICAgICAgICAgICAod29ya0luUHJvZ3Jlc3MuY2hpbGQgPSBjdXJyZW50LmNoaWxkKSxcbiAgICAgICAgICAgICAgICAod29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gMTI4KSxcbiAgICAgICAgICAgICAgICAod29ya0luUHJvZ3Jlc3MgPSBudWxsKSlcbiAgICAgICAgICAgICAgOiAocmV1c2VTdXNwZW5zZUhhbmRsZXJPblN0YWNrKHdvcmtJblByb2dyZXNzKSxcbiAgICAgICAgICAgICAgICAoc2hvd0ZhbGxiYWNrID0gbmV4dFByb3BzLmZhbGxiYWNrKSxcbiAgICAgICAgICAgICAgICAobmV4dEluc3RhbmNlID0gd29ya0luUHJvZ3Jlc3MubW9kZSksXG4gICAgICAgICAgICAgICAgKG5leHRQcm9wcyA9IG1vdW50V29ya0luUHJvZ3Jlc3NPZmZzY3JlZW5GaWJlcihcbiAgICAgICAgICAgICAgICAgIHsgbW9kZTogXCJ2aXNpYmxlXCIsIGNoaWxkcmVuOiBuZXh0UHJvcHMuY2hpbGRyZW4gfSxcbiAgICAgICAgICAgICAgICAgIG5leHRJbnN0YW5jZVxuICAgICAgICAgICAgICAgICkpLFxuICAgICAgICAgICAgICAgIChzaG93RmFsbGJhY2sgPSBjcmVhdGVGaWJlckZyb21GcmFnbWVudChcbiAgICAgICAgICAgICAgICAgIHNob3dGYWxsYmFjayxcbiAgICAgICAgICAgICAgICAgIG5leHRJbnN0YW5jZSxcbiAgICAgICAgICAgICAgICAgIHJlbmRlckxhbmVzLFxuICAgICAgICAgICAgICAgICAgbnVsbFxuICAgICAgICAgICAgICAgICkpLFxuICAgICAgICAgICAgICAgIChzaG93RmFsbGJhY2suZmxhZ3MgfD0gMiksXG4gICAgICAgICAgICAgICAgKG5leHRQcm9wcy5yZXR1cm4gPSB3b3JrSW5Qcm9ncmVzcyksXG4gICAgICAgICAgICAgICAgKHNob3dGYWxsYmFjay5yZXR1cm4gPSB3b3JrSW5Qcm9ncmVzcyksXG4gICAgICAgICAgICAgICAgKG5leHRQcm9wcy5zaWJsaW5nID0gc2hvd0ZhbGxiYWNrKSxcbiAgICAgICAgICAgICAgICAod29ya0luUHJvZ3Jlc3MuY2hpbGQgPSBuZXh0UHJvcHMpLFxuICAgICAgICAgICAgICAgIHJlY29uY2lsZUNoaWxkRmliZXJzKFxuICAgICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gICAgICAgICAgICAgICAgICBjdXJyZW50LmNoaWxkLFxuICAgICAgICAgICAgICAgICAgbnVsbCxcbiAgICAgICAgICAgICAgICAgIHJlbmRlckxhbmVzXG4gICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICAobmV4dFByb3BzID0gd29ya0luUHJvZ3Jlc3MuY2hpbGQpLFxuICAgICAgICAgICAgICAgIChuZXh0UHJvcHMubWVtb2l6ZWRTdGF0ZSA9XG4gICAgICAgICAgICAgICAgICBtb3VudFN1c3BlbnNlT2Zmc2NyZWVuU3RhdGUocmVuZGVyTGFuZXMpKSxcbiAgICAgICAgICAgICAgICAobmV4dFByb3BzLmNoaWxkTGFuZXMgPSBnZXRSZW1haW5pbmdXb3JrSW5QcmltYXJ5VHJlZShcbiAgICAgICAgICAgICAgICAgIGN1cnJlbnQsXG4gICAgICAgICAgICAgICAgICBKU0NvbXBpbGVyX3RlbXAsXG4gICAgICAgICAgICAgICAgICByZW5kZXJMYW5lc1xuICAgICAgICAgICAgICAgICkpLFxuICAgICAgICAgICAgICAgICh3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlID0gU1VTUEVOREVEX01BUktFUiksXG4gICAgICAgICAgICAgICAgKHdvcmtJblByb2dyZXNzID0gc2hvd0ZhbGxiYWNrKSk7XG4gICAgICAgIGVsc2UgaWYgKFxuICAgICAgICAgIChwdXNoUHJpbWFyeVRyZWVTdXNwZW5zZUhhbmRsZXIod29ya0luUHJvZ3Jlc3MpLFxuICAgICAgICAgIGlzSHlkcmF0aW5nICYmXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICBcIldlIHNob3VsZCBub3QgYmUgaHlkcmF0aW5nIGhlcmUuIFRoaXMgaXMgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGEgYnVnLlwiXG4gICAgICAgICAgICApLFxuICAgICAgICAgIGlzU3VzcGVuc2VJbnN0YW5jZUZhbGxiYWNrKG5leHRJbnN0YW5jZSkpXG4gICAgICAgIClcbiAgICAgICAgICAobmV4dEluc3RhbmNlID1cbiAgICAgICAgICAgIGdldFN1c3BlbnNlSW5zdGFuY2VGYWxsYmFja0Vycm9yRGV0YWlscyhuZXh0SW5zdGFuY2UpKSxcbiAgICAgICAgICAgIChKU0NvbXBpbGVyX3RlbXAgPSBuZXh0SW5zdGFuY2UuZGlnZXN0KSxcbiAgICAgICAgICAgIChzaG93RmFsbGJhY2sgPSBuZXh0SW5zdGFuY2UubWVzc2FnZSksXG4gICAgICAgICAgICAobmV4dFByb3BzID0gbmV4dEluc3RhbmNlLnN0YWNrKSxcbiAgICAgICAgICAgIChuZXh0SW5zdGFuY2UgPSBuZXh0SW5zdGFuY2UuY29tcG9uZW50U3RhY2spLFxuICAgICAgICAgICAgKHNob3dGYWxsYmFjayA9IHNob3dGYWxsYmFja1xuICAgICAgICAgICAgICA/IEVycm9yKHNob3dGYWxsYmFjaylcbiAgICAgICAgICAgICAgOiBFcnJvcihcbiAgICAgICAgICAgICAgICAgIFwiVGhlIHNlcnZlciBjb3VsZCBub3QgZmluaXNoIHRoaXMgU3VzcGVuc2UgYm91bmRhcnksIGxpa2VseSBkdWUgdG8gYW4gZXJyb3IgZHVyaW5nIHNlcnZlciByZW5kZXJpbmcuIFN3aXRjaGVkIHRvIGNsaWVudCByZW5kZXJpbmcuXCJcbiAgICAgICAgICAgICAgICApKSxcbiAgICAgICAgICAgIChzaG93RmFsbGJhY2suc3RhY2sgPSBuZXh0UHJvcHMgfHwgXCJcIiksXG4gICAgICAgICAgICAoc2hvd0ZhbGxiYWNrLmRpZ2VzdCA9IEpTQ29tcGlsZXJfdGVtcCksXG4gICAgICAgICAgICAoSlNDb21waWxlcl90ZW1wID0gdm9pZCAwID09PSBuZXh0SW5zdGFuY2UgPyBudWxsIDogbmV4dEluc3RhbmNlKSxcbiAgICAgICAgICAgIChuZXh0UHJvcHMgPSB7XG4gICAgICAgICAgICAgIHZhbHVlOiBzaG93RmFsbGJhY2ssXG4gICAgICAgICAgICAgIHNvdXJjZTogbnVsbCxcbiAgICAgICAgICAgICAgc3RhY2s6IEpTQ29tcGlsZXJfdGVtcFxuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICBcInN0cmluZ1wiID09PSB0eXBlb2YgSlNDb21waWxlcl90ZW1wICYmXG4gICAgICAgICAgICAgIENhcHR1cmVkU3RhY2tzLnNldChzaG93RmFsbGJhY2ssIG5leHRQcm9wcyksXG4gICAgICAgICAgICBxdWV1ZUh5ZHJhdGlvbkVycm9yKG5leHRQcm9wcyksXG4gICAgICAgICAgICAod29ya0luUHJvZ3Jlc3MgPSByZXRyeVN1c3BlbnNlQ29tcG9uZW50V2l0aG91dEh5ZHJhdGluZyhcbiAgICAgICAgICAgICAgY3VycmVudCxcbiAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gICAgICAgICAgICAgIHJlbmRlckxhbmVzXG4gICAgICAgICAgICApKTtcbiAgICAgICAgZWxzZSBpZiAoXG4gICAgICAgICAgKGRpZFJlY2VpdmVVcGRhdGUgfHxcbiAgICAgICAgICAgIHByb3BhZ2F0ZVBhcmVudENvbnRleHRDaGFuZ2VzKFxuICAgICAgICAgICAgICBjdXJyZW50LFxuICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgICAgICAgICAgICAgcmVuZGVyTGFuZXMsXG4gICAgICAgICAgICAgICExXG4gICAgICAgICAgICApLFxuICAgICAgICAgIChKU0NvbXBpbGVyX3RlbXAgPSAwICE9PSAocmVuZGVyTGFuZXMgJiBjdXJyZW50LmNoaWxkTGFuZXMpKSxcbiAgICAgICAgICBkaWRSZWNlaXZlVXBkYXRlIHx8IEpTQ29tcGlsZXJfdGVtcClcbiAgICAgICAgKSB7XG4gICAgICAgICAgSlNDb21waWxlcl90ZW1wID0gd29ya0luUHJvZ3Jlc3NSb290O1xuICAgICAgICAgIGlmIChudWxsICE9PSBKU0NvbXBpbGVyX3RlbXApIHtcbiAgICAgICAgICAgIG5leHRQcm9wcyA9IHJlbmRlckxhbmVzICYgLXJlbmRlckxhbmVzO1xuICAgICAgICAgICAgaWYgKDAgIT09IChuZXh0UHJvcHMgJiA0MikpIG5leHRQcm9wcyA9IDE7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgIHN3aXRjaCAobmV4dFByb3BzKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgbmV4dFByb3BzID0gMTtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgODpcbiAgICAgICAgICAgICAgICAgIG5leHRQcm9wcyA9IDQ7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDMyOlxuICAgICAgICAgICAgICAgICAgbmV4dFByb3BzID0gMTY7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDEyODpcbiAgICAgICAgICAgICAgICBjYXNlIDI1NjpcbiAgICAgICAgICAgICAgICBjYXNlIDUxMjpcbiAgICAgICAgICAgICAgICBjYXNlIDEwMjQ6XG4gICAgICAgICAgICAgICAgY2FzZSAyMDQ4OlxuICAgICAgICAgICAgICAgIGNhc2UgNDA5NjpcbiAgICAgICAgICAgICAgICBjYXNlIDgxOTI6XG4gICAgICAgICAgICAgICAgY2FzZSAxNjM4NDpcbiAgICAgICAgICAgICAgICBjYXNlIDMyNzY4OlxuICAgICAgICAgICAgICAgIGNhc2UgNjU1MzY6XG4gICAgICAgICAgICAgICAgY2FzZSAxMzEwNzI6XG4gICAgICAgICAgICAgICAgY2FzZSAyNjIxNDQ6XG4gICAgICAgICAgICAgICAgY2FzZSA1MjQyODg6XG4gICAgICAgICAgICAgICAgY2FzZSAxMDQ4NTc2OlxuICAgICAgICAgICAgICAgIGNhc2UgMjA5NzE1MjpcbiAgICAgICAgICAgICAgICBjYXNlIDQxOTQzMDQ6XG4gICAgICAgICAgICAgICAgY2FzZSA4Mzg4NjA4OlxuICAgICAgICAgICAgICAgIGNhc2UgMTY3NzcyMTY6XG4gICAgICAgICAgICAgICAgY2FzZSAzMzU1NDQzMjpcbiAgICAgICAgICAgICAgICAgIG5leHRQcm9wcyA9IDY0O1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAyNjg0MzU0NTY6XG4gICAgICAgICAgICAgICAgICBuZXh0UHJvcHMgPSAxMzQyMTc3Mjg7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgbmV4dFByb3BzID0gMDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgbmV4dFByb3BzID1cbiAgICAgICAgICAgICAgMCAhPT0gKG5leHRQcm9wcyAmIChKU0NvbXBpbGVyX3RlbXAuc3VzcGVuZGVkTGFuZXMgfCByZW5kZXJMYW5lcykpXG4gICAgICAgICAgICAgICAgPyAwXG4gICAgICAgICAgICAgICAgOiBuZXh0UHJvcHM7XG4gICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgIDAgIT09IG5leHRQcm9wcyAmJlxuICAgICAgICAgICAgICBuZXh0UHJvcHMgIT09IEpTQ29tcGlsZXJfdGVtcCRqc2NvbXAkMC5yZXRyeUxhbmVcbiAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgdGhyb3cgKFxuICAgICAgICAgICAgICAgICgoSlNDb21waWxlcl90ZW1wJGpzY29tcCQwLnJldHJ5TGFuZSA9IG5leHRQcm9wcyksXG4gICAgICAgICAgICAgICAgZW5xdWV1ZUNvbmN1cnJlbnRSZW5kZXJGb3JMYW5lKGN1cnJlbnQsIG5leHRQcm9wcyksXG4gICAgICAgICAgICAgICAgc2NoZWR1bGVVcGRhdGVPbkZpYmVyKEpTQ29tcGlsZXJfdGVtcCwgY3VycmVudCwgbmV4dFByb3BzKSxcbiAgICAgICAgICAgICAgICBTZWxlY3RpdmVIeWRyYXRpb25FeGNlcHRpb24pXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlzU3VzcGVuc2VJbnN0YW5jZVBlbmRpbmcobmV4dEluc3RhbmNlKSB8fFxuICAgICAgICAgICAgcmVuZGVyRGlkU3VzcGVuZERlbGF5SWZQb3NzaWJsZSgpO1xuICAgICAgICAgIHdvcmtJblByb2dyZXNzID0gcmV0cnlTdXNwZW5zZUNvbXBvbmVudFdpdGhvdXRIeWRyYXRpbmcoXG4gICAgICAgICAgICBjdXJyZW50LFxuICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gICAgICAgICAgICByZW5kZXJMYW5lc1xuICAgICAgICAgICk7XG4gICAgICAgIH0gZWxzZVxuICAgICAgICAgIGlzU3VzcGVuc2VJbnN0YW5jZVBlbmRpbmcobmV4dEluc3RhbmNlKVxuICAgICAgICAgICAgPyAoKHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IDEyOCksXG4gICAgICAgICAgICAgICh3b3JrSW5Qcm9ncmVzcy5jaGlsZCA9IGN1cnJlbnQuY2hpbGQpLFxuICAgICAgICAgICAgICAod29ya0luUHJvZ3Jlc3MgPSByZXRyeURlaHlkcmF0ZWRTdXNwZW5zZUJvdW5kYXJ5LmJpbmQoXG4gICAgICAgICAgICAgICAgbnVsbCxcbiAgICAgICAgICAgICAgICBjdXJyZW50XG4gICAgICAgICAgICAgICkpLFxuICAgICAgICAgICAgICByZWdpc3RlclN1c3BlbnNlSW5zdGFuY2VSZXRyeShuZXh0SW5zdGFuY2UsIHdvcmtJblByb2dyZXNzKSxcbiAgICAgICAgICAgICAgKHdvcmtJblByb2dyZXNzID0gbnVsbCkpXG4gICAgICAgICAgICA6ICgoY3VycmVudCA9IEpTQ29tcGlsZXJfdGVtcCRqc2NvbXAkMC50cmVlQ29udGV4dCksXG4gICAgICAgICAgICAgIHN1cHBvcnRzSHlkcmF0aW9uICYmXG4gICAgICAgICAgICAgICAgKChuZXh0SHlkcmF0YWJsZUluc3RhbmNlID1cbiAgICAgICAgICAgICAgICAgIGdldEZpcnN0SHlkcmF0YWJsZUNoaWxkV2l0aGluU3VzcGVuc2VJbnN0YW5jZShuZXh0SW5zdGFuY2UpKSxcbiAgICAgICAgICAgICAgICAoaHlkcmF0aW9uUGFyZW50RmliZXIgPSB3b3JrSW5Qcm9ncmVzcyksXG4gICAgICAgICAgICAgICAgKGlzSHlkcmF0aW5nID0gITApLFxuICAgICAgICAgICAgICAgIChoeWRyYXRpb25FcnJvcnMgPSBudWxsKSxcbiAgICAgICAgICAgICAgICAoZGlkU3VzcGVuZE9yRXJyb3JERVYgPSAhMSksXG4gICAgICAgICAgICAgICAgKGh5ZHJhdGlvbkRpZmZSb290REVWID0gbnVsbCksXG4gICAgICAgICAgICAgICAgKHJvb3RPclNpbmdsZXRvbkNvbnRleHQgPSAhMSksXG4gICAgICAgICAgICAgICAgbnVsbCAhPT0gY3VycmVudCAmJlxuICAgICAgICAgICAgICAgICAgKHdhcm5JZk5vdEh5ZHJhdGluZygpLFxuICAgICAgICAgICAgICAgICAgKGlkU3RhY2tbaWRTdGFja0luZGV4KytdID0gdHJlZUNvbnRleHRJZCksXG4gICAgICAgICAgICAgICAgICAoaWRTdGFja1tpZFN0YWNrSW5kZXgrK10gPSB0cmVlQ29udGV4dE92ZXJmbG93KSxcbiAgICAgICAgICAgICAgICAgIChpZFN0YWNrW2lkU3RhY2tJbmRleCsrXSA9IHRyZWVDb250ZXh0UHJvdmlkZXIpLFxuICAgICAgICAgICAgICAgICAgKHRyZWVDb250ZXh0SWQgPSBjdXJyZW50LmlkKSxcbiAgICAgICAgICAgICAgICAgICh0cmVlQ29udGV4dE92ZXJmbG93ID0gY3VycmVudC5vdmVyZmxvdyksXG4gICAgICAgICAgICAgICAgICAodHJlZUNvbnRleHRQcm92aWRlciA9IHdvcmtJblByb2dyZXNzKSkpLFxuICAgICAgICAgICAgICAod29ya0luUHJvZ3Jlc3MgPSBtb3VudFN1c3BlbnNlUHJpbWFyeUNoaWxkcmVuKFxuICAgICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLFxuICAgICAgICAgICAgICAgIG5leHRQcm9wcy5jaGlsZHJlblxuICAgICAgICAgICAgICApKSxcbiAgICAgICAgICAgICAgKHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IDQwOTYpKTtcbiAgICAgICAgcmV0dXJuIHdvcmtJblByb2dyZXNzO1xuICAgICAgfVxuICAgICAgaWYgKHNob3dGYWxsYmFjaylcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICByZXVzZVN1c3BlbnNlSGFuZGxlck9uU3RhY2sod29ya0luUHJvZ3Jlc3MpLFxuICAgICAgICAgIChzaG93RmFsbGJhY2sgPSBuZXh0UHJvcHMuZmFsbGJhY2spLFxuICAgICAgICAgIChuZXh0SW5zdGFuY2UgPSB3b3JrSW5Qcm9ncmVzcy5tb2RlKSxcbiAgICAgICAgICAoSlNDb21waWxlcl90ZW1wJGpzY29tcCQwID0gY3VycmVudC5jaGlsZCksXG4gICAgICAgICAgKGRpZFN1c3BlbmQgPSBKU0NvbXBpbGVyX3RlbXAkanNjb21wJDAuc2libGluZyksXG4gICAgICAgICAgKG5leHRQcm9wcyA9IGNyZWF0ZVdvcmtJblByb2dyZXNzKEpTQ29tcGlsZXJfdGVtcCRqc2NvbXAkMCwge1xuICAgICAgICAgICAgbW9kZTogXCJoaWRkZW5cIixcbiAgICAgICAgICAgIGNoaWxkcmVuOiBuZXh0UHJvcHMuY2hpbGRyZW5cbiAgICAgICAgICB9KSksXG4gICAgICAgICAgKG5leHRQcm9wcy5zdWJ0cmVlRmxhZ3MgPVxuICAgICAgICAgICAgSlNDb21waWxlcl90ZW1wJGpzY29tcCQwLnN1YnRyZWVGbGFncyAmIDMxNDU3MjgwKSxcbiAgICAgICAgICBudWxsICE9PSBkaWRTdXNwZW5kXG4gICAgICAgICAgICA/IChzaG93RmFsbGJhY2sgPSBjcmVhdGVXb3JrSW5Qcm9ncmVzcyhkaWRTdXNwZW5kLCBzaG93RmFsbGJhY2spKVxuICAgICAgICAgICAgOiAoKHNob3dGYWxsYmFjayA9IGNyZWF0ZUZpYmVyRnJvbUZyYWdtZW50KFxuICAgICAgICAgICAgICAgIHNob3dGYWxsYmFjayxcbiAgICAgICAgICAgICAgICBuZXh0SW5zdGFuY2UsXG4gICAgICAgICAgICAgICAgcmVuZGVyTGFuZXMsXG4gICAgICAgICAgICAgICAgbnVsbFxuICAgICAgICAgICAgICApKSxcbiAgICAgICAgICAgICAgKHNob3dGYWxsYmFjay5mbGFncyB8PSAyKSksXG4gICAgICAgICAgKHNob3dGYWxsYmFjay5yZXR1cm4gPSB3b3JrSW5Qcm9ncmVzcyksXG4gICAgICAgICAgKG5leHRQcm9wcy5yZXR1cm4gPSB3b3JrSW5Qcm9ncmVzcyksXG4gICAgICAgICAgKG5leHRQcm9wcy5zaWJsaW5nID0gc2hvd0ZhbGxiYWNrKSxcbiAgICAgICAgICAod29ya0luUHJvZ3Jlc3MuY2hpbGQgPSBuZXh0UHJvcHMpLFxuICAgICAgICAgIChuZXh0UHJvcHMgPSBzaG93RmFsbGJhY2spLFxuICAgICAgICAgIChzaG93RmFsbGJhY2sgPSB3b3JrSW5Qcm9ncmVzcy5jaGlsZCksXG4gICAgICAgICAgKG5leHRJbnN0YW5jZSA9IGN1cnJlbnQuY2hpbGQubWVtb2l6ZWRTdGF0ZSksXG4gICAgICAgICAgbnVsbCA9PT0gbmV4dEluc3RhbmNlXG4gICAgICAgICAgICA/IChuZXh0SW5zdGFuY2UgPSBtb3VudFN1c3BlbnNlT2Zmc2NyZWVuU3RhdGUocmVuZGVyTGFuZXMpKVxuICAgICAgICAgICAgOiAoKEpTQ29tcGlsZXJfdGVtcCRqc2NvbXAkMCA9IG5leHRJbnN0YW5jZS5jYWNoZVBvb2wpLFxuICAgICAgICAgICAgICBudWxsICE9PSBKU0NvbXBpbGVyX3RlbXAkanNjb21wJDBcbiAgICAgICAgICAgICAgICA/ICgoZGlkU3VzcGVuZCA9IGlzUHJpbWFyeVJlbmRlcmVyXG4gICAgICAgICAgICAgICAgICAgID8gQ2FjaGVDb250ZXh0Ll9jdXJyZW50VmFsdWVcbiAgICAgICAgICAgICAgICAgICAgOiBDYWNoZUNvbnRleHQuX2N1cnJlbnRWYWx1ZTIpLFxuICAgICAgICAgICAgICAgICAgKEpTQ29tcGlsZXJfdGVtcCRqc2NvbXAkMCA9XG4gICAgICAgICAgICAgICAgICAgIEpTQ29tcGlsZXJfdGVtcCRqc2NvbXAkMC5wYXJlbnQgIT09IGRpZFN1c3BlbmRcbiAgICAgICAgICAgICAgICAgICAgICA/IHsgcGFyZW50OiBkaWRTdXNwZW5kLCBwb29sOiBkaWRTdXNwZW5kIH1cbiAgICAgICAgICAgICAgICAgICAgICA6IEpTQ29tcGlsZXJfdGVtcCRqc2NvbXAkMCkpXG4gICAgICAgICAgICAgICAgOiAoSlNDb21waWxlcl90ZW1wJGpzY29tcCQwID0gZ2V0U3VzcGVuZGVkQ2FjaGUoKSksXG4gICAgICAgICAgICAgIChuZXh0SW5zdGFuY2UgPSB7XG4gICAgICAgICAgICAgICAgYmFzZUxhbmVzOiBuZXh0SW5zdGFuY2UuYmFzZUxhbmVzIHwgcmVuZGVyTGFuZXMsXG4gICAgICAgICAgICAgICAgY2FjaGVQb29sOiBKU0NvbXBpbGVyX3RlbXAkanNjb21wJDBcbiAgICAgICAgICAgICAgfSkpLFxuICAgICAgICAgIChzaG93RmFsbGJhY2subWVtb2l6ZWRTdGF0ZSA9IG5leHRJbnN0YW5jZSksXG4gICAgICAgICAgKHNob3dGYWxsYmFjay5jaGlsZExhbmVzID0gZ2V0UmVtYWluaW5nV29ya0luUHJpbWFyeVRyZWUoXG4gICAgICAgICAgICBjdXJyZW50LFxuICAgICAgICAgICAgSlNDb21waWxlcl90ZW1wLFxuICAgICAgICAgICAgcmVuZGVyTGFuZXNcbiAgICAgICAgICApKSxcbiAgICAgICAgICAod29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZSA9IFNVU1BFTkRFRF9NQVJLRVIpLFxuICAgICAgICAgIG5leHRQcm9wc1xuICAgICAgICApO1xuICAgICAgcHVzaFByaW1hcnlUcmVlU3VzcGVuc2VIYW5kbGVyKHdvcmtJblByb2dyZXNzKTtcbiAgICAgIHJlbmRlckxhbmVzID0gY3VycmVudC5jaGlsZDtcbiAgICAgIGN1cnJlbnQgPSByZW5kZXJMYW5lcy5zaWJsaW5nO1xuICAgICAgcmVuZGVyTGFuZXMgPSBjcmVhdGVXb3JrSW5Qcm9ncmVzcyhyZW5kZXJMYW5lcywge1xuICAgICAgICBtb2RlOiBcInZpc2libGVcIixcbiAgICAgICAgY2hpbGRyZW46IG5leHRQcm9wcy5jaGlsZHJlblxuICAgICAgfSk7XG4gICAgICByZW5kZXJMYW5lcy5yZXR1cm4gPSB3b3JrSW5Qcm9ncmVzcztcbiAgICAgIHJlbmRlckxhbmVzLnNpYmxpbmcgPSBudWxsO1xuICAgICAgbnVsbCAhPT0gY3VycmVudCAmJlxuICAgICAgICAoKEpTQ29tcGlsZXJfdGVtcCA9IHdvcmtJblByb2dyZXNzLmRlbGV0aW9ucyksXG4gICAgICAgIG51bGwgPT09IEpTQ29tcGlsZXJfdGVtcFxuICAgICAgICAgID8gKCh3b3JrSW5Qcm9ncmVzcy5kZWxldGlvbnMgPSBbY3VycmVudF0pLFxuICAgICAgICAgICAgKHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IDE2KSlcbiAgICAgICAgICA6IEpTQ29tcGlsZXJfdGVtcC5wdXNoKGN1cnJlbnQpKTtcbiAgICAgIHdvcmtJblByb2dyZXNzLmNoaWxkID0gcmVuZGVyTGFuZXM7XG4gICAgICB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlID0gbnVsbDtcbiAgICAgIHJldHVybiByZW5kZXJMYW5lcztcbiAgICB9XG4gICAgZnVuY3Rpb24gbW91bnRTdXNwZW5zZVByaW1hcnlDaGlsZHJlbih3b3JrSW5Qcm9ncmVzcywgcHJpbWFyeUNoaWxkcmVuKSB7XG4gICAgICBwcmltYXJ5Q2hpbGRyZW4gPSBtb3VudFdvcmtJblByb2dyZXNzT2Zmc2NyZWVuRmliZXIoXG4gICAgICAgIHsgbW9kZTogXCJ2aXNpYmxlXCIsIGNoaWxkcmVuOiBwcmltYXJ5Q2hpbGRyZW4gfSxcbiAgICAgICAgd29ya0luUHJvZ3Jlc3MubW9kZVxuICAgICAgKTtcbiAgICAgIHByaW1hcnlDaGlsZHJlbi5yZXR1cm4gPSB3b3JrSW5Qcm9ncmVzcztcbiAgICAgIHJldHVybiAod29ya0luUHJvZ3Jlc3MuY2hpbGQgPSBwcmltYXJ5Q2hpbGRyZW4pO1xuICAgIH1cbiAgICBmdW5jdGlvbiBtb3VudFdvcmtJblByb2dyZXNzT2Zmc2NyZWVuRmliZXIob2Zmc2NyZWVuUHJvcHMsIG1vZGUpIHtcbiAgICAgIHJldHVybiBjcmVhdGVGaWJlckZyb21PZmZzY3JlZW4ob2Zmc2NyZWVuUHJvcHMsIG1vZGUsIDAsIG51bGwpO1xuICAgIH1cbiAgICBmdW5jdGlvbiByZXRyeVN1c3BlbnNlQ29tcG9uZW50V2l0aG91dEh5ZHJhdGluZyhcbiAgICAgIGN1cnJlbnQsXG4gICAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgICAgIHJlbmRlckxhbmVzXG4gICAgKSB7XG4gICAgICByZWNvbmNpbGVDaGlsZEZpYmVycyh3b3JrSW5Qcm9ncmVzcywgY3VycmVudC5jaGlsZCwgbnVsbCwgcmVuZGVyTGFuZXMpO1xuICAgICAgY3VycmVudCA9IG1vdW50U3VzcGVuc2VQcmltYXJ5Q2hpbGRyZW4oXG4gICAgICAgIHdvcmtJblByb2dyZXNzLFxuICAgICAgICB3b3JrSW5Qcm9ncmVzcy5wZW5kaW5nUHJvcHMuY2hpbGRyZW5cbiAgICAgICk7XG4gICAgICBjdXJyZW50LmZsYWdzIHw9IDI7XG4gICAgICB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlID0gbnVsbDtcbiAgICAgIHJldHVybiBjdXJyZW50O1xuICAgIH1cbiAgICBmdW5jdGlvbiBzY2hlZHVsZVN1c3BlbnNlV29ya09uRmliZXIoZmliZXIsIHJlbmRlckxhbmVzLCBwcm9wYWdhdGlvblJvb3QpIHtcbiAgICAgIGZpYmVyLmxhbmVzIHw9IHJlbmRlckxhbmVzO1xuICAgICAgdmFyIGFsdGVybmF0ZSA9IGZpYmVyLmFsdGVybmF0ZTtcbiAgICAgIG51bGwgIT09IGFsdGVybmF0ZSAmJiAoYWx0ZXJuYXRlLmxhbmVzIHw9IHJlbmRlckxhbmVzKTtcbiAgICAgIHNjaGVkdWxlQ29udGV4dFdvcmtPblBhcmVudFBhdGgoXG4gICAgICAgIGZpYmVyLnJldHVybixcbiAgICAgICAgcmVuZGVyTGFuZXMsXG4gICAgICAgIHByb3BhZ2F0aW9uUm9vdFxuICAgICAgKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gdmFsaWRhdGVTdXNwZW5zZUxpc3ROZXN0ZWRDaGlsZChjaGlsZFNsb3QsIGluZGV4KSB7XG4gICAgICB2YXIgaXNBbkFycmF5ID0gaXNBcnJheUltcGwoY2hpbGRTbG90KTtcbiAgICAgIGNoaWxkU2xvdCA9ICFpc0FuQXJyYXkgJiYgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgZ2V0SXRlcmF0b3JGbihjaGlsZFNsb3QpO1xuICAgICAgcmV0dXJuIGlzQW5BcnJheSB8fCBjaGlsZFNsb3RcbiAgICAgICAgPyAoKGlzQW5BcnJheSA9IGlzQW5BcnJheSA/IFwiYXJyYXlcIiA6IFwiaXRlcmFibGVcIiksXG4gICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgIFwiQSBuZXN0ZWQgJXMgd2FzIHBhc3NlZCB0byByb3cgIyVzIGluIDxTdXNwZW5zZUxpc3QgLz4uIFdyYXAgaXQgaW4gYW4gYWRkaXRpb25hbCBTdXNwZW5zZUxpc3QgdG8gY29uZmlndXJlIGl0cyByZXZlYWxPcmRlcjogPFN1c3BlbnNlTGlzdCByZXZlYWxPcmRlcj0uLi4+IC4uLiA8U3VzcGVuc2VMaXN0IHJldmVhbE9yZGVyPS4uLj57JXN9PC9TdXNwZW5zZUxpc3Q+IC4uLiA8L1N1c3BlbnNlTGlzdD5cIixcbiAgICAgICAgICAgIGlzQW5BcnJheSxcbiAgICAgICAgICAgIGluZGV4LFxuICAgICAgICAgICAgaXNBbkFycmF5XG4gICAgICAgICAgKSxcbiAgICAgICAgICAhMSlcbiAgICAgICAgOiAhMDtcbiAgICB9XG4gICAgZnVuY3Rpb24gaW5pdFN1c3BlbnNlTGlzdFJlbmRlclN0YXRlKFxuICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gICAgICBpc0JhY2t3YXJkcyxcbiAgICAgIHRhaWwsXG4gICAgICBsYXN0Q29udGVudFJvdyxcbiAgICAgIHRhaWxNb2RlXG4gICAgKSB7XG4gICAgICB2YXIgcmVuZGVyU3RhdGUgPSB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlO1xuICAgICAgbnVsbCA9PT0gcmVuZGVyU3RhdGVcbiAgICAgICAgPyAod29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZSA9IHtcbiAgICAgICAgICAgIGlzQmFja3dhcmRzOiBpc0JhY2t3YXJkcyxcbiAgICAgICAgICAgIHJlbmRlcmluZzogbnVsbCxcbiAgICAgICAgICAgIHJlbmRlcmluZ1N0YXJ0VGltZTogMCxcbiAgICAgICAgICAgIGxhc3Q6IGxhc3RDb250ZW50Um93LFxuICAgICAgICAgICAgdGFpbDogdGFpbCxcbiAgICAgICAgICAgIHRhaWxNb2RlOiB0YWlsTW9kZVxuICAgICAgICAgIH0pXG4gICAgICAgIDogKChyZW5kZXJTdGF0ZS5pc0JhY2t3YXJkcyA9IGlzQmFja3dhcmRzKSxcbiAgICAgICAgICAocmVuZGVyU3RhdGUucmVuZGVyaW5nID0gbnVsbCksXG4gICAgICAgICAgKHJlbmRlclN0YXRlLnJlbmRlcmluZ1N0YXJ0VGltZSA9IDApLFxuICAgICAgICAgIChyZW5kZXJTdGF0ZS5sYXN0ID0gbGFzdENvbnRlbnRSb3cpLFxuICAgICAgICAgIChyZW5kZXJTdGF0ZS50YWlsID0gdGFpbCksXG4gICAgICAgICAgKHJlbmRlclN0YXRlLnRhaWxNb2RlID0gdGFpbE1vZGUpKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gdXBkYXRlU3VzcGVuc2VMaXN0Q29tcG9uZW50KGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCByZW5kZXJMYW5lcykge1xuICAgICAgdmFyIG5leHRQcm9wcyA9IHdvcmtJblByb2dyZXNzLnBlbmRpbmdQcm9wcyxcbiAgICAgICAgcmV2ZWFsT3JkZXIgPSBuZXh0UHJvcHMucmV2ZWFsT3JkZXIsXG4gICAgICAgIHRhaWxNb2RlID0gbmV4dFByb3BzLnRhaWw7XG4gICAgICBuZXh0UHJvcHMgPSBuZXh0UHJvcHMuY2hpbGRyZW47XG4gICAgICBpZiAoXG4gICAgICAgIHZvaWQgMCAhPT0gcmV2ZWFsT3JkZXIgJiZcbiAgICAgICAgXCJmb3J3YXJkc1wiICE9PSByZXZlYWxPcmRlciAmJlxuICAgICAgICBcImJhY2t3YXJkc1wiICE9PSByZXZlYWxPcmRlciAmJlxuICAgICAgICBcInRvZ2V0aGVyXCIgIT09IHJldmVhbE9yZGVyICYmXG4gICAgICAgICFkaWRXYXJuQWJvdXRSZXZlYWxPcmRlcltyZXZlYWxPcmRlcl1cbiAgICAgIClcbiAgICAgICAgaWYgKFxuICAgICAgICAgICgoZGlkV2FybkFib3V0UmV2ZWFsT3JkZXJbcmV2ZWFsT3JkZXJdID0gITApLFxuICAgICAgICAgIFwic3RyaW5nXCIgPT09IHR5cGVvZiByZXZlYWxPcmRlcilcbiAgICAgICAgKVxuICAgICAgICAgIHN3aXRjaCAocmV2ZWFsT3JkZXIudG9Mb3dlckNhc2UoKSkge1xuICAgICAgICAgICAgY2FzZSBcInRvZ2V0aGVyXCI6XG4gICAgICAgICAgICBjYXNlIFwiZm9yd2FyZHNcIjpcbiAgICAgICAgICAgIGNhc2UgXCJiYWNrd2FyZHNcIjpcbiAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgICAnXCIlc1wiIGlzIG5vdCBhIHZhbGlkIHZhbHVlIGZvciByZXZlYWxPcmRlciBvbiA8U3VzcGVuc2VMaXN0IC8+LiBVc2UgbG93ZXJjYXNlIFwiJXNcIiBpbnN0ZWFkLicsXG4gICAgICAgICAgICAgICAgcmV2ZWFsT3JkZXIsXG4gICAgICAgICAgICAgICAgcmV2ZWFsT3JkZXIudG9Mb3dlckNhc2UoKVxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJmb3J3YXJkXCI6XG4gICAgICAgICAgICBjYXNlIFwiYmFja3dhcmRcIjpcbiAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgICAnXCIlc1wiIGlzIG5vdCBhIHZhbGlkIHZhbHVlIGZvciByZXZlYWxPcmRlciBvbiA8U3VzcGVuc2VMaXN0IC8+LiBSZWFjdCB1c2VzIHRoZSAtcyBzdWZmaXggaW4gdGhlIHNwZWxsaW5nLiBVc2UgXCIlc3NcIiBpbnN0ZWFkLicsXG4gICAgICAgICAgICAgICAgcmV2ZWFsT3JkZXIsXG4gICAgICAgICAgICAgICAgcmV2ZWFsT3JkZXIudG9Mb3dlckNhc2UoKVxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgICAgJ1wiJXNcIiBpcyBub3QgYSBzdXBwb3J0ZWQgcmV2ZWFsT3JkZXIgb24gPFN1c3BlbnNlTGlzdCAvPi4gRGlkIHlvdSBtZWFuIFwidG9nZXRoZXJcIiwgXCJmb3J3YXJkc1wiIG9yIFwiYmFja3dhcmRzXCI/JyxcbiAgICAgICAgICAgICAgICByZXZlYWxPcmRlclxuICAgICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgZWxzZVxuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAnJXMgaXMgbm90IGEgc3VwcG9ydGVkIHZhbHVlIGZvciByZXZlYWxPcmRlciBvbiA8U3VzcGVuc2VMaXN0IC8+LiBEaWQgeW91IG1lYW4gXCJ0b2dldGhlclwiLCBcImZvcndhcmRzXCIgb3IgXCJiYWNrd2FyZHNcIj8nLFxuICAgICAgICAgICAgcmV2ZWFsT3JkZXJcbiAgICAgICAgICApO1xuICAgICAgdm9pZCAwID09PSB0YWlsTW9kZSB8fFxuICAgICAgICBkaWRXYXJuQWJvdXRUYWlsT3B0aW9uc1t0YWlsTW9kZV0gfHxcbiAgICAgICAgKFwiY29sbGFwc2VkXCIgIT09IHRhaWxNb2RlICYmIFwiaGlkZGVuXCIgIT09IHRhaWxNb2RlXG4gICAgICAgICAgPyAoKGRpZFdhcm5BYm91dFRhaWxPcHRpb25zW3RhaWxNb2RlXSA9ICEwKSxcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgICdcIiVzXCIgaXMgbm90IGEgc3VwcG9ydGVkIHZhbHVlIGZvciB0YWlsIG9uIDxTdXNwZW5zZUxpc3QgLz4uIERpZCB5b3UgbWVhbiBcImNvbGxhcHNlZFwiIG9yIFwiaGlkZGVuXCI/JyxcbiAgICAgICAgICAgICAgdGFpbE1vZGVcbiAgICAgICAgICAgICkpXG4gICAgICAgICAgOiBcImZvcndhcmRzXCIgIT09IHJldmVhbE9yZGVyICYmXG4gICAgICAgICAgICBcImJhY2t3YXJkc1wiICE9PSByZXZlYWxPcmRlciAmJlxuICAgICAgICAgICAgKChkaWRXYXJuQWJvdXRUYWlsT3B0aW9uc1t0YWlsTW9kZV0gPSAhMCksXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICAnPFN1c3BlbnNlTGlzdCB0YWlsPVwiJXNcIiAvPiBpcyBvbmx5IHZhbGlkIGlmIHJldmVhbE9yZGVyIGlzIFwiZm9yd2FyZHNcIiBvciBcImJhY2t3YXJkc1wiLiBEaWQgeW91IG1lYW4gdG8gc3BlY2lmeSByZXZlYWxPcmRlcj1cImZvcndhcmRzXCI/JyxcbiAgICAgICAgICAgICAgdGFpbE1vZGVcbiAgICAgICAgICAgICkpKTtcbiAgICAgIGE6IGlmIChcbiAgICAgICAgKFwiZm9yd2FyZHNcIiA9PT0gcmV2ZWFsT3JkZXIgfHwgXCJiYWNrd2FyZHNcIiA9PT0gcmV2ZWFsT3JkZXIpICYmXG4gICAgICAgIHZvaWQgMCAhPT0gbmV4dFByb3BzICYmXG4gICAgICAgIG51bGwgIT09IG5leHRQcm9wcyAmJlxuICAgICAgICAhMSAhPT0gbmV4dFByb3BzXG4gICAgICApXG4gICAgICAgIGlmIChpc0FycmF5SW1wbChuZXh0UHJvcHMpKVxuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbmV4dFByb3BzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoIXZhbGlkYXRlU3VzcGVuc2VMaXN0TmVzdGVkQ2hpbGQobmV4dFByb3BzW2ldLCBpKSkgYnJlYWsgYTtcbiAgICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCgoaSA9IGdldEl0ZXJhdG9yRm4obmV4dFByb3BzKSksIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIGkpKSB7XG4gICAgICAgICAgaWYgKChpID0gaS5jYWxsKG5leHRQcm9wcykpKVxuICAgICAgICAgICAgZm9yICh2YXIgc3RlcCA9IGkubmV4dCgpLCBfaSA9IDA7ICFzdGVwLmRvbmU7IHN0ZXAgPSBpLm5leHQoKSkge1xuICAgICAgICAgICAgICBpZiAoIXZhbGlkYXRlU3VzcGVuc2VMaXN0TmVzdGVkQ2hpbGQoc3RlcC52YWx1ZSwgX2kpKSBicmVhayBhO1xuICAgICAgICAgICAgICBfaSsrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2VcbiAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgJ0Egc2luZ2xlIHJvdyB3YXMgcGFzc2VkIHRvIGEgPFN1c3BlbnNlTGlzdCByZXZlYWxPcmRlcj1cIiVzXCIgLz4uIFRoaXMgaXMgbm90IHVzZWZ1bCBzaW5jZSBpdCBuZWVkcyBtdWx0aXBsZSByb3dzLiBEaWQgeW91IG1lYW4gdG8gcGFzcyBtdWx0aXBsZSBjaGlsZHJlbiBvciBhbiBhcnJheT8nLFxuICAgICAgICAgICAgcmV2ZWFsT3JkZXJcbiAgICAgICAgICApO1xuICAgICAgcmVjb25jaWxlQ2hpbGRyZW4oY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIG5leHRQcm9wcywgcmVuZGVyTGFuZXMpO1xuICAgICAgbmV4dFByb3BzID0gc3VzcGVuc2VTdGFja0N1cnNvci5jdXJyZW50O1xuICAgICAgaWYgKDAgIT09IChuZXh0UHJvcHMgJiBGb3JjZVN1c3BlbnNlRmFsbGJhY2spKVxuICAgICAgICAobmV4dFByb3BzID1cbiAgICAgICAgICAobmV4dFByb3BzICYgU3VidHJlZVN1c3BlbnNlQ29udGV4dE1hc2spIHwgRm9yY2VTdXNwZW5zZUZhbGxiYWNrKSxcbiAgICAgICAgICAod29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gMTI4KTtcbiAgICAgIGVsc2Uge1xuICAgICAgICBpZiAobnVsbCAhPT0gY3VycmVudCAmJiAwICE9PSAoY3VycmVudC5mbGFncyAmIDEyOCkpXG4gICAgICAgICAgYTogZm9yIChjdXJyZW50ID0gd29ya0luUHJvZ3Jlc3MuY2hpbGQ7IG51bGwgIT09IGN1cnJlbnQ7ICkge1xuICAgICAgICAgICAgaWYgKDEzID09PSBjdXJyZW50LnRhZylcbiAgICAgICAgICAgICAgbnVsbCAhPT0gY3VycmVudC5tZW1vaXplZFN0YXRlICYmXG4gICAgICAgICAgICAgICAgc2NoZWR1bGVTdXNwZW5zZVdvcmtPbkZpYmVyKFxuICAgICAgICAgICAgICAgICAgY3VycmVudCxcbiAgICAgICAgICAgICAgICAgIHJlbmRlckxhbmVzLFxuICAgICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3NcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgZWxzZSBpZiAoMTkgPT09IGN1cnJlbnQudGFnKVxuICAgICAgICAgICAgICBzY2hlZHVsZVN1c3BlbnNlV29ya09uRmliZXIoY3VycmVudCwgcmVuZGVyTGFuZXMsIHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgICAgIGVsc2UgaWYgKG51bGwgIT09IGN1cnJlbnQuY2hpbGQpIHtcbiAgICAgICAgICAgICAgY3VycmVudC5jaGlsZC5yZXR1cm4gPSBjdXJyZW50O1xuICAgICAgICAgICAgICBjdXJyZW50ID0gY3VycmVudC5jaGlsZDtcbiAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY3VycmVudCA9PT0gd29ya0luUHJvZ3Jlc3MpIGJyZWFrIGE7XG4gICAgICAgICAgICBmb3IgKDsgbnVsbCA9PT0gY3VycmVudC5zaWJsaW5nOyApIHtcbiAgICAgICAgICAgICAgaWYgKG51bGwgPT09IGN1cnJlbnQucmV0dXJuIHx8IGN1cnJlbnQucmV0dXJuID09PSB3b3JrSW5Qcm9ncmVzcylcbiAgICAgICAgICAgICAgICBicmVhayBhO1xuICAgICAgICAgICAgICBjdXJyZW50ID0gY3VycmVudC5yZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjdXJyZW50LnNpYmxpbmcucmV0dXJuID0gY3VycmVudC5yZXR1cm47XG4gICAgICAgICAgICBjdXJyZW50ID0gY3VycmVudC5zaWJsaW5nO1xuICAgICAgICAgIH1cbiAgICAgICAgbmV4dFByb3BzICY9IFN1YnRyZWVTdXNwZW5zZUNvbnRleHRNYXNrO1xuICAgICAgfVxuICAgICAgcHVzaChzdXNwZW5zZVN0YWNrQ3Vyc29yLCBuZXh0UHJvcHMsIHdvcmtJblByb2dyZXNzKTtcbiAgICAgIHN3aXRjaCAocmV2ZWFsT3JkZXIpIHtcbiAgICAgICAgY2FzZSBcImZvcndhcmRzXCI6XG4gICAgICAgICAgcmVuZGVyTGFuZXMgPSB3b3JrSW5Qcm9ncmVzcy5jaGlsZDtcbiAgICAgICAgICBmb3IgKHJldmVhbE9yZGVyID0gbnVsbDsgbnVsbCAhPT0gcmVuZGVyTGFuZXM7IClcbiAgICAgICAgICAgIChjdXJyZW50ID0gcmVuZGVyTGFuZXMuYWx0ZXJuYXRlKSxcbiAgICAgICAgICAgICAgbnVsbCAhPT0gY3VycmVudCAmJlxuICAgICAgICAgICAgICAgIG51bGwgPT09IGZpbmRGaXJzdFN1c3BlbmRlZChjdXJyZW50KSAmJlxuICAgICAgICAgICAgICAgIChyZXZlYWxPcmRlciA9IHJlbmRlckxhbmVzKSxcbiAgICAgICAgICAgICAgKHJlbmRlckxhbmVzID0gcmVuZGVyTGFuZXMuc2libGluZyk7XG4gICAgICAgICAgcmVuZGVyTGFuZXMgPSByZXZlYWxPcmRlcjtcbiAgICAgICAgICBudWxsID09PSByZW5kZXJMYW5lc1xuICAgICAgICAgICAgPyAoKHJldmVhbE9yZGVyID0gd29ya0luUHJvZ3Jlc3MuY2hpbGQpLFxuICAgICAgICAgICAgICAod29ya0luUHJvZ3Jlc3MuY2hpbGQgPSBudWxsKSlcbiAgICAgICAgICAgIDogKChyZXZlYWxPcmRlciA9IHJlbmRlckxhbmVzLnNpYmxpbmcpLFxuICAgICAgICAgICAgICAocmVuZGVyTGFuZXMuc2libGluZyA9IG51bGwpKTtcbiAgICAgICAgICBpbml0U3VzcGVuc2VMaXN0UmVuZGVyU3RhdGUoXG4gICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgICAgICAgICAgICExLFxuICAgICAgICAgICAgcmV2ZWFsT3JkZXIsXG4gICAgICAgICAgICByZW5kZXJMYW5lcyxcbiAgICAgICAgICAgIHRhaWxNb2RlXG4gICAgICAgICAgKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcImJhY2t3YXJkc1wiOlxuICAgICAgICAgIHJlbmRlckxhbmVzID0gbnVsbDtcbiAgICAgICAgICByZXZlYWxPcmRlciA9IHdvcmtJblByb2dyZXNzLmNoaWxkO1xuICAgICAgICAgIGZvciAod29ya0luUHJvZ3Jlc3MuY2hpbGQgPSBudWxsOyBudWxsICE9PSByZXZlYWxPcmRlcjsgKSB7XG4gICAgICAgICAgICBjdXJyZW50ID0gcmV2ZWFsT3JkZXIuYWx0ZXJuYXRlO1xuICAgICAgICAgICAgaWYgKG51bGwgIT09IGN1cnJlbnQgJiYgbnVsbCA9PT0gZmluZEZpcnN0U3VzcGVuZGVkKGN1cnJlbnQpKSB7XG4gICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLmNoaWxkID0gcmV2ZWFsT3JkZXI7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY3VycmVudCA9IHJldmVhbE9yZGVyLnNpYmxpbmc7XG4gICAgICAgICAgICByZXZlYWxPcmRlci5zaWJsaW5nID0gcmVuZGVyTGFuZXM7XG4gICAgICAgICAgICByZW5kZXJMYW5lcyA9IHJldmVhbE9yZGVyO1xuICAgICAgICAgICAgcmV2ZWFsT3JkZXIgPSBjdXJyZW50O1xuICAgICAgICAgIH1cbiAgICAgICAgICBpbml0U3VzcGVuc2VMaXN0UmVuZGVyU3RhdGUoXG4gICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgICAgICAgICAgICEwLFxuICAgICAgICAgICAgcmVuZGVyTGFuZXMsXG4gICAgICAgICAgICBudWxsLFxuICAgICAgICAgICAgdGFpbE1vZGVcbiAgICAgICAgICApO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwidG9nZXRoZXJcIjpcbiAgICAgICAgICBpbml0U3VzcGVuc2VMaXN0UmVuZGVyU3RhdGUod29ya0luUHJvZ3Jlc3MsICExLCBudWxsLCBudWxsLCB2b2lkIDApO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGUgPSBudWxsO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHdvcmtJblByb2dyZXNzLmNoaWxkO1xuICAgIH1cbiAgICBmdW5jdGlvbiBiYWlsb3V0T25BbHJlYWR5RmluaXNoZWRXb3JrKFxuICAgICAgY3VycmVudCxcbiAgICAgIHdvcmtJblByb2dyZXNzLFxuICAgICAgcmVuZGVyTGFuZXNcbiAgICApIHtcbiAgICAgIG51bGwgIT09IGN1cnJlbnQgJiYgKHdvcmtJblByb2dyZXNzLmRlcGVuZGVuY2llcyA9IGN1cnJlbnQuZGVwZW5kZW5jaWVzKTtcbiAgICAgIHByb2ZpbGVyU3RhcnRUaW1lID0gLTE7XG4gICAgICB3b3JrSW5Qcm9ncmVzc1Jvb3RTa2lwcGVkTGFuZXMgfD0gd29ya0luUHJvZ3Jlc3MubGFuZXM7XG4gICAgICBpZiAoMCA9PT0gKHJlbmRlckxhbmVzICYgd29ya0luUHJvZ3Jlc3MuY2hpbGRMYW5lcykpXG4gICAgICAgIGlmIChudWxsICE9PSBjdXJyZW50KSB7XG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgKHByb3BhZ2F0ZVBhcmVudENvbnRleHRDaGFuZ2VzKFxuICAgICAgICAgICAgICBjdXJyZW50LFxuICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgICAgICAgICAgICAgcmVuZGVyTGFuZXMsXG4gICAgICAgICAgICAgICExXG4gICAgICAgICAgICApLFxuICAgICAgICAgICAgMCA9PT0gKHJlbmRlckxhbmVzICYgd29ya0luUHJvZ3Jlc3MuY2hpbGRMYW5lcykpXG4gICAgICAgICAgKVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH0gZWxzZSByZXR1cm4gbnVsbDtcbiAgICAgIGlmIChudWxsICE9PSBjdXJyZW50ICYmIHdvcmtJblByb2dyZXNzLmNoaWxkICE9PSBjdXJyZW50LmNoaWxkKVxuICAgICAgICB0aHJvdyBFcnJvcihcIlJlc3VtaW5nIHdvcmsgbm90IHlldCBpbXBsZW1lbnRlZC5cIik7XG4gICAgICBpZiAobnVsbCAhPT0gd29ya0luUHJvZ3Jlc3MuY2hpbGQpIHtcbiAgICAgICAgY3VycmVudCA9IHdvcmtJblByb2dyZXNzLmNoaWxkO1xuICAgICAgICByZW5kZXJMYW5lcyA9IGNyZWF0ZVdvcmtJblByb2dyZXNzKGN1cnJlbnQsIGN1cnJlbnQucGVuZGluZ1Byb3BzKTtcbiAgICAgICAgd29ya0luUHJvZ3Jlc3MuY2hpbGQgPSByZW5kZXJMYW5lcztcbiAgICAgICAgZm9yIChyZW5kZXJMYW5lcy5yZXR1cm4gPSB3b3JrSW5Qcm9ncmVzczsgbnVsbCAhPT0gY3VycmVudC5zaWJsaW5nOyApXG4gICAgICAgICAgKGN1cnJlbnQgPSBjdXJyZW50LnNpYmxpbmcpLFxuICAgICAgICAgICAgKHJlbmRlckxhbmVzID0gcmVuZGVyTGFuZXMuc2libGluZyA9XG4gICAgICAgICAgICAgIGNyZWF0ZVdvcmtJblByb2dyZXNzKGN1cnJlbnQsIGN1cnJlbnQucGVuZGluZ1Byb3BzKSksXG4gICAgICAgICAgICAocmVuZGVyTGFuZXMucmV0dXJuID0gd29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICByZW5kZXJMYW5lcy5zaWJsaW5nID0gbnVsbDtcbiAgICAgIH1cbiAgICAgIHJldHVybiB3b3JrSW5Qcm9ncmVzcy5jaGlsZDtcbiAgICB9XG4gICAgZnVuY3Rpb24gY2hlY2tTY2hlZHVsZWRVcGRhdGVPckNvbnRleHQoY3VycmVudCwgcmVuZGVyTGFuZXMpIHtcbiAgICAgIGlmICgwICE9PSAoY3VycmVudC5sYW5lcyAmIHJlbmRlckxhbmVzKSkgcmV0dXJuICEwO1xuICAgICAgY3VycmVudCA9IGN1cnJlbnQuZGVwZW5kZW5jaWVzO1xuICAgICAgcmV0dXJuIG51bGwgIT09IGN1cnJlbnQgJiYgY2hlY2tJZkNvbnRleHRDaGFuZ2VkKGN1cnJlbnQpID8gITAgOiAhMTtcbiAgICB9XG4gICAgZnVuY3Rpb24gYXR0ZW1wdEVhcmx5QmFpbG91dElmTm9TY2hlZHVsZWRVcGRhdGUoXG4gICAgICBjdXJyZW50LFxuICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gICAgICByZW5kZXJMYW5lc1xuICAgICkge1xuICAgICAgc3dpdGNoICh3b3JrSW5Qcm9ncmVzcy50YWcpIHtcbiAgICAgICAgY2FzZSAzOlxuICAgICAgICAgIHB1c2hIb3N0Q29udGFpbmVyKFxuICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGUuY29udGFpbmVySW5mb1xuICAgICAgICAgICk7XG4gICAgICAgICAgcHVzaFByb3ZpZGVyKFxuICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gICAgICAgICAgICBDYWNoZUNvbnRleHQsXG4gICAgICAgICAgICBjdXJyZW50Lm1lbW9pemVkU3RhdGUuY2FjaGVcbiAgICAgICAgICApO1xuICAgICAgICAgIHJlc2V0SHlkcmF0aW9uU3RhdGUoKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAyNzpcbiAgICAgICAgY2FzZSA1OlxuICAgICAgICAgIHB1c2hIb3N0Q29udGV4dCh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgNDpcbiAgICAgICAgICBwdXNoSG9zdENvbnRhaW5lcihcbiAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLFxuICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlLmNvbnRhaW5lckluZm9cbiAgICAgICAgICApO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDEwOlxuICAgICAgICAgIHB1c2hQcm92aWRlcihcbiAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLFxuICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MudHlwZSxcbiAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLm1lbW9pemVkUHJvcHMudmFsdWVcbiAgICAgICAgICApO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDEyOlxuICAgICAgICAgIDAgIT09IChyZW5kZXJMYW5lcyAmIHdvcmtJblByb2dyZXNzLmNoaWxkTGFuZXMpICYmXG4gICAgICAgICAgICAod29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gNCk7XG4gICAgICAgICAgd29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gMjA0ODtcbiAgICAgICAgICB2YXIgc3RhdGVOb2RlID0gd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlO1xuICAgICAgICAgIHN0YXRlTm9kZS5lZmZlY3REdXJhdGlvbiA9IC0wO1xuICAgICAgICAgIHN0YXRlTm9kZS5wYXNzaXZlRWZmZWN0RHVyYXRpb24gPSAtMDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAxMzpcbiAgICAgICAgICBzdGF0ZU5vZGUgPSB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlO1xuICAgICAgICAgIGlmIChudWxsICE9PSBzdGF0ZU5vZGUpIHtcbiAgICAgICAgICAgIGlmIChudWxsICE9PSBzdGF0ZU5vZGUuZGVoeWRyYXRlZClcbiAgICAgICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICAgICBwdXNoUHJpbWFyeVRyZWVTdXNwZW5zZUhhbmRsZXIod29ya0luUHJvZ3Jlc3MpLFxuICAgICAgICAgICAgICAgICh3b3JrSW5Qcm9ncmVzcy5mbGFncyB8PSAxMjgpLFxuICAgICAgICAgICAgICAgIG51bGxcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGlmICgwICE9PSAocmVuZGVyTGFuZXMgJiB3b3JrSW5Qcm9ncmVzcy5jaGlsZC5jaGlsZExhbmVzKSlcbiAgICAgICAgICAgICAgcmV0dXJuIHVwZGF0ZVN1c3BlbnNlQ29tcG9uZW50KFxuICAgICAgICAgICAgICAgIGN1cnJlbnQsXG4gICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gICAgICAgICAgICAgICAgcmVuZGVyTGFuZXNcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIHB1c2hQcmltYXJ5VHJlZVN1c3BlbnNlSGFuZGxlcih3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgICAgICBjdXJyZW50ID0gYmFpbG91dE9uQWxyZWFkeUZpbmlzaGVkV29yayhcbiAgICAgICAgICAgICAgY3VycmVudCxcbiAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gICAgICAgICAgICAgIHJlbmRlckxhbmVzXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgcmV0dXJuIG51bGwgIT09IGN1cnJlbnQgPyBjdXJyZW50LnNpYmxpbmcgOiBudWxsO1xuICAgICAgICAgIH1cbiAgICAgICAgICBwdXNoUHJpbWFyeVRyZWVTdXNwZW5zZUhhbmRsZXIod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDE5OlxuICAgICAgICAgIHZhciBkaWRTdXNwZW5kQmVmb3JlID0gMCAhPT0gKGN1cnJlbnQuZmxhZ3MgJiAxMjgpO1xuICAgICAgICAgIHN0YXRlTm9kZSA9IDAgIT09IChyZW5kZXJMYW5lcyAmIHdvcmtJblByb2dyZXNzLmNoaWxkTGFuZXMpO1xuICAgICAgICAgIHN0YXRlTm9kZSB8fFxuICAgICAgICAgICAgKHByb3BhZ2F0ZVBhcmVudENvbnRleHRDaGFuZ2VzKFxuICAgICAgICAgICAgICBjdXJyZW50LFxuICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgICAgICAgICAgICAgcmVuZGVyTGFuZXMsXG4gICAgICAgICAgICAgICExXG4gICAgICAgICAgICApLFxuICAgICAgICAgICAgKHN0YXRlTm9kZSA9IDAgIT09IChyZW5kZXJMYW5lcyAmIHdvcmtJblByb2dyZXNzLmNoaWxkTGFuZXMpKSk7XG4gICAgICAgICAgaWYgKGRpZFN1c3BlbmRCZWZvcmUpIHtcbiAgICAgICAgICAgIGlmIChzdGF0ZU5vZGUpXG4gICAgICAgICAgICAgIHJldHVybiB1cGRhdGVTdXNwZW5zZUxpc3RDb21wb25lbnQoXG4gICAgICAgICAgICAgICAgY3VycmVudCxcbiAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgICAgICAgICAgICAgICByZW5kZXJMYW5lc1xuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gMTI4O1xuICAgICAgICAgIH1cbiAgICAgICAgICBkaWRTdXNwZW5kQmVmb3JlID0gd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZTtcbiAgICAgICAgICBudWxsICE9PSBkaWRTdXNwZW5kQmVmb3JlICYmXG4gICAgICAgICAgICAoKGRpZFN1c3BlbmRCZWZvcmUucmVuZGVyaW5nID0gbnVsbCksXG4gICAgICAgICAgICAoZGlkU3VzcGVuZEJlZm9yZS50YWlsID0gbnVsbCksXG4gICAgICAgICAgICAoZGlkU3VzcGVuZEJlZm9yZS5sYXN0RWZmZWN0ID0gbnVsbCkpO1xuICAgICAgICAgIHB1c2goXG4gICAgICAgICAgICBzdXNwZW5zZVN0YWNrQ3Vyc29yLFxuICAgICAgICAgICAgc3VzcGVuc2VTdGFja0N1cnNvci5jdXJyZW50LFxuICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3NcbiAgICAgICAgICApO1xuICAgICAgICAgIGlmIChzdGF0ZU5vZGUpIGJyZWFrO1xuICAgICAgICAgIGVsc2UgcmV0dXJuIG51bGw7XG4gICAgICAgIGNhc2UgMjI6XG4gICAgICAgIGNhc2UgMjM6XG4gICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICh3b3JrSW5Qcm9ncmVzcy5sYW5lcyA9IDApLFxuICAgICAgICAgICAgdXBkYXRlT2Zmc2NyZWVuQ29tcG9uZW50KGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCByZW5kZXJMYW5lcylcbiAgICAgICAgICApO1xuICAgICAgICBjYXNlIDI0OlxuICAgICAgICAgIHB1c2hQcm92aWRlcihcbiAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLFxuICAgICAgICAgICAgQ2FjaGVDb250ZXh0LFxuICAgICAgICAgICAgY3VycmVudC5tZW1vaXplZFN0YXRlLmNhY2hlXG4gICAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBiYWlsb3V0T25BbHJlYWR5RmluaXNoZWRXb3JrKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCByZW5kZXJMYW5lcyk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGJlZ2luV29yayhjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyTGFuZXMpIHtcbiAgICAgIGlmICh3b3JrSW5Qcm9ncmVzcy5fZGVidWdOZWVkc1JlbW91bnQgJiYgbnVsbCAhPT0gY3VycmVudCkge1xuICAgICAgICByZW5kZXJMYW5lcyA9IGNyZWF0ZUZpYmVyRnJvbVR5cGVBbmRQcm9wcyhcbiAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy50eXBlLFxuICAgICAgICAgIHdvcmtJblByb2dyZXNzLmtleSxcbiAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5wZW5kaW5nUHJvcHMsXG4gICAgICAgICAgd29ya0luUHJvZ3Jlc3MuX2RlYnVnT3duZXIgfHwgbnVsbCxcbiAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5tb2RlLFxuICAgICAgICAgIHdvcmtJblByb2dyZXNzLmxhbmVzXG4gICAgICAgICk7XG4gICAgICAgIHZhciByZXR1cm5GaWJlciA9IHdvcmtJblByb2dyZXNzLnJldHVybjtcbiAgICAgICAgaWYgKG51bGwgPT09IHJldHVybkZpYmVyKSB0aHJvdyBFcnJvcihcIkNhbm5vdCBzd2FwIHRoZSByb290IGZpYmVyLlwiKTtcbiAgICAgICAgY3VycmVudC5hbHRlcm5hdGUgPSBudWxsO1xuICAgICAgICB3b3JrSW5Qcm9ncmVzcy5hbHRlcm5hdGUgPSBudWxsO1xuICAgICAgICByZW5kZXJMYW5lcy5pbmRleCA9IHdvcmtJblByb2dyZXNzLmluZGV4O1xuICAgICAgICByZW5kZXJMYW5lcy5zaWJsaW5nID0gd29ya0luUHJvZ3Jlc3Muc2libGluZztcbiAgICAgICAgcmVuZGVyTGFuZXMucmV0dXJuID0gd29ya0luUHJvZ3Jlc3MucmV0dXJuO1xuICAgICAgICByZW5kZXJMYW5lcy5yZWYgPSB3b3JrSW5Qcm9ncmVzcy5yZWY7XG4gICAgICAgIHJlbmRlckxhbmVzLl9kZWJ1Z0luZm8gPSB3b3JrSW5Qcm9ncmVzcy5fZGVidWdJbmZvO1xuICAgICAgICBpZiAod29ya0luUHJvZ3Jlc3MgPT09IHJldHVybkZpYmVyLmNoaWxkKVxuICAgICAgICAgIHJldHVybkZpYmVyLmNoaWxkID0gcmVuZGVyTGFuZXM7XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIHZhciBwcmV2U2libGluZyA9IHJldHVybkZpYmVyLmNoaWxkO1xuICAgICAgICAgIGlmIChudWxsID09PSBwcmV2U2libGluZylcbiAgICAgICAgICAgIHRocm93IEVycm9yKFwiRXhwZWN0ZWQgcGFyZW50IHRvIGhhdmUgYSBjaGlsZC5cIik7XG4gICAgICAgICAgZm9yICg7IHByZXZTaWJsaW5nLnNpYmxpbmcgIT09IHdvcmtJblByb2dyZXNzOyApXG4gICAgICAgICAgICBpZiAoKChwcmV2U2libGluZyA9IHByZXZTaWJsaW5nLnNpYmxpbmcpLCBudWxsID09PSBwcmV2U2libGluZykpXG4gICAgICAgICAgICAgIHRocm93IEVycm9yKFwiRXhwZWN0ZWQgdG8gZmluZCB0aGUgcHJldmlvdXMgc2libGluZy5cIik7XG4gICAgICAgICAgcHJldlNpYmxpbmcuc2libGluZyA9IHJlbmRlckxhbmVzO1xuICAgICAgICB9XG4gICAgICAgIHdvcmtJblByb2dyZXNzID0gcmV0dXJuRmliZXIuZGVsZXRpb25zO1xuICAgICAgICBudWxsID09PSB3b3JrSW5Qcm9ncmVzc1xuICAgICAgICAgID8gKChyZXR1cm5GaWJlci5kZWxldGlvbnMgPSBbY3VycmVudF0pLCAocmV0dXJuRmliZXIuZmxhZ3MgfD0gMTYpKVxuICAgICAgICAgIDogd29ya0luUHJvZ3Jlc3MucHVzaChjdXJyZW50KTtcbiAgICAgICAgcmVuZGVyTGFuZXMuZmxhZ3MgfD0gMjtcbiAgICAgICAgcmV0dXJuIHJlbmRlckxhbmVzO1xuICAgICAgfVxuICAgICAgaWYgKG51bGwgIT09IGN1cnJlbnQpXG4gICAgICAgIGlmIChcbiAgICAgICAgICBjdXJyZW50Lm1lbW9pemVkUHJvcHMgIT09IHdvcmtJblByb2dyZXNzLnBlbmRpbmdQcm9wcyB8fFxuICAgICAgICAgIHdvcmtJblByb2dyZXNzLnR5cGUgIT09IGN1cnJlbnQudHlwZVxuICAgICAgICApXG4gICAgICAgICAgZGlkUmVjZWl2ZVVwZGF0ZSA9ICEwO1xuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAhY2hlY2tTY2hlZHVsZWRVcGRhdGVPckNvbnRleHQoY3VycmVudCwgcmVuZGVyTGFuZXMpICYmXG4gICAgICAgICAgICAwID09PSAod29ya0luUHJvZ3Jlc3MuZmxhZ3MgJiAxMjgpXG4gICAgICAgICAgKVxuICAgICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICAgKGRpZFJlY2VpdmVVcGRhdGUgPSAhMSksXG4gICAgICAgICAgICAgIGF0dGVtcHRFYXJseUJhaWxvdXRJZk5vU2NoZWR1bGVkVXBkYXRlKFxuICAgICAgICAgICAgICAgIGN1cnJlbnQsXG4gICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gICAgICAgICAgICAgICAgcmVuZGVyTGFuZXNcbiAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICBkaWRSZWNlaXZlVXBkYXRlID0gMCAhPT0gKGN1cnJlbnQuZmxhZ3MgJiAxMzEwNzIpID8gITAgOiAhMTtcbiAgICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIGRpZFJlY2VpdmVVcGRhdGUgPSAhMTtcbiAgICAgICAgaWYgKChyZXR1cm5GaWJlciA9IGlzSHlkcmF0aW5nKSlcbiAgICAgICAgICB3YXJuSWZOb3RIeWRyYXRpbmcoKSxcbiAgICAgICAgICAgIChyZXR1cm5GaWJlciA9IDAgIT09ICh3b3JrSW5Qcm9ncmVzcy5mbGFncyAmIDEwNDg1NzYpKTtcbiAgICAgICAgcmV0dXJuRmliZXIgJiZcbiAgICAgICAgICAoKHJldHVybkZpYmVyID0gd29ya0luUHJvZ3Jlc3MuaW5kZXgpLFxuICAgICAgICAgIHdhcm5JZk5vdEh5ZHJhdGluZygpLFxuICAgICAgICAgIHB1c2hUcmVlSWQod29ya0luUHJvZ3Jlc3MsIHRyZWVGb3JrQ291bnQsIHJldHVybkZpYmVyKSk7XG4gICAgICB9XG4gICAgICB3b3JrSW5Qcm9ncmVzcy5sYW5lcyA9IDA7XG4gICAgICBzd2l0Y2ggKHdvcmtJblByb2dyZXNzLnRhZykge1xuICAgICAgICBjYXNlIDE2OlxuICAgICAgICAgIGE6IGlmIChcbiAgICAgICAgICAgICgocmV0dXJuRmliZXIgPSB3b3JrSW5Qcm9ncmVzcy5wZW5kaW5nUHJvcHMpLFxuICAgICAgICAgICAgKGN1cnJlbnQgPSBjYWxsTGF6eUluaXRJbkRFVih3b3JrSW5Qcm9ncmVzcy5lbGVtZW50VHlwZSkpLFxuICAgICAgICAgICAgKHdvcmtJblByb2dyZXNzLnR5cGUgPSBjdXJyZW50KSxcbiAgICAgICAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIGN1cnJlbnQpXG4gICAgICAgICAgKVxuICAgICAgICAgICAgc2hvdWxkQ29uc3RydWN0KGN1cnJlbnQpXG4gICAgICAgICAgICAgID8gKChyZXR1cm5GaWJlciA9IHJlc29sdmVDbGFzc0NvbXBvbmVudFByb3BzKFxuICAgICAgICAgICAgICAgICAgY3VycmVudCxcbiAgICAgICAgICAgICAgICAgIHJldHVybkZpYmVyXG4gICAgICAgICAgICAgICAgKSksXG4gICAgICAgICAgICAgICAgKHdvcmtJblByb2dyZXNzLnRhZyA9IDEpLFxuICAgICAgICAgICAgICAgICh3b3JrSW5Qcm9ncmVzcy50eXBlID0gY3VycmVudCA9XG4gICAgICAgICAgICAgICAgICByZXNvbHZlRnVuY3Rpb25Gb3JIb3RSZWxvYWRpbmcoY3VycmVudCkpLFxuICAgICAgICAgICAgICAgICh3b3JrSW5Qcm9ncmVzcyA9IHVwZGF0ZUNsYXNzQ29tcG9uZW50KFxuICAgICAgICAgICAgICAgICAgbnVsbCxcbiAgICAgICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLFxuICAgICAgICAgICAgICAgICAgY3VycmVudCxcbiAgICAgICAgICAgICAgICAgIHJldHVybkZpYmVyLFxuICAgICAgICAgICAgICAgICAgcmVuZGVyTGFuZXNcbiAgICAgICAgICAgICAgICApKSlcbiAgICAgICAgICAgICAgOiAoKHdvcmtJblByb2dyZXNzLnRhZyA9IDApLFxuICAgICAgICAgICAgICAgIHZhbGlkYXRlRnVuY3Rpb25Db21wb25lbnRJbkRldih3b3JrSW5Qcm9ncmVzcywgY3VycmVudCksXG4gICAgICAgICAgICAgICAgKHdvcmtJblByb2dyZXNzLnR5cGUgPSBjdXJyZW50ID1cbiAgICAgICAgICAgICAgICAgIHJlc29sdmVGdW5jdGlvbkZvckhvdFJlbG9hZGluZyhjdXJyZW50KSksXG4gICAgICAgICAgICAgICAgKHdvcmtJblByb2dyZXNzID0gdXBkYXRlRnVuY3Rpb25Db21wb25lbnQoXG4gICAgICAgICAgICAgICAgICBudWxsLFxuICAgICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gICAgICAgICAgICAgICAgICBjdXJyZW50LFxuICAgICAgICAgICAgICAgICAgcmV0dXJuRmliZXIsXG4gICAgICAgICAgICAgICAgICByZW5kZXJMYW5lc1xuICAgICAgICAgICAgICAgICkpKTtcbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmICh2b2lkIDAgIT09IGN1cnJlbnQgJiYgbnVsbCAhPT0gY3VycmVudClcbiAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICgocHJldlNpYmxpbmcgPSBjdXJyZW50LiQkdHlwZW9mKSxcbiAgICAgICAgICAgICAgICBwcmV2U2libGluZyA9PT0gUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRSlcbiAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MudGFnID0gMTE7XG4gICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MudHlwZSA9IGN1cnJlbnQgPVxuICAgICAgICAgICAgICAgICAgcmVzb2x2ZUZvcndhcmRSZWZGb3JIb3RSZWxvYWRpbmcoY3VycmVudCk7XG4gICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MgPSB1cGRhdGVGb3J3YXJkUmVmKFxuICAgICAgICAgICAgICAgICAgbnVsbCxcbiAgICAgICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLFxuICAgICAgICAgICAgICAgICAgY3VycmVudCxcbiAgICAgICAgICAgICAgICAgIHJldHVybkZpYmVyLFxuICAgICAgICAgICAgICAgICAgcmVuZGVyTGFuZXNcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIGJyZWFrIGE7XG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAocHJldlNpYmxpbmcgPT09IFJFQUNUX01FTU9fVFlQRSkge1xuICAgICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLnRhZyA9IDE0O1xuICAgICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzID0gdXBkYXRlTWVtb0NvbXBvbmVudChcbiAgICAgICAgICAgICAgICAgIG51bGwsXG4gICAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgICAgICAgICAgICAgICAgIGN1cnJlbnQsXG4gICAgICAgICAgICAgICAgICByZXR1cm5GaWJlcixcbiAgICAgICAgICAgICAgICAgIHJlbmRlckxhbmVzXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICBicmVhayBhO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcyA9IFwiXCI7XG4gICAgICAgICAgICBudWxsICE9PSBjdXJyZW50ICYmXG4gICAgICAgICAgICAgIFwib2JqZWN0XCIgPT09IHR5cGVvZiBjdXJyZW50ICYmXG4gICAgICAgICAgICAgIGN1cnJlbnQuJCR0eXBlb2YgPT09IFJFQUNUX0xBWllfVFlQRSAmJlxuICAgICAgICAgICAgICAod29ya0luUHJvZ3Jlc3MgPVxuICAgICAgICAgICAgICAgIFwiIERpZCB5b3Ugd3JhcCBhIGNvbXBvbmVudCBpbiBSZWFjdC5sYXp5KCkgbW9yZSB0aGFuIG9uY2U/XCIpO1xuICAgICAgICAgICAgY3VycmVudCA9IGdldENvbXBvbmVudE5hbWVGcm9tVHlwZShjdXJyZW50KSB8fCBjdXJyZW50O1xuICAgICAgICAgICAgdGhyb3cgRXJyb3IoXG4gICAgICAgICAgICAgIFwiRWxlbWVudCB0eXBlIGlzIGludmFsaWQuIFJlY2VpdmVkIGEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvOiBcIiArXG4gICAgICAgICAgICAgICAgY3VycmVudCArXG4gICAgICAgICAgICAgICAgXCIuIExhenkgZWxlbWVudCB0eXBlIG11c3QgcmVzb2x2ZSB0byBhIGNsYXNzIG9yIGZ1bmN0aW9uLlwiICtcbiAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzc1xuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHdvcmtJblByb2dyZXNzO1xuICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgcmV0dXJuIHVwZGF0ZUZ1bmN0aW9uQ29tcG9uZW50KFxuICAgICAgICAgICAgY3VycmVudCxcbiAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLFxuICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MudHlwZSxcbiAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLnBlbmRpbmdQcm9wcyxcbiAgICAgICAgICAgIHJlbmRlckxhbmVzXG4gICAgICAgICAgKTtcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAocmV0dXJuRmliZXIgPSB3b3JrSW5Qcm9ncmVzcy50eXBlKSxcbiAgICAgICAgICAgIChwcmV2U2libGluZyA9IHJlc29sdmVDbGFzc0NvbXBvbmVudFByb3BzKFxuICAgICAgICAgICAgICByZXR1cm5GaWJlcixcbiAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzXG4gICAgICAgICAgICApKSxcbiAgICAgICAgICAgIHVwZGF0ZUNsYXNzQ29tcG9uZW50KFxuICAgICAgICAgICAgICBjdXJyZW50LFxuICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgICAgICAgICAgICAgcmV0dXJuRmliZXIsXG4gICAgICAgICAgICAgIHByZXZTaWJsaW5nLFxuICAgICAgICAgICAgICByZW5kZXJMYW5lc1xuICAgICAgICAgICAgKVxuICAgICAgICAgICk7XG4gICAgICAgIGNhc2UgMzpcbiAgICAgICAgICBhOiB7XG4gICAgICAgICAgICBwdXNoSG9zdENvbnRhaW5lcihcbiAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZS5jb250YWluZXJJbmZvXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgaWYgKG51bGwgPT09IGN1cnJlbnQpXG4gICAgICAgICAgICAgIHRocm93IEVycm9yKFxuICAgICAgICAgICAgICAgIFwiU2hvdWxkIGhhdmUgYSBjdXJyZW50IGZpYmVyLiBUaGlzIGlzIGEgYnVnIGluIFJlYWN0LlwiXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB2YXIgbmV4dFByb3BzID0gd29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzO1xuICAgICAgICAgICAgcHJldlNpYmxpbmcgPSB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlO1xuICAgICAgICAgICAgcmV0dXJuRmliZXIgPSBwcmV2U2libGluZy5lbGVtZW50O1xuICAgICAgICAgICAgY2xvbmVVcGRhdGVRdWV1ZShjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgICAgICBwcm9jZXNzVXBkYXRlUXVldWUod29ya0luUHJvZ3Jlc3MsIG5leHRQcm9wcywgbnVsbCwgcmVuZGVyTGFuZXMpO1xuICAgICAgICAgICAgdmFyIG5leHRTdGF0ZSA9IHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGU7XG4gICAgICAgICAgICBuZXh0UHJvcHMgPSBuZXh0U3RhdGUuY2FjaGU7XG4gICAgICAgICAgICBwdXNoUHJvdmlkZXIod29ya0luUHJvZ3Jlc3MsIENhY2hlQ29udGV4dCwgbmV4dFByb3BzKTtcbiAgICAgICAgICAgIG5leHRQcm9wcyAhPT0gcHJldlNpYmxpbmcuY2FjaGUgJiZcbiAgICAgICAgICAgICAgcHJvcGFnYXRlQ29udGV4dENoYW5nZXMoXG4gICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gICAgICAgICAgICAgICAgW0NhY2hlQ29udGV4dF0sXG4gICAgICAgICAgICAgICAgcmVuZGVyTGFuZXMsXG4gICAgICAgICAgICAgICAgITBcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIHN1c3BlbmRJZlVwZGF0ZVJlYWRGcm9tRW50YW5nbGVkQXN5bmNBY3Rpb24oKTtcbiAgICAgICAgICAgIG5leHRQcm9wcyA9IG5leHRTdGF0ZS5lbGVtZW50O1xuICAgICAgICAgICAgaWYgKHN1cHBvcnRzSHlkcmF0aW9uICYmIHByZXZTaWJsaW5nLmlzRGVoeWRyYXRlZClcbiAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICgocHJldlNpYmxpbmcgPSB7XG4gICAgICAgICAgICAgICAgICBlbGVtZW50OiBuZXh0UHJvcHMsXG4gICAgICAgICAgICAgICAgICBpc0RlaHlkcmF0ZWQ6ICExLFxuICAgICAgICAgICAgICAgICAgY2FjaGU6IG5leHRTdGF0ZS5jYWNoZVxuICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgICh3b3JrSW5Qcm9ncmVzcy51cGRhdGVRdWV1ZS5iYXNlU3RhdGUgPSBwcmV2U2libGluZyksXG4gICAgICAgICAgICAgICAgKHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGUgPSBwcmV2U2libGluZyksXG4gICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MuZmxhZ3MgJiAyNTYpXG4gICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzID0gbW91bnRIb3N0Um9vdFdpdGhvdXRIeWRyYXRpbmcoXG4gICAgICAgICAgICAgICAgICBjdXJyZW50LFxuICAgICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gICAgICAgICAgICAgICAgICBuZXh0UHJvcHMsXG4gICAgICAgICAgICAgICAgICByZW5kZXJMYW5lc1xuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgYnJlYWsgYTtcbiAgICAgICAgICAgICAgfSBlbHNlIGlmIChuZXh0UHJvcHMgIT09IHJldHVybkZpYmVyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuRmliZXIgPSBjcmVhdGVDYXB0dXJlZFZhbHVlQXRGaWJlcihcbiAgICAgICAgICAgICAgICAgIEVycm9yKFxuICAgICAgICAgICAgICAgICAgICBcIlRoaXMgcm9vdCByZWNlaXZlZCBhbiBlYXJseSB1cGRhdGUsIGJlZm9yZSBhbnl0aGluZyB3YXMgYWJsZSBoeWRyYXRlLiBTd2l0Y2hlZCB0aGUgZW50aXJlIHJvb3QgdG8gY2xpZW50IHJlbmRlcmluZy5cIlxuICAgICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICBxdWV1ZUh5ZHJhdGlvbkVycm9yKHJldHVybkZpYmVyKTtcbiAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcyA9IG1vdW50SG9zdFJvb3RXaXRob3V0SHlkcmF0aW5nKFxuICAgICAgICAgICAgICAgICAgY3VycmVudCxcbiAgICAgICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLFxuICAgICAgICAgICAgICAgICAgbmV4dFByb3BzLFxuICAgICAgICAgICAgICAgICAgcmVuZGVyTGFuZXNcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIGJyZWFrIGE7XG4gICAgICAgICAgICAgIH0gZWxzZVxuICAgICAgICAgICAgICAgIGZvciAoXG4gICAgICAgICAgICAgICAgICBzdXBwb3J0c0h5ZHJhdGlvbiAmJlxuICAgICAgICAgICAgICAgICAgICAoKG5leHRIeWRyYXRhYmxlSW5zdGFuY2UgPVxuICAgICAgICAgICAgICAgICAgICAgIGdldEZpcnN0SHlkcmF0YWJsZUNoaWxkV2l0aGluQ29udGFpbmVyKFxuICAgICAgICAgICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlLmNvbnRhaW5lckluZm9cbiAgICAgICAgICAgICAgICAgICAgICApKSxcbiAgICAgICAgICAgICAgICAgICAgKGh5ZHJhdGlvblBhcmVudEZpYmVyID0gd29ya0luUHJvZ3Jlc3MpLFxuICAgICAgICAgICAgICAgICAgICAoaXNIeWRyYXRpbmcgPSAhMCksXG4gICAgICAgICAgICAgICAgICAgIChoeWRyYXRpb25FcnJvcnMgPSBudWxsKSxcbiAgICAgICAgICAgICAgICAgICAgKGRpZFN1c3BlbmRPckVycm9yREVWID0gITEpLFxuICAgICAgICAgICAgICAgICAgICAoaHlkcmF0aW9uRGlmZlJvb3RERVYgPSBudWxsKSxcbiAgICAgICAgICAgICAgICAgICAgKHJvb3RPclNpbmdsZXRvbkNvbnRleHQgPSAhMCkpLFxuICAgICAgICAgICAgICAgICAgICBjdXJyZW50ID0gbW91bnRDaGlsZEZpYmVycyhcbiAgICAgICAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgICAgICAgICAgICAgICAgICAgICBudWxsLFxuICAgICAgICAgICAgICAgICAgICAgIG5leHRQcm9wcyxcbiAgICAgICAgICAgICAgICAgICAgICByZW5kZXJMYW5lc1xuICAgICAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5jaGlsZCA9IGN1cnJlbnQ7XG4gICAgICAgICAgICAgICAgICBjdXJyZW50O1xuXG4gICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgKGN1cnJlbnQuZmxhZ3MgPSAoY3VycmVudC5mbGFncyAmIC0zKSB8IDQwOTYpLFxuICAgICAgICAgICAgICAgICAgICAoY3VycmVudCA9IGN1cnJlbnQuc2libGluZyk7XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgcmVzZXRIeWRyYXRpb25TdGF0ZSgpO1xuICAgICAgICAgICAgICBpZiAobmV4dFByb3BzID09PSByZXR1cm5GaWJlcikge1xuICAgICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzID0gYmFpbG91dE9uQWxyZWFkeUZpbmlzaGVkV29yayhcbiAgICAgICAgICAgICAgICAgIGN1cnJlbnQsXG4gICAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgICAgICAgICAgICAgICAgIHJlbmRlckxhbmVzXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICBicmVhayBhO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJlY29uY2lsZUNoaWxkcmVuKFxuICAgICAgICAgICAgICAgIGN1cnJlbnQsXG4gICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gICAgICAgICAgICAgICAgbmV4dFByb3BzLFxuICAgICAgICAgICAgICAgIHJlbmRlckxhbmVzXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcyA9IHdvcmtJblByb2dyZXNzLmNoaWxkO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gd29ya0luUHJvZ3Jlc3M7XG4gICAgICAgIGNhc2UgMjY6XG4gICAgICAgICAgaWYgKHN1cHBvcnRzUmVzb3VyY2VzKVxuICAgICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICAgbWFya1JlZihjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcyksXG4gICAgICAgICAgICAgIG51bGwgPT09IGN1cnJlbnRcbiAgICAgICAgICAgICAgICA/IChjdXJyZW50ID0gZ2V0UmVzb3VyY2UoXG4gICAgICAgICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLnR5cGUsXG4gICAgICAgICAgICAgICAgICAgIG51bGwsXG4gICAgICAgICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLnBlbmRpbmdQcm9wcyxcbiAgICAgICAgICAgICAgICAgICAgbnVsbFxuICAgICAgICAgICAgICAgICAgKSlcbiAgICAgICAgICAgICAgICAgID8gKHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGUgPSBjdXJyZW50KVxuICAgICAgICAgICAgICAgICAgOiBpc0h5ZHJhdGluZyB8fFxuICAgICAgICAgICAgICAgICAgICAod29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlID0gY3JlYXRlSG9pc3RhYmxlSW5zdGFuY2UoXG4gICAgICAgICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MudHlwZSxcbiAgICAgICAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5wZW5kaW5nUHJvcHMsXG4gICAgICAgICAgICAgICAgICAgICAgcmVxdWlyZWRDb250ZXh0KHJvb3RJbnN0YW5jZVN0YWNrQ3Vyc29yLmN1cnJlbnQpLFxuICAgICAgICAgICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzXG4gICAgICAgICAgICAgICAgICAgICkpXG4gICAgICAgICAgICAgICAgOiAod29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZSA9IGdldFJlc291cmNlKFxuICAgICAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy50eXBlLFxuICAgICAgICAgICAgICAgICAgICBjdXJyZW50Lm1lbW9pemVkUHJvcHMsXG4gICAgICAgICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLnBlbmRpbmdQcm9wcyxcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudC5tZW1vaXplZFN0YXRlXG4gICAgICAgICAgICAgICAgICApKSxcbiAgICAgICAgICAgICAgbnVsbFxuICAgICAgICAgICAgKTtcbiAgICAgICAgY2FzZSAyNzpcbiAgICAgICAgICBpZiAoc3VwcG9ydHNTaW5nbGV0b25zKVxuICAgICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICAgcHVzaEhvc3RDb250ZXh0KHdvcmtJblByb2dyZXNzKSxcbiAgICAgICAgICAgICAgbnVsbCA9PT0gY3VycmVudCAmJlxuICAgICAgICAgICAgICAgIHN1cHBvcnRzU2luZ2xldG9ucyAmJlxuICAgICAgICAgICAgICAgIGlzSHlkcmF0aW5nICYmXG4gICAgICAgICAgICAgICAgKChwcmV2U2libGluZyA9IHJlcXVpcmVkQ29udGV4dChcbiAgICAgICAgICAgICAgICAgIHJvb3RJbnN0YW5jZVN0YWNrQ3Vyc29yLmN1cnJlbnRcbiAgICAgICAgICAgICAgICApKSxcbiAgICAgICAgICAgICAgICAocmV0dXJuRmliZXIgPSBnZXRIb3N0Q29udGV4dCgpKSxcbiAgICAgICAgICAgICAgICAocHJldlNpYmxpbmcgPSB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGUgPVxuICAgICAgICAgICAgICAgICAgcmVzb2x2ZVNpbmdsZXRvbkluc3RhbmNlKFxuICAgICAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy50eXBlLFxuICAgICAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5wZW5kaW5nUHJvcHMsXG4gICAgICAgICAgICAgICAgICAgIHByZXZTaWJsaW5nLFxuICAgICAgICAgICAgICAgICAgICByZXR1cm5GaWJlcixcbiAgICAgICAgICAgICAgICAgICAgITFcbiAgICAgICAgICAgICAgICAgICkpLFxuICAgICAgICAgICAgICAgIGRpZFN1c3BlbmRPckVycm9yREVWIHx8XG4gICAgICAgICAgICAgICAgICAoKHJldHVybkZpYmVyID0gZGlmZkh5ZHJhdGVkUHJvcHNGb3JEZXZXYXJuaW5ncyhcbiAgICAgICAgICAgICAgICAgICAgcHJldlNpYmxpbmcsXG4gICAgICAgICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLnR5cGUsXG4gICAgICAgICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLnBlbmRpbmdQcm9wcyxcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuRmliZXJcbiAgICAgICAgICAgICAgICAgICkpLFxuICAgICAgICAgICAgICAgICAgbnVsbCAhPT0gcmV0dXJuRmliZXIgJiZcbiAgICAgICAgICAgICAgICAgICAgKGJ1aWxkSHlkcmF0aW9uRGlmZk5vZGUod29ya0luUHJvZ3Jlc3MsIDApLnNlcnZlclByb3BzID1cbiAgICAgICAgICAgICAgICAgICAgICByZXR1cm5GaWJlcikpLFxuICAgICAgICAgICAgICAgIChoeWRyYXRpb25QYXJlbnRGaWJlciA9IHdvcmtJblByb2dyZXNzKSxcbiAgICAgICAgICAgICAgICAocm9vdE9yU2luZ2xldG9uQ29udGV4dCA9ICEwKSxcbiAgICAgICAgICAgICAgICAobmV4dEh5ZHJhdGFibGVJbnN0YW5jZSA9XG4gICAgICAgICAgICAgICAgICBnZXRGaXJzdEh5ZHJhdGFibGVDaGlsZChwcmV2U2libGluZykpKSxcbiAgICAgICAgICAgICAgKHJldHVybkZpYmVyID0gd29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzLmNoaWxkcmVuKSxcbiAgICAgICAgICAgICAgbnVsbCAhPT0gY3VycmVudCB8fCBpc0h5ZHJhdGluZ1xuICAgICAgICAgICAgICAgID8gcmVjb25jaWxlQ2hpbGRyZW4oXG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnQsXG4gICAgICAgICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLFxuICAgICAgICAgICAgICAgICAgICByZXR1cm5GaWJlcixcbiAgICAgICAgICAgICAgICAgICAgcmVuZGVyTGFuZXNcbiAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICA6ICh3b3JrSW5Qcm9ncmVzcy5jaGlsZCA9IHJlY29uY2lsZUNoaWxkRmliZXJzKFxuICAgICAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgICAgICAgICAgICAgICAgICAgbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuRmliZXIsXG4gICAgICAgICAgICAgICAgICAgIHJlbmRlckxhbmVzXG4gICAgICAgICAgICAgICAgICApKSxcbiAgICAgICAgICAgICAgbWFya1JlZihjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcyksXG4gICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLmNoaWxkXG4gICAgICAgICAgICApO1xuICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIG51bGwgPT09IGN1cnJlbnQgJiZcbiAgICAgICAgICAgICAgaXNIeWRyYXRpbmcgJiZcbiAgICAgICAgICAgICAgKChuZXh0UHJvcHMgPSBnZXRIb3N0Q29udGV4dCgpKSxcbiAgICAgICAgICAgICAgKHJldHVybkZpYmVyID0gdmFsaWRhdGVIeWRyYXRhYmxlSW5zdGFuY2UoXG4gICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MudHlwZSxcbiAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5wZW5kaW5nUHJvcHMsXG4gICAgICAgICAgICAgICAgbmV4dFByb3BzXG4gICAgICAgICAgICAgICkpLFxuICAgICAgICAgICAgICAocHJldlNpYmxpbmcgPSBuZXh0SHlkcmF0YWJsZUluc3RhbmNlKSxcbiAgICAgICAgICAgICAgKG5leHRTdGF0ZSA9ICFwcmV2U2libGluZykgfHxcbiAgICAgICAgICAgICAgICAoKG5leHRTdGF0ZSA9IGNhbkh5ZHJhdGVJbnN0YW5jZShcbiAgICAgICAgICAgICAgICAgIHByZXZTaWJsaW5nLFxuICAgICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MudHlwZSxcbiAgICAgICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLnBlbmRpbmdQcm9wcyxcbiAgICAgICAgICAgICAgICAgIHJvb3RPclNpbmdsZXRvbkNvbnRleHRcbiAgICAgICAgICAgICAgICApKSxcbiAgICAgICAgICAgICAgICBudWxsICE9PSBuZXh0U3RhdGVcbiAgICAgICAgICAgICAgICAgID8gKCh3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGUgPSBuZXh0U3RhdGUpLFxuICAgICAgICAgICAgICAgICAgICBkaWRTdXNwZW5kT3JFcnJvckRFViB8fFxuICAgICAgICAgICAgICAgICAgICAgICgobmV4dFByb3BzID0gZGlmZkh5ZHJhdGVkUHJvcHNGb3JEZXZXYXJuaW5ncyhcbiAgICAgICAgICAgICAgICAgICAgICAgIG5leHRTdGF0ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLnR5cGUsXG4gICAgICAgICAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5wZW5kaW5nUHJvcHMsXG4gICAgICAgICAgICAgICAgICAgICAgICBuZXh0UHJvcHNcbiAgICAgICAgICAgICAgICAgICAgICApKSxcbiAgICAgICAgICAgICAgICAgICAgICBudWxsICE9PSBuZXh0UHJvcHMgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIChidWlsZEh5ZHJhdGlvbkRpZmZOb2RlKHdvcmtJblByb2dyZXNzLCAwKS5zZXJ2ZXJQcm9wcyA9XG4gICAgICAgICAgICAgICAgICAgICAgICAgIG5leHRQcm9wcykpLFxuICAgICAgICAgICAgICAgICAgICAoaHlkcmF0aW9uUGFyZW50RmliZXIgPSB3b3JrSW5Qcm9ncmVzcyksXG4gICAgICAgICAgICAgICAgICAgIChuZXh0SHlkcmF0YWJsZUluc3RhbmNlID1cbiAgICAgICAgICAgICAgICAgICAgICBnZXRGaXJzdEh5ZHJhdGFibGVDaGlsZChuZXh0U3RhdGUpKSxcbiAgICAgICAgICAgICAgICAgICAgKHJvb3RPclNpbmdsZXRvbkNvbnRleHQgPSAhMSksXG4gICAgICAgICAgICAgICAgICAgIChuZXh0UHJvcHMgPSAhMCkpXG4gICAgICAgICAgICAgICAgICA6IChuZXh0UHJvcHMgPSAhMSksXG4gICAgICAgICAgICAgICAgKG5leHRTdGF0ZSA9ICFuZXh0UHJvcHMpKSxcbiAgICAgICAgICAgICAgbmV4dFN0YXRlICYmXG4gICAgICAgICAgICAgICAgKHJldHVybkZpYmVyICYmXG4gICAgICAgICAgICAgICAgICB3YXJuTm9uSHlkcmF0ZWRJbnN0YW5jZSh3b3JrSW5Qcm9ncmVzcywgcHJldlNpYmxpbmcpLFxuICAgICAgICAgICAgICAgIHRocm93T25IeWRyYXRpb25NaXNtYXRjaCh3b3JrSW5Qcm9ncmVzcykpKSxcbiAgICAgICAgICAgIHB1c2hIb3N0Q29udGV4dCh3b3JrSW5Qcm9ncmVzcyksXG4gICAgICAgICAgICAocHJldlNpYmxpbmcgPSB3b3JrSW5Qcm9ncmVzcy50eXBlKSxcbiAgICAgICAgICAgIChuZXh0UHJvcHMgPSB3b3JrSW5Qcm9ncmVzcy5wZW5kaW5nUHJvcHMpLFxuICAgICAgICAgICAgKG5leHRTdGF0ZSA9IG51bGwgIT09IGN1cnJlbnQgPyBjdXJyZW50Lm1lbW9pemVkUHJvcHMgOiBudWxsKSxcbiAgICAgICAgICAgIChyZXR1cm5GaWJlciA9IG5leHRQcm9wcy5jaGlsZHJlbiksXG4gICAgICAgICAgICBzaG91bGRTZXRUZXh0Q29udGVudChwcmV2U2libGluZywgbmV4dFByb3BzKVxuICAgICAgICAgICAgICA/IChyZXR1cm5GaWJlciA9IG51bGwpXG4gICAgICAgICAgICAgIDogbnVsbCAhPT0gbmV4dFN0YXRlICYmXG4gICAgICAgICAgICAgICAgc2hvdWxkU2V0VGV4dENvbnRlbnQocHJldlNpYmxpbmcsIG5leHRTdGF0ZSkgJiZcbiAgICAgICAgICAgICAgICAod29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gMzIpLFxuICAgICAgICAgICAgbnVsbCAhPT0gd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZSAmJlxuICAgICAgICAgICAgICAoKHByZXZTaWJsaW5nID0gcmVuZGVyV2l0aEhvb2tzKFxuICAgICAgICAgICAgICAgIGN1cnJlbnQsXG4gICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gICAgICAgICAgICAgICAgVHJhbnNpdGlvbkF3YXJlSG9zdENvbXBvbmVudCxcbiAgICAgICAgICAgICAgICBudWxsLFxuICAgICAgICAgICAgICAgIG51bGwsXG4gICAgICAgICAgICAgICAgcmVuZGVyTGFuZXNcbiAgICAgICAgICAgICAgKSksXG4gICAgICAgICAgICAgIGlzUHJpbWFyeVJlbmRlcmVyXG4gICAgICAgICAgICAgICAgPyAoSG9zdFRyYW5zaXRpb25Db250ZXh0Ll9jdXJyZW50VmFsdWUgPSBwcmV2U2libGluZylcbiAgICAgICAgICAgICAgICA6IChIb3N0VHJhbnNpdGlvbkNvbnRleHQuX2N1cnJlbnRWYWx1ZTIgPSBwcmV2U2libGluZykpLFxuICAgICAgICAgICAgbWFya1JlZihjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcyksXG4gICAgICAgICAgICByZWNvbmNpbGVDaGlsZHJlbihcbiAgICAgICAgICAgICAgY3VycmVudCxcbiAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gICAgICAgICAgICAgIHJldHVybkZpYmVyLFxuICAgICAgICAgICAgICByZW5kZXJMYW5lc1xuICAgICAgICAgICAgKSxcbiAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLmNoaWxkXG4gICAgICAgICAgKTtcbiAgICAgICAgY2FzZSA2OlxuICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICBudWxsID09PSBjdXJyZW50ICYmXG4gICAgICAgICAgICAgIGlzSHlkcmF0aW5nICYmXG4gICAgICAgICAgICAgICgoY3VycmVudCA9IHdvcmtJblByb2dyZXNzLnBlbmRpbmdQcm9wcyksXG4gICAgICAgICAgICAgIChyZW5kZXJMYW5lcyA9IGdldEhvc3RDb250ZXh0KCkpLFxuICAgICAgICAgICAgICAoY3VycmVudCA9IHZhbGlkYXRlSHlkcmF0YWJsZVRleHRJbnN0YW5jZShjdXJyZW50LCByZW5kZXJMYW5lcykpLFxuICAgICAgICAgICAgICAocmVuZGVyTGFuZXMgPSBuZXh0SHlkcmF0YWJsZUluc3RhbmNlKSxcbiAgICAgICAgICAgICAgKHJldHVybkZpYmVyID0gIXJlbmRlckxhbmVzKSB8fFxuICAgICAgICAgICAgICAgICgocmV0dXJuRmliZXIgPSBjYW5IeWRyYXRlVGV4dEluc3RhbmNlKFxuICAgICAgICAgICAgICAgICAgcmVuZGVyTGFuZXMsXG4gICAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5wZW5kaW5nUHJvcHMsXG4gICAgICAgICAgICAgICAgICByb290T3JTaW5nbGV0b25Db250ZXh0XG4gICAgICAgICAgICAgICAgKSksXG4gICAgICAgICAgICAgICAgbnVsbCAhPT0gcmV0dXJuRmliZXJcbiAgICAgICAgICAgICAgICAgID8gKCh3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGUgPSByZXR1cm5GaWJlciksXG4gICAgICAgICAgICAgICAgICAgIChoeWRyYXRpb25QYXJlbnRGaWJlciA9IHdvcmtJblByb2dyZXNzKSxcbiAgICAgICAgICAgICAgICAgICAgKG5leHRIeWRyYXRhYmxlSW5zdGFuY2UgPSBudWxsKSxcbiAgICAgICAgICAgICAgICAgICAgKHJldHVybkZpYmVyID0gITApKVxuICAgICAgICAgICAgICAgICAgOiAocmV0dXJuRmliZXIgPSAhMSksXG4gICAgICAgICAgICAgICAgKHJldHVybkZpYmVyID0gIXJldHVybkZpYmVyKSksXG4gICAgICAgICAgICAgIHJldHVybkZpYmVyICYmXG4gICAgICAgICAgICAgICAgKGN1cnJlbnQgJiZcbiAgICAgICAgICAgICAgICAgIHdhcm5Ob25IeWRyYXRlZEluc3RhbmNlKHdvcmtJblByb2dyZXNzLCByZW5kZXJMYW5lcyksXG4gICAgICAgICAgICAgICAgdGhyb3dPbkh5ZHJhdGlvbk1pc21hdGNoKHdvcmtJblByb2dyZXNzKSkpLFxuICAgICAgICAgICAgbnVsbFxuICAgICAgICAgICk7XG4gICAgICAgIGNhc2UgMTM6XG4gICAgICAgICAgcmV0dXJuIHVwZGF0ZVN1c3BlbnNlQ29tcG9uZW50KGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCByZW5kZXJMYW5lcyk7XG4gICAgICAgIGNhc2UgNDpcbiAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgcHVzaEhvc3RDb250YWluZXIoXG4gICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLFxuICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGUuY29udGFpbmVySW5mb1xuICAgICAgICAgICAgKSxcbiAgICAgICAgICAgIChyZXR1cm5GaWJlciA9IHdvcmtJblByb2dyZXNzLnBlbmRpbmdQcm9wcyksXG4gICAgICAgICAgICBudWxsID09PSBjdXJyZW50XG4gICAgICAgICAgICAgID8gKHdvcmtJblByb2dyZXNzLmNoaWxkID0gcmVjb25jaWxlQ2hpbGRGaWJlcnMoXG4gICAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgICAgICAgICAgICAgICAgIG51bGwsXG4gICAgICAgICAgICAgICAgICByZXR1cm5GaWJlcixcbiAgICAgICAgICAgICAgICAgIHJlbmRlckxhbmVzXG4gICAgICAgICAgICAgICAgKSlcbiAgICAgICAgICAgICAgOiByZWNvbmNpbGVDaGlsZHJlbihcbiAgICAgICAgICAgICAgICAgIGN1cnJlbnQsXG4gICAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgICAgICAgICAgICAgICAgIHJldHVybkZpYmVyLFxuICAgICAgICAgICAgICAgICAgcmVuZGVyTGFuZXNcbiAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MuY2hpbGRcbiAgICAgICAgICApO1xuICAgICAgICBjYXNlIDExOlxuICAgICAgICAgIHJldHVybiB1cGRhdGVGb3J3YXJkUmVmKFxuICAgICAgICAgICAgY3VycmVudCxcbiAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLFxuICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MudHlwZSxcbiAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLnBlbmRpbmdQcm9wcyxcbiAgICAgICAgICAgIHJlbmRlckxhbmVzXG4gICAgICAgICAgKTtcbiAgICAgICAgY2FzZSA3OlxuICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICByZWNvbmNpbGVDaGlsZHJlbihcbiAgICAgICAgICAgICAgY3VycmVudCxcbiAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLnBlbmRpbmdQcm9wcyxcbiAgICAgICAgICAgICAgcmVuZGVyTGFuZXNcbiAgICAgICAgICAgICksXG4gICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5jaGlsZFxuICAgICAgICAgICk7XG4gICAgICAgIGNhc2UgODpcbiAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgcmVjb25jaWxlQ2hpbGRyZW4oXG4gICAgICAgICAgICAgIGN1cnJlbnQsXG4gICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLFxuICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5wZW5kaW5nUHJvcHMuY2hpbGRyZW4sXG4gICAgICAgICAgICAgIHJlbmRlckxhbmVzXG4gICAgICAgICAgICApLFxuICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MuY2hpbGRcbiAgICAgICAgICApO1xuICAgICAgICBjYXNlIDEyOlxuICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAod29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gNCksXG4gICAgICAgICAgICAod29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gMjA0OCksXG4gICAgICAgICAgICAocmV0dXJuRmliZXIgPSB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGUpLFxuICAgICAgICAgICAgKHJldHVybkZpYmVyLmVmZmVjdER1cmF0aW9uID0gLTApLFxuICAgICAgICAgICAgKHJldHVybkZpYmVyLnBhc3NpdmVFZmZlY3REdXJhdGlvbiA9IC0wKSxcbiAgICAgICAgICAgIHJlY29uY2lsZUNoaWxkcmVuKFxuICAgICAgICAgICAgICBjdXJyZW50LFxuICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzLmNoaWxkcmVuLFxuICAgICAgICAgICAgICByZW5kZXJMYW5lc1xuICAgICAgICAgICAgKSxcbiAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLmNoaWxkXG4gICAgICAgICAgKTtcbiAgICAgICAgY2FzZSAxMDpcbiAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgKHJldHVybkZpYmVyID0gd29ya0luUHJvZ3Jlc3MudHlwZSksXG4gICAgICAgICAgICAocHJldlNpYmxpbmcgPSB3b3JrSW5Qcm9ncmVzcy5wZW5kaW5nUHJvcHMpLFxuICAgICAgICAgICAgKG5leHRQcm9wcyA9IHByZXZTaWJsaW5nLnZhbHVlKSxcbiAgICAgICAgICAgIFwidmFsdWVcIiBpbiBwcmV2U2libGluZyB8fFxuICAgICAgICAgICAgICBoYXNXYXJuZWRBYm91dFVzaW5nTm9WYWx1ZVByb3BPbkNvbnRleHRQcm92aWRlciB8fFxuICAgICAgICAgICAgICAoKGhhc1dhcm5lZEFib3V0VXNpbmdOb1ZhbHVlUHJvcE9uQ29udGV4dFByb3ZpZGVyID0gITApLFxuICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICAgIFwiVGhlIGB2YWx1ZWAgcHJvcCBpcyByZXF1aXJlZCBmb3IgdGhlIGA8Q29udGV4dC5Qcm92aWRlcj5gLiBEaWQgeW91IG1pc3NwZWxsIGl0IG9yIGZvcmdldCB0byBwYXNzIGl0P1wiXG4gICAgICAgICAgICAgICkpLFxuICAgICAgICAgICAgcHVzaFByb3ZpZGVyKHdvcmtJblByb2dyZXNzLCByZXR1cm5GaWJlciwgbmV4dFByb3BzKSxcbiAgICAgICAgICAgIHJlY29uY2lsZUNoaWxkcmVuKFxuICAgICAgICAgICAgICBjdXJyZW50LFxuICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgICAgICAgICAgICAgcHJldlNpYmxpbmcuY2hpbGRyZW4sXG4gICAgICAgICAgICAgIHJlbmRlckxhbmVzXG4gICAgICAgICAgICApLFxuICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MuY2hpbGRcbiAgICAgICAgICApO1xuICAgICAgICBjYXNlIDk6XG4gICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIChwcmV2U2libGluZyA9IHdvcmtJblByb2dyZXNzLnR5cGUuX2NvbnRleHQpLFxuICAgICAgICAgICAgKHJldHVybkZpYmVyID0gd29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzLmNoaWxkcmVuKSxcbiAgICAgICAgICAgIFwiZnVuY3Rpb25cIiAhPT0gdHlwZW9mIHJldHVybkZpYmVyICYmXG4gICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgICAgXCJBIGNvbnRleHQgY29uc3VtZXIgd2FzIHJlbmRlcmVkIHdpdGggbXVsdGlwbGUgY2hpbGRyZW4sIG9yIGEgY2hpbGQgdGhhdCBpc24ndCBhIGZ1bmN0aW9uLiBBIGNvbnRleHQgY29uc3VtZXIgZXhwZWN0cyBhIHNpbmdsZSBjaGlsZCB0aGF0IGlzIGEgZnVuY3Rpb24uIElmIHlvdSBkaWQgcGFzcyBhIGZ1bmN0aW9uLCBtYWtlIHN1cmUgdGhlcmUgaXMgbm8gdHJhaWxpbmcgb3IgbGVhZGluZyB3aGl0ZXNwYWNlIGFyb3VuZCBpdC5cIlxuICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgcHJlcGFyZVRvUmVhZENvbnRleHQod29ya0luUHJvZ3Jlc3MpLFxuICAgICAgICAgICAgKHByZXZTaWJsaW5nID0gcmVhZENvbnRleHQocHJldlNpYmxpbmcpKSxcbiAgICAgICAgICAgIG1hcmtDb21wb25lbnRSZW5kZXJTdGFydGVkKHdvcmtJblByb2dyZXNzKSxcbiAgICAgICAgICAgIChyZXR1cm5GaWJlciA9IGNhbGxDb21wb25lbnRJbkRFVihcbiAgICAgICAgICAgICAgcmV0dXJuRmliZXIsXG4gICAgICAgICAgICAgIHByZXZTaWJsaW5nLFxuICAgICAgICAgICAgICB2b2lkIDBcbiAgICAgICAgICAgICkpLFxuICAgICAgICAgICAgbWFya0NvbXBvbmVudFJlbmRlclN0b3BwZWQoKSxcbiAgICAgICAgICAgICh3b3JrSW5Qcm9ncmVzcy5mbGFncyB8PSAxKSxcbiAgICAgICAgICAgIHJlY29uY2lsZUNoaWxkcmVuKFxuICAgICAgICAgICAgICBjdXJyZW50LFxuICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgICAgICAgICAgICAgcmV0dXJuRmliZXIsXG4gICAgICAgICAgICAgIHJlbmRlckxhbmVzXG4gICAgICAgICAgICApLFxuICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MuY2hpbGRcbiAgICAgICAgICApO1xuICAgICAgICBjYXNlIDE0OlxuICAgICAgICAgIHJldHVybiB1cGRhdGVNZW1vQ29tcG9uZW50KFxuICAgICAgICAgICAgY3VycmVudCxcbiAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLFxuICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MudHlwZSxcbiAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLnBlbmRpbmdQcm9wcyxcbiAgICAgICAgICAgIHJlbmRlckxhbmVzXG4gICAgICAgICAgKTtcbiAgICAgICAgY2FzZSAxNTpcbiAgICAgICAgICByZXR1cm4gdXBkYXRlU2ltcGxlTWVtb0NvbXBvbmVudChcbiAgICAgICAgICAgIGN1cnJlbnQsXG4gICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLnR5cGUsXG4gICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5wZW5kaW5nUHJvcHMsXG4gICAgICAgICAgICByZW5kZXJMYW5lc1xuICAgICAgICAgICk7XG4gICAgICAgIGNhc2UgMTk6XG4gICAgICAgICAgcmV0dXJuIHVwZGF0ZVN1c3BlbnNlTGlzdENvbXBvbmVudChcbiAgICAgICAgICAgIGN1cnJlbnQsXG4gICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgICAgICAgICAgIHJlbmRlckxhbmVzXG4gICAgICAgICAgKTtcbiAgICAgICAgY2FzZSAyMjpcbiAgICAgICAgICByZXR1cm4gdXBkYXRlT2Zmc2NyZWVuQ29tcG9uZW50KGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCByZW5kZXJMYW5lcyk7XG4gICAgICAgIGNhc2UgMjQ6XG4gICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIHByZXBhcmVUb1JlYWRDb250ZXh0KHdvcmtJblByb2dyZXNzKSxcbiAgICAgICAgICAgIChyZXR1cm5GaWJlciA9IHJlYWRDb250ZXh0KENhY2hlQ29udGV4dCkpLFxuICAgICAgICAgICAgbnVsbCA9PT0gY3VycmVudFxuICAgICAgICAgICAgICA/ICgocHJldlNpYmxpbmcgPSBwZWVrQ2FjaGVGcm9tUG9vbCgpKSxcbiAgICAgICAgICAgICAgICBudWxsID09PSBwcmV2U2libGluZyAmJlxuICAgICAgICAgICAgICAgICAgKChwcmV2U2libGluZyA9IHdvcmtJblByb2dyZXNzUm9vdCksXG4gICAgICAgICAgICAgICAgICAobmV4dFByb3BzID0gY3JlYXRlQ2FjaGUoKSksXG4gICAgICAgICAgICAgICAgICAocHJldlNpYmxpbmcucG9vbGVkQ2FjaGUgPSBuZXh0UHJvcHMpLFxuICAgICAgICAgICAgICAgICAgcmV0YWluQ2FjaGUobmV4dFByb3BzKSxcbiAgICAgICAgICAgICAgICAgIG51bGwgIT09IG5leHRQcm9wcyAmJlxuICAgICAgICAgICAgICAgICAgICAocHJldlNpYmxpbmcucG9vbGVkQ2FjaGVMYW5lcyB8PSByZW5kZXJMYW5lcyksXG4gICAgICAgICAgICAgICAgICAocHJldlNpYmxpbmcgPSBuZXh0UHJvcHMpKSxcbiAgICAgICAgICAgICAgICAod29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZSA9IHtcbiAgICAgICAgICAgICAgICAgIHBhcmVudDogcmV0dXJuRmliZXIsXG4gICAgICAgICAgICAgICAgICBjYWNoZTogcHJldlNpYmxpbmdcbiAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICBpbml0aWFsaXplVXBkYXRlUXVldWUod29ya0luUHJvZ3Jlc3MpLFxuICAgICAgICAgICAgICAgIHB1c2hQcm92aWRlcih3b3JrSW5Qcm9ncmVzcywgQ2FjaGVDb250ZXh0LCBwcmV2U2libGluZykpXG4gICAgICAgICAgICAgIDogKDAgIT09IChjdXJyZW50LmxhbmVzICYgcmVuZGVyTGFuZXMpICYmXG4gICAgICAgICAgICAgICAgICAoY2xvbmVVcGRhdGVRdWV1ZShjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcyksXG4gICAgICAgICAgICAgICAgICBwcm9jZXNzVXBkYXRlUXVldWUod29ya0luUHJvZ3Jlc3MsIG51bGwsIG51bGwsIHJlbmRlckxhbmVzKSxcbiAgICAgICAgICAgICAgICAgIHN1c3BlbmRJZlVwZGF0ZVJlYWRGcm9tRW50YW5nbGVkQXN5bmNBY3Rpb24oKSksXG4gICAgICAgICAgICAgICAgKHByZXZTaWJsaW5nID0gY3VycmVudC5tZW1vaXplZFN0YXRlKSxcbiAgICAgICAgICAgICAgICAobmV4dFByb3BzID0gd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZSksXG4gICAgICAgICAgICAgICAgcHJldlNpYmxpbmcucGFyZW50ICE9PSByZXR1cm5GaWJlclxuICAgICAgICAgICAgICAgICAgPyAoKHByZXZTaWJsaW5nID0ge1xuICAgICAgICAgICAgICAgICAgICAgIHBhcmVudDogcmV0dXJuRmliZXIsXG4gICAgICAgICAgICAgICAgICAgICAgY2FjaGU6IHJldHVybkZpYmVyXG4gICAgICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgICAgICAod29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZSA9IHByZXZTaWJsaW5nKSxcbiAgICAgICAgICAgICAgICAgICAgMCA9PT0gd29ya0luUHJvZ3Jlc3MubGFuZXMgJiZcbiAgICAgICAgICAgICAgICAgICAgICAod29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZSA9XG4gICAgICAgICAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy51cGRhdGVRdWV1ZS5iYXNlU3RhdGUgPVxuICAgICAgICAgICAgICAgICAgICAgICAgICBwcmV2U2libGluZyksXG4gICAgICAgICAgICAgICAgICAgIHB1c2hQcm92aWRlcih3b3JrSW5Qcm9ncmVzcywgQ2FjaGVDb250ZXh0LCByZXR1cm5GaWJlcikpXG4gICAgICAgICAgICAgICAgICA6ICgocmV0dXJuRmliZXIgPSBuZXh0UHJvcHMuY2FjaGUpLFxuICAgICAgICAgICAgICAgICAgICBwdXNoUHJvdmlkZXIod29ya0luUHJvZ3Jlc3MsIENhY2hlQ29udGV4dCwgcmV0dXJuRmliZXIpLFxuICAgICAgICAgICAgICAgICAgICByZXR1cm5GaWJlciAhPT0gcHJldlNpYmxpbmcuY2FjaGUgJiZcbiAgICAgICAgICAgICAgICAgICAgICBwcm9wYWdhdGVDb250ZXh0Q2hhbmdlcyhcbiAgICAgICAgICAgICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLFxuICAgICAgICAgICAgICAgICAgICAgICAgW0NhY2hlQ29udGV4dF0sXG4gICAgICAgICAgICAgICAgICAgICAgICByZW5kZXJMYW5lcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICEwXG4gICAgICAgICAgICAgICAgICAgICAgKSkpLFxuICAgICAgICAgICAgcmVjb25jaWxlQ2hpbGRyZW4oXG4gICAgICAgICAgICAgIGN1cnJlbnQsXG4gICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLFxuICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5wZW5kaW5nUHJvcHMuY2hpbGRyZW4sXG4gICAgICAgICAgICAgIHJlbmRlckxhbmVzXG4gICAgICAgICAgICApLFxuICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MuY2hpbGRcbiAgICAgICAgICApO1xuICAgICAgICBjYXNlIDI5OlxuICAgICAgICAgIHRocm93IHdvcmtJblByb2dyZXNzLnBlbmRpbmdQcm9wcztcbiAgICAgIH1cbiAgICAgIHRocm93IEVycm9yKFxuICAgICAgICBcIlVua25vd24gdW5pdCBvZiB3b3JrIHRhZyAoXCIgK1xuICAgICAgICAgIHdvcmtJblByb2dyZXNzLnRhZyArXG4gICAgICAgICAgXCIpLiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLlwiXG4gICAgICApO1xuICAgIH1cbiAgICBmdW5jdGlvbiByZXNldENvbnRleHREZXBlbmRlbmNpZXMoKSB7XG4gICAgICBsYXN0Q29udGV4dERlcGVuZGVuY3kgPSBjdXJyZW50bHlSZW5kZXJpbmdGaWJlciA9IG51bGw7XG4gICAgICBpc0Rpc2FsbG93ZWRDb250ZXh0UmVhZEluREVWID0gITE7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHB1c2hQcm92aWRlcihwcm92aWRlckZpYmVyLCBjb250ZXh0LCBuZXh0VmFsdWUpIHtcbiAgICAgIGlzUHJpbWFyeVJlbmRlcmVyXG4gICAgICAgID8gKHB1c2godmFsdWVDdXJzb3IsIGNvbnRleHQuX2N1cnJlbnRWYWx1ZSwgcHJvdmlkZXJGaWJlciksXG4gICAgICAgICAgKGNvbnRleHQuX2N1cnJlbnRWYWx1ZSA9IG5leHRWYWx1ZSksXG4gICAgICAgICAgcHVzaChyZW5kZXJlckN1cnNvckRFViwgY29udGV4dC5fY3VycmVudFJlbmRlcmVyLCBwcm92aWRlckZpYmVyKSxcbiAgICAgICAgICB2b2lkIDAgIT09IGNvbnRleHQuX2N1cnJlbnRSZW5kZXJlciAmJlxuICAgICAgICAgICAgbnVsbCAhPT0gY29udGV4dC5fY3VycmVudFJlbmRlcmVyICYmXG4gICAgICAgICAgICBjb250ZXh0Ll9jdXJyZW50UmVuZGVyZXIgIT09IHJlbmRlcmVyU2lnaWwgJiZcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgIFwiRGV0ZWN0ZWQgbXVsdGlwbGUgcmVuZGVyZXJzIGNvbmN1cnJlbnRseSByZW5kZXJpbmcgdGhlIHNhbWUgY29udGV4dCBwcm92aWRlci4gVGhpcyBpcyBjdXJyZW50bHkgdW5zdXBwb3J0ZWQuXCJcbiAgICAgICAgICAgICksXG4gICAgICAgICAgKGNvbnRleHQuX2N1cnJlbnRSZW5kZXJlciA9IHJlbmRlcmVyU2lnaWwpKVxuICAgICAgICA6IChwdXNoKHZhbHVlQ3Vyc29yLCBjb250ZXh0Ll9jdXJyZW50VmFsdWUyLCBwcm92aWRlckZpYmVyKSxcbiAgICAgICAgICAoY29udGV4dC5fY3VycmVudFZhbHVlMiA9IG5leHRWYWx1ZSksXG4gICAgICAgICAgcHVzaChyZW5kZXJlcjJDdXJzb3JERVYsIGNvbnRleHQuX2N1cnJlbnRSZW5kZXJlcjIsIHByb3ZpZGVyRmliZXIpLFxuICAgICAgICAgIHZvaWQgMCAhPT0gY29udGV4dC5fY3VycmVudFJlbmRlcmVyMiAmJlxuICAgICAgICAgICAgbnVsbCAhPT0gY29udGV4dC5fY3VycmVudFJlbmRlcmVyMiAmJlxuICAgICAgICAgICAgY29udGV4dC5fY3VycmVudFJlbmRlcmVyMiAhPT0gcmVuZGVyZXJTaWdpbCAmJlxuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgXCJEZXRlY3RlZCBtdWx0aXBsZSByZW5kZXJlcnMgY29uY3VycmVudGx5IHJlbmRlcmluZyB0aGUgc2FtZSBjb250ZXh0IHByb3ZpZGVyLiBUaGlzIGlzIGN1cnJlbnRseSB1bnN1cHBvcnRlZC5cIlxuICAgICAgICAgICAgKSxcbiAgICAgICAgICAoY29udGV4dC5fY3VycmVudFJlbmRlcmVyMiA9IHJlbmRlcmVyU2lnaWwpKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcG9wUHJvdmlkZXIoY29udGV4dCwgcHJvdmlkZXJGaWJlcikge1xuICAgICAgdmFyIGN1cnJlbnRWYWx1ZSA9IHZhbHVlQ3Vyc29yLmN1cnJlbnQ7XG4gICAgICBpc1ByaW1hcnlSZW5kZXJlclxuICAgICAgICA/ICgoY29udGV4dC5fY3VycmVudFZhbHVlID0gY3VycmVudFZhbHVlKSxcbiAgICAgICAgICAoY3VycmVudFZhbHVlID0gcmVuZGVyZXJDdXJzb3JERVYuY3VycmVudCksXG4gICAgICAgICAgcG9wKHJlbmRlcmVyQ3Vyc29yREVWLCBwcm92aWRlckZpYmVyKSxcbiAgICAgICAgICAoY29udGV4dC5fY3VycmVudFJlbmRlcmVyID0gY3VycmVudFZhbHVlKSlcbiAgICAgICAgOiAoKGNvbnRleHQuX2N1cnJlbnRWYWx1ZTIgPSBjdXJyZW50VmFsdWUpLFxuICAgICAgICAgIChjdXJyZW50VmFsdWUgPSByZW5kZXJlcjJDdXJzb3JERVYuY3VycmVudCksXG4gICAgICAgICAgcG9wKHJlbmRlcmVyMkN1cnNvckRFViwgcHJvdmlkZXJGaWJlciksXG4gICAgICAgICAgKGNvbnRleHQuX2N1cnJlbnRSZW5kZXJlcjIgPSBjdXJyZW50VmFsdWUpKTtcbiAgICAgIHBvcCh2YWx1ZUN1cnNvciwgcHJvdmlkZXJGaWJlcik7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHNjaGVkdWxlQ29udGV4dFdvcmtPblBhcmVudFBhdGgoXG4gICAgICBwYXJlbnQsXG4gICAgICByZW5kZXJMYW5lcyxcbiAgICAgIHByb3BhZ2F0aW9uUm9vdFxuICAgICkge1xuICAgICAgZm9yICg7IG51bGwgIT09IHBhcmVudDsgKSB7XG4gICAgICAgIHZhciBhbHRlcm5hdGUgPSBwYXJlbnQuYWx0ZXJuYXRlO1xuICAgICAgICAocGFyZW50LmNoaWxkTGFuZXMgJiByZW5kZXJMYW5lcykgIT09IHJlbmRlckxhbmVzXG4gICAgICAgICAgPyAoKHBhcmVudC5jaGlsZExhbmVzIHw9IHJlbmRlckxhbmVzKSxcbiAgICAgICAgICAgIG51bGwgIT09IGFsdGVybmF0ZSAmJiAoYWx0ZXJuYXRlLmNoaWxkTGFuZXMgfD0gcmVuZGVyTGFuZXMpKVxuICAgICAgICAgIDogbnVsbCAhPT0gYWx0ZXJuYXRlICYmXG4gICAgICAgICAgICAoYWx0ZXJuYXRlLmNoaWxkTGFuZXMgJiByZW5kZXJMYW5lcykgIT09IHJlbmRlckxhbmVzICYmXG4gICAgICAgICAgICAoYWx0ZXJuYXRlLmNoaWxkTGFuZXMgfD0gcmVuZGVyTGFuZXMpO1xuICAgICAgICBpZiAocGFyZW50ID09PSBwcm9wYWdhdGlvblJvb3QpIGJyZWFrO1xuICAgICAgICBwYXJlbnQgPSBwYXJlbnQucmV0dXJuO1xuICAgICAgfVxuICAgICAgcGFyZW50ICE9PSBwcm9wYWdhdGlvblJvb3QgJiZcbiAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICBcIkV4cGVjdGVkIHRvIGZpbmQgdGhlIHByb3BhZ2F0aW9uIHJvb3Qgd2hlbiBzY2hlZHVsaW5nIGNvbnRleHQgd29yay4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS5cIlxuICAgICAgICApO1xuICAgIH1cbiAgICBmdW5jdGlvbiBwcm9wYWdhdGVDb250ZXh0Q2hhbmdlcyhcbiAgICAgIHdvcmtJblByb2dyZXNzLFxuICAgICAgY29udGV4dHMsXG4gICAgICByZW5kZXJMYW5lcyxcbiAgICAgIGZvcmNlUHJvcGFnYXRlRW50aXJlVHJlZVxuICAgICkge1xuICAgICAgdmFyIGZpYmVyID0gd29ya0luUHJvZ3Jlc3MuY2hpbGQ7XG4gICAgICBudWxsICE9PSBmaWJlciAmJiAoZmliZXIucmV0dXJuID0gd29ya0luUHJvZ3Jlc3MpO1xuICAgICAgZm9yICg7IG51bGwgIT09IGZpYmVyOyApIHtcbiAgICAgICAgdmFyIGxpc3QgPSBmaWJlci5kZXBlbmRlbmNpZXM7XG4gICAgICAgIGlmIChudWxsICE9PSBsaXN0KSB7XG4gICAgICAgICAgdmFyIG5leHRGaWJlciA9IGZpYmVyLmNoaWxkO1xuICAgICAgICAgIGxpc3QgPSBsaXN0LmZpcnN0Q29udGV4dDtcbiAgICAgICAgICBhOiBmb3IgKDsgbnVsbCAhPT0gbGlzdDsgKSB7XG4gICAgICAgICAgICB2YXIgZGVwZW5kZW5jeSA9IGxpc3Q7XG4gICAgICAgICAgICBsaXN0ID0gZmliZXI7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvbnRleHRzLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgICBpZiAoZGVwZW5kZW5jeS5jb250ZXh0ID09PSBjb250ZXh0c1tpXSkge1xuICAgICAgICAgICAgICAgIGxpc3QubGFuZXMgfD0gcmVuZGVyTGFuZXM7XG4gICAgICAgICAgICAgICAgZGVwZW5kZW5jeSA9IGxpc3QuYWx0ZXJuYXRlO1xuICAgICAgICAgICAgICAgIG51bGwgIT09IGRlcGVuZGVuY3kgJiYgKGRlcGVuZGVuY3kubGFuZXMgfD0gcmVuZGVyTGFuZXMpO1xuICAgICAgICAgICAgICAgIHNjaGVkdWxlQ29udGV4dFdvcmtPblBhcmVudFBhdGgoXG4gICAgICAgICAgICAgICAgICBsaXN0LnJldHVybixcbiAgICAgICAgICAgICAgICAgIHJlbmRlckxhbmVzLFxuICAgICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3NcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIGZvcmNlUHJvcGFnYXRlRW50aXJlVHJlZSB8fCAobmV4dEZpYmVyID0gbnVsbCk7XG4gICAgICAgICAgICAgICAgYnJlYWsgYTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGlzdCA9IGRlcGVuZGVuY3kubmV4dDtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoMTggPT09IGZpYmVyLnRhZykge1xuICAgICAgICAgIG5leHRGaWJlciA9IGZpYmVyLnJldHVybjtcbiAgICAgICAgICBpZiAobnVsbCA9PT0gbmV4dEZpYmVyKVxuICAgICAgICAgICAgdGhyb3cgRXJyb3IoXG4gICAgICAgICAgICAgIFwiV2UganVzdCBjYW1lIGZyb20gYSBwYXJlbnQgc28gd2UgbXVzdCBoYXZlIGhhZCBhIHBhcmVudC4gVGhpcyBpcyBhIGJ1ZyBpbiBSZWFjdC5cIlxuICAgICAgICAgICAgKTtcbiAgICAgICAgICBuZXh0RmliZXIubGFuZXMgfD0gcmVuZGVyTGFuZXM7XG4gICAgICAgICAgbGlzdCA9IG5leHRGaWJlci5hbHRlcm5hdGU7XG4gICAgICAgICAgbnVsbCAhPT0gbGlzdCAmJiAobGlzdC5sYW5lcyB8PSByZW5kZXJMYW5lcyk7XG4gICAgICAgICAgc2NoZWR1bGVDb250ZXh0V29ya09uUGFyZW50UGF0aChcbiAgICAgICAgICAgIG5leHRGaWJlcixcbiAgICAgICAgICAgIHJlbmRlckxhbmVzLFxuICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3NcbiAgICAgICAgICApO1xuICAgICAgICAgIG5leHRGaWJlciA9IG51bGw7XG4gICAgICAgIH0gZWxzZSBuZXh0RmliZXIgPSBmaWJlci5jaGlsZDtcbiAgICAgICAgaWYgKG51bGwgIT09IG5leHRGaWJlcikgbmV4dEZpYmVyLnJldHVybiA9IGZpYmVyO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgZm9yIChuZXh0RmliZXIgPSBmaWJlcjsgbnVsbCAhPT0gbmV4dEZpYmVyOyApIHtcbiAgICAgICAgICAgIGlmIChuZXh0RmliZXIgPT09IHdvcmtJblByb2dyZXNzKSB7XG4gICAgICAgICAgICAgIG5leHRGaWJlciA9IG51bGw7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZmliZXIgPSBuZXh0RmliZXIuc2libGluZztcbiAgICAgICAgICAgIGlmIChudWxsICE9PSBmaWJlcikge1xuICAgICAgICAgICAgICBmaWJlci5yZXR1cm4gPSBuZXh0RmliZXIucmV0dXJuO1xuICAgICAgICAgICAgICBuZXh0RmliZXIgPSBmaWJlcjtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBuZXh0RmliZXIgPSBuZXh0RmliZXIucmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgZmliZXIgPSBuZXh0RmliZXI7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIHByb3BhZ2F0ZVBhcmVudENvbnRleHRDaGFuZ2VzKFxuICAgICAgY3VycmVudCxcbiAgICAgIHdvcmtJblByb2dyZXNzLFxuICAgICAgcmVuZGVyTGFuZXMsXG4gICAgICBmb3JjZVByb3BhZ2F0ZUVudGlyZVRyZWVcbiAgICApIHtcbiAgICAgIGN1cnJlbnQgPSBudWxsO1xuICAgICAgZm9yIChcbiAgICAgICAgdmFyIHBhcmVudCA9IHdvcmtJblByb2dyZXNzLCBpc0luc2lkZVByb3BhZ2F0aW9uQmFpbG91dCA9ICExO1xuICAgICAgICBudWxsICE9PSBwYXJlbnQ7XG5cbiAgICAgICkge1xuICAgICAgICBpZiAoIWlzSW5zaWRlUHJvcGFnYXRpb25CYWlsb3V0KVxuICAgICAgICAgIGlmICgwICE9PSAocGFyZW50LmZsYWdzICYgNTI0Mjg4KSkgaXNJbnNpZGVQcm9wYWdhdGlvbkJhaWxvdXQgPSAhMDtcbiAgICAgICAgICBlbHNlIGlmICgwICE9PSAocGFyZW50LmZsYWdzICYgMjYyMTQ0KSkgYnJlYWs7XG4gICAgICAgIGlmICgxMCA9PT0gcGFyZW50LnRhZykge1xuICAgICAgICAgIHZhciBjdXJyZW50UGFyZW50ID0gcGFyZW50LmFsdGVybmF0ZTtcbiAgICAgICAgICBpZiAobnVsbCA9PT0gY3VycmVudFBhcmVudClcbiAgICAgICAgICAgIHRocm93IEVycm9yKFwiU2hvdWxkIGhhdmUgYSBjdXJyZW50IGZpYmVyLiBUaGlzIGlzIGEgYnVnIGluIFJlYWN0LlwiKTtcbiAgICAgICAgICBjdXJyZW50UGFyZW50ID0gY3VycmVudFBhcmVudC5tZW1vaXplZFByb3BzO1xuICAgICAgICAgIGlmIChudWxsICE9PSBjdXJyZW50UGFyZW50KSB7XG4gICAgICAgICAgICB2YXIgY29udGV4dCA9IHBhcmVudC50eXBlO1xuICAgICAgICAgICAgb2JqZWN0SXMocGFyZW50LnBlbmRpbmdQcm9wcy52YWx1ZSwgY3VycmVudFBhcmVudC52YWx1ZSkgfHxcbiAgICAgICAgICAgICAgKG51bGwgIT09IGN1cnJlbnRcbiAgICAgICAgICAgICAgICA/IGN1cnJlbnQucHVzaChjb250ZXh0KVxuICAgICAgICAgICAgICAgIDogKGN1cnJlbnQgPSBbY29udGV4dF0pKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAocGFyZW50ID09PSBob3N0VHJhbnNpdGlvblByb3ZpZGVyQ3Vyc29yLmN1cnJlbnQpIHtcbiAgICAgICAgICBjdXJyZW50UGFyZW50ID0gcGFyZW50LmFsdGVybmF0ZTtcbiAgICAgICAgICBpZiAobnVsbCA9PT0gY3VycmVudFBhcmVudClcbiAgICAgICAgICAgIHRocm93IEVycm9yKFwiU2hvdWxkIGhhdmUgYSBjdXJyZW50IGZpYmVyLiBUaGlzIGlzIGEgYnVnIGluIFJlYWN0LlwiKTtcbiAgICAgICAgICBjdXJyZW50UGFyZW50Lm1lbW9pemVkU3RhdGUubWVtb2l6ZWRTdGF0ZSAhPT1cbiAgICAgICAgICAgIHBhcmVudC5tZW1vaXplZFN0YXRlLm1lbW9pemVkU3RhdGUgJiZcbiAgICAgICAgICAgIChudWxsICE9PSBjdXJyZW50XG4gICAgICAgICAgICAgID8gY3VycmVudC5wdXNoKEhvc3RUcmFuc2l0aW9uQ29udGV4dClcbiAgICAgICAgICAgICAgOiAoY3VycmVudCA9IFtIb3N0VHJhbnNpdGlvbkNvbnRleHRdKSk7XG4gICAgICAgIH1cbiAgICAgICAgcGFyZW50ID0gcGFyZW50LnJldHVybjtcbiAgICAgIH1cbiAgICAgIG51bGwgIT09IGN1cnJlbnQgJiZcbiAgICAgICAgcHJvcGFnYXRlQ29udGV4dENoYW5nZXMoXG4gICAgICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gICAgICAgICAgY3VycmVudCxcbiAgICAgICAgICByZW5kZXJMYW5lcyxcbiAgICAgICAgICBmb3JjZVByb3BhZ2F0ZUVudGlyZVRyZWVcbiAgICAgICAgKTtcbiAgICAgIHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IDI2MjE0NDtcbiAgICB9XG4gICAgZnVuY3Rpb24gY2hlY2tJZkNvbnRleHRDaGFuZ2VkKGN1cnJlbnREZXBlbmRlbmNpZXMpIHtcbiAgICAgIGZvciAoXG4gICAgICAgIGN1cnJlbnREZXBlbmRlbmNpZXMgPSBjdXJyZW50RGVwZW5kZW5jaWVzLmZpcnN0Q29udGV4dDtcbiAgICAgICAgbnVsbCAhPT0gY3VycmVudERlcGVuZGVuY2llcztcblxuICAgICAgKSB7XG4gICAgICAgIHZhciBjb250ZXh0ID0gY3VycmVudERlcGVuZGVuY2llcy5jb250ZXh0O1xuICAgICAgICBpZiAoXG4gICAgICAgICAgIW9iamVjdElzKFxuICAgICAgICAgICAgaXNQcmltYXJ5UmVuZGVyZXIgPyBjb250ZXh0Ll9jdXJyZW50VmFsdWUgOiBjb250ZXh0Ll9jdXJyZW50VmFsdWUyLFxuICAgICAgICAgICAgY3VycmVudERlcGVuZGVuY2llcy5tZW1vaXplZFZhbHVlXG4gICAgICAgICAgKVxuICAgICAgICApXG4gICAgICAgICAgcmV0dXJuICEwO1xuICAgICAgICBjdXJyZW50RGVwZW5kZW5jaWVzID0gY3VycmVudERlcGVuZGVuY2llcy5uZXh0O1xuICAgICAgfVxuICAgICAgcmV0dXJuICExO1xuICAgIH1cbiAgICBmdW5jdGlvbiBwcmVwYXJlVG9SZWFkQ29udGV4dCh3b3JrSW5Qcm9ncmVzcykge1xuICAgICAgY3VycmVudGx5UmVuZGVyaW5nRmliZXIgPSB3b3JrSW5Qcm9ncmVzcztcbiAgICAgIGxhc3RDb250ZXh0RGVwZW5kZW5jeSA9IG51bGw7XG4gICAgICB3b3JrSW5Qcm9ncmVzcyA9IHdvcmtJblByb2dyZXNzLmRlcGVuZGVuY2llcztcbiAgICAgIG51bGwgIT09IHdvcmtJblByb2dyZXNzICYmICh3b3JrSW5Qcm9ncmVzcy5maXJzdENvbnRleHQgPSBudWxsKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcmVhZENvbnRleHQoY29udGV4dCkge1xuICAgICAgaXNEaXNhbGxvd2VkQ29udGV4dFJlYWRJbkRFViAmJlxuICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgIFwiQ29udGV4dCBjYW4gb25seSBiZSByZWFkIHdoaWxlIFJlYWN0IGlzIHJlbmRlcmluZy4gSW4gY2xhc3NlcywgeW91IGNhbiByZWFkIGl0IGluIHRoZSByZW5kZXIgbWV0aG9kIG9yIGdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcy4gSW4gZnVuY3Rpb24gY29tcG9uZW50cywgeW91IGNhbiByZWFkIGl0IGRpcmVjdGx5IGluIHRoZSBmdW5jdGlvbiBib2R5LCBidXQgbm90IGluc2lkZSBIb29rcyBsaWtlIHVzZVJlZHVjZXIoKSBvciB1c2VNZW1vKCkuXCJcbiAgICAgICAgKTtcbiAgICAgIHJldHVybiByZWFkQ29udGV4dEZvckNvbnN1bWVyKGN1cnJlbnRseVJlbmRlcmluZ0ZpYmVyLCBjb250ZXh0KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcmVhZENvbnRleHREdXJpbmdSZWNvbmNpbGlhdGlvbihjb25zdW1lciwgY29udGV4dCkge1xuICAgICAgbnVsbCA9PT0gY3VycmVudGx5UmVuZGVyaW5nRmliZXIgJiYgcHJlcGFyZVRvUmVhZENvbnRleHQoY29uc3VtZXIpO1xuICAgICAgcmV0dXJuIHJlYWRDb250ZXh0Rm9yQ29uc3VtZXIoY29uc3VtZXIsIGNvbnRleHQpO1xuICAgIH1cbiAgICBmdW5jdGlvbiByZWFkQ29udGV4dEZvckNvbnN1bWVyKGNvbnN1bWVyLCBjb250ZXh0KSB7XG4gICAgICB2YXIgdmFsdWUgPSBpc1ByaW1hcnlSZW5kZXJlclxuICAgICAgICA/IGNvbnRleHQuX2N1cnJlbnRWYWx1ZVxuICAgICAgICA6IGNvbnRleHQuX2N1cnJlbnRWYWx1ZTI7XG4gICAgICBjb250ZXh0ID0geyBjb250ZXh0OiBjb250ZXh0LCBtZW1vaXplZFZhbHVlOiB2YWx1ZSwgbmV4dDogbnVsbCB9O1xuICAgICAgaWYgKG51bGwgPT09IGxhc3RDb250ZXh0RGVwZW5kZW5jeSkge1xuICAgICAgICBpZiAobnVsbCA9PT0gY29uc3VtZXIpXG4gICAgICAgICAgdGhyb3cgRXJyb3IoXG4gICAgICAgICAgICBcIkNvbnRleHQgY2FuIG9ubHkgYmUgcmVhZCB3aGlsZSBSZWFjdCBpcyByZW5kZXJpbmcuIEluIGNsYXNzZXMsIHlvdSBjYW4gcmVhZCBpdCBpbiB0aGUgcmVuZGVyIG1ldGhvZCBvciBnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMuIEluIGZ1bmN0aW9uIGNvbXBvbmVudHMsIHlvdSBjYW4gcmVhZCBpdCBkaXJlY3RseSBpbiB0aGUgZnVuY3Rpb24gYm9keSwgYnV0IG5vdCBpbnNpZGUgSG9va3MgbGlrZSB1c2VSZWR1Y2VyKCkgb3IgdXNlTWVtbygpLlwiXG4gICAgICAgICAgKTtcbiAgICAgICAgbGFzdENvbnRleHREZXBlbmRlbmN5ID0gY29udGV4dDtcbiAgICAgICAgY29uc3VtZXIuZGVwZW5kZW5jaWVzID0ge1xuICAgICAgICAgIGxhbmVzOiAwLFxuICAgICAgICAgIGZpcnN0Q29udGV4dDogY29udGV4dCxcbiAgICAgICAgICBfZGVidWdUaGVuYWJsZVN0YXRlOiBudWxsXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN1bWVyLmZsYWdzIHw9IDUyNDI4ODtcbiAgICAgIH0gZWxzZSBsYXN0Q29udGV4dERlcGVuZGVuY3kgPSBsYXN0Q29udGV4dERlcGVuZGVuY3kubmV4dCA9IGNvbnRleHQ7XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNyZWF0ZUNhY2hlKCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgY29udHJvbGxlcjogbmV3IEFib3J0Q29udHJvbGxlckxvY2FsKCksXG4gICAgICAgIGRhdGE6IG5ldyBNYXAoKSxcbiAgICAgICAgcmVmQ291bnQ6IDBcbiAgICAgIH07XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJldGFpbkNhY2hlKGNhY2hlKSB7XG4gICAgICBjYWNoZS5jb250cm9sbGVyLnNpZ25hbC5hYm9ydGVkICYmXG4gICAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgICBcIkEgY2FjaGUgaW5zdGFuY2Ugd2FzIHJldGFpbmVkIGFmdGVyIGl0IHdhcyBhbHJlYWR5IGZyZWVkLiBUaGlzIGxpa2VseSBpbmRpY2F0ZXMgYSBidWcgaW4gUmVhY3QuXCJcbiAgICAgICAgKTtcbiAgICAgIGNhY2hlLnJlZkNvdW50Kys7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlbGVhc2VDYWNoZShjYWNoZSkge1xuICAgICAgY2FjaGUucmVmQ291bnQtLTtcbiAgICAgIDAgPiBjYWNoZS5yZWZDb3VudCAmJlxuICAgICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgICAgXCJBIGNhY2hlIGluc3RhbmNlIHdhcyByZWxlYXNlZCBhZnRlciBpdCB3YXMgYWxyZWFkeSBmcmVlZC4gVGhpcyBsaWtlbHkgaW5kaWNhdGVzIGEgYnVnIGluIFJlYWN0LlwiXG4gICAgICAgICk7XG4gICAgICAwID09PSBjYWNoZS5yZWZDb3VudCAmJlxuICAgICAgICBzY2hlZHVsZUNhbGxiYWNrJDEoTm9ybWFsUHJpb3JpdHksIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBjYWNoZS5jb250cm9sbGVyLmFib3J0KCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBmdW5jdGlvbiBwZWVrQ2FjaGVGcm9tUG9vbCgpIHtcbiAgICAgIHZhciBjYWNoZVJlc3VtZWRGcm9tUHJldmlvdXNSZW5kZXIgPSByZXN1bWVkQ2FjaGUuY3VycmVudDtcbiAgICAgIHJldHVybiBudWxsICE9PSBjYWNoZVJlc3VtZWRGcm9tUHJldmlvdXNSZW5kZXJcbiAgICAgICAgPyBjYWNoZVJlc3VtZWRGcm9tUHJldmlvdXNSZW5kZXJcbiAgICAgICAgOiB3b3JrSW5Qcm9ncmVzc1Jvb3QucG9vbGVkQ2FjaGU7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHB1c2hUcmFuc2l0aW9uKG9mZnNjcmVlbldvcmtJblByb2dyZXNzLCBwcmV2Q2FjaGVQb29sKSB7XG4gICAgICBudWxsID09PSBwcmV2Q2FjaGVQb29sXG4gICAgICAgID8gcHVzaChyZXN1bWVkQ2FjaGUsIHJlc3VtZWRDYWNoZS5jdXJyZW50LCBvZmZzY3JlZW5Xb3JrSW5Qcm9ncmVzcylcbiAgICAgICAgOiBwdXNoKHJlc3VtZWRDYWNoZSwgcHJldkNhY2hlUG9vbC5wb29sLCBvZmZzY3JlZW5Xb3JrSW5Qcm9ncmVzcyk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGdldFN1c3BlbmRlZENhY2hlKCkge1xuICAgICAgdmFyIGNhY2hlRnJvbVBvb2wgPSBwZWVrQ2FjaGVGcm9tUG9vbCgpO1xuICAgICAgcmV0dXJuIG51bGwgPT09IGNhY2hlRnJvbVBvb2xcbiAgICAgICAgPyBudWxsXG4gICAgICAgIDoge1xuICAgICAgICAgICAgcGFyZW50OiBpc1ByaW1hcnlSZW5kZXJlclxuICAgICAgICAgICAgICA/IENhY2hlQ29udGV4dC5fY3VycmVudFZhbHVlXG4gICAgICAgICAgICAgIDogQ2FjaGVDb250ZXh0Ll9jdXJyZW50VmFsdWUyLFxuICAgICAgICAgICAgcG9vbDogY2FjaGVGcm9tUG9vbFxuICAgICAgICAgIH07XG4gICAgfVxuICAgIGZ1bmN0aW9uIG1hcmtVcGRhdGUod29ya0luUHJvZ3Jlc3MpIHtcbiAgICAgIHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IDQ7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGRvZXNSZXF1aXJlQ2xvbmUoY3VycmVudCwgY29tcGxldGVkV29yaykge1xuICAgICAgaWYgKG51bGwgIT09IGN1cnJlbnQgJiYgY3VycmVudC5jaGlsZCA9PT0gY29tcGxldGVkV29yay5jaGlsZCkgcmV0dXJuICExO1xuICAgICAgaWYgKDAgIT09IChjb21wbGV0ZWRXb3JrLmZsYWdzICYgMTYpKSByZXR1cm4gITA7XG4gICAgICBmb3IgKGN1cnJlbnQgPSBjb21wbGV0ZWRXb3JrLmNoaWxkOyBudWxsICE9PSBjdXJyZW50OyApIHtcbiAgICAgICAgaWYgKFxuICAgICAgICAgIDAgIT09IChjdXJyZW50LmZsYWdzICYgMTM4NzgpIHx8XG4gICAgICAgICAgMCAhPT0gKGN1cnJlbnQuc3VidHJlZUZsYWdzICYgMTM4NzgpXG4gICAgICAgIClcbiAgICAgICAgICByZXR1cm4gITA7XG4gICAgICAgIGN1cnJlbnQgPSBjdXJyZW50LnNpYmxpbmc7XG4gICAgICB9XG4gICAgICByZXR1cm4gITE7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGFwcGVuZEFsbENoaWxkcmVuKFxuICAgICAgcGFyZW50LFxuICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gICAgICBuZWVkc1Zpc2liaWxpdHlUb2dnbGUsXG4gICAgICBpc0hpZGRlblxuICAgICkge1xuICAgICAgaWYgKHN1cHBvcnRzTXV0YXRpb24pXG4gICAgICAgIGZvciAoXG4gICAgICAgICAgbmVlZHNWaXNpYmlsaXR5VG9nZ2xlID0gd29ya0luUHJvZ3Jlc3MuY2hpbGQ7XG4gICAgICAgICAgbnVsbCAhPT0gbmVlZHNWaXNpYmlsaXR5VG9nZ2xlO1xuXG4gICAgICAgICkge1xuICAgICAgICAgIGlmIChcbiAgICAgICAgICAgIDUgPT09IG5lZWRzVmlzaWJpbGl0eVRvZ2dsZS50YWcgfHxcbiAgICAgICAgICAgIDYgPT09IG5lZWRzVmlzaWJpbGl0eVRvZ2dsZS50YWdcbiAgICAgICAgICApXG4gICAgICAgICAgICBhcHBlbmRJbml0aWFsQ2hpbGQocGFyZW50LCBuZWVkc1Zpc2liaWxpdHlUb2dnbGUuc3RhdGVOb2RlKTtcbiAgICAgICAgICBlbHNlIGlmIChcbiAgICAgICAgICAgICEoXG4gICAgICAgICAgICAgIDQgPT09IG5lZWRzVmlzaWJpbGl0eVRvZ2dsZS50YWcgfHxcbiAgICAgICAgICAgICAgKHN1cHBvcnRzU2luZ2xldG9ucyAmJiAyNyA9PT0gbmVlZHNWaXNpYmlsaXR5VG9nZ2xlLnRhZylcbiAgICAgICAgICAgICkgJiZcbiAgICAgICAgICAgIG51bGwgIT09IG5lZWRzVmlzaWJpbGl0eVRvZ2dsZS5jaGlsZFxuICAgICAgICAgICkge1xuICAgICAgICAgICAgbmVlZHNWaXNpYmlsaXR5VG9nZ2xlLmNoaWxkLnJldHVybiA9IG5lZWRzVmlzaWJpbGl0eVRvZ2dsZTtcbiAgICAgICAgICAgIG5lZWRzVmlzaWJpbGl0eVRvZ2dsZSA9IG5lZWRzVmlzaWJpbGl0eVRvZ2dsZS5jaGlsZDtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAobmVlZHNWaXNpYmlsaXR5VG9nZ2xlID09PSB3b3JrSW5Qcm9ncmVzcykgYnJlYWs7XG4gICAgICAgICAgZm9yICg7IG51bGwgPT09IG5lZWRzVmlzaWJpbGl0eVRvZ2dsZS5zaWJsaW5nOyApIHtcbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgbnVsbCA9PT0gbmVlZHNWaXNpYmlsaXR5VG9nZ2xlLnJldHVybiB8fFxuICAgICAgICAgICAgICBuZWVkc1Zpc2liaWxpdHlUb2dnbGUucmV0dXJuID09PSB3b3JrSW5Qcm9ncmVzc1xuICAgICAgICAgICAgKVxuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBuZWVkc1Zpc2liaWxpdHlUb2dnbGUgPSBuZWVkc1Zpc2liaWxpdHlUb2dnbGUucmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBuZWVkc1Zpc2liaWxpdHlUb2dnbGUuc2libGluZy5yZXR1cm4gPSBuZWVkc1Zpc2liaWxpdHlUb2dnbGUucmV0dXJuO1xuICAgICAgICAgIG5lZWRzVmlzaWJpbGl0eVRvZ2dsZSA9IG5lZWRzVmlzaWJpbGl0eVRvZ2dsZS5zaWJsaW5nO1xuICAgICAgICB9XG4gICAgICBlbHNlIGlmIChzdXBwb3J0c1BlcnNpc3RlbmNlKVxuICAgICAgICBmb3IgKHZhciBfbm9kZSA9IHdvcmtJblByb2dyZXNzLmNoaWxkOyBudWxsICE9PSBfbm9kZTsgKSB7XG4gICAgICAgICAgaWYgKDUgPT09IF9ub2RlLnRhZykge1xuICAgICAgICAgICAgdmFyIGluc3RhbmNlID0gX25vZGUuc3RhdGVOb2RlO1xuICAgICAgICAgICAgbmVlZHNWaXNpYmlsaXR5VG9nZ2xlICYmXG4gICAgICAgICAgICAgIGlzSGlkZGVuICYmXG4gICAgICAgICAgICAgIChpbnN0YW5jZSA9IGNsb25lSGlkZGVuSW5zdGFuY2UoXG4gICAgICAgICAgICAgICAgaW5zdGFuY2UsXG4gICAgICAgICAgICAgICAgX25vZGUudHlwZSxcbiAgICAgICAgICAgICAgICBfbm9kZS5tZW1vaXplZFByb3BzXG4gICAgICAgICAgICAgICkpO1xuICAgICAgICAgICAgYXBwZW5kSW5pdGlhbENoaWxkKHBhcmVudCwgaW5zdGFuY2UpO1xuICAgICAgICAgIH0gZWxzZSBpZiAoNiA9PT0gX25vZGUudGFnKVxuICAgICAgICAgICAgKGluc3RhbmNlID0gX25vZGUuc3RhdGVOb2RlKSxcbiAgICAgICAgICAgICAgbmVlZHNWaXNpYmlsaXR5VG9nZ2xlICYmXG4gICAgICAgICAgICAgICAgaXNIaWRkZW4gJiZcbiAgICAgICAgICAgICAgICAoaW5zdGFuY2UgPSBjbG9uZUhpZGRlblRleHRJbnN0YW5jZShcbiAgICAgICAgICAgICAgICAgIGluc3RhbmNlLFxuICAgICAgICAgICAgICAgICAgX25vZGUubWVtb2l6ZWRQcm9wc1xuICAgICAgICAgICAgICAgICkpLFxuICAgICAgICAgICAgICBhcHBlbmRJbml0aWFsQ2hpbGQocGFyZW50LCBpbnN0YW5jZSk7XG4gICAgICAgICAgZWxzZSBpZiAoNCAhPT0gX25vZGUudGFnKVxuICAgICAgICAgICAgaWYgKDIyID09PSBfbm9kZS50YWcgJiYgbnVsbCAhPT0gX25vZGUubWVtb2l6ZWRTdGF0ZSlcbiAgICAgICAgICAgICAgKGluc3RhbmNlID0gX25vZGUuY2hpbGQpLFxuICAgICAgICAgICAgICAgIG51bGwgIT09IGluc3RhbmNlICYmIChpbnN0YW5jZS5yZXR1cm4gPSBfbm9kZSksXG4gICAgICAgICAgICAgICAgYXBwZW5kQWxsQ2hpbGRyZW4ocGFyZW50LCBfbm9kZSwgITAsICEwKTtcbiAgICAgICAgICAgIGVsc2UgaWYgKG51bGwgIT09IF9ub2RlLmNoaWxkKSB7XG4gICAgICAgICAgICAgIF9ub2RlLmNoaWxkLnJldHVybiA9IF9ub2RlO1xuICAgICAgICAgICAgICBfbm9kZSA9IF9ub2RlLmNoaWxkO1xuICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoX25vZGUgPT09IHdvcmtJblByb2dyZXNzKSBicmVhaztcbiAgICAgICAgICBmb3IgKDsgbnVsbCA9PT0gX25vZGUuc2libGluZzsgKSB7XG4gICAgICAgICAgICBpZiAobnVsbCA9PT0gX25vZGUucmV0dXJuIHx8IF9ub2RlLnJldHVybiA9PT0gd29ya0luUHJvZ3Jlc3MpXG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIF9ub2RlID0gX25vZGUucmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBfbm9kZS5zaWJsaW5nLnJldHVybiA9IF9ub2RlLnJldHVybjtcbiAgICAgICAgICBfbm9kZSA9IF9ub2RlLnNpYmxpbmc7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gYXBwZW5kQWxsQ2hpbGRyZW5Ub0NvbnRhaW5lcihcbiAgICAgIGNvbnRhaW5lckNoaWxkU2V0LFxuICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gICAgICBuZWVkc1Zpc2liaWxpdHlUb2dnbGUsXG4gICAgICBpc0hpZGRlblxuICAgICkge1xuICAgICAgaWYgKHN1cHBvcnRzUGVyc2lzdGVuY2UpXG4gICAgICAgIGZvciAodmFyIG5vZGUgPSB3b3JrSW5Qcm9ncmVzcy5jaGlsZDsgbnVsbCAhPT0gbm9kZTsgKSB7XG4gICAgICAgICAgaWYgKDUgPT09IG5vZGUudGFnKSB7XG4gICAgICAgICAgICB2YXIgaW5zdGFuY2UgPSBub2RlLnN0YXRlTm9kZTtcbiAgICAgICAgICAgIG5lZWRzVmlzaWJpbGl0eVRvZ2dsZSAmJlxuICAgICAgICAgICAgICBpc0hpZGRlbiAmJlxuICAgICAgICAgICAgICAoaW5zdGFuY2UgPSBjbG9uZUhpZGRlbkluc3RhbmNlKFxuICAgICAgICAgICAgICAgIGluc3RhbmNlLFxuICAgICAgICAgICAgICAgIG5vZGUudHlwZSxcbiAgICAgICAgICAgICAgICBub2RlLm1lbW9pemVkUHJvcHNcbiAgICAgICAgICAgICAgKSk7XG4gICAgICAgICAgICBhcHBlbmRDaGlsZFRvQ29udGFpbmVyQ2hpbGRTZXQoY29udGFpbmVyQ2hpbGRTZXQsIGluc3RhbmNlKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKDYgPT09IG5vZGUudGFnKVxuICAgICAgICAgICAgKGluc3RhbmNlID0gbm9kZS5zdGF0ZU5vZGUpLFxuICAgICAgICAgICAgICBuZWVkc1Zpc2liaWxpdHlUb2dnbGUgJiZcbiAgICAgICAgICAgICAgICBpc0hpZGRlbiAmJlxuICAgICAgICAgICAgICAgIChpbnN0YW5jZSA9IGNsb25lSGlkZGVuVGV4dEluc3RhbmNlKFxuICAgICAgICAgICAgICAgICAgaW5zdGFuY2UsXG4gICAgICAgICAgICAgICAgICBub2RlLm1lbW9pemVkUHJvcHNcbiAgICAgICAgICAgICAgICApKSxcbiAgICAgICAgICAgICAgYXBwZW5kQ2hpbGRUb0NvbnRhaW5lckNoaWxkU2V0KGNvbnRhaW5lckNoaWxkU2V0LCBpbnN0YW5jZSk7XG4gICAgICAgICAgZWxzZSBpZiAoNCAhPT0gbm9kZS50YWcpXG4gICAgICAgICAgICBpZiAoMjIgPT09IG5vZGUudGFnICYmIG51bGwgIT09IG5vZGUubWVtb2l6ZWRTdGF0ZSlcbiAgICAgICAgICAgICAgKGluc3RhbmNlID0gbm9kZS5jaGlsZCksXG4gICAgICAgICAgICAgICAgbnVsbCAhPT0gaW5zdGFuY2UgJiYgKGluc3RhbmNlLnJldHVybiA9IG5vZGUpLFxuICAgICAgICAgICAgICAgIGFwcGVuZEFsbENoaWxkcmVuVG9Db250YWluZXIoXG4gICAgICAgICAgICAgICAgICBjb250YWluZXJDaGlsZFNldCxcbiAgICAgICAgICAgICAgICAgIG5vZGUsXG4gICAgICAgICAgICAgICAgICAhKFxuICAgICAgICAgICAgICAgICAgICBudWxsICE9PSBub2RlLm1lbW9pemVkUHJvcHMgJiZcbiAgICAgICAgICAgICAgICAgICAgXCJtYW51YWxcIiA9PT0gbm9kZS5tZW1vaXplZFByb3BzLm1vZGVcbiAgICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgICAhMFxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICBlbHNlIGlmIChudWxsICE9PSBub2RlLmNoaWxkKSB7XG4gICAgICAgICAgICAgIG5vZGUuY2hpbGQucmV0dXJuID0gbm9kZTtcbiAgICAgICAgICAgICAgbm9kZSA9IG5vZGUuY2hpbGQ7XG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIGlmIChub2RlID09PSB3b3JrSW5Qcm9ncmVzcykgYnJlYWs7XG4gICAgICAgICAgZm9yICg7IG51bGwgPT09IG5vZGUuc2libGluZzsgKSB7XG4gICAgICAgICAgICBpZiAobnVsbCA9PT0gbm9kZS5yZXR1cm4gfHwgbm9kZS5yZXR1cm4gPT09IHdvcmtJblByb2dyZXNzKSByZXR1cm47XG4gICAgICAgICAgICBub2RlID0gbm9kZS5yZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIG5vZGUuc2libGluZy5yZXR1cm4gPSBub2RlLnJldHVybjtcbiAgICAgICAgICBub2RlID0gbm9kZS5zaWJsaW5nO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIHVwZGF0ZUhvc3RDb250YWluZXIoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MpIHtcbiAgICAgIGlmIChzdXBwb3J0c1BlcnNpc3RlbmNlICYmIGRvZXNSZXF1aXJlQ2xvbmUoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MpKSB7XG4gICAgICAgIGN1cnJlbnQgPSB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGU7XG4gICAgICAgIHZhciBjb250YWluZXIgPSBjdXJyZW50LmNvbnRhaW5lckluZm8sXG4gICAgICAgICAgbmV3Q2hpbGRTZXQgPSBjcmVhdGVDb250YWluZXJDaGlsZFNldCgpO1xuICAgICAgICBhcHBlbmRBbGxDaGlsZHJlblRvQ29udGFpbmVyKG5ld0NoaWxkU2V0LCB3b3JrSW5Qcm9ncmVzcywgITEsICExKTtcbiAgICAgICAgY3VycmVudC5wZW5kaW5nQ2hpbGRyZW4gPSBuZXdDaGlsZFNldDtcbiAgICAgICAgbWFya1VwZGF0ZSh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgIGZpbmFsaXplQ29udGFpbmVyQ2hpbGRyZW4oY29udGFpbmVyLCBuZXdDaGlsZFNldCk7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIHVwZGF0ZUhvc3RDb21wb25lbnQoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHR5cGUsIG5ld1Byb3BzKSB7XG4gICAgICBpZiAoc3VwcG9ydHNNdXRhdGlvbilcbiAgICAgICAgY3VycmVudC5tZW1vaXplZFByb3BzICE9PSBuZXdQcm9wcyAmJiBtYXJrVXBkYXRlKHdvcmtJblByb2dyZXNzKTtcbiAgICAgIGVsc2UgaWYgKHN1cHBvcnRzUGVyc2lzdGVuY2UpIHtcbiAgICAgICAgdmFyIGN1cnJlbnRJbnN0YW5jZSA9IGN1cnJlbnQuc3RhdGVOb2RlLFxuICAgICAgICAgIF9vbGRQcm9wcyA9IGN1cnJlbnQubWVtb2l6ZWRQcm9wcztcbiAgICAgICAgaWYgKFxuICAgICAgICAgIChjdXJyZW50ID0gZG9lc1JlcXVpcmVDbG9uZShjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcykpIHx8XG4gICAgICAgICAgX29sZFByb3BzICE9PSBuZXdQcm9wc1xuICAgICAgICApIHtcbiAgICAgICAgICB2YXIgY3VycmVudEhvc3RDb250ZXh0ID0gZ2V0SG9zdENvbnRleHQoKTtcbiAgICAgICAgICBfb2xkUHJvcHMgPSBjbG9uZUluc3RhbmNlKFxuICAgICAgICAgICAgY3VycmVudEluc3RhbmNlLFxuICAgICAgICAgICAgdHlwZSxcbiAgICAgICAgICAgIF9vbGRQcm9wcyxcbiAgICAgICAgICAgIG5ld1Byb3BzLFxuICAgICAgICAgICAgIWN1cnJlbnQsXG4gICAgICAgICAgICBudWxsXG4gICAgICAgICAgKTtcbiAgICAgICAgICBfb2xkUHJvcHMgPT09IGN1cnJlbnRJbnN0YW5jZVxuICAgICAgICAgICAgPyAod29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlID0gY3VycmVudEluc3RhbmNlKVxuICAgICAgICAgICAgOiAoZmluYWxpemVJbml0aWFsQ2hpbGRyZW4oXG4gICAgICAgICAgICAgICAgX29sZFByb3BzLFxuICAgICAgICAgICAgICAgIHR5cGUsXG4gICAgICAgICAgICAgICAgbmV3UHJvcHMsXG4gICAgICAgICAgICAgICAgY3VycmVudEhvc3RDb250ZXh0XG4gICAgICAgICAgICAgICkgJiYgbWFya1VwZGF0ZSh3b3JrSW5Qcm9ncmVzcyksXG4gICAgICAgICAgICAgICh3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGUgPSBfb2xkUHJvcHMpLFxuICAgICAgICAgICAgICBjdXJyZW50XG4gICAgICAgICAgICAgICAgPyBhcHBlbmRBbGxDaGlsZHJlbihfb2xkUHJvcHMsIHdvcmtJblByb2dyZXNzLCAhMSwgITEpXG4gICAgICAgICAgICAgICAgOiBtYXJrVXBkYXRlKHdvcmtJblByb2dyZXNzKSk7XG4gICAgICAgIH0gZWxzZSB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGUgPSBjdXJyZW50SW5zdGFuY2U7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIHByZWxvYWRJbnN0YW5jZUFuZFN1c3BlbmRJZk5lZWRlZCh3b3JrSW5Qcm9ncmVzcywgdHlwZSwgcHJvcHMpIHtcbiAgICAgIGlmIChtYXlTdXNwZW5kQ29tbWl0KHR5cGUsIHByb3BzKSkge1xuICAgICAgICBpZiAoKCh3b3JrSW5Qcm9ncmVzcy5mbGFncyB8PSAxNjc3NzIxNiksICFwcmVsb2FkSW5zdGFuY2UodHlwZSwgcHJvcHMpKSlcbiAgICAgICAgICBpZiAoc2hvdWxkUmVtYWluT25QcmV2aW91c1NjcmVlbigpKSB3b3JrSW5Qcm9ncmVzcy5mbGFncyB8PSA4MTkyO1xuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIHRocm93IChcbiAgICAgICAgICAgICAgKChzdXNwZW5kZWRUaGVuYWJsZSA9IG5vb3BTdXNwZW5zZXlDb21taXRUaGVuYWJsZSksXG4gICAgICAgICAgICAgIFN1c3BlbnNleUNvbW1pdEV4Y2VwdGlvbilcbiAgICAgICAgICAgICk7XG4gICAgICB9IGVsc2Ugd29ya0luUHJvZ3Jlc3MuZmxhZ3MgJj0gLTE2Nzc3MjE3O1xuICAgIH1cbiAgICBmdW5jdGlvbiBwcmVsb2FkUmVzb3VyY2VBbmRTdXNwZW5kSWZOZWVkZWQod29ya0luUHJvZ3Jlc3MsIHJlc291cmNlKSB7XG4gICAgICBpZiAobWF5UmVzb3VyY2VTdXNwZW5kQ29tbWl0KHJlc291cmNlKSkge1xuICAgICAgICBpZiAoKCh3b3JrSW5Qcm9ncmVzcy5mbGFncyB8PSAxNjc3NzIxNiksICFwcmVsb2FkUmVzb3VyY2UocmVzb3VyY2UpKSlcbiAgICAgICAgICBpZiAoc2hvdWxkUmVtYWluT25QcmV2aW91c1NjcmVlbigpKSB3b3JrSW5Qcm9ncmVzcy5mbGFncyB8PSA4MTkyO1xuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIHRocm93IChcbiAgICAgICAgICAgICAgKChzdXNwZW5kZWRUaGVuYWJsZSA9IG5vb3BTdXNwZW5zZXlDb21taXRUaGVuYWJsZSksXG4gICAgICAgICAgICAgIFN1c3BlbnNleUNvbW1pdEV4Y2VwdGlvbilcbiAgICAgICAgICAgICk7XG4gICAgICB9IGVsc2Ugd29ya0luUHJvZ3Jlc3MuZmxhZ3MgJj0gLTE2Nzc3MjE3O1xuICAgIH1cbiAgICBmdW5jdGlvbiBzY2hlZHVsZVJldHJ5RWZmZWN0KHdvcmtJblByb2dyZXNzLCByZXRyeVF1ZXVlKSB7XG4gICAgICBudWxsICE9PSByZXRyeVF1ZXVlICYmICh3b3JrSW5Qcm9ncmVzcy5mbGFncyB8PSA0KTtcbiAgICAgIHdvcmtJblByb2dyZXNzLmZsYWdzICYgMTYzODQgJiZcbiAgICAgICAgKChyZXRyeVF1ZXVlID1cbiAgICAgICAgICAyMiAhPT0gd29ya0luUHJvZ3Jlc3MudGFnID8gY2xhaW1OZXh0UmV0cnlMYW5lKCkgOiA1MzY4NzA5MTIpLFxuICAgICAgICAod29ya0luUHJvZ3Jlc3MubGFuZXMgfD0gcmV0cnlRdWV1ZSksXG4gICAgICAgICh3b3JrSW5Qcm9ncmVzc1N1c3BlbmRlZFJldHJ5TGFuZXMgfD0gcmV0cnlRdWV1ZSkpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjdXRPZmZUYWlsSWZOZWVkZWQocmVuZGVyU3RhdGUsIGhhc1JlbmRlcmVkQVRhaWxGYWxsYmFjaykge1xuICAgICAgaWYgKCFpc0h5ZHJhdGluZylcbiAgICAgICAgc3dpdGNoIChyZW5kZXJTdGF0ZS50YWlsTW9kZSkge1xuICAgICAgICAgIGNhc2UgXCJoaWRkZW5cIjpcbiAgICAgICAgICAgIGhhc1JlbmRlcmVkQVRhaWxGYWxsYmFjayA9IHJlbmRlclN0YXRlLnRhaWw7XG4gICAgICAgICAgICBmb3IgKHZhciBsYXN0VGFpbE5vZGUgPSBudWxsOyBudWxsICE9PSBoYXNSZW5kZXJlZEFUYWlsRmFsbGJhY2s7IClcbiAgICAgICAgICAgICAgbnVsbCAhPT0gaGFzUmVuZGVyZWRBVGFpbEZhbGxiYWNrLmFsdGVybmF0ZSAmJlxuICAgICAgICAgICAgICAgIChsYXN0VGFpbE5vZGUgPSBoYXNSZW5kZXJlZEFUYWlsRmFsbGJhY2spLFxuICAgICAgICAgICAgICAgIChoYXNSZW5kZXJlZEFUYWlsRmFsbGJhY2sgPSBoYXNSZW5kZXJlZEFUYWlsRmFsbGJhY2suc2libGluZyk7XG4gICAgICAgICAgICBudWxsID09PSBsYXN0VGFpbE5vZGVcbiAgICAgICAgICAgICAgPyAocmVuZGVyU3RhdGUudGFpbCA9IG51bGwpXG4gICAgICAgICAgICAgIDogKGxhc3RUYWlsTm9kZS5zaWJsaW5nID0gbnVsbCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIFwiY29sbGFwc2VkXCI6XG4gICAgICAgICAgICBsYXN0VGFpbE5vZGUgPSByZW5kZXJTdGF0ZS50YWlsO1xuICAgICAgICAgICAgZm9yICh2YXIgX2xhc3RUYWlsTm9kZSA9IG51bGw7IG51bGwgIT09IGxhc3RUYWlsTm9kZTsgKVxuICAgICAgICAgICAgICBudWxsICE9PSBsYXN0VGFpbE5vZGUuYWx0ZXJuYXRlICYmIChfbGFzdFRhaWxOb2RlID0gbGFzdFRhaWxOb2RlKSxcbiAgICAgICAgICAgICAgICAobGFzdFRhaWxOb2RlID0gbGFzdFRhaWxOb2RlLnNpYmxpbmcpO1xuICAgICAgICAgICAgbnVsbCA9PT0gX2xhc3RUYWlsTm9kZVxuICAgICAgICAgICAgICA/IGhhc1JlbmRlcmVkQVRhaWxGYWxsYmFjayB8fCBudWxsID09PSByZW5kZXJTdGF0ZS50YWlsXG4gICAgICAgICAgICAgICAgPyAocmVuZGVyU3RhdGUudGFpbCA9IG51bGwpXG4gICAgICAgICAgICAgICAgOiAocmVuZGVyU3RhdGUudGFpbC5zaWJsaW5nID0gbnVsbClcbiAgICAgICAgICAgICAgOiAoX2xhc3RUYWlsTm9kZS5zaWJsaW5nID0gbnVsbCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gYnViYmxlUHJvcGVydGllcyhjb21wbGV0ZWRXb3JrKSB7XG4gICAgICB2YXIgZGlkQmFpbG91dCA9XG4gICAgICAgICAgbnVsbCAhPT0gY29tcGxldGVkV29yay5hbHRlcm5hdGUgJiZcbiAgICAgICAgICBjb21wbGV0ZWRXb3JrLmFsdGVybmF0ZS5jaGlsZCA9PT0gY29tcGxldGVkV29yay5jaGlsZCxcbiAgICAgICAgbmV3Q2hpbGRMYW5lcyA9IDAsXG4gICAgICAgIHN1YnRyZWVGbGFncyA9IDA7XG4gICAgICBpZiAoZGlkQmFpbG91dClcbiAgICAgICAgaWYgKChjb21wbGV0ZWRXb3JrLm1vZGUgJiAyKSAhPT0gTm9Nb2RlKSB7XG4gICAgICAgICAgZm9yIChcbiAgICAgICAgICAgIHZhciBfdHJlZUJhc2VEdXJhdGlvbiA9IGNvbXBsZXRlZFdvcmsuc2VsZkJhc2VEdXJhdGlvbixcbiAgICAgICAgICAgICAgX2NoaWxkMiA9IGNvbXBsZXRlZFdvcmsuY2hpbGQ7XG4gICAgICAgICAgICBudWxsICE9PSBfY2hpbGQyO1xuXG4gICAgICAgICAgKVxuICAgICAgICAgICAgKG5ld0NoaWxkTGFuZXMgfD0gX2NoaWxkMi5sYW5lcyB8IF9jaGlsZDIuY2hpbGRMYW5lcyksXG4gICAgICAgICAgICAgIChzdWJ0cmVlRmxhZ3MgfD0gX2NoaWxkMi5zdWJ0cmVlRmxhZ3MgJiAzMTQ1NzI4MCksXG4gICAgICAgICAgICAgIChzdWJ0cmVlRmxhZ3MgfD0gX2NoaWxkMi5mbGFncyAmIDMxNDU3MjgwKSxcbiAgICAgICAgICAgICAgKF90cmVlQmFzZUR1cmF0aW9uICs9IF9jaGlsZDIudHJlZUJhc2VEdXJhdGlvbiksXG4gICAgICAgICAgICAgIChfY2hpbGQyID0gX2NoaWxkMi5zaWJsaW5nKTtcbiAgICAgICAgICBjb21wbGV0ZWRXb3JrLnRyZWVCYXNlRHVyYXRpb24gPSBfdHJlZUJhc2VEdXJhdGlvbjtcbiAgICAgICAgfSBlbHNlXG4gICAgICAgICAgZm9yIChcbiAgICAgICAgICAgIF90cmVlQmFzZUR1cmF0aW9uID0gY29tcGxldGVkV29yay5jaGlsZDtcbiAgICAgICAgICAgIG51bGwgIT09IF90cmVlQmFzZUR1cmF0aW9uO1xuXG4gICAgICAgICAgKVxuICAgICAgICAgICAgKG5ld0NoaWxkTGFuZXMgfD1cbiAgICAgICAgICAgICAgX3RyZWVCYXNlRHVyYXRpb24ubGFuZXMgfCBfdHJlZUJhc2VEdXJhdGlvbi5jaGlsZExhbmVzKSxcbiAgICAgICAgICAgICAgKHN1YnRyZWVGbGFncyB8PSBfdHJlZUJhc2VEdXJhdGlvbi5zdWJ0cmVlRmxhZ3MgJiAzMTQ1NzI4MCksXG4gICAgICAgICAgICAgIChzdWJ0cmVlRmxhZ3MgfD0gX3RyZWVCYXNlRHVyYXRpb24uZmxhZ3MgJiAzMTQ1NzI4MCksXG4gICAgICAgICAgICAgIChfdHJlZUJhc2VEdXJhdGlvbi5yZXR1cm4gPSBjb21wbGV0ZWRXb3JrKSxcbiAgICAgICAgICAgICAgKF90cmVlQmFzZUR1cmF0aW9uID0gX3RyZWVCYXNlRHVyYXRpb24uc2libGluZyk7XG4gICAgICBlbHNlIGlmICgoY29tcGxldGVkV29yay5tb2RlICYgMikgIT09IE5vTW9kZSkge1xuICAgICAgICBfdHJlZUJhc2VEdXJhdGlvbiA9IGNvbXBsZXRlZFdvcmsuYWN0dWFsRHVyYXRpb247XG4gICAgICAgIF9jaGlsZDIgPSBjb21wbGV0ZWRXb3JrLnNlbGZCYXNlRHVyYXRpb247XG4gICAgICAgIGZvciAodmFyIGNoaWxkID0gY29tcGxldGVkV29yay5jaGlsZDsgbnVsbCAhPT0gY2hpbGQ7IClcbiAgICAgICAgICAobmV3Q2hpbGRMYW5lcyB8PSBjaGlsZC5sYW5lcyB8IGNoaWxkLmNoaWxkTGFuZXMpLFxuICAgICAgICAgICAgKHN1YnRyZWVGbGFncyB8PSBjaGlsZC5zdWJ0cmVlRmxhZ3MpLFxuICAgICAgICAgICAgKHN1YnRyZWVGbGFncyB8PSBjaGlsZC5mbGFncyksXG4gICAgICAgICAgICAoX3RyZWVCYXNlRHVyYXRpb24gKz0gY2hpbGQuYWN0dWFsRHVyYXRpb24pLFxuICAgICAgICAgICAgKF9jaGlsZDIgKz0gY2hpbGQudHJlZUJhc2VEdXJhdGlvbiksXG4gICAgICAgICAgICAoY2hpbGQgPSBjaGlsZC5zaWJsaW5nKTtcbiAgICAgICAgY29tcGxldGVkV29yay5hY3R1YWxEdXJhdGlvbiA9IF90cmVlQmFzZUR1cmF0aW9uO1xuICAgICAgICBjb21wbGV0ZWRXb3JrLnRyZWVCYXNlRHVyYXRpb24gPSBfY2hpbGQyO1xuICAgICAgfSBlbHNlXG4gICAgICAgIGZvciAoXG4gICAgICAgICAgX3RyZWVCYXNlRHVyYXRpb24gPSBjb21wbGV0ZWRXb3JrLmNoaWxkO1xuICAgICAgICAgIG51bGwgIT09IF90cmVlQmFzZUR1cmF0aW9uO1xuXG4gICAgICAgIClcbiAgICAgICAgICAobmV3Q2hpbGRMYW5lcyB8PVxuICAgICAgICAgICAgX3RyZWVCYXNlRHVyYXRpb24ubGFuZXMgfCBfdHJlZUJhc2VEdXJhdGlvbi5jaGlsZExhbmVzKSxcbiAgICAgICAgICAgIChzdWJ0cmVlRmxhZ3MgfD0gX3RyZWVCYXNlRHVyYXRpb24uc3VidHJlZUZsYWdzKSxcbiAgICAgICAgICAgIChzdWJ0cmVlRmxhZ3MgfD0gX3RyZWVCYXNlRHVyYXRpb24uZmxhZ3MpLFxuICAgICAgICAgICAgKF90cmVlQmFzZUR1cmF0aW9uLnJldHVybiA9IGNvbXBsZXRlZFdvcmspLFxuICAgICAgICAgICAgKF90cmVlQmFzZUR1cmF0aW9uID0gX3RyZWVCYXNlRHVyYXRpb24uc2libGluZyk7XG4gICAgICBjb21wbGV0ZWRXb3JrLnN1YnRyZWVGbGFncyB8PSBzdWJ0cmVlRmxhZ3M7XG4gICAgICBjb21wbGV0ZWRXb3JrLmNoaWxkTGFuZXMgPSBuZXdDaGlsZExhbmVzO1xuICAgICAgcmV0dXJuIGRpZEJhaWxvdXQ7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNvbXBsZXRlV29yayhjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyTGFuZXMpIHtcbiAgICAgIHZhciBuZXdQcm9wcyA9IHdvcmtJblByb2dyZXNzLnBlbmRpbmdQcm9wcztcbiAgICAgIHBvcFRyZWVDb250ZXh0KHdvcmtJblByb2dyZXNzKTtcbiAgICAgIHN3aXRjaCAod29ya0luUHJvZ3Jlc3MudGFnKSB7XG4gICAgICAgIGNhc2UgMTY6XG4gICAgICAgIGNhc2UgMTU6XG4gICAgICAgIGNhc2UgMDpcbiAgICAgICAgY2FzZSAxMTpcbiAgICAgICAgY2FzZSA3OlxuICAgICAgICBjYXNlIDg6XG4gICAgICAgIGNhc2UgMTI6XG4gICAgICAgIGNhc2UgOTpcbiAgICAgICAgY2FzZSAxNDpcbiAgICAgICAgICByZXR1cm4gYnViYmxlUHJvcGVydGllcyh3b3JrSW5Qcm9ncmVzcyksIG51bGw7XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICByZXR1cm4gYnViYmxlUHJvcGVydGllcyh3b3JrSW5Qcm9ncmVzcyksIG51bGw7XG4gICAgICAgIGNhc2UgMzpcbiAgICAgICAgICByZW5kZXJMYW5lcyA9IHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZTtcbiAgICAgICAgICBuZXdQcm9wcyA9IG51bGw7XG4gICAgICAgICAgbnVsbCAhPT0gY3VycmVudCAmJiAobmV3UHJvcHMgPSBjdXJyZW50Lm1lbW9pemVkU3RhdGUuY2FjaGUpO1xuICAgICAgICAgIHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGUuY2FjaGUgIT09IG5ld1Byb3BzICYmXG4gICAgICAgICAgICAod29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gMjA0OCk7XG4gICAgICAgICAgcG9wUHJvdmlkZXIoQ2FjaGVDb250ZXh0LCB3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgICAgcG9wSG9zdENvbnRhaW5lcih3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgICAgcmVuZGVyTGFuZXMucGVuZGluZ0NvbnRleHQgJiZcbiAgICAgICAgICAgICgocmVuZGVyTGFuZXMuY29udGV4dCA9IHJlbmRlckxhbmVzLnBlbmRpbmdDb250ZXh0KSxcbiAgICAgICAgICAgIChyZW5kZXJMYW5lcy5wZW5kaW5nQ29udGV4dCA9IG51bGwpKTtcbiAgICAgICAgICBpZiAobnVsbCA9PT0gY3VycmVudCB8fCBudWxsID09PSBjdXJyZW50LmNoaWxkKVxuICAgICAgICAgICAgcG9wSHlkcmF0aW9uU3RhdGUod29ya0luUHJvZ3Jlc3MpXG4gICAgICAgICAgICAgID8gKGVtaXRQZW5kaW5nSHlkcmF0aW9uV2FybmluZ3MoKSwgbWFya1VwZGF0ZSh3b3JrSW5Qcm9ncmVzcykpXG4gICAgICAgICAgICAgIDogbnVsbCA9PT0gY3VycmVudCB8fFxuICAgICAgICAgICAgICAgIChjdXJyZW50Lm1lbW9pemVkU3RhdGUuaXNEZWh5ZHJhdGVkICYmXG4gICAgICAgICAgICAgICAgICAwID09PSAod29ya0luUHJvZ3Jlc3MuZmxhZ3MgJiAyNTYpKSB8fFxuICAgICAgICAgICAgICAgICgod29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gMTAyNCksXG4gICAgICAgICAgICAgICAgbnVsbCAhPT0gaHlkcmF0aW9uRXJyb3JzICYmXG4gICAgICAgICAgICAgICAgICAocXVldWVSZWNvdmVyYWJsZUVycm9ycyhoeWRyYXRpb25FcnJvcnMpLFxuICAgICAgICAgICAgICAgICAgKGh5ZHJhdGlvbkVycm9ycyA9IG51bGwpKSk7XG4gICAgICAgICAgdXBkYXRlSG9zdENvbnRhaW5lcihjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgICAgYnViYmxlUHJvcGVydGllcyh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIGNhc2UgMjY6XG4gICAgICAgICAgaWYgKHN1cHBvcnRzUmVzb3VyY2VzKSB7XG4gICAgICAgICAgICByZW5kZXJMYW5lcyA9IHdvcmtJblByb2dyZXNzLnR5cGU7XG4gICAgICAgICAgICB2YXIgbmV4dFJlc291cmNlID0gd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZTtcbiAgICAgICAgICAgIG51bGwgPT09IGN1cnJlbnRcbiAgICAgICAgICAgICAgPyAobWFya1VwZGF0ZSh3b3JrSW5Qcm9ncmVzcyksXG4gICAgICAgICAgICAgICAgbnVsbCAhPT0gbmV4dFJlc291cmNlXG4gICAgICAgICAgICAgICAgICA/IChidWJibGVQcm9wZXJ0aWVzKHdvcmtJblByb2dyZXNzKSxcbiAgICAgICAgICAgICAgICAgICAgcHJlbG9hZFJlc291cmNlQW5kU3VzcGVuZElmTmVlZGVkKFxuICAgICAgICAgICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLFxuICAgICAgICAgICAgICAgICAgICAgIG5leHRSZXNvdXJjZVxuICAgICAgICAgICAgICAgICAgICApKVxuICAgICAgICAgICAgICAgICAgOiAoYnViYmxlUHJvcGVydGllcyh3b3JrSW5Qcm9ncmVzcyksXG4gICAgICAgICAgICAgICAgICAgIHByZWxvYWRJbnN0YW5jZUFuZFN1c3BlbmRJZk5lZWRlZChcbiAgICAgICAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgICAgICAgICAgICAgICAgICAgICByZW5kZXJMYW5lcyxcbiAgICAgICAgICAgICAgICAgICAgICBuZXdQcm9wc1xuICAgICAgICAgICAgICAgICAgICApKSlcbiAgICAgICAgICAgICAgOiBuZXh0UmVzb3VyY2VcbiAgICAgICAgICAgICAgICA/IG5leHRSZXNvdXJjZSAhPT0gY3VycmVudC5tZW1vaXplZFN0YXRlXG4gICAgICAgICAgICAgICAgICA/IChtYXJrVXBkYXRlKHdvcmtJblByb2dyZXNzKSxcbiAgICAgICAgICAgICAgICAgICAgYnViYmxlUHJvcGVydGllcyh3b3JrSW5Qcm9ncmVzcyksXG4gICAgICAgICAgICAgICAgICAgIHByZWxvYWRSZXNvdXJjZUFuZFN1c3BlbmRJZk5lZWRlZChcbiAgICAgICAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgICAgICAgICAgICAgICAgICAgICBuZXh0UmVzb3VyY2VcbiAgICAgICAgICAgICAgICAgICAgKSlcbiAgICAgICAgICAgICAgICAgIDogKGJ1YmJsZVByb3BlcnRpZXMod29ya0luUHJvZ3Jlc3MpLFxuICAgICAgICAgICAgICAgICAgICAod29ya0luUHJvZ3Jlc3MuZmxhZ3MgJj0gLTE2Nzc3MjE3KSlcbiAgICAgICAgICAgICAgICA6IChzdXBwb3J0c011dGF0aW9uXG4gICAgICAgICAgICAgICAgICAgID8gY3VycmVudC5tZW1vaXplZFByb3BzICE9PSBuZXdQcm9wcyAmJlxuICAgICAgICAgICAgICAgICAgICAgIG1hcmtVcGRhdGUod29ya0luUHJvZ3Jlc3MpXG4gICAgICAgICAgICAgICAgICAgIDogdXBkYXRlSG9zdENvbXBvbmVudChcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnQsXG4gICAgICAgICAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlbmRlckxhbmVzLFxuICAgICAgICAgICAgICAgICAgICAgICAgbmV3UHJvcHNcbiAgICAgICAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgICAgYnViYmxlUHJvcGVydGllcyh3b3JrSW5Qcm9ncmVzcyksXG4gICAgICAgICAgICAgICAgICBwcmVsb2FkSW5zdGFuY2VBbmRTdXNwZW5kSWZOZWVkZWQoXG4gICAgICAgICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLFxuICAgICAgICAgICAgICAgICAgICByZW5kZXJMYW5lcyxcbiAgICAgICAgICAgICAgICAgICAgbmV3UHJvcHNcbiAgICAgICAgICAgICAgICAgICkpO1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgfVxuICAgICAgICBjYXNlIDI3OlxuICAgICAgICAgIGlmIChzdXBwb3J0c1NpbmdsZXRvbnMpIHtcbiAgICAgICAgICAgIHBvcEhvc3RDb250ZXh0KHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgICAgIHJlbmRlckxhbmVzID0gcmVxdWlyZWRDb250ZXh0KHJvb3RJbnN0YW5jZVN0YWNrQ3Vyc29yLmN1cnJlbnQpO1xuICAgICAgICAgICAgbmV4dFJlc291cmNlID0gd29ya0luUHJvZ3Jlc3MudHlwZTtcbiAgICAgICAgICAgIGlmIChudWxsICE9PSBjdXJyZW50ICYmIG51bGwgIT0gd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlKVxuICAgICAgICAgICAgICBzdXBwb3J0c011dGF0aW9uXG4gICAgICAgICAgICAgICAgPyBjdXJyZW50Lm1lbW9pemVkUHJvcHMgIT09IG5ld1Byb3BzICYmXG4gICAgICAgICAgICAgICAgICBtYXJrVXBkYXRlKHdvcmtJblByb2dyZXNzKVxuICAgICAgICAgICAgICAgIDogdXBkYXRlSG9zdENvbXBvbmVudChcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudCxcbiAgICAgICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gICAgICAgICAgICAgICAgICAgIG5leHRSZXNvdXJjZSxcbiAgICAgICAgICAgICAgICAgICAgbmV3UHJvcHNcbiAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgaWYgKCFuZXdQcm9wcykge1xuICAgICAgICAgICAgICAgIGlmIChudWxsID09PSB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGUpXG4gICAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcbiAgICAgICAgICAgICAgICAgICAgXCJXZSBtdXN0IGhhdmUgbmV3IHByb3BzIGZvciBuZXcgbW91bnRzLiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLlwiXG4gICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIGJ1YmJsZVByb3BlcnRpZXMod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGN1cnJlbnQgPSBnZXRIb3N0Q29udGV4dCgpO1xuICAgICAgICAgICAgICBwb3BIeWRyYXRpb25TdGF0ZSh3b3JrSW5Qcm9ncmVzcylcbiAgICAgICAgICAgICAgICA/IHByZXBhcmVUb0h5ZHJhdGVIb3N0SW5zdGFuY2Uod29ya0luUHJvZ3Jlc3MsIGN1cnJlbnQpXG4gICAgICAgICAgICAgICAgOiAoKGN1cnJlbnQgPSByZXNvbHZlU2luZ2xldG9uSW5zdGFuY2UoXG4gICAgICAgICAgICAgICAgICAgIG5leHRSZXNvdXJjZSxcbiAgICAgICAgICAgICAgICAgICAgbmV3UHJvcHMsXG4gICAgICAgICAgICAgICAgICAgIHJlbmRlckxhbmVzLFxuICAgICAgICAgICAgICAgICAgICBjdXJyZW50LFxuICAgICAgICAgICAgICAgICAgICAhMFxuICAgICAgICAgICAgICAgICAgKSksXG4gICAgICAgICAgICAgICAgICAod29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlID0gY3VycmVudCksXG4gICAgICAgICAgICAgICAgICBtYXJrVXBkYXRlKHdvcmtJblByb2dyZXNzKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBidWJibGVQcm9wZXJ0aWVzKHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgIH1cbiAgICAgICAgY2FzZSA1OlxuICAgICAgICAgIHBvcEhvc3RDb250ZXh0KHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgICByZW5kZXJMYW5lcyA9IHdvcmtJblByb2dyZXNzLnR5cGU7XG4gICAgICAgICAgaWYgKG51bGwgIT09IGN1cnJlbnQgJiYgbnVsbCAhPSB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGUpXG4gICAgICAgICAgICB1cGRhdGVIb3N0Q29tcG9uZW50KGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCByZW5kZXJMYW5lcywgbmV3UHJvcHMpO1xuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKCFuZXdQcm9wcykge1xuICAgICAgICAgICAgICBpZiAobnVsbCA9PT0gd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlKVxuICAgICAgICAgICAgICAgIHRocm93IEVycm9yKFxuICAgICAgICAgICAgICAgICAgXCJXZSBtdXN0IGhhdmUgbmV3IHByb3BzIGZvciBuZXcgbW91bnRzLiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLlwiXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgYnViYmxlUHJvcGVydGllcyh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY3VycmVudCA9IGdldEhvc3RDb250ZXh0KCk7XG4gICAgICAgICAgICBwb3BIeWRyYXRpb25TdGF0ZSh3b3JrSW5Qcm9ncmVzcylcbiAgICAgICAgICAgICAgPyBwcmVwYXJlVG9IeWRyYXRlSG9zdEluc3RhbmNlKHdvcmtJblByb2dyZXNzLCBjdXJyZW50KVxuICAgICAgICAgICAgICA6ICgobmV4dFJlc291cmNlID0gcmVxdWlyZWRDb250ZXh0KFxuICAgICAgICAgICAgICAgICAgcm9vdEluc3RhbmNlU3RhY2tDdXJzb3IuY3VycmVudFxuICAgICAgICAgICAgICAgICkpLFxuICAgICAgICAgICAgICAgIChuZXh0UmVzb3VyY2UgPSBjcmVhdGVJbnN0YW5jZShcbiAgICAgICAgICAgICAgICAgIHJlbmRlckxhbmVzLFxuICAgICAgICAgICAgICAgICAgbmV3UHJvcHMsXG4gICAgICAgICAgICAgICAgICBuZXh0UmVzb3VyY2UsXG4gICAgICAgICAgICAgICAgICBjdXJyZW50LFxuICAgICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3NcbiAgICAgICAgICAgICAgICApKSxcbiAgICAgICAgICAgICAgICBhcHBlbmRBbGxDaGlsZHJlbihuZXh0UmVzb3VyY2UsIHdvcmtJblByb2dyZXNzLCAhMSwgITEpLFxuICAgICAgICAgICAgICAgICh3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGUgPSBuZXh0UmVzb3VyY2UpLFxuICAgICAgICAgICAgICAgIGZpbmFsaXplSW5pdGlhbENoaWxkcmVuKFxuICAgICAgICAgICAgICAgICAgbmV4dFJlc291cmNlLFxuICAgICAgICAgICAgICAgICAgcmVuZGVyTGFuZXMsXG4gICAgICAgICAgICAgICAgICBuZXdQcm9wcyxcbiAgICAgICAgICAgICAgICAgIGN1cnJlbnRcbiAgICAgICAgICAgICAgICApICYmIG1hcmtVcGRhdGUod29ya0luUHJvZ3Jlc3MpKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnViYmxlUHJvcGVydGllcyh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgICAgcHJlbG9hZEluc3RhbmNlQW5kU3VzcGVuZElmTmVlZGVkKFxuICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy50eXBlLFxuICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzXG4gICAgICAgICAgKTtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgY2FzZSA2OlxuICAgICAgICAgIGlmIChjdXJyZW50ICYmIG51bGwgIT0gd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlKVxuICAgICAgICAgICAgKHJlbmRlckxhbmVzID0gY3VycmVudC5tZW1vaXplZFByb3BzKSxcbiAgICAgICAgICAgICAgc3VwcG9ydHNNdXRhdGlvblxuICAgICAgICAgICAgICAgID8gcmVuZGVyTGFuZXMgIT09IG5ld1Byb3BzICYmIG1hcmtVcGRhdGUod29ya0luUHJvZ3Jlc3MpXG4gICAgICAgICAgICAgICAgOiBzdXBwb3J0c1BlcnNpc3RlbmNlICYmXG4gICAgICAgICAgICAgICAgICAocmVuZGVyTGFuZXMgIT09IG5ld1Byb3BzXG4gICAgICAgICAgICAgICAgICAgID8gKChjdXJyZW50ID0gcmVxdWlyZWRDb250ZXh0KFxuICAgICAgICAgICAgICAgICAgICAgICAgcm9vdEluc3RhbmNlU3RhY2tDdXJzb3IuY3VycmVudFxuICAgICAgICAgICAgICAgICAgICAgICkpLFxuICAgICAgICAgICAgICAgICAgICAgIChyZW5kZXJMYW5lcyA9IGdldEhvc3RDb250ZXh0KCkpLFxuICAgICAgICAgICAgICAgICAgICAgICh3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGUgPSBjcmVhdGVUZXh0SW5zdGFuY2UoXG4gICAgICAgICAgICAgICAgICAgICAgICBuZXdQcm9wcyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnQsXG4gICAgICAgICAgICAgICAgICAgICAgICByZW5kZXJMYW5lcyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzXG4gICAgICAgICAgICAgICAgICAgICAgKSksXG4gICAgICAgICAgICAgICAgICAgICAgbWFya1VwZGF0ZSh3b3JrSW5Qcm9ncmVzcykpXG4gICAgICAgICAgICAgICAgICAgIDogKHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZSA9IGN1cnJlbnQuc3RhdGVOb2RlKSk7XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgIFwic3RyaW5nXCIgIT09IHR5cGVvZiBuZXdQcm9wcyAmJlxuICAgICAgICAgICAgICBudWxsID09PSB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGVcbiAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXG4gICAgICAgICAgICAgICAgXCJXZSBtdXN0IGhhdmUgbmV3IHByb3BzIGZvciBuZXcgbW91bnRzLiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLlwiXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICBjdXJyZW50ID0gcmVxdWlyZWRDb250ZXh0KHJvb3RJbnN0YW5jZVN0YWNrQ3Vyc29yLmN1cnJlbnQpO1xuICAgICAgICAgICAgcmVuZGVyTGFuZXMgPSBnZXRIb3N0Q29udGV4dCgpO1xuICAgICAgICAgICAgaWYgKHBvcEh5ZHJhdGlvblN0YXRlKHdvcmtJblByb2dyZXNzKSkge1xuICAgICAgICAgICAgICBpZiAoIXN1cHBvcnRzSHlkcmF0aW9uKVxuICAgICAgICAgICAgICAgIHRocm93IEVycm9yKFxuICAgICAgICAgICAgICAgICAgXCJFeHBlY3RlZCBwcmVwYXJlVG9IeWRyYXRlSG9zdFRleHRJbnN0YW5jZSgpIHRvIG5ldmVyIGJlIGNhbGxlZC4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS5cIlxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIGN1cnJlbnQgPSB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGU7XG4gICAgICAgICAgICAgIHJlbmRlckxhbmVzID0gd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRQcm9wcztcbiAgICAgICAgICAgICAgbmV4dFJlc291cmNlID0gIWRpZFN1c3BlbmRPckVycm9yREVWO1xuICAgICAgICAgICAgICBuZXdQcm9wcyA9IG51bGw7XG4gICAgICAgICAgICAgIHZhciByZXR1cm5GaWJlciA9IGh5ZHJhdGlvblBhcmVudEZpYmVyO1xuICAgICAgICAgICAgICBpZiAobnVsbCAhPT0gcmV0dXJuRmliZXIpXG4gICAgICAgICAgICAgICAgc3dpdGNoIChyZXR1cm5GaWJlci50YWcpIHtcbiAgICAgICAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICAgICAgbmV4dFJlc291cmNlICYmXG4gICAgICAgICAgICAgICAgICAgICAgKChuZXh0UmVzb3VyY2UgPSBkaWZmSHlkcmF0ZWRUZXh0Rm9yRGV2V2FybmluZ3MoXG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50LFxuICAgICAgICAgICAgICAgICAgICAgICAgcmVuZGVyTGFuZXMsXG4gICAgICAgICAgICAgICAgICAgICAgICBuZXdQcm9wc1xuICAgICAgICAgICAgICAgICAgICAgICkpLFxuICAgICAgICAgICAgICAgICAgICAgIG51bGwgIT09IG5leHRSZXNvdXJjZSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgKGJ1aWxkSHlkcmF0aW9uRGlmZk5vZGUod29ya0luUHJvZ3Jlc3MsIDApLnNlcnZlclByb3BzID1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgbmV4dFJlc291cmNlKSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgY2FzZSAyNzpcbiAgICAgICAgICAgICAgICAgIGNhc2UgNTpcbiAgICAgICAgICAgICAgICAgICAgKG5ld1Byb3BzID0gcmV0dXJuRmliZXIubWVtb2l6ZWRQcm9wcyksXG4gICAgICAgICAgICAgICAgICAgICAgbmV4dFJlc291cmNlICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAoKG5leHRSZXNvdXJjZSA9IGRpZmZIeWRyYXRlZFRleHRGb3JEZXZXYXJuaW5ncyhcbiAgICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgcmVuZGVyTGFuZXMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIG5ld1Byb3BzXG4gICAgICAgICAgICAgICAgICAgICAgICApKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG51bGwgIT09IG5leHRSZXNvdXJjZSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAoYnVpbGRIeWRyYXRpb25EaWZmTm9kZShcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAwXG4gICAgICAgICAgICAgICAgICAgICAgICAgICkuc2VydmVyUHJvcHMgPSBuZXh0UmVzb3VyY2UpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGh5ZHJhdGVUZXh0SW5zdGFuY2UoXG4gICAgICAgICAgICAgICAgY3VycmVudCxcbiAgICAgICAgICAgICAgICByZW5kZXJMYW5lcyxcbiAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgICAgICAgICAgICAgICBuZXdQcm9wc1xuICAgICAgICAgICAgICApIHx8IHRocm93T25IeWRyYXRpb25NaXNtYXRjaCh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgICAgICB9IGVsc2VcbiAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlID0gY3JlYXRlVGV4dEluc3RhbmNlKFxuICAgICAgICAgICAgICAgIG5ld1Byb3BzLFxuICAgICAgICAgICAgICAgIGN1cnJlbnQsXG4gICAgICAgICAgICAgICAgcmVuZGVyTGFuZXMsXG4gICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3NcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnViYmxlUHJvcGVydGllcyh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIGNhc2UgMTM6XG4gICAgICAgICAgbmV3UHJvcHMgPSB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlO1xuICAgICAgICAgIGlmIChcbiAgICAgICAgICAgIG51bGwgPT09IGN1cnJlbnQgfHxcbiAgICAgICAgICAgIChudWxsICE9PSBjdXJyZW50Lm1lbW9pemVkU3RhdGUgJiZcbiAgICAgICAgICAgICAgbnVsbCAhPT0gY3VycmVudC5tZW1vaXplZFN0YXRlLmRlaHlkcmF0ZWQpXG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICBuZXh0UmVzb3VyY2UgPSBwb3BIeWRyYXRpb25TdGF0ZSh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgICAgICBpZiAobnVsbCAhPT0gbmV3UHJvcHMgJiYgbnVsbCAhPT0gbmV3UHJvcHMuZGVoeWRyYXRlZCkge1xuICAgICAgICAgICAgICBpZiAobnVsbCA9PT0gY3VycmVudCkge1xuICAgICAgICAgICAgICAgIGlmICghbmV4dFJlc291cmNlKVxuICAgICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXG4gICAgICAgICAgICAgICAgICAgIFwiQSBkZWh5ZHJhdGVkIHN1c3BlbnNlIGNvbXBvbmVudCB3YXMgY29tcGxldGVkIHdpdGhvdXQgYSBoeWRyYXRlZCBub2RlLiBUaGlzIGlzIHByb2JhYmx5IGEgYnVnIGluIFJlYWN0LlwiXG4gICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIGlmICghc3VwcG9ydHNIeWRyYXRpb24pXG4gICAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcbiAgICAgICAgICAgICAgICAgICAgXCJFeHBlY3RlZCBwcmVwYXJlVG9IeWRyYXRlSG9zdFN1c3BlbnNlSW5zdGFuY2UoKSB0byBuZXZlciBiZSBjYWxsZWQuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuXCJcbiAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgbmV4dFJlc291cmNlID0gd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZTtcbiAgICAgICAgICAgICAgICBuZXh0UmVzb3VyY2UgPVxuICAgICAgICAgICAgICAgICAgbnVsbCAhPT0gbmV4dFJlc291cmNlID8gbmV4dFJlc291cmNlLmRlaHlkcmF0ZWQgOiBudWxsO1xuICAgICAgICAgICAgICAgIGlmICghbmV4dFJlc291cmNlKVxuICAgICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXG4gICAgICAgICAgICAgICAgICAgIFwiRXhwZWN0ZWQgdG8gaGF2ZSBhIGh5ZHJhdGVkIHN1c3BlbnNlIGluc3RhbmNlLiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLlwiXG4gICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIGh5ZHJhdGVTdXNwZW5zZUluc3RhbmNlKG5leHRSZXNvdXJjZSwgd29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICAgICAgICAgIGJ1YmJsZVByb3BlcnRpZXMod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICAgICAgICAgICh3b3JrSW5Qcm9ncmVzcy5tb2RlICYgMikgIT09IE5vTW9kZSAmJlxuICAgICAgICAgICAgICAgICAgbnVsbCAhPT0gbmV3UHJvcHMgJiZcbiAgICAgICAgICAgICAgICAgICgobmV4dFJlc291cmNlID0gd29ya0luUHJvZ3Jlc3MuY2hpbGQpLFxuICAgICAgICAgICAgICAgICAgbnVsbCAhPT0gbmV4dFJlc291cmNlICYmXG4gICAgICAgICAgICAgICAgICAgICh3b3JrSW5Qcm9ncmVzcy50cmVlQmFzZUR1cmF0aW9uIC09XG4gICAgICAgICAgICAgICAgICAgICAgbmV4dFJlc291cmNlLnRyZWVCYXNlRHVyYXRpb24pKTtcbiAgICAgICAgICAgICAgfSBlbHNlXG4gICAgICAgICAgICAgICAgZW1pdFBlbmRpbmdIeWRyYXRpb25XYXJuaW5ncygpLFxuICAgICAgICAgICAgICAgICAgcmVzZXRIeWRyYXRpb25TdGF0ZSgpLFxuICAgICAgICAgICAgICAgICAgMCA9PT0gKHdvcmtJblByb2dyZXNzLmZsYWdzICYgMTI4KSAmJlxuICAgICAgICAgICAgICAgICAgICAod29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZSA9IG51bGwpLFxuICAgICAgICAgICAgICAgICAgKHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IDQpLFxuICAgICAgICAgICAgICAgICAgYnViYmxlUHJvcGVydGllcyh3b3JrSW5Qcm9ncmVzcyksXG4gICAgICAgICAgICAgICAgICAod29ya0luUHJvZ3Jlc3MubW9kZSAmIDIpICE9PSBOb01vZGUgJiZcbiAgICAgICAgICAgICAgICAgICAgbnVsbCAhPT0gbmV3UHJvcHMgJiZcbiAgICAgICAgICAgICAgICAgICAgKChuZXh0UmVzb3VyY2UgPSB3b3JrSW5Qcm9ncmVzcy5jaGlsZCksXG4gICAgICAgICAgICAgICAgICAgIG51bGwgIT09IG5leHRSZXNvdXJjZSAmJlxuICAgICAgICAgICAgICAgICAgICAgICh3b3JrSW5Qcm9ncmVzcy50cmVlQmFzZUR1cmF0aW9uIC09XG4gICAgICAgICAgICAgICAgICAgICAgICBuZXh0UmVzb3VyY2UudHJlZUJhc2VEdXJhdGlvbikpO1xuICAgICAgICAgICAgICBuZXh0UmVzb3VyY2UgPSAhMTtcbiAgICAgICAgICAgIH0gZWxzZVxuICAgICAgICAgICAgICBudWxsICE9PSBoeWRyYXRpb25FcnJvcnMgJiZcbiAgICAgICAgICAgICAgICAocXVldWVSZWNvdmVyYWJsZUVycm9ycyhoeWRyYXRpb25FcnJvcnMpLFxuICAgICAgICAgICAgICAgIChoeWRyYXRpb25FcnJvcnMgPSBudWxsKSksXG4gICAgICAgICAgICAgICAgKG5leHRSZXNvdXJjZSA9ICEwKTtcbiAgICAgICAgICAgIGlmICghbmV4dFJlc291cmNlKSB7XG4gICAgICAgICAgICAgIGlmICh3b3JrSW5Qcm9ncmVzcy5mbGFncyAmIDI1NilcbiAgICAgICAgICAgICAgICByZXR1cm4gcG9wU3VzcGVuc2VIYW5kbGVyKHdvcmtJblByb2dyZXNzKSwgd29ya0luUHJvZ3Jlc3M7XG4gICAgICAgICAgICAgIHBvcFN1c3BlbnNlSGFuZGxlcih3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBwb3BTdXNwZW5zZUhhbmRsZXIod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICAgIGlmICgwICE9PSAod29ya0luUHJvZ3Jlc3MuZmxhZ3MgJiAxMjgpKVxuICAgICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICAgKHdvcmtJblByb2dyZXNzLmxhbmVzID0gcmVuZGVyTGFuZXMpLFxuICAgICAgICAgICAgICAod29ya0luUHJvZ3Jlc3MubW9kZSAmIDIpICE9PSBOb01vZGUgJiZcbiAgICAgICAgICAgICAgICB0cmFuc2ZlckFjdHVhbER1cmF0aW9uKHdvcmtJblByb2dyZXNzKSxcbiAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3NcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgcmVuZGVyTGFuZXMgPSBudWxsICE9PSBuZXdQcm9wcztcbiAgICAgICAgICBjdXJyZW50ID0gbnVsbCAhPT0gY3VycmVudCAmJiBudWxsICE9PSBjdXJyZW50Lm1lbW9pemVkU3RhdGU7XG4gICAgICAgICAgcmVuZGVyTGFuZXMgJiZcbiAgICAgICAgICAgICgobmV3UHJvcHMgPSB3b3JrSW5Qcm9ncmVzcy5jaGlsZCksXG4gICAgICAgICAgICAobmV4dFJlc291cmNlID0gbnVsbCksXG4gICAgICAgICAgICBudWxsICE9PSBuZXdQcm9wcy5hbHRlcm5hdGUgJiZcbiAgICAgICAgICAgICAgbnVsbCAhPT0gbmV3UHJvcHMuYWx0ZXJuYXRlLm1lbW9pemVkU3RhdGUgJiZcbiAgICAgICAgICAgICAgbnVsbCAhPT0gbmV3UHJvcHMuYWx0ZXJuYXRlLm1lbW9pemVkU3RhdGUuY2FjaGVQb29sICYmXG4gICAgICAgICAgICAgIChuZXh0UmVzb3VyY2UgPSBuZXdQcm9wcy5hbHRlcm5hdGUubWVtb2l6ZWRTdGF0ZS5jYWNoZVBvb2wucG9vbCksXG4gICAgICAgICAgICAocmV0dXJuRmliZXIgPSBudWxsKSxcbiAgICAgICAgICAgIG51bGwgIT09IG5ld1Byb3BzLm1lbW9pemVkU3RhdGUgJiZcbiAgICAgICAgICAgICAgbnVsbCAhPT0gbmV3UHJvcHMubWVtb2l6ZWRTdGF0ZS5jYWNoZVBvb2wgJiZcbiAgICAgICAgICAgICAgKHJldHVybkZpYmVyID0gbmV3UHJvcHMubWVtb2l6ZWRTdGF0ZS5jYWNoZVBvb2wucG9vbCksXG4gICAgICAgICAgICByZXR1cm5GaWJlciAhPT0gbmV4dFJlc291cmNlICYmIChuZXdQcm9wcy5mbGFncyB8PSAyMDQ4KSk7XG4gICAgICAgICAgcmVuZGVyTGFuZXMgIT09IGN1cnJlbnQgJiZcbiAgICAgICAgICAgIHJlbmRlckxhbmVzICYmXG4gICAgICAgICAgICAod29ya0luUHJvZ3Jlc3MuY2hpbGQuZmxhZ3MgfD0gODE5Mik7XG4gICAgICAgICAgc2NoZWR1bGVSZXRyeUVmZmVjdCh3b3JrSW5Qcm9ncmVzcywgd29ya0luUHJvZ3Jlc3MudXBkYXRlUXVldWUpO1xuICAgICAgICAgIGJ1YmJsZVByb3BlcnRpZXMod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICAgICh3b3JrSW5Qcm9ncmVzcy5tb2RlICYgMikgIT09IE5vTW9kZSAmJlxuICAgICAgICAgICAgcmVuZGVyTGFuZXMgJiZcbiAgICAgICAgICAgICgoY3VycmVudCA9IHdvcmtJblByb2dyZXNzLmNoaWxkKSxcbiAgICAgICAgICAgIG51bGwgIT09IGN1cnJlbnQgJiZcbiAgICAgICAgICAgICAgKHdvcmtJblByb2dyZXNzLnRyZWVCYXNlRHVyYXRpb24gLT0gY3VycmVudC50cmVlQmFzZUR1cmF0aW9uKSk7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIGNhc2UgNDpcbiAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgcG9wSG9zdENvbnRhaW5lcih3b3JrSW5Qcm9ncmVzcyksXG4gICAgICAgICAgICB1cGRhdGVIb3N0Q29udGFpbmVyKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzKSxcbiAgICAgICAgICAgIG51bGwgPT09IGN1cnJlbnQgJiZcbiAgICAgICAgICAgICAgcHJlcGFyZVBvcnRhbE1vdW50KHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZS5jb250YWluZXJJbmZvKSxcbiAgICAgICAgICAgIGJ1YmJsZVByb3BlcnRpZXMod29ya0luUHJvZ3Jlc3MpLFxuICAgICAgICAgICAgbnVsbFxuICAgICAgICAgICk7XG4gICAgICAgIGNhc2UgMTA6XG4gICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIHBvcFByb3ZpZGVyKHdvcmtJblByb2dyZXNzLnR5cGUsIHdvcmtJblByb2dyZXNzKSxcbiAgICAgICAgICAgIGJ1YmJsZVByb3BlcnRpZXMod29ya0luUHJvZ3Jlc3MpLFxuICAgICAgICAgICAgbnVsbFxuICAgICAgICAgICk7XG4gICAgICAgIGNhc2UgMTk6XG4gICAgICAgICAgcG9wKHN1c3BlbnNlU3RhY2tDdXJzb3IsIHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgICBuZXh0UmVzb3VyY2UgPSB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlO1xuICAgICAgICAgIGlmIChudWxsID09PSBuZXh0UmVzb3VyY2UpXG4gICAgICAgICAgICByZXR1cm4gYnViYmxlUHJvcGVydGllcyh3b3JrSW5Qcm9ncmVzcyksIG51bGw7XG4gICAgICAgICAgbmV3UHJvcHMgPSAwICE9PSAod29ya0luUHJvZ3Jlc3MuZmxhZ3MgJiAxMjgpO1xuICAgICAgICAgIHJldHVybkZpYmVyID0gbmV4dFJlc291cmNlLnJlbmRlcmluZztcbiAgICAgICAgICBpZiAobnVsbCA9PT0gcmV0dXJuRmliZXIpXG4gICAgICAgICAgICBpZiAobmV3UHJvcHMpIGN1dE9mZlRhaWxJZk5lZWRlZChuZXh0UmVzb3VyY2UsICExKTtcbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3NSb290RXhpdFN0YXR1cyAhPT0gUm9vdEluUHJvZ3Jlc3MgfHxcbiAgICAgICAgICAgICAgICAobnVsbCAhPT0gY3VycmVudCAmJiAwICE9PSAoY3VycmVudC5mbGFncyAmIDEyOCkpXG4gICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICBmb3IgKGN1cnJlbnQgPSB3b3JrSW5Qcm9ncmVzcy5jaGlsZDsgbnVsbCAhPT0gY3VycmVudDsgKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm5GaWJlciA9IGZpbmRGaXJzdFN1c3BlbmRlZChjdXJyZW50KTtcbiAgICAgICAgICAgICAgICAgIGlmIChudWxsICE9PSByZXR1cm5GaWJlcikge1xuICAgICAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5mbGFncyB8PSAxMjg7XG4gICAgICAgICAgICAgICAgICAgIGN1dE9mZlRhaWxJZk5lZWRlZChuZXh0UmVzb3VyY2UsICExKTtcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudCA9IHJldHVybkZpYmVyLnVwZGF0ZVF1ZXVlO1xuICAgICAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy51cGRhdGVRdWV1ZSA9IGN1cnJlbnQ7XG4gICAgICAgICAgICAgICAgICAgIHNjaGVkdWxlUmV0cnlFZmZlY3Qod29ya0luUHJvZ3Jlc3MsIGN1cnJlbnQpO1xuICAgICAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5zdWJ0cmVlRmxhZ3MgPSAwO1xuICAgICAgICAgICAgICAgICAgICBjdXJyZW50ID0gcmVuZGVyTGFuZXM7XG4gICAgICAgICAgICAgICAgICAgIGZvciAoXG4gICAgICAgICAgICAgICAgICAgICAgcmVuZGVyTGFuZXMgPSB3b3JrSW5Qcm9ncmVzcy5jaGlsZDtcbiAgICAgICAgICAgICAgICAgICAgICBudWxsICE9PSByZW5kZXJMYW5lcztcblxuICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICAgICAgcmVzZXRXb3JrSW5Qcm9ncmVzcyhyZW5kZXJMYW5lcywgY3VycmVudCksXG4gICAgICAgICAgICAgICAgICAgICAgICAocmVuZGVyTGFuZXMgPSByZW5kZXJMYW5lcy5zaWJsaW5nKTtcbiAgICAgICAgICAgICAgICAgICAgcHVzaChcbiAgICAgICAgICAgICAgICAgICAgICBzdXNwZW5zZVN0YWNrQ3Vyc29yLFxuICAgICAgICAgICAgICAgICAgICAgIChzdXNwZW5zZVN0YWNrQ3Vyc29yLmN1cnJlbnQgJlxuICAgICAgICAgICAgICAgICAgICAgICAgU3VidHJlZVN1c3BlbnNlQ29udGV4dE1hc2spIHxcbiAgICAgICAgICAgICAgICAgICAgICAgIEZvcmNlU3VzcGVuc2VGYWxsYmFjayxcbiAgICAgICAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzc1xuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gd29ya0luUHJvZ3Jlc3MuY2hpbGQ7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBjdXJyZW50ID0gY3VycmVudC5zaWJsaW5nO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgbnVsbCAhPT0gbmV4dFJlc291cmNlLnRhaWwgJiZcbiAgICAgICAgICAgICAgICBub3ckMSgpID4gd29ya0luUHJvZ3Jlc3NSb290UmVuZGVyVGFyZ2V0VGltZSAmJlxuICAgICAgICAgICAgICAgICgod29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gMTI4KSxcbiAgICAgICAgICAgICAgICAobmV3UHJvcHMgPSAhMCksXG4gICAgICAgICAgICAgICAgY3V0T2ZmVGFpbElmTmVlZGVkKG5leHRSZXNvdXJjZSwgITEpLFxuICAgICAgICAgICAgICAgICh3b3JrSW5Qcm9ncmVzcy5sYW5lcyA9IDQxOTQzMDQpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmICghbmV3UHJvcHMpXG4gICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAoKGN1cnJlbnQgPSBmaW5kRmlyc3RTdXNwZW5kZWQocmV0dXJuRmliZXIpKSwgbnVsbCAhPT0gY3VycmVudClcbiAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICAgKCh3b3JrSW5Qcm9ncmVzcy5mbGFncyB8PSAxMjgpLFxuICAgICAgICAgICAgICAgICAgKG5ld1Byb3BzID0gITApLFxuICAgICAgICAgICAgICAgICAgKGN1cnJlbnQgPSBjdXJyZW50LnVwZGF0ZVF1ZXVlKSxcbiAgICAgICAgICAgICAgICAgICh3b3JrSW5Qcm9ncmVzcy51cGRhdGVRdWV1ZSA9IGN1cnJlbnQpLFxuICAgICAgICAgICAgICAgICAgc2NoZWR1bGVSZXRyeUVmZmVjdCh3b3JrSW5Qcm9ncmVzcywgY3VycmVudCksXG4gICAgICAgICAgICAgICAgICBjdXRPZmZUYWlsSWZOZWVkZWQobmV4dFJlc291cmNlLCAhMCksXG4gICAgICAgICAgICAgICAgICBudWxsID09PSBuZXh0UmVzb3VyY2UudGFpbCAmJlxuICAgICAgICAgICAgICAgICAgICBcImhpZGRlblwiID09PSBuZXh0UmVzb3VyY2UudGFpbE1vZGUgJiZcbiAgICAgICAgICAgICAgICAgICAgIXJldHVybkZpYmVyLmFsdGVybmF0ZSAmJlxuICAgICAgICAgICAgICAgICAgICAhaXNIeWRyYXRpbmcpXG4gICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgcmV0dXJuIGJ1YmJsZVByb3BlcnRpZXMod29ya0luUHJvZ3Jlc3MpLCBudWxsO1xuICAgICAgICAgICAgICB9IGVsc2VcbiAgICAgICAgICAgICAgICAyICogbm93JDEoKSAtIG5leHRSZXNvdXJjZS5yZW5kZXJpbmdTdGFydFRpbWUgPlxuICAgICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3NSb290UmVuZGVyVGFyZ2V0VGltZSAmJlxuICAgICAgICAgICAgICAgICAgNTM2ODcwOTEyICE9PSByZW5kZXJMYW5lcyAmJlxuICAgICAgICAgICAgICAgICAgKCh3b3JrSW5Qcm9ncmVzcy5mbGFncyB8PSAxMjgpLFxuICAgICAgICAgICAgICAgICAgKG5ld1Byb3BzID0gITApLFxuICAgICAgICAgICAgICAgICAgY3V0T2ZmVGFpbElmTmVlZGVkKG5leHRSZXNvdXJjZSwgITEpLFxuICAgICAgICAgICAgICAgICAgKHdvcmtJblByb2dyZXNzLmxhbmVzID0gNDE5NDMwNCkpO1xuICAgICAgICAgICAgbmV4dFJlc291cmNlLmlzQmFja3dhcmRzXG4gICAgICAgICAgICAgID8gKChyZXR1cm5GaWJlci5zaWJsaW5nID0gd29ya0luUHJvZ3Jlc3MuY2hpbGQpLFxuICAgICAgICAgICAgICAgICh3b3JrSW5Qcm9ncmVzcy5jaGlsZCA9IHJldHVybkZpYmVyKSlcbiAgICAgICAgICAgICAgOiAoKGN1cnJlbnQgPSBuZXh0UmVzb3VyY2UubGFzdCksXG4gICAgICAgICAgICAgICAgbnVsbCAhPT0gY3VycmVudFxuICAgICAgICAgICAgICAgICAgPyAoY3VycmVudC5zaWJsaW5nID0gcmV0dXJuRmliZXIpXG4gICAgICAgICAgICAgICAgICA6ICh3b3JrSW5Qcm9ncmVzcy5jaGlsZCA9IHJldHVybkZpYmVyKSxcbiAgICAgICAgICAgICAgICAobmV4dFJlc291cmNlLmxhc3QgPSByZXR1cm5GaWJlcikpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAobnVsbCAhPT0gbmV4dFJlc291cmNlLnRhaWwpXG4gICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICAoY3VycmVudCA9IG5leHRSZXNvdXJjZS50YWlsKSxcbiAgICAgICAgICAgICAgKG5leHRSZXNvdXJjZS5yZW5kZXJpbmcgPSBjdXJyZW50KSxcbiAgICAgICAgICAgICAgKG5leHRSZXNvdXJjZS50YWlsID0gY3VycmVudC5zaWJsaW5nKSxcbiAgICAgICAgICAgICAgKG5leHRSZXNvdXJjZS5yZW5kZXJpbmdTdGFydFRpbWUgPSBub3ckMSgpKSxcbiAgICAgICAgICAgICAgKGN1cnJlbnQuc2libGluZyA9IG51bGwpLFxuICAgICAgICAgICAgICAocmVuZGVyTGFuZXMgPSBzdXNwZW5zZVN0YWNrQ3Vyc29yLmN1cnJlbnQpLFxuICAgICAgICAgICAgICAocmVuZGVyTGFuZXMgPSBuZXdQcm9wc1xuICAgICAgICAgICAgICAgID8gKHJlbmRlckxhbmVzICYgU3VidHJlZVN1c3BlbnNlQ29udGV4dE1hc2spIHxcbiAgICAgICAgICAgICAgICAgIEZvcmNlU3VzcGVuc2VGYWxsYmFja1xuICAgICAgICAgICAgICAgIDogcmVuZGVyTGFuZXMgJiBTdWJ0cmVlU3VzcGVuc2VDb250ZXh0TWFzayksXG4gICAgICAgICAgICAgIHB1c2goc3VzcGVuc2VTdGFja0N1cnNvciwgcmVuZGVyTGFuZXMsIHdvcmtJblByb2dyZXNzKSxcbiAgICAgICAgICAgICAgY3VycmVudFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICBidWJibGVQcm9wZXJ0aWVzKHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgY2FzZSAyMjpcbiAgICAgICAgY2FzZSAyMzpcbiAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgcG9wU3VzcGVuc2VIYW5kbGVyKHdvcmtJblByb2dyZXNzKSxcbiAgICAgICAgICAgIHBvcEhpZGRlbkNvbnRleHQod29ya0luUHJvZ3Jlc3MpLFxuICAgICAgICAgICAgKG5ld1Byb3BzID0gbnVsbCAhPT0gd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZSksXG4gICAgICAgICAgICBudWxsICE9PSBjdXJyZW50XG4gICAgICAgICAgICAgID8gKG51bGwgIT09IGN1cnJlbnQubWVtb2l6ZWRTdGF0ZSkgIT09IG5ld1Byb3BzICYmXG4gICAgICAgICAgICAgICAgKHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IDgxOTIpXG4gICAgICAgICAgICAgIDogbmV3UHJvcHMgJiYgKHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IDgxOTIpLFxuICAgICAgICAgICAgbmV3UHJvcHNcbiAgICAgICAgICAgICAgPyAwICE9PSAocmVuZGVyTGFuZXMgJiA1MzY4NzA5MTIpICYmXG4gICAgICAgICAgICAgICAgMCA9PT0gKHdvcmtJblByb2dyZXNzLmZsYWdzICYgMTI4KSAmJlxuICAgICAgICAgICAgICAgIChidWJibGVQcm9wZXJ0aWVzKHdvcmtJblByb2dyZXNzKSxcbiAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5zdWJ0cmVlRmxhZ3MgJiA2ICYmXG4gICAgICAgICAgICAgICAgICAod29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gODE5MikpXG4gICAgICAgICAgICAgIDogYnViYmxlUHJvcGVydGllcyh3b3JrSW5Qcm9ncmVzcyksXG4gICAgICAgICAgICAocmVuZGVyTGFuZXMgPSB3b3JrSW5Qcm9ncmVzcy51cGRhdGVRdWV1ZSksXG4gICAgICAgICAgICBudWxsICE9PSByZW5kZXJMYW5lcyAmJlxuICAgICAgICAgICAgICBzY2hlZHVsZVJldHJ5RWZmZWN0KHdvcmtJblByb2dyZXNzLCByZW5kZXJMYW5lcy5yZXRyeVF1ZXVlKSxcbiAgICAgICAgICAgIChyZW5kZXJMYW5lcyA9IG51bGwpLFxuICAgICAgICAgICAgbnVsbCAhPT0gY3VycmVudCAmJlxuICAgICAgICAgICAgICBudWxsICE9PSBjdXJyZW50Lm1lbW9pemVkU3RhdGUgJiZcbiAgICAgICAgICAgICAgbnVsbCAhPT0gY3VycmVudC5tZW1vaXplZFN0YXRlLmNhY2hlUG9vbCAmJlxuICAgICAgICAgICAgICAocmVuZGVyTGFuZXMgPSBjdXJyZW50Lm1lbW9pemVkU3RhdGUuY2FjaGVQb29sLnBvb2wpLFxuICAgICAgICAgICAgKG5ld1Byb3BzID0gbnVsbCksXG4gICAgICAgICAgICBudWxsICE9PSB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlICYmXG4gICAgICAgICAgICAgIG51bGwgIT09IHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGUuY2FjaGVQb29sICYmXG4gICAgICAgICAgICAgIChuZXdQcm9wcyA9IHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGUuY2FjaGVQb29sLnBvb2wpLFxuICAgICAgICAgICAgbmV3UHJvcHMgIT09IHJlbmRlckxhbmVzICYmICh3b3JrSW5Qcm9ncmVzcy5mbGFncyB8PSAyMDQ4KSxcbiAgICAgICAgICAgIG51bGwgIT09IGN1cnJlbnQgJiYgcG9wKHJlc3VtZWRDYWNoZSwgd29ya0luUHJvZ3Jlc3MpLFxuICAgICAgICAgICAgbnVsbFxuICAgICAgICAgICk7XG4gICAgICAgIGNhc2UgMjQ6XG4gICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIChyZW5kZXJMYW5lcyA9IG51bGwpLFxuICAgICAgICAgICAgbnVsbCAhPT0gY3VycmVudCAmJiAocmVuZGVyTGFuZXMgPSBjdXJyZW50Lm1lbW9pemVkU3RhdGUuY2FjaGUpLFxuICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZS5jYWNoZSAhPT0gcmVuZGVyTGFuZXMgJiZcbiAgICAgICAgICAgICAgKHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IDIwNDgpLFxuICAgICAgICAgICAgcG9wUHJvdmlkZXIoQ2FjaGVDb250ZXh0LCB3b3JrSW5Qcm9ncmVzcyksXG4gICAgICAgICAgICBidWJibGVQcm9wZXJ0aWVzKHdvcmtJblByb2dyZXNzKSxcbiAgICAgICAgICAgIG51bGxcbiAgICAgICAgICApO1xuICAgICAgICBjYXNlIDI1OlxuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgdGhyb3cgRXJyb3IoXG4gICAgICAgIFwiVW5rbm93biB1bml0IG9mIHdvcmsgdGFnIChcIiArXG4gICAgICAgICAgd29ya0luUHJvZ3Jlc3MudGFnICtcbiAgICAgICAgICBcIikuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuXCJcbiAgICAgICk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHVud2luZFdvcmsoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MpIHtcbiAgICAgIHBvcFRyZWVDb250ZXh0KHdvcmtJblByb2dyZXNzKTtcbiAgICAgIHN3aXRjaCAod29ya0luUHJvZ3Jlc3MudGFnKSB7XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgKGN1cnJlbnQgPSB3b3JrSW5Qcm9ncmVzcy5mbGFncyksXG4gICAgICAgICAgICBjdXJyZW50ICYgNjU1MzZcbiAgICAgICAgICAgICAgPyAoKHdvcmtJblByb2dyZXNzLmZsYWdzID0gKGN1cnJlbnQgJiAtNjU1MzcpIHwgMTI4KSxcbiAgICAgICAgICAgICAgICAod29ya0luUHJvZ3Jlc3MubW9kZSAmIDIpICE9PSBOb01vZGUgJiZcbiAgICAgICAgICAgICAgICAgIHRyYW5zZmVyQWN0dWFsRHVyYXRpb24od29ya0luUHJvZ3Jlc3MpLFxuICAgICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzKVxuICAgICAgICAgICAgICA6IG51bGxcbiAgICAgICAgICApO1xuICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIHBvcFByb3ZpZGVyKENhY2hlQ29udGV4dCwgd29ya0luUHJvZ3Jlc3MpLFxuICAgICAgICAgICAgcG9wSG9zdENvbnRhaW5lcih3b3JrSW5Qcm9ncmVzcyksXG4gICAgICAgICAgICAoY3VycmVudCA9IHdvcmtJblByb2dyZXNzLmZsYWdzKSxcbiAgICAgICAgICAgIDAgIT09IChjdXJyZW50ICYgNjU1MzYpICYmIDAgPT09IChjdXJyZW50ICYgMTI4KVxuICAgICAgICAgICAgICA/ICgod29ya0luUHJvZ3Jlc3MuZmxhZ3MgPSAoY3VycmVudCAmIC02NTUzNykgfCAxMjgpLFxuICAgICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzKVxuICAgICAgICAgICAgICA6IG51bGxcbiAgICAgICAgICApO1xuICAgICAgICBjYXNlIDI2OlxuICAgICAgICBjYXNlIDI3OlxuICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgcmV0dXJuIHBvcEhvc3RDb250ZXh0KHdvcmtJblByb2dyZXNzKSwgbnVsbDtcbiAgICAgICAgY2FzZSAxMzpcbiAgICAgICAgICBwb3BTdXNwZW5zZUhhbmRsZXIod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICAgIGN1cnJlbnQgPSB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlO1xuICAgICAgICAgIGlmIChudWxsICE9PSBjdXJyZW50ICYmIG51bGwgIT09IGN1cnJlbnQuZGVoeWRyYXRlZCkge1xuICAgICAgICAgICAgaWYgKG51bGwgPT09IHdvcmtJblByb2dyZXNzLmFsdGVybmF0ZSlcbiAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXG4gICAgICAgICAgICAgICAgXCJUaHJldyBpbiBuZXdseSBtb3VudGVkIGRlaHlkcmF0ZWQgY29tcG9uZW50LiBUaGlzIGlzIGxpa2VseSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuXCJcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIHJlc2V0SHlkcmF0aW9uU3RhdGUoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY3VycmVudCA9IHdvcmtJblByb2dyZXNzLmZsYWdzO1xuICAgICAgICAgIHJldHVybiBjdXJyZW50ICYgNjU1MzZcbiAgICAgICAgICAgID8gKCh3b3JrSW5Qcm9ncmVzcy5mbGFncyA9IChjdXJyZW50ICYgLTY1NTM3KSB8IDEyOCksXG4gICAgICAgICAgICAgICh3b3JrSW5Qcm9ncmVzcy5tb2RlICYgMikgIT09IE5vTW9kZSAmJlxuICAgICAgICAgICAgICAgIHRyYW5zZmVyQWN0dWFsRHVyYXRpb24od29ya0luUHJvZ3Jlc3MpLFxuICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcylcbiAgICAgICAgICAgIDogbnVsbDtcbiAgICAgICAgY2FzZSAxOTpcbiAgICAgICAgICByZXR1cm4gcG9wKHN1c3BlbnNlU3RhY2tDdXJzb3IsIHdvcmtJblByb2dyZXNzKSwgbnVsbDtcbiAgICAgICAgY2FzZSA0OlxuICAgICAgICAgIHJldHVybiBwb3BIb3N0Q29udGFpbmVyKHdvcmtJblByb2dyZXNzKSwgbnVsbDtcbiAgICAgICAgY2FzZSAxMDpcbiAgICAgICAgICByZXR1cm4gcG9wUHJvdmlkZXIod29ya0luUHJvZ3Jlc3MudHlwZSwgd29ya0luUHJvZ3Jlc3MpLCBudWxsO1xuICAgICAgICBjYXNlIDIyOlxuICAgICAgICBjYXNlIDIzOlxuICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICBwb3BTdXNwZW5zZUhhbmRsZXIod29ya0luUHJvZ3Jlc3MpLFxuICAgICAgICAgICAgcG9wSGlkZGVuQ29udGV4dCh3b3JrSW5Qcm9ncmVzcyksXG4gICAgICAgICAgICBudWxsICE9PSBjdXJyZW50ICYmIHBvcChyZXN1bWVkQ2FjaGUsIHdvcmtJblByb2dyZXNzKSxcbiAgICAgICAgICAgIChjdXJyZW50ID0gd29ya0luUHJvZ3Jlc3MuZmxhZ3MpLFxuICAgICAgICAgICAgY3VycmVudCAmIDY1NTM2XG4gICAgICAgICAgICAgID8gKCh3b3JrSW5Qcm9ncmVzcy5mbGFncyA9IChjdXJyZW50ICYgLTY1NTM3KSB8IDEyOCksXG4gICAgICAgICAgICAgICAgKHdvcmtJblByb2dyZXNzLm1vZGUgJiAyKSAhPT0gTm9Nb2RlICYmXG4gICAgICAgICAgICAgICAgICB0cmFuc2ZlckFjdHVhbER1cmF0aW9uKHdvcmtJblByb2dyZXNzKSxcbiAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcylcbiAgICAgICAgICAgICAgOiBudWxsXG4gICAgICAgICAgKTtcbiAgICAgICAgY2FzZSAyNDpcbiAgICAgICAgICByZXR1cm4gcG9wUHJvdmlkZXIoQ2FjaGVDb250ZXh0LCB3b3JrSW5Qcm9ncmVzcyksIG51bGw7XG4gICAgICAgIGNhc2UgMjU6XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIHVud2luZEludGVycnVwdGVkV29yayhjdXJyZW50LCBpbnRlcnJ1cHRlZFdvcmspIHtcbiAgICAgIHBvcFRyZWVDb250ZXh0KGludGVycnVwdGVkV29yayk7XG4gICAgICBzd2l0Y2ggKGludGVycnVwdGVkV29yay50YWcpIHtcbiAgICAgICAgY2FzZSAzOlxuICAgICAgICAgIHBvcFByb3ZpZGVyKENhY2hlQ29udGV4dCwgaW50ZXJydXB0ZWRXb3JrKTtcbiAgICAgICAgICBwb3BIb3N0Q29udGFpbmVyKGludGVycnVwdGVkV29yayk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMjY6XG4gICAgICAgIGNhc2UgMjc6XG4gICAgICAgIGNhc2UgNTpcbiAgICAgICAgICBwb3BIb3N0Q29udGV4dChpbnRlcnJ1cHRlZFdvcmspO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgcG9wSG9zdENvbnRhaW5lcihpbnRlcnJ1cHRlZFdvcmspO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDEzOlxuICAgICAgICAgIHBvcFN1c3BlbnNlSGFuZGxlcihpbnRlcnJ1cHRlZFdvcmspO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDE5OlxuICAgICAgICAgIHBvcChzdXNwZW5zZVN0YWNrQ3Vyc29yLCBpbnRlcnJ1cHRlZFdvcmspO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDEwOlxuICAgICAgICAgIHBvcFByb3ZpZGVyKGludGVycnVwdGVkV29yay50eXBlLCBpbnRlcnJ1cHRlZFdvcmspO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDIyOlxuICAgICAgICBjYXNlIDIzOlxuICAgICAgICAgIHBvcFN1c3BlbnNlSGFuZGxlcihpbnRlcnJ1cHRlZFdvcmspO1xuICAgICAgICAgIHBvcEhpZGRlbkNvbnRleHQoaW50ZXJydXB0ZWRXb3JrKTtcbiAgICAgICAgICBudWxsICE9PSBjdXJyZW50ICYmIHBvcChyZXN1bWVkQ2FjaGUsIGludGVycnVwdGVkV29yayk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMjQ6XG4gICAgICAgICAgcG9wUHJvdmlkZXIoQ2FjaGVDb250ZXh0LCBpbnRlcnJ1cHRlZFdvcmspO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBzaG91bGRQcm9maWxlKGN1cnJlbnQpIHtcbiAgICAgIHJldHVybiAoY3VycmVudC5tb2RlICYgMikgIT09IE5vTW9kZTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY29tbWl0SG9va0xheW91dEVmZmVjdHMoZmluaXNoZWRXb3JrLCBob29rRmxhZ3MpIHtcbiAgICAgIHNob3VsZFByb2ZpbGUoZmluaXNoZWRXb3JrKVxuICAgICAgICA/IChzdGFydEVmZmVjdFRpbWVyKCksXG4gICAgICAgICAgY29tbWl0SG9va0VmZmVjdExpc3RNb3VudChob29rRmxhZ3MsIGZpbmlzaGVkV29yayksXG4gICAgICAgICAgcmVjb3JkRWZmZWN0RHVyYXRpb24oKSlcbiAgICAgICAgOiBjb21taXRIb29rRWZmZWN0TGlzdE1vdW50KGhvb2tGbGFncywgZmluaXNoZWRXb3JrKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY29tbWl0SG9va0xheW91dFVubW91bnRFZmZlY3RzKFxuICAgICAgZmluaXNoZWRXb3JrLFxuICAgICAgbmVhcmVzdE1vdW50ZWRBbmNlc3RvcixcbiAgICAgIGhvb2tGbGFnc1xuICAgICkge1xuICAgICAgc2hvdWxkUHJvZmlsZShmaW5pc2hlZFdvcmspXG4gICAgICAgID8gKHN0YXJ0RWZmZWN0VGltZXIoKSxcbiAgICAgICAgICBjb21taXRIb29rRWZmZWN0TGlzdFVubW91bnQoXG4gICAgICAgICAgICBob29rRmxhZ3MsXG4gICAgICAgICAgICBmaW5pc2hlZFdvcmssXG4gICAgICAgICAgICBuZWFyZXN0TW91bnRlZEFuY2VzdG9yXG4gICAgICAgICAgKSxcbiAgICAgICAgICByZWNvcmRFZmZlY3REdXJhdGlvbigpKVxuICAgICAgICA6IGNvbW1pdEhvb2tFZmZlY3RMaXN0VW5tb3VudChcbiAgICAgICAgICAgIGhvb2tGbGFncyxcbiAgICAgICAgICAgIGZpbmlzaGVkV29yayxcbiAgICAgICAgICAgIG5lYXJlc3RNb3VudGVkQW5jZXN0b3JcbiAgICAgICAgICApO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjb21taXRIb29rRWZmZWN0TGlzdE1vdW50KGZsYWdzLCBmaW5pc2hlZFdvcmspIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHZhciB1cGRhdGVRdWV1ZSA9IGZpbmlzaGVkV29yay51cGRhdGVRdWV1ZSxcbiAgICAgICAgICBsYXN0RWZmZWN0ID0gbnVsbCAhPT0gdXBkYXRlUXVldWUgPyB1cGRhdGVRdWV1ZS5sYXN0RWZmZWN0IDogbnVsbDtcbiAgICAgICAgaWYgKG51bGwgIT09IGxhc3RFZmZlY3QpIHtcbiAgICAgICAgICB2YXIgZmlyc3RFZmZlY3QgPSBsYXN0RWZmZWN0Lm5leHQ7XG4gICAgICAgICAgdXBkYXRlUXVldWUgPSBmaXJzdEVmZmVjdDtcbiAgICAgICAgICBkbyB7XG4gICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICh1cGRhdGVRdWV1ZS50YWcgJiBmbGFncykgPT09IGZsYWdzICYmXG4gICAgICAgICAgICAgICgoZmxhZ3MgJiBQYXNzaXZlKSAhPT0gTm9GbGFnc1xuICAgICAgICAgICAgICAgID8gbnVsbCAhPT0gaW5qZWN0ZWRQcm9maWxpbmdIb29rcyAmJlxuICAgICAgICAgICAgICAgICAgXCJmdW5jdGlvblwiID09PVxuICAgICAgICAgICAgICAgICAgICB0eXBlb2YgaW5qZWN0ZWRQcm9maWxpbmdIb29rcy5tYXJrQ29tcG9uZW50UGFzc2l2ZUVmZmVjdE1vdW50U3RhcnRlZCAmJlxuICAgICAgICAgICAgICAgICAgaW5qZWN0ZWRQcm9maWxpbmdIb29rcy5tYXJrQ29tcG9uZW50UGFzc2l2ZUVmZmVjdE1vdW50U3RhcnRlZChcbiAgICAgICAgICAgICAgICAgICAgZmluaXNoZWRXb3JrXG4gICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgOiAoZmxhZ3MgJiBMYXlvdXQpICE9PSBOb0ZsYWdzICYmXG4gICAgICAgICAgICAgICAgICBudWxsICE9PSBpbmplY3RlZFByb2ZpbGluZ0hvb2tzICYmXG4gICAgICAgICAgICAgICAgICBcImZ1bmN0aW9uXCIgPT09XG4gICAgICAgICAgICAgICAgICAgIHR5cGVvZiBpbmplY3RlZFByb2ZpbGluZ0hvb2tzLm1hcmtDb21wb25lbnRMYXlvdXRFZmZlY3RNb3VudFN0YXJ0ZWQgJiZcbiAgICAgICAgICAgICAgICAgIGluamVjdGVkUHJvZmlsaW5nSG9va3MubWFya0NvbXBvbmVudExheW91dEVmZmVjdE1vdW50U3RhcnRlZChcbiAgICAgICAgICAgICAgICAgICAgZmluaXNoZWRXb3JrXG4gICAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAobGFzdEVmZmVjdCA9IHZvaWQgMCksXG4gICAgICAgICAgICAgIChmbGFncyAmIEluc2VydGlvbikgIT09IE5vRmxhZ3MgJiZcbiAgICAgICAgICAgICAgICAoaXNSdW5uaW5nSW5zZXJ0aW9uRWZmZWN0ID0gITApLFxuICAgICAgICAgICAgICAobGFzdEVmZmVjdCA9IHJ1bldpdGhGaWJlckluREVWKFxuICAgICAgICAgICAgICAgIGZpbmlzaGVkV29yayxcbiAgICAgICAgICAgICAgICBjYWxsQ3JlYXRlSW5ERVYsXG4gICAgICAgICAgICAgICAgdXBkYXRlUXVldWVcbiAgICAgICAgICAgICAgKSksXG4gICAgICAgICAgICAgIChmbGFncyAmIEluc2VydGlvbikgIT09IE5vRmxhZ3MgJiZcbiAgICAgICAgICAgICAgICAoaXNSdW5uaW5nSW5zZXJ0aW9uRWZmZWN0ID0gITEpLFxuICAgICAgICAgICAgICAoZmxhZ3MgJiBQYXNzaXZlKSAhPT0gTm9GbGFnc1xuICAgICAgICAgICAgICAgID8gbnVsbCAhPT0gaW5qZWN0ZWRQcm9maWxpbmdIb29rcyAmJlxuICAgICAgICAgICAgICAgICAgXCJmdW5jdGlvblwiID09PVxuICAgICAgICAgICAgICAgICAgICB0eXBlb2YgaW5qZWN0ZWRQcm9maWxpbmdIb29rcy5tYXJrQ29tcG9uZW50UGFzc2l2ZUVmZmVjdE1vdW50U3RvcHBlZCAmJlxuICAgICAgICAgICAgICAgICAgaW5qZWN0ZWRQcm9maWxpbmdIb29rcy5tYXJrQ29tcG9uZW50UGFzc2l2ZUVmZmVjdE1vdW50U3RvcHBlZCgpXG4gICAgICAgICAgICAgICAgOiAoZmxhZ3MgJiBMYXlvdXQpICE9PSBOb0ZsYWdzICYmXG4gICAgICAgICAgICAgICAgICBudWxsICE9PSBpbmplY3RlZFByb2ZpbGluZ0hvb2tzICYmXG4gICAgICAgICAgICAgICAgICBcImZ1bmN0aW9uXCIgPT09XG4gICAgICAgICAgICAgICAgICAgIHR5cGVvZiBpbmplY3RlZFByb2ZpbGluZ0hvb2tzLm1hcmtDb21wb25lbnRMYXlvdXRFZmZlY3RNb3VudFN0b3BwZWQgJiZcbiAgICAgICAgICAgICAgICAgIGluamVjdGVkUHJvZmlsaW5nSG9va3MubWFya0NvbXBvbmVudExheW91dEVmZmVjdE1vdW50U3RvcHBlZCgpLFxuICAgICAgICAgICAgICB2b2lkIDAgIT09IGxhc3RFZmZlY3QgJiYgXCJmdW5jdGlvblwiICE9PSB0eXBlb2YgbGFzdEVmZmVjdClcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICB2YXIgaG9va05hbWUgPSB2b2lkIDA7XG4gICAgICAgICAgICAgIGhvb2tOYW1lID1cbiAgICAgICAgICAgICAgICAwICE9PSAodXBkYXRlUXVldWUudGFnICYgTGF5b3V0KVxuICAgICAgICAgICAgICAgICAgPyBcInVzZUxheW91dEVmZmVjdFwiXG4gICAgICAgICAgICAgICAgICA6IDAgIT09ICh1cGRhdGVRdWV1ZS50YWcgJiBJbnNlcnRpb24pXG4gICAgICAgICAgICAgICAgICAgID8gXCJ1c2VJbnNlcnRpb25FZmZlY3RcIlxuICAgICAgICAgICAgICAgICAgICA6IFwidXNlRWZmZWN0XCI7XG4gICAgICAgICAgICAgIHZhciBhZGRlbmR1bSA9IHZvaWQgMDtcbiAgICAgICAgICAgICAgYWRkZW5kdW0gPVxuICAgICAgICAgICAgICAgIG51bGwgPT09IGxhc3RFZmZlY3RcbiAgICAgICAgICAgICAgICAgID8gXCIgWW91IHJldHVybmVkIG51bGwuIElmIHlvdXIgZWZmZWN0IGRvZXMgbm90IHJlcXVpcmUgY2xlYW4gdXAsIHJldHVybiB1bmRlZmluZWQgKG9yIG5vdGhpbmcpLlwiXG4gICAgICAgICAgICAgICAgICA6IFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIGxhc3RFZmZlY3QudGhlblxuICAgICAgICAgICAgICAgICAgICA/IFwiXFxuXFxuSXQgbG9va3MgbGlrZSB5b3Ugd3JvdGUgXCIgK1xuICAgICAgICAgICAgICAgICAgICAgIGhvb2tOYW1lICtcbiAgICAgICAgICAgICAgICAgICAgICBcIihhc3luYyAoKSA9PiAuLi4pIG9yIHJldHVybmVkIGEgUHJvbWlzZS4gSW5zdGVhZCwgd3JpdGUgdGhlIGFzeW5jIGZ1bmN0aW9uIGluc2lkZSB5b3VyIGVmZmVjdCBhbmQgY2FsbCBpdCBpbW1lZGlhdGVseTpcXG5cXG5cIiArXG4gICAgICAgICAgICAgICAgICAgICAgaG9va05hbWUgK1xuICAgICAgICAgICAgICAgICAgICAgIFwiKCgpID0+IHtcXG4gIGFzeW5jIGZ1bmN0aW9uIGZldGNoRGF0YSgpIHtcXG4gICAgLy8gWW91IGNhbiBhd2FpdCBoZXJlXFxuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgTXlBUEkuZ2V0RGF0YShzb21lSWQpO1xcbiAgICAvLyAuLi5cXG4gIH1cXG4gIGZldGNoRGF0YSgpO1xcbn0sIFtzb21lSWRdKTsgLy8gT3IgW10gaWYgZWZmZWN0IGRvZXNuJ3QgbmVlZCBwcm9wcyBvciBzdGF0ZVxcblxcbkxlYXJuIG1vcmUgYWJvdXQgZGF0YSBmZXRjaGluZyB3aXRoIEhvb2tzOiBodHRwczovL3JlYWN0LmRldi9saW5rL2hvb2tzLWRhdGEtZmV0Y2hpbmdcIlxuICAgICAgICAgICAgICAgICAgICA6IFwiIFlvdSByZXR1cm5lZDogXCIgKyBsYXN0RWZmZWN0O1xuICAgICAgICAgICAgICBydW5XaXRoRmliZXJJbkRFVihcbiAgICAgICAgICAgICAgICBmaW5pc2hlZFdvcmssXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gKG4sIGEpIHtcbiAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgICAgICAgIFwiJXMgbXVzdCBub3QgcmV0dXJuIGFueXRoaW5nIGJlc2lkZXMgYSBmdW5jdGlvbiwgd2hpY2ggaXMgdXNlZCBmb3IgY2xlYW4tdXAuJXNcIixcbiAgICAgICAgICAgICAgICAgICAgbixcbiAgICAgICAgICAgICAgICAgICAgYVxuICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGhvb2tOYW1lLFxuICAgICAgICAgICAgICAgIGFkZGVuZHVtXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB1cGRhdGVRdWV1ZSA9IHVwZGF0ZVF1ZXVlLm5leHQ7XG4gICAgICAgICAgfSB3aGlsZSAodXBkYXRlUXVldWUgIT09IGZpcnN0RWZmZWN0KTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgY2FwdHVyZUNvbW1pdFBoYXNlRXJyb3IoZmluaXNoZWRXb3JrLCBmaW5pc2hlZFdvcmsucmV0dXJuLCBlcnJvcik7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNvbW1pdEhvb2tFZmZlY3RMaXN0VW5tb3VudChcbiAgICAgIGZsYWdzLFxuICAgICAgZmluaXNoZWRXb3JrLFxuICAgICAgbmVhcmVzdE1vdW50ZWRBbmNlc3RvclxuICAgICkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgdmFyIHVwZGF0ZVF1ZXVlID0gZmluaXNoZWRXb3JrLnVwZGF0ZVF1ZXVlLFxuICAgICAgICAgIGxhc3RFZmZlY3QgPSBudWxsICE9PSB1cGRhdGVRdWV1ZSA/IHVwZGF0ZVF1ZXVlLmxhc3RFZmZlY3QgOiBudWxsO1xuICAgICAgICBpZiAobnVsbCAhPT0gbGFzdEVmZmVjdCkge1xuICAgICAgICAgIHZhciBmaXJzdEVmZmVjdCA9IGxhc3RFZmZlY3QubmV4dDtcbiAgICAgICAgICB1cGRhdGVRdWV1ZSA9IGZpcnN0RWZmZWN0O1xuICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgIGlmICgodXBkYXRlUXVldWUudGFnICYgZmxhZ3MpID09PSBmbGFncykge1xuICAgICAgICAgICAgICB2YXIgaW5zdCA9IHVwZGF0ZVF1ZXVlLmluc3QsXG4gICAgICAgICAgICAgICAgZGVzdHJveSA9IGluc3QuZGVzdHJveTtcbiAgICAgICAgICAgICAgdm9pZCAwICE9PSBkZXN0cm95ICYmXG4gICAgICAgICAgICAgICAgKChpbnN0LmRlc3Ryb3kgPSB2b2lkIDApLFxuICAgICAgICAgICAgICAgIChmbGFncyAmIFBhc3NpdmUpICE9PSBOb0ZsYWdzXG4gICAgICAgICAgICAgICAgICA/IG51bGwgIT09IGluamVjdGVkUHJvZmlsaW5nSG9va3MgJiZcbiAgICAgICAgICAgICAgICAgICAgXCJmdW5jdGlvblwiID09PVxuICAgICAgICAgICAgICAgICAgICAgIHR5cGVvZiBpbmplY3RlZFByb2ZpbGluZ0hvb2tzLm1hcmtDb21wb25lbnRQYXNzaXZlRWZmZWN0VW5tb3VudFN0YXJ0ZWQgJiZcbiAgICAgICAgICAgICAgICAgICAgaW5qZWN0ZWRQcm9maWxpbmdIb29rcy5tYXJrQ29tcG9uZW50UGFzc2l2ZUVmZmVjdFVubW91bnRTdGFydGVkKFxuICAgICAgICAgICAgICAgICAgICAgIGZpbmlzaGVkV29ya1xuICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICA6IChmbGFncyAmIExheW91dCkgIT09IE5vRmxhZ3MgJiZcbiAgICAgICAgICAgICAgICAgICAgbnVsbCAhPT0gaW5qZWN0ZWRQcm9maWxpbmdIb29rcyAmJlxuICAgICAgICAgICAgICAgICAgICBcImZ1bmN0aW9uXCIgPT09XG4gICAgICAgICAgICAgICAgICAgICAgdHlwZW9mIGluamVjdGVkUHJvZmlsaW5nSG9va3MubWFya0NvbXBvbmVudExheW91dEVmZmVjdFVubW91bnRTdGFydGVkICYmXG4gICAgICAgICAgICAgICAgICAgIGluamVjdGVkUHJvZmlsaW5nSG9va3MubWFya0NvbXBvbmVudExheW91dEVmZmVjdFVubW91bnRTdGFydGVkKFxuICAgICAgICAgICAgICAgICAgICAgIGZpbmlzaGVkV29ya1xuICAgICAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgIChmbGFncyAmIEluc2VydGlvbikgIT09IE5vRmxhZ3MgJiZcbiAgICAgICAgICAgICAgICAgIChpc1J1bm5pbmdJbnNlcnRpb25FZmZlY3QgPSAhMCksXG4gICAgICAgICAgICAgICAgcnVuV2l0aEZpYmVySW5ERVYoXG4gICAgICAgICAgICAgICAgICBmaW5pc2hlZFdvcmssXG4gICAgICAgICAgICAgICAgICBjYWxsRGVzdHJveUluREVWLFxuICAgICAgICAgICAgICAgICAgZmluaXNoZWRXb3JrLFxuICAgICAgICAgICAgICAgICAgbmVhcmVzdE1vdW50ZWRBbmNlc3RvcixcbiAgICAgICAgICAgICAgICAgIGRlc3Ryb3lcbiAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgIChmbGFncyAmIEluc2VydGlvbikgIT09IE5vRmxhZ3MgJiZcbiAgICAgICAgICAgICAgICAgIChpc1J1bm5pbmdJbnNlcnRpb25FZmZlY3QgPSAhMSksXG4gICAgICAgICAgICAgICAgKGZsYWdzICYgUGFzc2l2ZSkgIT09IE5vRmxhZ3NcbiAgICAgICAgICAgICAgICAgID8gbnVsbCAhPT0gaW5qZWN0ZWRQcm9maWxpbmdIb29rcyAmJlxuICAgICAgICAgICAgICAgICAgICBcImZ1bmN0aW9uXCIgPT09XG4gICAgICAgICAgICAgICAgICAgICAgdHlwZW9mIGluamVjdGVkUHJvZmlsaW5nSG9va3MubWFya0NvbXBvbmVudFBhc3NpdmVFZmZlY3RVbm1vdW50U3RvcHBlZCAmJlxuICAgICAgICAgICAgICAgICAgICBpbmplY3RlZFByb2ZpbGluZ0hvb2tzLm1hcmtDb21wb25lbnRQYXNzaXZlRWZmZWN0VW5tb3VudFN0b3BwZWQoKVxuICAgICAgICAgICAgICAgICAgOiAoZmxhZ3MgJiBMYXlvdXQpICE9PSBOb0ZsYWdzICYmXG4gICAgICAgICAgICAgICAgICAgIG51bGwgIT09IGluamVjdGVkUHJvZmlsaW5nSG9va3MgJiZcbiAgICAgICAgICAgICAgICAgICAgXCJmdW5jdGlvblwiID09PVxuICAgICAgICAgICAgICAgICAgICAgIHR5cGVvZiBpbmplY3RlZFByb2ZpbGluZ0hvb2tzLm1hcmtDb21wb25lbnRMYXlvdXRFZmZlY3RVbm1vdW50U3RvcHBlZCAmJlxuICAgICAgICAgICAgICAgICAgICBpbmplY3RlZFByb2ZpbGluZ0hvb2tzLm1hcmtDb21wb25lbnRMYXlvdXRFZmZlY3RVbm1vdW50U3RvcHBlZCgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHVwZGF0ZVF1ZXVlID0gdXBkYXRlUXVldWUubmV4dDtcbiAgICAgICAgICB9IHdoaWxlICh1cGRhdGVRdWV1ZSAhPT0gZmlyc3RFZmZlY3QpO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBjYXB0dXJlQ29tbWl0UGhhc2VFcnJvcihmaW5pc2hlZFdvcmssIGZpbmlzaGVkV29yay5yZXR1cm4sIGVycm9yKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gY29tbWl0SG9va1Bhc3NpdmVNb3VudEVmZmVjdHMoZmluaXNoZWRXb3JrLCBob29rRmxhZ3MpIHtcbiAgICAgIHNob3VsZFByb2ZpbGUoZmluaXNoZWRXb3JrKVxuICAgICAgICA/IChzdGFydEVmZmVjdFRpbWVyKCksXG4gICAgICAgICAgY29tbWl0SG9va0VmZmVjdExpc3RNb3VudChob29rRmxhZ3MsIGZpbmlzaGVkV29yayksXG4gICAgICAgICAgcmVjb3JkRWZmZWN0RHVyYXRpb24oKSlcbiAgICAgICAgOiBjb21taXRIb29rRWZmZWN0TGlzdE1vdW50KGhvb2tGbGFncywgZmluaXNoZWRXb3JrKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY29tbWl0SG9va1Bhc3NpdmVVbm1vdW50RWZmZWN0cyhcbiAgICAgIGZpbmlzaGVkV29yayxcbiAgICAgIG5lYXJlc3RNb3VudGVkQW5jZXN0b3IsXG4gICAgICBob29rRmxhZ3NcbiAgICApIHtcbiAgICAgIHNob3VsZFByb2ZpbGUoZmluaXNoZWRXb3JrKVxuICAgICAgICA/IChzdGFydEVmZmVjdFRpbWVyKCksXG4gICAgICAgICAgY29tbWl0SG9va0VmZmVjdExpc3RVbm1vdW50KFxuICAgICAgICAgICAgaG9va0ZsYWdzLFxuICAgICAgICAgICAgZmluaXNoZWRXb3JrLFxuICAgICAgICAgICAgbmVhcmVzdE1vdW50ZWRBbmNlc3RvclxuICAgICAgICAgICksXG4gICAgICAgICAgcmVjb3JkRWZmZWN0RHVyYXRpb24oKSlcbiAgICAgICAgOiBjb21taXRIb29rRWZmZWN0TGlzdFVubW91bnQoXG4gICAgICAgICAgICBob29rRmxhZ3MsXG4gICAgICAgICAgICBmaW5pc2hlZFdvcmssXG4gICAgICAgICAgICBuZWFyZXN0TW91bnRlZEFuY2VzdG9yXG4gICAgICAgICAgKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY29tbWl0Q2xhc3NDYWxsYmFja3MoZmluaXNoZWRXb3JrKSB7XG4gICAgICB2YXIgdXBkYXRlUXVldWUgPSBmaW5pc2hlZFdvcmsudXBkYXRlUXVldWU7XG4gICAgICBpZiAobnVsbCAhPT0gdXBkYXRlUXVldWUpIHtcbiAgICAgICAgdmFyIGluc3RhbmNlID0gZmluaXNoZWRXb3JrLnN0YXRlTm9kZTtcbiAgICAgICAgZmluaXNoZWRXb3JrLnR5cGUuZGVmYXVsdFByb3BzIHx8XG4gICAgICAgICAgXCJyZWZcIiBpbiBmaW5pc2hlZFdvcmsubWVtb2l6ZWRQcm9wcyB8fFxuICAgICAgICAgIGRpZFdhcm5BYm91dFJlYXNzaWduaW5nUHJvcHMgfHxcbiAgICAgICAgICAoaW5zdGFuY2UucHJvcHMgIT09IGZpbmlzaGVkV29yay5tZW1vaXplZFByb3BzICYmXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICBcIkV4cGVjdGVkICVzIHByb3BzIHRvIG1hdGNoIG1lbW9pemVkIHByb3BzIGJlZm9yZSBwcm9jZXNzaW5nIHRoZSB1cGRhdGUgcXVldWUuIFRoaXMgbWlnaHQgZWl0aGVyIGJlIGJlY2F1c2Ugb2YgYSBidWcgaW4gUmVhY3QsIG9yIGJlY2F1c2UgYSBjb21wb25lbnQgcmVhc3NpZ25zIGl0cyBvd24gYHRoaXMucHJvcHNgLiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS5cIixcbiAgICAgICAgICAgICAgZ2V0Q29tcG9uZW50TmFtZUZyb21GaWJlcihmaW5pc2hlZFdvcmspIHx8IFwiaW5zdGFuY2VcIlxuICAgICAgICAgICAgKSxcbiAgICAgICAgICBpbnN0YW5jZS5zdGF0ZSAhPT0gZmluaXNoZWRXb3JrLm1lbW9pemVkU3RhdGUgJiZcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgIFwiRXhwZWN0ZWQgJXMgc3RhdGUgdG8gbWF0Y2ggbWVtb2l6ZWQgc3RhdGUgYmVmb3JlIHByb2Nlc3NpbmcgdGhlIHVwZGF0ZSBxdWV1ZS4gVGhpcyBtaWdodCBlaXRoZXIgYmUgYmVjYXVzZSBvZiBhIGJ1ZyBpbiBSZWFjdCwgb3IgYmVjYXVzZSBhIGNvbXBvbmVudCByZWFzc2lnbnMgaXRzIG93biBgdGhpcy5zdGF0ZWAuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLlwiLFxuICAgICAgICAgICAgICBnZXRDb21wb25lbnROYW1lRnJvbUZpYmVyKGZpbmlzaGVkV29yaykgfHwgXCJpbnN0YW5jZVwiXG4gICAgICAgICAgICApKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBydW5XaXRoRmliZXJJbkRFVihcbiAgICAgICAgICAgIGZpbmlzaGVkV29yayxcbiAgICAgICAgICAgIGNvbW1pdENhbGxiYWNrcyxcbiAgICAgICAgICAgIHVwZGF0ZVF1ZXVlLFxuICAgICAgICAgICAgaW5zdGFuY2VcbiAgICAgICAgICApO1xuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgIGNhcHR1cmVDb21taXRQaGFzZUVycm9yKGZpbmlzaGVkV29yaywgZmluaXNoZWRXb3JrLnJldHVybiwgZXJyb3IpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNhbGxHZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZXMoaW5zdGFuY2UsIHByZXZQcm9wcywgcHJldlN0YXRlKSB7XG4gICAgICByZXR1cm4gaW5zdGFuY2UuZ2V0U25hcHNob3RCZWZvcmVVcGRhdGUocHJldlByb3BzLCBwcmV2U3RhdGUpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjb21taXRDbGFzc1NuYXBzaG90KGZpbmlzaGVkV29yaywgY3VycmVudCkge1xuICAgICAgdmFyIHByZXZQcm9wcyA9IGN1cnJlbnQubWVtb2l6ZWRQcm9wcyxcbiAgICAgICAgcHJldlN0YXRlID0gY3VycmVudC5tZW1vaXplZFN0YXRlO1xuICAgICAgY3VycmVudCA9IGZpbmlzaGVkV29yay5zdGF0ZU5vZGU7XG4gICAgICBmaW5pc2hlZFdvcmsudHlwZS5kZWZhdWx0UHJvcHMgfHxcbiAgICAgICAgXCJyZWZcIiBpbiBmaW5pc2hlZFdvcmsubWVtb2l6ZWRQcm9wcyB8fFxuICAgICAgICBkaWRXYXJuQWJvdXRSZWFzc2lnbmluZ1Byb3BzIHx8XG4gICAgICAgIChjdXJyZW50LnByb3BzICE9PSBmaW5pc2hlZFdvcmsubWVtb2l6ZWRQcm9wcyAmJlxuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICBcIkV4cGVjdGVkICVzIHByb3BzIHRvIG1hdGNoIG1lbW9pemVkIHByb3BzIGJlZm9yZSBnZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZS4gVGhpcyBtaWdodCBlaXRoZXIgYmUgYmVjYXVzZSBvZiBhIGJ1ZyBpbiBSZWFjdCwgb3IgYmVjYXVzZSBhIGNvbXBvbmVudCByZWFzc2lnbnMgaXRzIG93biBgdGhpcy5wcm9wc2AuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLlwiLFxuICAgICAgICAgICAgZ2V0Q29tcG9uZW50TmFtZUZyb21GaWJlcihmaW5pc2hlZFdvcmspIHx8IFwiaW5zdGFuY2VcIlxuICAgICAgICAgICksXG4gICAgICAgIGN1cnJlbnQuc3RhdGUgIT09IGZpbmlzaGVkV29yay5tZW1vaXplZFN0YXRlICYmXG4gICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgIFwiRXhwZWN0ZWQgJXMgc3RhdGUgdG8gbWF0Y2ggbWVtb2l6ZWQgc3RhdGUgYmVmb3JlIGdldFNuYXBzaG90QmVmb3JlVXBkYXRlLiBUaGlzIG1pZ2h0IGVpdGhlciBiZSBiZWNhdXNlIG9mIGEgYnVnIGluIFJlYWN0LCBvciBiZWNhdXNlIGEgY29tcG9uZW50IHJlYXNzaWducyBpdHMgb3duIGB0aGlzLnN0YXRlYC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuXCIsXG4gICAgICAgICAgICBnZXRDb21wb25lbnROYW1lRnJvbUZpYmVyKGZpbmlzaGVkV29yaykgfHwgXCJpbnN0YW5jZVwiXG4gICAgICAgICAgKSk7XG4gICAgICB0cnkge1xuICAgICAgICB2YXIgcmVzb2x2ZWRQcmV2UHJvcHMgPSByZXNvbHZlQ2xhc3NDb21wb25lbnRQcm9wcyhcbiAgICAgICAgICBmaW5pc2hlZFdvcmsudHlwZSxcbiAgICAgICAgICBwcmV2UHJvcHMsXG4gICAgICAgICAgZmluaXNoZWRXb3JrLmVsZW1lbnRUeXBlID09PSBmaW5pc2hlZFdvcmsudHlwZVxuICAgICAgICApO1xuICAgICAgICB2YXIgc25hcHNob3QgPSBydW5XaXRoRmliZXJJbkRFVihcbiAgICAgICAgICBmaW5pc2hlZFdvcmssXG4gICAgICAgICAgY2FsbEdldFNuYXBzaG90QmVmb3JlVXBkYXRlcyxcbiAgICAgICAgICBjdXJyZW50LFxuICAgICAgICAgIHJlc29sdmVkUHJldlByb3BzLFxuICAgICAgICAgIHByZXZTdGF0ZVxuICAgICAgICApO1xuICAgICAgICBwcmV2UHJvcHMgPSBkaWRXYXJuQWJvdXRVbmRlZmluZWRTbmFwc2hvdEJlZm9yZVVwZGF0ZTtcbiAgICAgICAgdm9pZCAwICE9PSBzbmFwc2hvdCB8fFxuICAgICAgICAgIHByZXZQcm9wcy5oYXMoZmluaXNoZWRXb3JrLnR5cGUpIHx8XG4gICAgICAgICAgKHByZXZQcm9wcy5hZGQoZmluaXNoZWRXb3JrLnR5cGUpLFxuICAgICAgICAgIHJ1bldpdGhGaWJlckluREVWKGZpbmlzaGVkV29yaywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgXCIlcy5nZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZSgpOiBBIHNuYXBzaG90IHZhbHVlIChvciBudWxsKSBtdXN0IGJlIHJldHVybmVkLiBZb3UgaGF2ZSByZXR1cm5lZCB1bmRlZmluZWQuXCIsXG4gICAgICAgICAgICAgIGdldENvbXBvbmVudE5hbWVGcm9tRmliZXIoZmluaXNoZWRXb3JrKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9KSk7XG4gICAgICAgIGN1cnJlbnQuX19yZWFjdEludGVybmFsU25hcHNob3RCZWZvcmVVcGRhdGUgPSBzbmFwc2hvdDtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGNhcHR1cmVDb21taXRQaGFzZUVycm9yKGZpbmlzaGVkV29yaywgZmluaXNoZWRXb3JrLnJldHVybiwgZXJyb3IpO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBzYWZlbHlDYWxsQ29tcG9uZW50V2lsbFVubW91bnQoXG4gICAgICBjdXJyZW50LFxuICAgICAgbmVhcmVzdE1vdW50ZWRBbmNlc3RvcixcbiAgICAgIGluc3RhbmNlXG4gICAgKSB7XG4gICAgICBpbnN0YW5jZS5wcm9wcyA9IHJlc29sdmVDbGFzc0NvbXBvbmVudFByb3BzKFxuICAgICAgICBjdXJyZW50LnR5cGUsXG4gICAgICAgIGN1cnJlbnQubWVtb2l6ZWRQcm9wc1xuICAgICAgKTtcbiAgICAgIGluc3RhbmNlLnN0YXRlID0gY3VycmVudC5tZW1vaXplZFN0YXRlO1xuICAgICAgc2hvdWxkUHJvZmlsZShjdXJyZW50KVxuICAgICAgICA/IChzdGFydEVmZmVjdFRpbWVyKCksXG4gICAgICAgICAgcnVuV2l0aEZpYmVySW5ERVYoXG4gICAgICAgICAgICBjdXJyZW50LFxuICAgICAgICAgICAgY2FsbENvbXBvbmVudFdpbGxVbm1vdW50SW5ERVYsXG4gICAgICAgICAgICBjdXJyZW50LFxuICAgICAgICAgICAgbmVhcmVzdE1vdW50ZWRBbmNlc3RvcixcbiAgICAgICAgICAgIGluc3RhbmNlXG4gICAgICAgICAgKSxcbiAgICAgICAgICByZWNvcmRFZmZlY3REdXJhdGlvbigpKVxuICAgICAgICA6IHJ1bldpdGhGaWJlckluREVWKFxuICAgICAgICAgICAgY3VycmVudCxcbiAgICAgICAgICAgIGNhbGxDb21wb25lbnRXaWxsVW5tb3VudEluREVWLFxuICAgICAgICAgICAgY3VycmVudCxcbiAgICAgICAgICAgIG5lYXJlc3RNb3VudGVkQW5jZXN0b3IsXG4gICAgICAgICAgICBpbnN0YW5jZVxuICAgICAgICAgICk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNvbW1pdEF0dGFjaFJlZihmaW5pc2hlZFdvcmspIHtcbiAgICAgIHZhciByZWYgPSBmaW5pc2hlZFdvcmsucmVmO1xuICAgICAgaWYgKG51bGwgIT09IHJlZikge1xuICAgICAgICB2YXIgaW5zdGFuY2UgPSBmaW5pc2hlZFdvcmsuc3RhdGVOb2RlO1xuICAgICAgICBzd2l0Y2ggKGZpbmlzaGVkV29yay50YWcpIHtcbiAgICAgICAgICBjYXNlIDI2OlxuICAgICAgICAgIGNhc2UgMjc6XG4gICAgICAgICAgY2FzZSA1OlxuICAgICAgICAgICAgaW5zdGFuY2UgPSBnZXRQdWJsaWNJbnN0YW5jZShpbnN0YW5jZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIHJlZilcbiAgICAgICAgICBpZiAoc2hvdWxkUHJvZmlsZShmaW5pc2hlZFdvcmspKVxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgc3RhcnRFZmZlY3RUaW1lcigpLCAoZmluaXNoZWRXb3JrLnJlZkNsZWFudXAgPSByZWYoaW5zdGFuY2UpKTtcbiAgICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICAgIHJlY29yZEVmZmVjdER1cmF0aW9uKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSBmaW5pc2hlZFdvcmsucmVmQ2xlYW51cCA9IHJlZihpbnN0YW5jZSk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICBcInN0cmluZ1wiID09PSB0eXBlb2YgcmVmXG4gICAgICAgICAgICA/IGNvbnNvbGUuZXJyb3IoXCJTdHJpbmcgcmVmcyBhcmUgbm8gbG9uZ2VyIHN1cHBvcnRlZC5cIilcbiAgICAgICAgICAgIDogcmVmLmhhc093blByb3BlcnR5KFwiY3VycmVudFwiKSB8fFxuICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICAgIFwiVW5leHBlY3RlZCByZWYgb2JqZWN0IHByb3ZpZGVkIGZvciAlcy4gVXNlIGVpdGhlciBhIHJlZi1zZXR0ZXIgZnVuY3Rpb24gb3IgUmVhY3QuY3JlYXRlUmVmKCkuXCIsXG4gICAgICAgICAgICAgICAgZ2V0Q29tcG9uZW50TmFtZUZyb21GaWJlcihmaW5pc2hlZFdvcmspXG4gICAgICAgICAgICAgICksXG4gICAgICAgICAgICAocmVmLmN1cnJlbnQgPSBpbnN0YW5jZSk7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIHNhZmVseUF0dGFjaFJlZihjdXJyZW50LCBuZWFyZXN0TW91bnRlZEFuY2VzdG9yKSB7XG4gICAgICB0cnkge1xuICAgICAgICBydW5XaXRoRmliZXJJbkRFVihjdXJyZW50LCBjb21taXRBdHRhY2hSZWYsIGN1cnJlbnQpO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgY2FwdHVyZUNvbW1pdFBoYXNlRXJyb3IoY3VycmVudCwgbmVhcmVzdE1vdW50ZWRBbmNlc3RvciwgZXJyb3IpO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBzYWZlbHlEZXRhY2hSZWYoY3VycmVudCwgbmVhcmVzdE1vdW50ZWRBbmNlc3Rvcikge1xuICAgICAgdmFyIHJlZiA9IGN1cnJlbnQucmVmLFxuICAgICAgICByZWZDbGVhbnVwID0gY3VycmVudC5yZWZDbGVhbnVwO1xuICAgICAgaWYgKG51bGwgIT09IHJlZilcbiAgICAgICAgaWYgKFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIHJlZkNsZWFudXApXG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmIChzaG91bGRQcm9maWxlKGN1cnJlbnQpKVxuICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHN0YXJ0RWZmZWN0VGltZXIoKSwgcnVuV2l0aEZpYmVySW5ERVYoY3VycmVudCwgcmVmQ2xlYW51cCk7XG4gICAgICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICAgICAgcmVjb3JkRWZmZWN0RHVyYXRpb24oY3VycmVudCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgcnVuV2l0aEZpYmVySW5ERVYoY3VycmVudCwgcmVmQ2xlYW51cCk7XG4gICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGNhcHR1cmVDb21taXRQaGFzZUVycm9yKGN1cnJlbnQsIG5lYXJlc3RNb3VudGVkQW5jZXN0b3IsIGVycm9yKTtcbiAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgKGN1cnJlbnQucmVmQ2xlYW51cCA9IG51bGwpLFxuICAgICAgICAgICAgICAoY3VycmVudCA9IGN1cnJlbnQuYWx0ZXJuYXRlKSxcbiAgICAgICAgICAgICAgbnVsbCAhPSBjdXJyZW50ICYmIChjdXJyZW50LnJlZkNsZWFudXAgPSBudWxsKTtcbiAgICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIHJlZilcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKHNob3VsZFByb2ZpbGUoY3VycmVudCkpXG4gICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgc3RhcnRFZmZlY3RUaW1lcigpLCBydW5XaXRoRmliZXJJbkRFVihjdXJyZW50LCByZWYsIG51bGwpO1xuICAgICAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgICAgIHJlY29yZEVmZmVjdER1cmF0aW9uKGN1cnJlbnQpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHJ1bldpdGhGaWJlckluREVWKGN1cnJlbnQsIHJlZiwgbnVsbCk7XG4gICAgICAgICAgfSBjYXRjaCAoZXJyb3IkMykge1xuICAgICAgICAgICAgY2FwdHVyZUNvbW1pdFBoYXNlRXJyb3IoY3VycmVudCwgbmVhcmVzdE1vdW50ZWRBbmNlc3RvciwgZXJyb3IkMyk7XG4gICAgICAgICAgfVxuICAgICAgICBlbHNlIHJlZi5jdXJyZW50ID0gbnVsbDtcbiAgICB9XG4gICAgZnVuY3Rpb24gY29tbWl0UHJvZmlsZXIoXG4gICAgICBmaW5pc2hlZFdvcmssXG4gICAgICBjdXJyZW50LFxuICAgICAgY29tbWl0U3RhcnRUaW1lLFxuICAgICAgZWZmZWN0RHVyYXRpb25cbiAgICApIHtcbiAgICAgIHZhciBfZmluaXNoZWRXb3JrJG1lbW9pemUgPSBmaW5pc2hlZFdvcmsubWVtb2l6ZWRQcm9wcyxcbiAgICAgICAgaWQgPSBfZmluaXNoZWRXb3JrJG1lbW9pemUuaWQsXG4gICAgICAgIG9uQ29tbWl0ID0gX2ZpbmlzaGVkV29yayRtZW1vaXplLm9uQ29tbWl0O1xuICAgICAgX2ZpbmlzaGVkV29yayRtZW1vaXplID0gX2ZpbmlzaGVkV29yayRtZW1vaXplLm9uUmVuZGVyO1xuICAgICAgY3VycmVudCA9IG51bGwgPT09IGN1cnJlbnQgPyBcIm1vdW50XCIgOiBcInVwZGF0ZVwiO1xuICAgICAgY3VycmVudFVwZGF0ZUlzTmVzdGVkICYmIChjdXJyZW50ID0gXCJuZXN0ZWQtdXBkYXRlXCIpO1xuICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgX2ZpbmlzaGVkV29yayRtZW1vaXplICYmXG4gICAgICAgIF9maW5pc2hlZFdvcmskbWVtb2l6ZShcbiAgICAgICAgICBpZCxcbiAgICAgICAgICBjdXJyZW50LFxuICAgICAgICAgIGZpbmlzaGVkV29yay5hY3R1YWxEdXJhdGlvbixcbiAgICAgICAgICBmaW5pc2hlZFdvcmsudHJlZUJhc2VEdXJhdGlvbixcbiAgICAgICAgICBmaW5pc2hlZFdvcmsuYWN0dWFsU3RhcnRUaW1lLFxuICAgICAgICAgIGNvbW1pdFN0YXJ0VGltZVxuICAgICAgICApO1xuICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2Ygb25Db21taXQgJiZcbiAgICAgICAgb25Db21taXQoXG4gICAgICAgICAgZmluaXNoZWRXb3JrLm1lbW9pemVkUHJvcHMuaWQsXG4gICAgICAgICAgY3VycmVudCxcbiAgICAgICAgICBlZmZlY3REdXJhdGlvbixcbiAgICAgICAgICBjb21taXRTdGFydFRpbWVcbiAgICAgICAgKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY29tbWl0UHJvZmlsZXJQb3N0Q29tbWl0SW1wbChcbiAgICAgIGZpbmlzaGVkV29yayxcbiAgICAgIGN1cnJlbnQsXG4gICAgICBjb21taXRTdGFydFRpbWUsXG4gICAgICBwYXNzaXZlRWZmZWN0RHVyYXRpb25cbiAgICApIHtcbiAgICAgIHZhciBfZmluaXNoZWRXb3JrJG1lbW9pemUyID0gZmluaXNoZWRXb3JrLm1lbW9pemVkUHJvcHM7XG4gICAgICBmaW5pc2hlZFdvcmsgPSBfZmluaXNoZWRXb3JrJG1lbW9pemUyLmlkO1xuICAgICAgX2ZpbmlzaGVkV29yayRtZW1vaXplMiA9IF9maW5pc2hlZFdvcmskbWVtb2l6ZTIub25Qb3N0Q29tbWl0O1xuICAgICAgY3VycmVudCA9IG51bGwgPT09IGN1cnJlbnQgPyBcIm1vdW50XCIgOiBcInVwZGF0ZVwiO1xuICAgICAgY3VycmVudFVwZGF0ZUlzTmVzdGVkICYmIChjdXJyZW50ID0gXCJuZXN0ZWQtdXBkYXRlXCIpO1xuICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgX2ZpbmlzaGVkV29yayRtZW1vaXplMiAmJlxuICAgICAgICBfZmluaXNoZWRXb3JrJG1lbW9pemUyKFxuICAgICAgICAgIGZpbmlzaGVkV29yayxcbiAgICAgICAgICBjdXJyZW50LFxuICAgICAgICAgIHBhc3NpdmVFZmZlY3REdXJhdGlvbixcbiAgICAgICAgICBjb21taXRTdGFydFRpbWVcbiAgICAgICAgKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY29tbWl0SG9zdE1vdW50KGZpbmlzaGVkV29yaykge1xuICAgICAgdmFyIHR5cGUgPSBmaW5pc2hlZFdvcmsudHlwZSxcbiAgICAgICAgcHJvcHMgPSBmaW5pc2hlZFdvcmsubWVtb2l6ZWRQcm9wcyxcbiAgICAgICAgaW5zdGFuY2UgPSBmaW5pc2hlZFdvcmsuc3RhdGVOb2RlO1xuICAgICAgdHJ5IHtcbiAgICAgICAgcnVuV2l0aEZpYmVySW5ERVYoXG4gICAgICAgICAgZmluaXNoZWRXb3JrLFxuICAgICAgICAgIGNvbW1pdE1vdW50LFxuICAgICAgICAgIGluc3RhbmNlLFxuICAgICAgICAgIHR5cGUsXG4gICAgICAgICAgcHJvcHMsXG4gICAgICAgICAgZmluaXNoZWRXb3JrXG4gICAgICAgICk7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBjYXB0dXJlQ29tbWl0UGhhc2VFcnJvcihmaW5pc2hlZFdvcmssIGZpbmlzaGVkV29yay5yZXR1cm4sIGVycm9yKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gY29tbWl0SG9zdFVwZGF0ZShmaW5pc2hlZFdvcmssIG5ld1Byb3BzLCBvbGRQcm9wcykge1xuICAgICAgdHJ5IHtcbiAgICAgICAgcnVuV2l0aEZpYmVySW5ERVYoXG4gICAgICAgICAgZmluaXNoZWRXb3JrLFxuICAgICAgICAgIGNvbW1pdFVwZGF0ZSxcbiAgICAgICAgICBmaW5pc2hlZFdvcmsuc3RhdGVOb2RlLFxuICAgICAgICAgIGZpbmlzaGVkV29yay50eXBlLFxuICAgICAgICAgIG9sZFByb3BzLFxuICAgICAgICAgIG5ld1Byb3BzLFxuICAgICAgICAgIGZpbmlzaGVkV29ya1xuICAgICAgICApO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgY2FwdHVyZUNvbW1pdFBoYXNlRXJyb3IoZmluaXNoZWRXb3JrLCBmaW5pc2hlZFdvcmsucmV0dXJuLCBlcnJvcik7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGlzSG9zdFBhcmVudChmaWJlcikge1xuICAgICAgcmV0dXJuIChcbiAgICAgICAgNSA9PT0gZmliZXIudGFnIHx8XG4gICAgICAgIDMgPT09IGZpYmVyLnRhZyB8fFxuICAgICAgICAoc3VwcG9ydHNSZXNvdXJjZXMgPyAyNiA9PT0gZmliZXIudGFnIDogITEpIHx8XG4gICAgICAgIChzdXBwb3J0c1NpbmdsZXRvbnMgPyAyNyA9PT0gZmliZXIudGFnIDogITEpIHx8XG4gICAgICAgIDQgPT09IGZpYmVyLnRhZ1xuICAgICAgKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZ2V0SG9zdFNpYmxpbmcoZmliZXIpIHtcbiAgICAgIGE6IGZvciAoOzspIHtcbiAgICAgICAgZm9yICg7IG51bGwgPT09IGZpYmVyLnNpYmxpbmc7ICkge1xuICAgICAgICAgIGlmIChudWxsID09PSBmaWJlci5yZXR1cm4gfHwgaXNIb3N0UGFyZW50KGZpYmVyLnJldHVybikpIHJldHVybiBudWxsO1xuICAgICAgICAgIGZpYmVyID0gZmliZXIucmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGZpYmVyLnNpYmxpbmcucmV0dXJuID0gZmliZXIucmV0dXJuO1xuICAgICAgICBmb3IgKFxuICAgICAgICAgIGZpYmVyID0gZmliZXIuc2libGluZztcbiAgICAgICAgICA1ICE9PSBmaWJlci50YWcgJiZcbiAgICAgICAgICA2ICE9PSBmaWJlci50YWcgJiZcbiAgICAgICAgICAoc3VwcG9ydHNTaW5nbGV0b25zID8gMjcgIT09IGZpYmVyLnRhZyA6IDEpICYmXG4gICAgICAgICAgMTggIT09IGZpYmVyLnRhZztcblxuICAgICAgICApIHtcbiAgICAgICAgICBpZiAoZmliZXIuZmxhZ3MgJiAyKSBjb250aW51ZSBhO1xuICAgICAgICAgIGlmIChudWxsID09PSBmaWJlci5jaGlsZCB8fCA0ID09PSBmaWJlci50YWcpIGNvbnRpbnVlIGE7XG4gICAgICAgICAgZWxzZSAoZmliZXIuY2hpbGQucmV0dXJuID0gZmliZXIpLCAoZmliZXIgPSBmaWJlci5jaGlsZCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCEoZmliZXIuZmxhZ3MgJiAyKSkgcmV0dXJuIGZpYmVyLnN0YXRlTm9kZTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gaW5zZXJ0T3JBcHBlbmRQbGFjZW1lbnROb2RlSW50b0NvbnRhaW5lcihub2RlLCBiZWZvcmUsIHBhcmVudCkge1xuICAgICAgdmFyIHRhZyA9IG5vZGUudGFnO1xuICAgICAgaWYgKDUgPT09IHRhZyB8fCA2ID09PSB0YWcpXG4gICAgICAgIChub2RlID0gbm9kZS5zdGF0ZU5vZGUpLFxuICAgICAgICAgIGJlZm9yZVxuICAgICAgICAgICAgPyBpbnNlcnRJbkNvbnRhaW5lckJlZm9yZShwYXJlbnQsIG5vZGUsIGJlZm9yZSlcbiAgICAgICAgICAgIDogYXBwZW5kQ2hpbGRUb0NvbnRhaW5lcihwYXJlbnQsIG5vZGUpO1xuICAgICAgZWxzZSBpZiAoXG4gICAgICAgICEoNCA9PT0gdGFnIHx8IChzdXBwb3J0c1NpbmdsZXRvbnMgJiYgMjcgPT09IHRhZykpICYmXG4gICAgICAgICgobm9kZSA9IG5vZGUuY2hpbGQpLCBudWxsICE9PSBub2RlKVxuICAgICAgKVxuICAgICAgICBmb3IgKFxuICAgICAgICAgIGluc2VydE9yQXBwZW5kUGxhY2VtZW50Tm9kZUludG9Db250YWluZXIobm9kZSwgYmVmb3JlLCBwYXJlbnQpLFxuICAgICAgICAgICAgbm9kZSA9IG5vZGUuc2libGluZztcbiAgICAgICAgICBudWxsICE9PSBub2RlO1xuXG4gICAgICAgIClcbiAgICAgICAgICBpbnNlcnRPckFwcGVuZFBsYWNlbWVudE5vZGVJbnRvQ29udGFpbmVyKG5vZGUsIGJlZm9yZSwgcGFyZW50KSxcbiAgICAgICAgICAgIChub2RlID0gbm9kZS5zaWJsaW5nKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gaW5zZXJ0T3JBcHBlbmRQbGFjZW1lbnROb2RlKG5vZGUsIGJlZm9yZSwgcGFyZW50KSB7XG4gICAgICB2YXIgdGFnID0gbm9kZS50YWc7XG4gICAgICBpZiAoNSA9PT0gdGFnIHx8IDYgPT09IHRhZylcbiAgICAgICAgKG5vZGUgPSBub2RlLnN0YXRlTm9kZSksXG4gICAgICAgICAgYmVmb3JlXG4gICAgICAgICAgICA/IGluc2VydEJlZm9yZShwYXJlbnQsIG5vZGUsIGJlZm9yZSlcbiAgICAgICAgICAgIDogYXBwZW5kQ2hpbGQocGFyZW50LCBub2RlKTtcbiAgICAgIGVsc2UgaWYgKFxuICAgICAgICAhKDQgPT09IHRhZyB8fCAoc3VwcG9ydHNTaW5nbGV0b25zICYmIDI3ID09PSB0YWcpKSAmJlxuICAgICAgICAoKG5vZGUgPSBub2RlLmNoaWxkKSwgbnVsbCAhPT0gbm9kZSlcbiAgICAgIClcbiAgICAgICAgZm9yIChcbiAgICAgICAgICBpbnNlcnRPckFwcGVuZFBsYWNlbWVudE5vZGUobm9kZSwgYmVmb3JlLCBwYXJlbnQpLFxuICAgICAgICAgICAgbm9kZSA9IG5vZGUuc2libGluZztcbiAgICAgICAgICBudWxsICE9PSBub2RlO1xuXG4gICAgICAgIClcbiAgICAgICAgICBpbnNlcnRPckFwcGVuZFBsYWNlbWVudE5vZGUobm9kZSwgYmVmb3JlLCBwYXJlbnQpLFxuICAgICAgICAgICAgKG5vZGUgPSBub2RlLnNpYmxpbmcpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjb21taXRQbGFjZW1lbnQoZmluaXNoZWRXb3JrKSB7XG4gICAgICBpZiAoXG4gICAgICAgIHN1cHBvcnRzTXV0YXRpb24gJiZcbiAgICAgICAgKCFzdXBwb3J0c1NpbmdsZXRvbnMgfHwgMjcgIT09IGZpbmlzaGVkV29yay50YWcpXG4gICAgICApIHtcbiAgICAgICAgYToge1xuICAgICAgICAgIGZvciAodmFyIHBhcmVudCA9IGZpbmlzaGVkV29yay5yZXR1cm47IG51bGwgIT09IHBhcmVudDsgKSB7XG4gICAgICAgICAgICBpZiAoaXNIb3N0UGFyZW50KHBhcmVudCkpIHtcbiAgICAgICAgICAgICAgdmFyIHBhcmVudEZpYmVyID0gcGFyZW50O1xuICAgICAgICAgICAgICBicmVhayBhO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcGFyZW50ID0gcGFyZW50LnJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhyb3cgRXJyb3IoXG4gICAgICAgICAgICBcIkV4cGVjdGVkIHRvIGZpbmQgYSBob3N0IHBhcmVudC4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS5cIlxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgc3dpdGNoIChwYXJlbnRGaWJlci50YWcpIHtcbiAgICAgICAgICBjYXNlIDI3OlxuICAgICAgICAgICAgaWYgKHN1cHBvcnRzU2luZ2xldG9ucykge1xuICAgICAgICAgICAgICBwYXJlbnQgPSBwYXJlbnRGaWJlci5zdGF0ZU5vZGU7XG4gICAgICAgICAgICAgIHBhcmVudEZpYmVyID0gZ2V0SG9zdFNpYmxpbmcoZmluaXNoZWRXb3JrKTtcbiAgICAgICAgICAgICAgaW5zZXJ0T3JBcHBlbmRQbGFjZW1lbnROb2RlKGZpbmlzaGVkV29yaywgcGFyZW50RmliZXIsIHBhcmVudCk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIGNhc2UgNTpcbiAgICAgICAgICAgIHBhcmVudCA9IHBhcmVudEZpYmVyLnN0YXRlTm9kZTtcbiAgICAgICAgICAgIHBhcmVudEZpYmVyLmZsYWdzICYgMzIgJiZcbiAgICAgICAgICAgICAgKHJlc2V0VGV4dENvbnRlbnQocGFyZW50KSwgKHBhcmVudEZpYmVyLmZsYWdzICY9IC0zMykpO1xuICAgICAgICAgICAgcGFyZW50RmliZXIgPSBnZXRIb3N0U2libGluZyhmaW5pc2hlZFdvcmspO1xuICAgICAgICAgICAgaW5zZXJ0T3JBcHBlbmRQbGFjZW1lbnROb2RlKGZpbmlzaGVkV29yaywgcGFyZW50RmliZXIsIHBhcmVudCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgcGFyZW50ID0gcGFyZW50RmliZXIuc3RhdGVOb2RlLmNvbnRhaW5lckluZm87XG4gICAgICAgICAgICBwYXJlbnRGaWJlciA9IGdldEhvc3RTaWJsaW5nKGZpbmlzaGVkV29yayk7XG4gICAgICAgICAgICBpbnNlcnRPckFwcGVuZFBsYWNlbWVudE5vZGVJbnRvQ29udGFpbmVyKFxuICAgICAgICAgICAgICBmaW5pc2hlZFdvcmssXG4gICAgICAgICAgICAgIHBhcmVudEZpYmVyLFxuICAgICAgICAgICAgICBwYXJlbnRcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgdGhyb3cgRXJyb3IoXG4gICAgICAgICAgICAgIFwiSW52YWxpZCBob3N0IHBhcmVudCBmaWJlci4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS5cIlxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBjb21taXRIb3N0UG9ydGFsQ29udGFpbmVyQ2hpbGRyZW4oXG4gICAgICBwb3J0YWwsXG4gICAgICBmaW5pc2hlZFdvcmssXG4gICAgICBwZW5kaW5nQ2hpbGRyZW5cbiAgICApIHtcbiAgICAgIHBvcnRhbCA9IHBvcnRhbC5jb250YWluZXJJbmZvO1xuICAgICAgdHJ5IHtcbiAgICAgICAgcnVuV2l0aEZpYmVySW5ERVYoXG4gICAgICAgICAgZmluaXNoZWRXb3JrLFxuICAgICAgICAgIHJlcGxhY2VDb250YWluZXJDaGlsZHJlbixcbiAgICAgICAgICBwb3J0YWwsXG4gICAgICAgICAgcGVuZGluZ0NoaWxkcmVuXG4gICAgICAgICk7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBjYXB0dXJlQ29tbWl0UGhhc2VFcnJvcihmaW5pc2hlZFdvcmssIGZpbmlzaGVkV29yay5yZXR1cm4sIGVycm9yKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gY29tbWl0QmVmb3JlTXV0YXRpb25FZmZlY3RzKHJvb3QsIGZpcnN0Q2hpbGQpIHtcbiAgICAgIHByZXBhcmVGb3JDb21taXQocm9vdC5jb250YWluZXJJbmZvKTtcbiAgICAgIGZvciAobmV4dEVmZmVjdCA9IGZpcnN0Q2hpbGQ7IG51bGwgIT09IG5leHRFZmZlY3Q7IClcbiAgICAgICAgaWYgKFxuICAgICAgICAgICgocm9vdCA9IG5leHRFZmZlY3QpLFxuICAgICAgICAgIChmaXJzdENoaWxkID0gcm9vdC5jaGlsZCksXG4gICAgICAgICAgMCAhPT0gKHJvb3Quc3VidHJlZUZsYWdzICYgMTAyOCkgJiYgbnVsbCAhPT0gZmlyc3RDaGlsZClcbiAgICAgICAgKVxuICAgICAgICAgIChmaXJzdENoaWxkLnJldHVybiA9IHJvb3QpLCAobmV4dEVmZmVjdCA9IGZpcnN0Q2hpbGQpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgZm9yICg7IG51bGwgIT09IG5leHRFZmZlY3Q7ICkge1xuICAgICAgICAgICAgZmlyc3RDaGlsZCA9IHJvb3QgPSBuZXh0RWZmZWN0O1xuICAgICAgICAgICAgdmFyIGN1cnJlbnQgPSBmaXJzdENoaWxkLmFsdGVybmF0ZSxcbiAgICAgICAgICAgICAgZmxhZ3MgPSBmaXJzdENoaWxkLmZsYWdzO1xuICAgICAgICAgICAgc3dpdGNoIChmaXJzdENoaWxkLnRhZykge1xuICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGNhc2UgMTE6XG4gICAgICAgICAgICAgIGNhc2UgMTU6XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAwICE9PSAoZmxhZ3MgJiAxMDI0KSAmJlxuICAgICAgICAgICAgICAgICAgbnVsbCAhPT0gY3VycmVudCAmJlxuICAgICAgICAgICAgICAgICAgY29tbWl0Q2xhc3NTbmFwc2hvdChmaXJzdENoaWxkLCBjdXJyZW50KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgIDAgIT09IChmbGFncyAmIDEwMjQpICYmXG4gICAgICAgICAgICAgICAgICBzdXBwb3J0c011dGF0aW9uICYmXG4gICAgICAgICAgICAgICAgICBjbGVhckNvbnRhaW5lcihmaXJzdENoaWxkLnN0YXRlTm9kZS5jb250YWluZXJJbmZvKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgY2FzZSA1OlxuICAgICAgICAgICAgICBjYXNlIDI2OlxuICAgICAgICAgICAgICBjYXNlIDI3OlxuICAgICAgICAgICAgICBjYXNlIDY6XG4gICAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgY2FzZSAxNzpcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICBpZiAoMCAhPT0gKGZsYWdzICYgMTAyNCkpXG4gICAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcbiAgICAgICAgICAgICAgICAgICAgXCJUaGlzIHVuaXQgb2Ygd29yayB0YWcgc2hvdWxkIG5vdCBoYXZlIHNpZGUtZWZmZWN0cy4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS5cIlxuICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZpcnN0Q2hpbGQgPSByb290LnNpYmxpbmc7XG4gICAgICAgICAgICBpZiAobnVsbCAhPT0gZmlyc3RDaGlsZCkge1xuICAgICAgICAgICAgICBmaXJzdENoaWxkLnJldHVybiA9IHJvb3QucmV0dXJuO1xuICAgICAgICAgICAgICBuZXh0RWZmZWN0ID0gZmlyc3RDaGlsZDtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBuZXh0RWZmZWN0ID0gcm9vdC5yZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgcm9vdCA9IHNob3VsZEZpcmVBZnRlckFjdGl2ZUluc3RhbmNlQmx1cjtcbiAgICAgIHNob3VsZEZpcmVBZnRlckFjdGl2ZUluc3RhbmNlQmx1ciA9ICExO1xuICAgICAgcmV0dXJuIHJvb3Q7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNvbW1pdExheW91dEVmZmVjdE9uRmliZXIoZmluaXNoZWRSb290LCBjdXJyZW50LCBmaW5pc2hlZFdvcmspIHtcbiAgICAgIHZhciBmbGFncyA9IGZpbmlzaGVkV29yay5mbGFncztcbiAgICAgIHN3aXRjaCAoZmluaXNoZWRXb3JrLnRhZykge1xuICAgICAgICBjYXNlIDA6XG4gICAgICAgIGNhc2UgMTE6XG4gICAgICAgIGNhc2UgMTU6XG4gICAgICAgICAgcmVjdXJzaXZlbHlUcmF2ZXJzZUxheW91dEVmZmVjdHMoZmluaXNoZWRSb290LCBmaW5pc2hlZFdvcmspO1xuICAgICAgICAgIGZsYWdzICYgNCAmJlxuICAgICAgICAgICAgY29tbWl0SG9va0xheW91dEVmZmVjdHMoZmluaXNoZWRXb3JrLCBMYXlvdXQgfCBIYXNFZmZlY3QpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgcmVjdXJzaXZlbHlUcmF2ZXJzZUxheW91dEVmZmVjdHMoZmluaXNoZWRSb290LCBmaW5pc2hlZFdvcmspO1xuICAgICAgICAgIGlmIChmbGFncyAmIDQpXG4gICAgICAgICAgICBpZiAoKChmaW5pc2hlZFJvb3QgPSBmaW5pc2hlZFdvcmsuc3RhdGVOb2RlKSwgbnVsbCA9PT0gY3VycmVudCkpXG4gICAgICAgICAgICAgIGZpbmlzaGVkV29yay50eXBlLmRlZmF1bHRQcm9wcyB8fFxuICAgICAgICAgICAgICAgIFwicmVmXCIgaW4gZmluaXNoZWRXb3JrLm1lbW9pemVkUHJvcHMgfHxcbiAgICAgICAgICAgICAgICBkaWRXYXJuQWJvdXRSZWFzc2lnbmluZ1Byb3BzIHx8XG4gICAgICAgICAgICAgICAgKGZpbmlzaGVkUm9vdC5wcm9wcyAhPT0gZmluaXNoZWRXb3JrLm1lbW9pemVkUHJvcHMgJiZcbiAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgICAgICAgIFwiRXhwZWN0ZWQgJXMgcHJvcHMgdG8gbWF0Y2ggbWVtb2l6ZWQgcHJvcHMgYmVmb3JlIGNvbXBvbmVudERpZE1vdW50LiBUaGlzIG1pZ2h0IGVpdGhlciBiZSBiZWNhdXNlIG9mIGEgYnVnIGluIFJlYWN0LCBvciBiZWNhdXNlIGEgY29tcG9uZW50IHJlYXNzaWducyBpdHMgb3duIGB0aGlzLnByb3BzYC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuXCIsXG4gICAgICAgICAgICAgICAgICAgIGdldENvbXBvbmVudE5hbWVGcm9tRmliZXIoZmluaXNoZWRXb3JrKSB8fCBcImluc3RhbmNlXCJcbiAgICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgZmluaXNoZWRSb290LnN0YXRlICE9PSBmaW5pc2hlZFdvcmsubWVtb2l6ZWRTdGF0ZSAmJlxuICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgICAgICAgXCJFeHBlY3RlZCAlcyBzdGF0ZSB0byBtYXRjaCBtZW1vaXplZCBzdGF0ZSBiZWZvcmUgY29tcG9uZW50RGlkTW91bnQuIFRoaXMgbWlnaHQgZWl0aGVyIGJlIGJlY2F1c2Ugb2YgYSBidWcgaW4gUmVhY3QsIG9yIGJlY2F1c2UgYSBjb21wb25lbnQgcmVhc3NpZ25zIGl0cyBvd24gYHRoaXMuc3RhdGVgLiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS5cIixcbiAgICAgICAgICAgICAgICAgICAgZ2V0Q29tcG9uZW50TmFtZUZyb21GaWJlcihmaW5pc2hlZFdvcmspIHx8IFwiaW5zdGFuY2VcIlxuICAgICAgICAgICAgICAgICAgKSksXG4gICAgICAgICAgICAgICAgc2hvdWxkUHJvZmlsZShmaW5pc2hlZFdvcmspXG4gICAgICAgICAgICAgICAgICA/IChzdGFydEVmZmVjdFRpbWVyKCksXG4gICAgICAgICAgICAgICAgICAgIHJ1bldpdGhGaWJlckluREVWKFxuICAgICAgICAgICAgICAgICAgICAgIGZpbmlzaGVkV29yayxcbiAgICAgICAgICAgICAgICAgICAgICBjYWxsQ29tcG9uZW50RGlkTW91bnRJbkRFVixcbiAgICAgICAgICAgICAgICAgICAgICBmaW5pc2hlZFdvcmssXG4gICAgICAgICAgICAgICAgICAgICAgZmluaXNoZWRSb290XG4gICAgICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgICAgIHJlY29yZEVmZmVjdER1cmF0aW9uKCkpXG4gICAgICAgICAgICAgICAgICA6IHJ1bldpdGhGaWJlckluREVWKFxuICAgICAgICAgICAgICAgICAgICAgIGZpbmlzaGVkV29yayxcbiAgICAgICAgICAgICAgICAgICAgICBjYWxsQ29tcG9uZW50RGlkTW91bnRJbkRFVixcbiAgICAgICAgICAgICAgICAgICAgICBmaW5pc2hlZFdvcmssXG4gICAgICAgICAgICAgICAgICAgICAgZmluaXNoZWRSb290XG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgdmFyIHByZXZQcm9wcyA9IHJlc29sdmVDbGFzc0NvbXBvbmVudFByb3BzKFxuICAgICAgICAgICAgICAgIGZpbmlzaGVkV29yay50eXBlLFxuICAgICAgICAgICAgICAgIGN1cnJlbnQubWVtb2l6ZWRQcm9wc1xuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICBjdXJyZW50ID0gY3VycmVudC5tZW1vaXplZFN0YXRlO1xuICAgICAgICAgICAgICBmaW5pc2hlZFdvcmsudHlwZS5kZWZhdWx0UHJvcHMgfHxcbiAgICAgICAgICAgICAgICBcInJlZlwiIGluIGZpbmlzaGVkV29yay5tZW1vaXplZFByb3BzIHx8XG4gICAgICAgICAgICAgICAgZGlkV2FybkFib3V0UmVhc3NpZ25pbmdQcm9wcyB8fFxuICAgICAgICAgICAgICAgIChmaW5pc2hlZFJvb3QucHJvcHMgIT09IGZpbmlzaGVkV29yay5tZW1vaXplZFByb3BzICYmXG4gICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICAgICAgICBcIkV4cGVjdGVkICVzIHByb3BzIHRvIG1hdGNoIG1lbW9pemVkIHByb3BzIGJlZm9yZSBjb21wb25lbnREaWRVcGRhdGUuIFRoaXMgbWlnaHQgZWl0aGVyIGJlIGJlY2F1c2Ugb2YgYSBidWcgaW4gUmVhY3QsIG9yIGJlY2F1c2UgYSBjb21wb25lbnQgcmVhc3NpZ25zIGl0cyBvd24gYHRoaXMucHJvcHNgLiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS5cIixcbiAgICAgICAgICAgICAgICAgICAgZ2V0Q29tcG9uZW50TmFtZUZyb21GaWJlcihmaW5pc2hlZFdvcmspIHx8IFwiaW5zdGFuY2VcIlxuICAgICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICBmaW5pc2hlZFJvb3Quc3RhdGUgIT09IGZpbmlzaGVkV29yay5tZW1vaXplZFN0YXRlICYmXG4gICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICAgICAgICBcIkV4cGVjdGVkICVzIHN0YXRlIHRvIG1hdGNoIG1lbW9pemVkIHN0YXRlIGJlZm9yZSBjb21wb25lbnREaWRVcGRhdGUuIFRoaXMgbWlnaHQgZWl0aGVyIGJlIGJlY2F1c2Ugb2YgYSBidWcgaW4gUmVhY3QsIG9yIGJlY2F1c2UgYSBjb21wb25lbnQgcmVhc3NpZ25zIGl0cyBvd24gYHRoaXMuc3RhdGVgLiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS5cIixcbiAgICAgICAgICAgICAgICAgICAgZ2V0Q29tcG9uZW50TmFtZUZyb21GaWJlcihmaW5pc2hlZFdvcmspIHx8IFwiaW5zdGFuY2VcIlxuICAgICAgICAgICAgICAgICAgKSk7XG4gICAgICAgICAgICAgIHNob3VsZFByb2ZpbGUoZmluaXNoZWRXb3JrKVxuICAgICAgICAgICAgICAgID8gKHN0YXJ0RWZmZWN0VGltZXIoKSxcbiAgICAgICAgICAgICAgICAgIHJ1bldpdGhGaWJlckluREVWKFxuICAgICAgICAgICAgICAgICAgICBmaW5pc2hlZFdvcmssXG4gICAgICAgICAgICAgICAgICAgIGNhbGxDb21wb25lbnREaWRVcGRhdGVJbkRFVixcbiAgICAgICAgICAgICAgICAgICAgZmluaXNoZWRXb3JrLFxuICAgICAgICAgICAgICAgICAgICBmaW5pc2hlZFJvb3QsXG4gICAgICAgICAgICAgICAgICAgIHByZXZQcm9wcyxcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudCxcbiAgICAgICAgICAgICAgICAgICAgZmluaXNoZWRSb290Ll9fcmVhY3RJbnRlcm5hbFNuYXBzaG90QmVmb3JlVXBkYXRlXG4gICAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgICAgcmVjb3JkRWZmZWN0RHVyYXRpb24oKSlcbiAgICAgICAgICAgICAgICA6IHJ1bldpdGhGaWJlckluREVWKFxuICAgICAgICAgICAgICAgICAgICBmaW5pc2hlZFdvcmssXG4gICAgICAgICAgICAgICAgICAgIGNhbGxDb21wb25lbnREaWRVcGRhdGVJbkRFVixcbiAgICAgICAgICAgICAgICAgICAgZmluaXNoZWRXb3JrLFxuICAgICAgICAgICAgICAgICAgICBmaW5pc2hlZFJvb3QsXG4gICAgICAgICAgICAgICAgICAgIHByZXZQcm9wcyxcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudCxcbiAgICAgICAgICAgICAgICAgICAgZmluaXNoZWRSb290Ll9fcmVhY3RJbnRlcm5hbFNuYXBzaG90QmVmb3JlVXBkYXRlXG4gICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIGZsYWdzICYgNjQgJiYgY29tbWl0Q2xhc3NDYWxsYmFja3MoZmluaXNoZWRXb3JrKTtcbiAgICAgICAgICBmbGFncyAmIDUxMiAmJiBzYWZlbHlBdHRhY2hSZWYoZmluaXNoZWRXb3JrLCBmaW5pc2hlZFdvcmsucmV0dXJuKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAzOlxuICAgICAgICAgIGN1cnJlbnQgPSBwdXNoTmVzdGVkRWZmZWN0RHVyYXRpb25zKCk7XG4gICAgICAgICAgcmVjdXJzaXZlbHlUcmF2ZXJzZUxheW91dEVmZmVjdHMoZmluaXNoZWRSb290LCBmaW5pc2hlZFdvcmspO1xuICAgICAgICAgIGlmIChcbiAgICAgICAgICAgIGZsYWdzICYgNjQgJiZcbiAgICAgICAgICAgICgoZmxhZ3MgPSBmaW5pc2hlZFdvcmsudXBkYXRlUXVldWUpLCBudWxsICE9PSBmbGFncylcbiAgICAgICAgICApIHtcbiAgICAgICAgICAgIHByZXZQcm9wcyA9IG51bGw7XG4gICAgICAgICAgICBpZiAobnVsbCAhPT0gZmluaXNoZWRXb3JrLmNoaWxkKVxuICAgICAgICAgICAgICBzd2l0Y2ggKGZpbmlzaGVkV29yay5jaGlsZC50YWcpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDI3OlxuICAgICAgICAgICAgICAgIGNhc2UgNTpcbiAgICAgICAgICAgICAgICAgIHByZXZQcm9wcyA9IGdldFB1YmxpY0luc3RhbmNlKGZpbmlzaGVkV29yay5jaGlsZC5zdGF0ZU5vZGUpO1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgcHJldlByb3BzID0gZmluaXNoZWRXb3JrLmNoaWxkLnN0YXRlTm9kZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgcnVuV2l0aEZpYmVySW5ERVYoXG4gICAgICAgICAgICAgICAgZmluaXNoZWRXb3JrLFxuICAgICAgICAgICAgICAgIGNvbW1pdENhbGxiYWNrcyxcbiAgICAgICAgICAgICAgICBmbGFncyxcbiAgICAgICAgICAgICAgICBwcmV2UHJvcHNcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgIGNhcHR1cmVDb21taXRQaGFzZUVycm9yKGZpbmlzaGVkV29yaywgZmluaXNoZWRXb3JrLnJldHVybiwgZXJyb3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBmaW5pc2hlZFJvb3QuZWZmZWN0RHVyYXRpb24gKz0gcG9wTmVzdGVkRWZmZWN0RHVyYXRpb25zKGN1cnJlbnQpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDI2OlxuICAgICAgICAgIGlmIChzdXBwb3J0c1Jlc291cmNlcykge1xuICAgICAgICAgICAgcmVjdXJzaXZlbHlUcmF2ZXJzZUxheW91dEVmZmVjdHMoZmluaXNoZWRSb290LCBmaW5pc2hlZFdvcmspO1xuICAgICAgICAgICAgZmxhZ3MgJiA1MTIgJiYgc2FmZWx5QXR0YWNoUmVmKGZpbmlzaGVkV29yaywgZmluaXNoZWRXb3JrLnJldHVybik7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIGNhc2UgMjc6XG4gICAgICAgIGNhc2UgNTpcbiAgICAgICAgICByZWN1cnNpdmVseVRyYXZlcnNlTGF5b3V0RWZmZWN0cyhmaW5pc2hlZFJvb3QsIGZpbmlzaGVkV29yayk7XG4gICAgICAgICAgbnVsbCA9PT0gY3VycmVudCAmJiBmbGFncyAmIDQgJiYgY29tbWl0SG9zdE1vdW50KGZpbmlzaGVkV29yayk7XG4gICAgICAgICAgZmxhZ3MgJiA1MTIgJiYgc2FmZWx5QXR0YWNoUmVmKGZpbmlzaGVkV29yaywgZmluaXNoZWRXb3JrLnJldHVybik7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMTI6XG4gICAgICAgICAgaWYgKGZsYWdzICYgNCkge1xuICAgICAgICAgICAgZmxhZ3MgPSBwdXNoTmVzdGVkRWZmZWN0RHVyYXRpb25zKCk7XG4gICAgICAgICAgICByZWN1cnNpdmVseVRyYXZlcnNlTGF5b3V0RWZmZWN0cyhmaW5pc2hlZFJvb3QsIGZpbmlzaGVkV29yayk7XG4gICAgICAgICAgICBmaW5pc2hlZFJvb3QgPSBmaW5pc2hlZFdvcmsuc3RhdGVOb2RlO1xuICAgICAgICAgICAgZmluaXNoZWRSb290LmVmZmVjdER1cmF0aW9uICs9IGJ1YmJsZU5lc3RlZEVmZmVjdER1cmF0aW9ucyhmbGFncyk7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBydW5XaXRoRmliZXJJbkRFVihcbiAgICAgICAgICAgICAgICBmaW5pc2hlZFdvcmssXG4gICAgICAgICAgICAgICAgY29tbWl0UHJvZmlsZXIsXG4gICAgICAgICAgICAgICAgZmluaXNoZWRXb3JrLFxuICAgICAgICAgICAgICAgIGN1cnJlbnQsXG4gICAgICAgICAgICAgICAgY29tbWl0U3RhcnRUaW1lLFxuICAgICAgICAgICAgICAgIGZpbmlzaGVkUm9vdC5lZmZlY3REdXJhdGlvblxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgY2FwdHVyZUNvbW1pdFBoYXNlRXJyb3IoZmluaXNoZWRXb3JrLCBmaW5pc2hlZFdvcmsucmV0dXJuLCBlcnJvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHJlY3Vyc2l2ZWx5VHJhdmVyc2VMYXlvdXRFZmZlY3RzKGZpbmlzaGVkUm9vdCwgZmluaXNoZWRXb3JrKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAxMzpcbiAgICAgICAgICByZWN1cnNpdmVseVRyYXZlcnNlTGF5b3V0RWZmZWN0cyhmaW5pc2hlZFJvb3QsIGZpbmlzaGVkV29yayk7XG4gICAgICAgICAgZmxhZ3MgJiA0ICYmXG4gICAgICAgICAgICBjb21taXRTdXNwZW5zZUh5ZHJhdGlvbkNhbGxiYWNrcyhmaW5pc2hlZFJvb3QsIGZpbmlzaGVkV29yayk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMjI6XG4gICAgICAgICAgcHJldlByb3BzID1cbiAgICAgICAgICAgIG51bGwgIT09IGZpbmlzaGVkV29yay5tZW1vaXplZFN0YXRlIHx8IG9mZnNjcmVlblN1YnRyZWVJc0hpZGRlbjtcbiAgICAgICAgICBpZiAoIXByZXZQcm9wcykge1xuICAgICAgICAgICAgY3VycmVudCA9XG4gICAgICAgICAgICAgIChudWxsICE9PSBjdXJyZW50ICYmIG51bGwgIT09IGN1cnJlbnQubWVtb2l6ZWRTdGF0ZSkgfHxcbiAgICAgICAgICAgICAgb2Zmc2NyZWVuU3VidHJlZVdhc0hpZGRlbjtcbiAgICAgICAgICAgIHZhciBwcmV2T2Zmc2NyZWVuU3VidHJlZUlzSGlkZGVuID0gb2Zmc2NyZWVuU3VidHJlZUlzSGlkZGVuLFxuICAgICAgICAgICAgICBwcmV2T2Zmc2NyZWVuU3VidHJlZVdhc0hpZGRlbiA9IG9mZnNjcmVlblN1YnRyZWVXYXNIaWRkZW47XG4gICAgICAgICAgICBvZmZzY3JlZW5TdWJ0cmVlSXNIaWRkZW4gPSBwcmV2UHJvcHM7XG4gICAgICAgICAgICAob2Zmc2NyZWVuU3VidHJlZVdhc0hpZGRlbiA9IGN1cnJlbnQpICYmXG4gICAgICAgICAgICAhcHJldk9mZnNjcmVlblN1YnRyZWVXYXNIaWRkZW5cbiAgICAgICAgICAgICAgPyByZWN1cnNpdmVseVRyYXZlcnNlUmVhcHBlYXJMYXlvdXRFZmZlY3RzKFxuICAgICAgICAgICAgICAgICAgZmluaXNoZWRSb290LFxuICAgICAgICAgICAgICAgICAgZmluaXNoZWRXb3JrLFxuICAgICAgICAgICAgICAgICAgMCAhPT0gKGZpbmlzaGVkV29yay5zdWJ0cmVlRmxhZ3MgJiA4NzcyKVxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgOiByZWN1cnNpdmVseVRyYXZlcnNlTGF5b3V0RWZmZWN0cyhmaW5pc2hlZFJvb3QsIGZpbmlzaGVkV29yayk7XG4gICAgICAgICAgICBvZmZzY3JlZW5TdWJ0cmVlSXNIaWRkZW4gPSBwcmV2T2Zmc2NyZWVuU3VidHJlZUlzSGlkZGVuO1xuICAgICAgICAgICAgb2Zmc2NyZWVuU3VidHJlZVdhc0hpZGRlbiA9IHByZXZPZmZzY3JlZW5TdWJ0cmVlV2FzSGlkZGVuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBmbGFncyAmIDUxMiAmJlxuICAgICAgICAgICAgKFwibWFudWFsXCIgPT09IGZpbmlzaGVkV29yay5tZW1vaXplZFByb3BzLm1vZGVcbiAgICAgICAgICAgICAgPyBzYWZlbHlBdHRhY2hSZWYoZmluaXNoZWRXb3JrLCBmaW5pc2hlZFdvcmsucmV0dXJuKVxuICAgICAgICAgICAgICA6IHNhZmVseURldGFjaFJlZihmaW5pc2hlZFdvcmssIGZpbmlzaGVkV29yay5yZXR1cm4pKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICByZWN1cnNpdmVseVRyYXZlcnNlTGF5b3V0RWZmZWN0cyhmaW5pc2hlZFJvb3QsIGZpbmlzaGVkV29yayk7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGRldGFjaEZpYmVyQWZ0ZXJFZmZlY3RzKGZpYmVyKSB7XG4gICAgICB2YXIgYWx0ZXJuYXRlID0gZmliZXIuYWx0ZXJuYXRlO1xuICAgICAgbnVsbCAhPT0gYWx0ZXJuYXRlICYmXG4gICAgICAgICgoZmliZXIuYWx0ZXJuYXRlID0gbnVsbCksIGRldGFjaEZpYmVyQWZ0ZXJFZmZlY3RzKGFsdGVybmF0ZSkpO1xuICAgICAgZmliZXIuY2hpbGQgPSBudWxsO1xuICAgICAgZmliZXIuZGVsZXRpb25zID0gbnVsbDtcbiAgICAgIGZpYmVyLnNpYmxpbmcgPSBudWxsO1xuICAgICAgNSA9PT0gZmliZXIudGFnICYmXG4gICAgICAgICgoYWx0ZXJuYXRlID0gZmliZXIuc3RhdGVOb2RlKSxcbiAgICAgICAgbnVsbCAhPT0gYWx0ZXJuYXRlICYmIGRldGFjaERlbGV0ZWRJbnN0YW5jZShhbHRlcm5hdGUpKTtcbiAgICAgIGZpYmVyLnN0YXRlTm9kZSA9IG51bGw7XG4gICAgICBmaWJlci5fZGVidWdPd25lciA9IG51bGw7XG4gICAgICBmaWJlci5yZXR1cm4gPSBudWxsO1xuICAgICAgZmliZXIuZGVwZW5kZW5jaWVzID0gbnVsbDtcbiAgICAgIGZpYmVyLm1lbW9pemVkUHJvcHMgPSBudWxsO1xuICAgICAgZmliZXIubWVtb2l6ZWRTdGF0ZSA9IG51bGw7XG4gICAgICBmaWJlci5wZW5kaW5nUHJvcHMgPSBudWxsO1xuICAgICAgZmliZXIuc3RhdGVOb2RlID0gbnVsbDtcbiAgICAgIGZpYmVyLnVwZGF0ZVF1ZXVlID0gbnVsbDtcbiAgICB9XG4gICAgZnVuY3Rpb24gcmVjdXJzaXZlbHlUcmF2ZXJzZURlbGV0aW9uRWZmZWN0cyhcbiAgICAgIGZpbmlzaGVkUm9vdCxcbiAgICAgIG5lYXJlc3RNb3VudGVkQW5jZXN0b3IsXG4gICAgICBwYXJlbnRcbiAgICApIHtcbiAgICAgIGZvciAocGFyZW50ID0gcGFyZW50LmNoaWxkOyBudWxsICE9PSBwYXJlbnQ7IClcbiAgICAgICAgY29tbWl0RGVsZXRpb25FZmZlY3RzT25GaWJlcihcbiAgICAgICAgICBmaW5pc2hlZFJvb3QsXG4gICAgICAgICAgbmVhcmVzdE1vdW50ZWRBbmNlc3RvcixcbiAgICAgICAgICBwYXJlbnRcbiAgICAgICAgKSxcbiAgICAgICAgICAocGFyZW50ID0gcGFyZW50LnNpYmxpbmcpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjb21taXREZWxldGlvbkVmZmVjdHNPbkZpYmVyKFxuICAgICAgZmluaXNoZWRSb290LFxuICAgICAgbmVhcmVzdE1vdW50ZWRBbmNlc3RvcixcbiAgICAgIGRlbGV0ZWRGaWJlclxuICAgICkge1xuICAgICAgaWYgKFxuICAgICAgICBpbmplY3RlZEhvb2sgJiZcbiAgICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgaW5qZWN0ZWRIb29rLm9uQ29tbWl0RmliZXJVbm1vdW50XG4gICAgICApXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgaW5qZWN0ZWRIb29rLm9uQ29tbWl0RmliZXJVbm1vdW50KHJlbmRlcmVySUQsIGRlbGV0ZWRGaWJlcik7XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgIGhhc0xvZ2dlZEVycm9yIHx8XG4gICAgICAgICAgICAoKGhhc0xvZ2dlZEVycm9yID0gITApLFxuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgXCJSZWFjdCBpbnN0cnVtZW50YXRpb24gZW5jb3VudGVyZWQgYW4gZXJyb3I6ICVzXCIsXG4gICAgICAgICAgICAgIGVyclxuICAgICAgICAgICAgKSk7XG4gICAgICAgIH1cbiAgICAgIHN3aXRjaCAoZGVsZXRlZEZpYmVyLnRhZykge1xuICAgICAgICBjYXNlIDI2OlxuICAgICAgICAgIGlmIChzdXBwb3J0c1Jlc291cmNlcykge1xuICAgICAgICAgICAgb2Zmc2NyZWVuU3VidHJlZVdhc0hpZGRlbiB8fFxuICAgICAgICAgICAgICBzYWZlbHlEZXRhY2hSZWYoZGVsZXRlZEZpYmVyLCBuZWFyZXN0TW91bnRlZEFuY2VzdG9yKTtcbiAgICAgICAgICAgIHJlY3Vyc2l2ZWx5VHJhdmVyc2VEZWxldGlvbkVmZmVjdHMoXG4gICAgICAgICAgICAgIGZpbmlzaGVkUm9vdCxcbiAgICAgICAgICAgICAgbmVhcmVzdE1vdW50ZWRBbmNlc3RvcixcbiAgICAgICAgICAgICAgZGVsZXRlZEZpYmVyXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgZGVsZXRlZEZpYmVyLm1lbW9pemVkU3RhdGVcbiAgICAgICAgICAgICAgPyByZWxlYXNlUmVzb3VyY2UoZGVsZXRlZEZpYmVyLm1lbW9pemVkU3RhdGUpXG4gICAgICAgICAgICAgIDogZGVsZXRlZEZpYmVyLnN0YXRlTm9kZSAmJlxuICAgICAgICAgICAgICAgIHVubW91bnRIb2lzdGFibGUoZGVsZXRlZEZpYmVyLnN0YXRlTm9kZSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIGNhc2UgMjc6XG4gICAgICAgICAgaWYgKHN1cHBvcnRzU2luZ2xldG9ucykge1xuICAgICAgICAgICAgb2Zmc2NyZWVuU3VidHJlZVdhc0hpZGRlbiB8fFxuICAgICAgICAgICAgICBzYWZlbHlEZXRhY2hSZWYoZGVsZXRlZEZpYmVyLCBuZWFyZXN0TW91bnRlZEFuY2VzdG9yKTtcbiAgICAgICAgICAgIHZhciBwcmV2SG9zdFBhcmVudCA9IGhvc3RQYXJlbnQsXG4gICAgICAgICAgICAgIHByZXZIb3N0UGFyZW50SXNDb250YWluZXIgPSBob3N0UGFyZW50SXNDb250YWluZXI7XG4gICAgICAgICAgICBob3N0UGFyZW50ID0gZGVsZXRlZEZpYmVyLnN0YXRlTm9kZTtcbiAgICAgICAgICAgIHJlY3Vyc2l2ZWx5VHJhdmVyc2VEZWxldGlvbkVmZmVjdHMoXG4gICAgICAgICAgICAgIGZpbmlzaGVkUm9vdCxcbiAgICAgICAgICAgICAgbmVhcmVzdE1vdW50ZWRBbmNlc3RvcixcbiAgICAgICAgICAgICAgZGVsZXRlZEZpYmVyXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgcmVsZWFzZVNpbmdsZXRvbkluc3RhbmNlKGRlbGV0ZWRGaWJlci5zdGF0ZU5vZGUpO1xuICAgICAgICAgICAgaG9zdFBhcmVudCA9IHByZXZIb3N0UGFyZW50O1xuICAgICAgICAgICAgaG9zdFBhcmVudElzQ29udGFpbmVyID0gcHJldkhvc3RQYXJlbnRJc0NvbnRhaW5lcjtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgY2FzZSA1OlxuICAgICAgICAgIG9mZnNjcmVlblN1YnRyZWVXYXNIaWRkZW4gfHxcbiAgICAgICAgICAgIHNhZmVseURldGFjaFJlZihkZWxldGVkRmliZXIsIG5lYXJlc3RNb3VudGVkQW5jZXN0b3IpO1xuICAgICAgICBjYXNlIDY6XG4gICAgICAgICAgaWYgKHN1cHBvcnRzTXV0YXRpb24pIHtcbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgKChwcmV2SG9zdFBhcmVudCA9IGhvc3RQYXJlbnQpLFxuICAgICAgICAgICAgICAocHJldkhvc3RQYXJlbnRJc0NvbnRhaW5lciA9IGhvc3RQYXJlbnRJc0NvbnRhaW5lciksXG4gICAgICAgICAgICAgIChob3N0UGFyZW50ID0gbnVsbCksXG4gICAgICAgICAgICAgIHJlY3Vyc2l2ZWx5VHJhdmVyc2VEZWxldGlvbkVmZmVjdHMoXG4gICAgICAgICAgICAgICAgZmluaXNoZWRSb290LFxuICAgICAgICAgICAgICAgIG5lYXJlc3RNb3VudGVkQW5jZXN0b3IsXG4gICAgICAgICAgICAgICAgZGVsZXRlZEZpYmVyXG4gICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgIChob3N0UGFyZW50ID0gcHJldkhvc3RQYXJlbnQpLFxuICAgICAgICAgICAgICAoaG9zdFBhcmVudElzQ29udGFpbmVyID0gcHJldkhvc3RQYXJlbnRJc0NvbnRhaW5lciksXG4gICAgICAgICAgICAgIG51bGwgIT09IGhvc3RQYXJlbnQpXG4gICAgICAgICAgICApXG4gICAgICAgICAgICAgIGlmIChob3N0UGFyZW50SXNDb250YWluZXIpXG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgIHJ1bldpdGhGaWJlckluREVWKFxuICAgICAgICAgICAgICAgICAgICBkZWxldGVkRmliZXIsXG4gICAgICAgICAgICAgICAgICAgIHJlbW92ZUNoaWxkRnJvbUNvbnRhaW5lcixcbiAgICAgICAgICAgICAgICAgICAgaG9zdFBhcmVudCxcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlZEZpYmVyLnN0YXRlTm9kZVxuICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgY2FwdHVyZUNvbW1pdFBoYXNlRXJyb3IoXG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZWRGaWJlcixcbiAgICAgICAgICAgICAgICAgICAgbmVhcmVzdE1vdW50ZWRBbmNlc3RvcixcbiAgICAgICAgICAgICAgICAgICAgZXJyb3JcbiAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgIHJ1bldpdGhGaWJlckluREVWKFxuICAgICAgICAgICAgICAgICAgICBkZWxldGVkRmliZXIsXG4gICAgICAgICAgICAgICAgICAgIHJlbW92ZUNoaWxkLFxuICAgICAgICAgICAgICAgICAgICBob3N0UGFyZW50LFxuICAgICAgICAgICAgICAgICAgICBkZWxldGVkRmliZXIuc3RhdGVOb2RlXG4gICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICBjYXB0dXJlQ29tbWl0UGhhc2VFcnJvcihcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlZEZpYmVyLFxuICAgICAgICAgICAgICAgICAgICBuZWFyZXN0TW91bnRlZEFuY2VzdG9yLFxuICAgICAgICAgICAgICAgICAgICBlcnJvclxuICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlXG4gICAgICAgICAgICByZWN1cnNpdmVseVRyYXZlcnNlRGVsZXRpb25FZmZlY3RzKFxuICAgICAgICAgICAgICBmaW5pc2hlZFJvb3QsXG4gICAgICAgICAgICAgIG5lYXJlc3RNb3VudGVkQW5jZXN0b3IsXG4gICAgICAgICAgICAgIGRlbGV0ZWRGaWJlclxuICAgICAgICAgICAgKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAxODpcbiAgICAgICAgICBzdXBwb3J0c011dGF0aW9uICYmXG4gICAgICAgICAgICBudWxsICE9PSBob3N0UGFyZW50ICYmXG4gICAgICAgICAgICAoaG9zdFBhcmVudElzQ29udGFpbmVyXG4gICAgICAgICAgICAgID8gY2xlYXJTdXNwZW5zZUJvdW5kYXJ5RnJvbUNvbnRhaW5lcihcbiAgICAgICAgICAgICAgICAgIGhvc3RQYXJlbnQsXG4gICAgICAgICAgICAgICAgICBkZWxldGVkRmliZXIuc3RhdGVOb2RlXG4gICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICA6IGNsZWFyU3VzcGVuc2VCb3VuZGFyeShob3N0UGFyZW50LCBkZWxldGVkRmliZXIuc3RhdGVOb2RlKSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgNDpcbiAgICAgICAgICBzdXBwb3J0c011dGF0aW9uXG4gICAgICAgICAgICA/ICgocHJldkhvc3RQYXJlbnQgPSBob3N0UGFyZW50KSxcbiAgICAgICAgICAgICAgKHByZXZIb3N0UGFyZW50SXNDb250YWluZXIgPSBob3N0UGFyZW50SXNDb250YWluZXIpLFxuICAgICAgICAgICAgICAoaG9zdFBhcmVudCA9IGRlbGV0ZWRGaWJlci5zdGF0ZU5vZGUuY29udGFpbmVySW5mbyksXG4gICAgICAgICAgICAgIChob3N0UGFyZW50SXNDb250YWluZXIgPSAhMCksXG4gICAgICAgICAgICAgIHJlY3Vyc2l2ZWx5VHJhdmVyc2VEZWxldGlvbkVmZmVjdHMoXG4gICAgICAgICAgICAgICAgZmluaXNoZWRSb290LFxuICAgICAgICAgICAgICAgIG5lYXJlc3RNb3VudGVkQW5jZXN0b3IsXG4gICAgICAgICAgICAgICAgZGVsZXRlZEZpYmVyXG4gICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgIChob3N0UGFyZW50ID0gcHJldkhvc3RQYXJlbnQpLFxuICAgICAgICAgICAgICAoaG9zdFBhcmVudElzQ29udGFpbmVyID0gcHJldkhvc3RQYXJlbnRJc0NvbnRhaW5lcikpXG4gICAgICAgICAgICA6IChzdXBwb3J0c1BlcnNpc3RlbmNlICYmXG4gICAgICAgICAgICAgICAgY29tbWl0SG9zdFBvcnRhbENvbnRhaW5lckNoaWxkcmVuKFxuICAgICAgICAgICAgICAgICAgZGVsZXRlZEZpYmVyLnN0YXRlTm9kZSxcbiAgICAgICAgICAgICAgICAgIGRlbGV0ZWRGaWJlcixcbiAgICAgICAgICAgICAgICAgIGNyZWF0ZUNvbnRhaW5lckNoaWxkU2V0KClcbiAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICByZWN1cnNpdmVseVRyYXZlcnNlRGVsZXRpb25FZmZlY3RzKFxuICAgICAgICAgICAgICAgIGZpbmlzaGVkUm9vdCxcbiAgICAgICAgICAgICAgICBuZWFyZXN0TW91bnRlZEFuY2VzdG9yLFxuICAgICAgICAgICAgICAgIGRlbGV0ZWRGaWJlclxuICAgICAgICAgICAgICApKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAwOlxuICAgICAgICBjYXNlIDExOlxuICAgICAgICBjYXNlIDE0OlxuICAgICAgICBjYXNlIDE1OlxuICAgICAgICAgIG9mZnNjcmVlblN1YnRyZWVXYXNIaWRkZW4gfHxcbiAgICAgICAgICAgIGNvbW1pdEhvb2tFZmZlY3RMaXN0VW5tb3VudChcbiAgICAgICAgICAgICAgSW5zZXJ0aW9uLFxuICAgICAgICAgICAgICBkZWxldGVkRmliZXIsXG4gICAgICAgICAgICAgIG5lYXJlc3RNb3VudGVkQW5jZXN0b3JcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgb2Zmc2NyZWVuU3VidHJlZVdhc0hpZGRlbiB8fFxuICAgICAgICAgICAgY29tbWl0SG9va0xheW91dFVubW91bnRFZmZlY3RzKFxuICAgICAgICAgICAgICBkZWxldGVkRmliZXIsXG4gICAgICAgICAgICAgIG5lYXJlc3RNb3VudGVkQW5jZXN0b3IsXG4gICAgICAgICAgICAgIExheW91dFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICByZWN1cnNpdmVseVRyYXZlcnNlRGVsZXRpb25FZmZlY3RzKFxuICAgICAgICAgICAgZmluaXNoZWRSb290LFxuICAgICAgICAgICAgbmVhcmVzdE1vdW50ZWRBbmNlc3RvcixcbiAgICAgICAgICAgIGRlbGV0ZWRGaWJlclxuICAgICAgICAgICk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICBvZmZzY3JlZW5TdWJ0cmVlV2FzSGlkZGVuIHx8XG4gICAgICAgICAgICAoc2FmZWx5RGV0YWNoUmVmKGRlbGV0ZWRGaWJlciwgbmVhcmVzdE1vdW50ZWRBbmNlc3RvciksXG4gICAgICAgICAgICAocHJldkhvc3RQYXJlbnQgPSBkZWxldGVkRmliZXIuc3RhdGVOb2RlKSxcbiAgICAgICAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIHByZXZIb3N0UGFyZW50LmNvbXBvbmVudFdpbGxVbm1vdW50ICYmXG4gICAgICAgICAgICAgIHNhZmVseUNhbGxDb21wb25lbnRXaWxsVW5tb3VudChcbiAgICAgICAgICAgICAgICBkZWxldGVkRmliZXIsXG4gICAgICAgICAgICAgICAgbmVhcmVzdE1vdW50ZWRBbmNlc3RvcixcbiAgICAgICAgICAgICAgICBwcmV2SG9zdFBhcmVudFxuICAgICAgICAgICAgICApKTtcbiAgICAgICAgICByZWN1cnNpdmVseVRyYXZlcnNlRGVsZXRpb25FZmZlY3RzKFxuICAgICAgICAgICAgZmluaXNoZWRSb290LFxuICAgICAgICAgICAgbmVhcmVzdE1vdW50ZWRBbmNlc3RvcixcbiAgICAgICAgICAgIGRlbGV0ZWRGaWJlclxuICAgICAgICAgICk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMjE6XG4gICAgICAgICAgcmVjdXJzaXZlbHlUcmF2ZXJzZURlbGV0aW9uRWZmZWN0cyhcbiAgICAgICAgICAgIGZpbmlzaGVkUm9vdCxcbiAgICAgICAgICAgIG5lYXJlc3RNb3VudGVkQW5jZXN0b3IsXG4gICAgICAgICAgICBkZWxldGVkRmliZXJcbiAgICAgICAgICApO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDIyOlxuICAgICAgICAgIG9mZnNjcmVlblN1YnRyZWVXYXNIaWRkZW4gfHxcbiAgICAgICAgICAgIHNhZmVseURldGFjaFJlZihkZWxldGVkRmliZXIsIG5lYXJlc3RNb3VudGVkQW5jZXN0b3IpO1xuICAgICAgICAgIG9mZnNjcmVlblN1YnRyZWVXYXNIaWRkZW4gPVxuICAgICAgICAgICAgKHByZXZIb3N0UGFyZW50ID0gb2Zmc2NyZWVuU3VidHJlZVdhc0hpZGRlbikgfHxcbiAgICAgICAgICAgIG51bGwgIT09IGRlbGV0ZWRGaWJlci5tZW1vaXplZFN0YXRlO1xuICAgICAgICAgIHJlY3Vyc2l2ZWx5VHJhdmVyc2VEZWxldGlvbkVmZmVjdHMoXG4gICAgICAgICAgICBmaW5pc2hlZFJvb3QsXG4gICAgICAgICAgICBuZWFyZXN0TW91bnRlZEFuY2VzdG9yLFxuICAgICAgICAgICAgZGVsZXRlZEZpYmVyXG4gICAgICAgICAgKTtcbiAgICAgICAgICBvZmZzY3JlZW5TdWJ0cmVlV2FzSGlkZGVuID0gcHJldkhvc3RQYXJlbnQ7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgcmVjdXJzaXZlbHlUcmF2ZXJzZURlbGV0aW9uRWZmZWN0cyhcbiAgICAgICAgICAgIGZpbmlzaGVkUm9vdCxcbiAgICAgICAgICAgIG5lYXJlc3RNb3VudGVkQW5jZXN0b3IsXG4gICAgICAgICAgICBkZWxldGVkRmliZXJcbiAgICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBjb21taXRTdXNwZW5zZUh5ZHJhdGlvbkNhbGxiYWNrcyhmaW5pc2hlZFJvb3QsIGZpbmlzaGVkV29yaykge1xuICAgICAgaWYgKFxuICAgICAgICBzdXBwb3J0c0h5ZHJhdGlvbiAmJlxuICAgICAgICBudWxsID09PSBmaW5pc2hlZFdvcmsubWVtb2l6ZWRTdGF0ZSAmJlxuICAgICAgICAoKGZpbmlzaGVkUm9vdCA9IGZpbmlzaGVkV29yay5hbHRlcm5hdGUpLFxuICAgICAgICBudWxsICE9PSBmaW5pc2hlZFJvb3QgJiZcbiAgICAgICAgICAoKGZpbmlzaGVkUm9vdCA9IGZpbmlzaGVkUm9vdC5tZW1vaXplZFN0YXRlKSxcbiAgICAgICAgICBudWxsICE9PSBmaW5pc2hlZFJvb3QgJiZcbiAgICAgICAgICAgICgoZmluaXNoZWRSb290ID0gZmluaXNoZWRSb290LmRlaHlkcmF0ZWQpLCBudWxsICE9PSBmaW5pc2hlZFJvb3QpKSlcbiAgICAgIClcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBydW5XaXRoRmliZXJJbkRFVihcbiAgICAgICAgICAgIGZpbmlzaGVkV29yayxcbiAgICAgICAgICAgIGNvbW1pdEh5ZHJhdGVkU3VzcGVuc2VJbnN0YW5jZSxcbiAgICAgICAgICAgIGZpbmlzaGVkUm9vdFxuICAgICAgICAgICk7XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgY2FwdHVyZUNvbW1pdFBoYXNlRXJyb3IoZmluaXNoZWRXb3JrLCBmaW5pc2hlZFdvcmsucmV0dXJuLCBlcnJvcik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gZ2V0UmV0cnlDYWNoZShmaW5pc2hlZFdvcmspIHtcbiAgICAgIHN3aXRjaCAoZmluaXNoZWRXb3JrLnRhZykge1xuICAgICAgICBjYXNlIDEzOlxuICAgICAgICBjYXNlIDE5OlxuICAgICAgICAgIHZhciByZXRyeUNhY2hlID0gZmluaXNoZWRXb3JrLnN0YXRlTm9kZTtcbiAgICAgICAgICBudWxsID09PSByZXRyeUNhY2hlICYmXG4gICAgICAgICAgICAocmV0cnlDYWNoZSA9IGZpbmlzaGVkV29yay5zdGF0ZU5vZGUgPSBuZXcgUG9zc2libHlXZWFrU2V0KCkpO1xuICAgICAgICAgIHJldHVybiByZXRyeUNhY2hlO1xuICAgICAgICBjYXNlIDIyOlxuICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAoZmluaXNoZWRXb3JrID0gZmluaXNoZWRXb3JrLnN0YXRlTm9kZSksXG4gICAgICAgICAgICAocmV0cnlDYWNoZSA9IGZpbmlzaGVkV29yay5fcmV0cnlDYWNoZSksXG4gICAgICAgICAgICBudWxsID09PSByZXRyeUNhY2hlICYmXG4gICAgICAgICAgICAgIChyZXRyeUNhY2hlID0gZmluaXNoZWRXb3JrLl9yZXRyeUNhY2hlID0gbmV3IFBvc3NpYmx5V2Vha1NldCgpKSxcbiAgICAgICAgICAgIHJldHJ5Q2FjaGVcbiAgICAgICAgICApO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHRocm93IEVycm9yKFxuICAgICAgICAgICAgXCJVbmV4cGVjdGVkIFN1c3BlbnNlIGhhbmRsZXIgdGFnIChcIiArXG4gICAgICAgICAgICAgIGZpbmlzaGVkV29yay50YWcgK1xuICAgICAgICAgICAgICBcIikuIFRoaXMgaXMgYSBidWcgaW4gUmVhY3QuXCJcbiAgICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBhdHRhY2hTdXNwZW5zZVJldHJ5TGlzdGVuZXJzKGZpbmlzaGVkV29yaywgd2FrZWFibGVzKSB7XG4gICAgICB2YXIgcmV0cnlDYWNoZSA9IGdldFJldHJ5Q2FjaGUoZmluaXNoZWRXb3JrKTtcbiAgICAgIHdha2VhYmxlcy5mb3JFYWNoKGZ1bmN0aW9uICh3YWtlYWJsZSkge1xuICAgICAgICB2YXIgcmV0cnkgPSByZXNvbHZlUmV0cnlXYWtlYWJsZS5iaW5kKG51bGwsIGZpbmlzaGVkV29yaywgd2FrZWFibGUpO1xuICAgICAgICBpZiAoIXJldHJ5Q2FjaGUuaGFzKHdha2VhYmxlKSkge1xuICAgICAgICAgIHJldHJ5Q2FjaGUuYWRkKHdha2VhYmxlKTtcbiAgICAgICAgICBpZiAoaXNEZXZUb29sc1ByZXNlbnQpXG4gICAgICAgICAgICBpZiAobnVsbCAhPT0gaW5Qcm9ncmVzc0xhbmVzICYmIG51bGwgIT09IGluUHJvZ3Jlc3NSb290KVxuICAgICAgICAgICAgICByZXN0b3JlUGVuZGluZ1VwZGF0ZXJzKGluUHJvZ3Jlc3NSb290LCBpblByb2dyZXNzTGFuZXMpO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcbiAgICAgICAgICAgICAgICBcIkV4cGVjdGVkIGZpbmlzaGVkIHJvb3QgYW5kIGxhbmVzIHRvIGJlIHNldC4gVGhpcyBpcyBhIGJ1ZyBpbiBSZWFjdC5cIlxuICAgICAgICAgICAgICApO1xuICAgICAgICAgIHdha2VhYmxlLnRoZW4ocmV0cnksIHJldHJ5KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNvbW1pdE11dGF0aW9uRWZmZWN0cyhyb290LCBmaW5pc2hlZFdvcmssIGNvbW1pdHRlZExhbmVzKSB7XG4gICAgICBpblByb2dyZXNzTGFuZXMgPSBjb21taXR0ZWRMYW5lcztcbiAgICAgIGluUHJvZ3Jlc3NSb290ID0gcm9vdDtcbiAgICAgIGNvbW1pdE11dGF0aW9uRWZmZWN0c09uRmliZXIoZmluaXNoZWRXb3JrLCByb290KTtcbiAgICAgIGluUHJvZ3Jlc3NSb290ID0gaW5Qcm9ncmVzc0xhbmVzID0gbnVsbDtcbiAgICB9XG4gICAgZnVuY3Rpb24gcmVjdXJzaXZlbHlUcmF2ZXJzZU11dGF0aW9uRWZmZWN0cyhyb290JGpzY29tcCQwLCBwYXJlbnRGaWJlcikge1xuICAgICAgdmFyIGRlbGV0aW9ucyA9IHBhcmVudEZpYmVyLmRlbGV0aW9ucztcbiAgICAgIGlmIChudWxsICE9PSBkZWxldGlvbnMpXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGVsZXRpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdmFyIHJvb3QgPSByb290JGpzY29tcCQwLFxuICAgICAgICAgICAgcmV0dXJuRmliZXIgPSBwYXJlbnRGaWJlcixcbiAgICAgICAgICAgIGRlbGV0ZWRGaWJlciA9IGRlbGV0aW9uc1tpXTtcbiAgICAgICAgICBpZiAoc3VwcG9ydHNNdXRhdGlvbikge1xuICAgICAgICAgICAgdmFyIHBhcmVudCA9IHJldHVybkZpYmVyO1xuICAgICAgICAgICAgYTogZm9yICg7IG51bGwgIT09IHBhcmVudDsgKSB7XG4gICAgICAgICAgICAgIHN3aXRjaCAocGFyZW50LnRhZykge1xuICAgICAgICAgICAgICAgIGNhc2UgMjc6XG4gICAgICAgICAgICAgICAgY2FzZSA1OlxuICAgICAgICAgICAgICAgICAgaG9zdFBhcmVudCA9IHBhcmVudC5zdGF0ZU5vZGU7XG4gICAgICAgICAgICAgICAgICBob3N0UGFyZW50SXNDb250YWluZXIgPSAhMTtcbiAgICAgICAgICAgICAgICAgIGJyZWFrIGE7XG4gICAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgICAgaG9zdFBhcmVudCA9IHBhcmVudC5zdGF0ZU5vZGUuY29udGFpbmVySW5mbztcbiAgICAgICAgICAgICAgICAgIGhvc3RQYXJlbnRJc0NvbnRhaW5lciA9ICEwO1xuICAgICAgICAgICAgICAgICAgYnJlYWsgYTtcbiAgICAgICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgICAgICBob3N0UGFyZW50ID0gcGFyZW50LnN0YXRlTm9kZS5jb250YWluZXJJbmZvO1xuICAgICAgICAgICAgICAgICAgaG9zdFBhcmVudElzQ29udGFpbmVyID0gITA7XG4gICAgICAgICAgICAgICAgICBicmVhayBhO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHBhcmVudCA9IHBhcmVudC5yZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobnVsbCA9PT0gaG9zdFBhcmVudClcbiAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXG4gICAgICAgICAgICAgICAgXCJFeHBlY3RlZCB0byBmaW5kIGEgaG9zdCBwYXJlbnQuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuXCJcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGNvbW1pdERlbGV0aW9uRWZmZWN0c09uRmliZXIocm9vdCwgcmV0dXJuRmliZXIsIGRlbGV0ZWRGaWJlcik7XG4gICAgICAgICAgICBob3N0UGFyZW50ID0gbnVsbDtcbiAgICAgICAgICAgIGhvc3RQYXJlbnRJc0NvbnRhaW5lciA9ICExO1xuICAgICAgICAgIH0gZWxzZSBjb21taXREZWxldGlvbkVmZmVjdHNPbkZpYmVyKHJvb3QsIHJldHVybkZpYmVyLCBkZWxldGVkRmliZXIpO1xuICAgICAgICAgIHJvb3QgPSBkZWxldGVkRmliZXI7XG4gICAgICAgICAgcmV0dXJuRmliZXIgPSByb290LmFsdGVybmF0ZTtcbiAgICAgICAgICBudWxsICE9PSByZXR1cm5GaWJlciAmJiAocmV0dXJuRmliZXIucmV0dXJuID0gbnVsbCk7XG4gICAgICAgICAgcm9vdC5yZXR1cm4gPSBudWxsO1xuICAgICAgICB9XG4gICAgICBpZiAocGFyZW50RmliZXIuc3VidHJlZUZsYWdzICYgMTM4NzgpXG4gICAgICAgIGZvciAocGFyZW50RmliZXIgPSBwYXJlbnRGaWJlci5jaGlsZDsgbnVsbCAhPT0gcGFyZW50RmliZXI7IClcbiAgICAgICAgICBjb21taXRNdXRhdGlvbkVmZmVjdHNPbkZpYmVyKHBhcmVudEZpYmVyLCByb290JGpzY29tcCQwKSxcbiAgICAgICAgICAgIChwYXJlbnRGaWJlciA9IHBhcmVudEZpYmVyLnNpYmxpbmcpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjb21taXRNdXRhdGlvbkVmZmVjdHNPbkZpYmVyKGZpbmlzaGVkV29yaywgcm9vdCkge1xuICAgICAgdmFyIGN1cnJlbnQgPSBmaW5pc2hlZFdvcmsuYWx0ZXJuYXRlLFxuICAgICAgICBmbGFncyA9IGZpbmlzaGVkV29yay5mbGFncztcbiAgICAgIHN3aXRjaCAoZmluaXNoZWRXb3JrLnRhZykge1xuICAgICAgICBjYXNlIDA6XG4gICAgICAgIGNhc2UgMTE6XG4gICAgICAgIGNhc2UgMTQ6XG4gICAgICAgIGNhc2UgMTU6XG4gICAgICAgICAgcmVjdXJzaXZlbHlUcmF2ZXJzZU11dGF0aW9uRWZmZWN0cyhyb290LCBmaW5pc2hlZFdvcmspO1xuICAgICAgICAgIGNvbW1pdFJlY29uY2lsaWF0aW9uRWZmZWN0cyhmaW5pc2hlZFdvcmspO1xuICAgICAgICAgIGZsYWdzICYgNCAmJlxuICAgICAgICAgICAgKGNvbW1pdEhvb2tFZmZlY3RMaXN0VW5tb3VudChcbiAgICAgICAgICAgICAgSW5zZXJ0aW9uIHwgSGFzRWZmZWN0LFxuICAgICAgICAgICAgICBmaW5pc2hlZFdvcmssXG4gICAgICAgICAgICAgIGZpbmlzaGVkV29yay5yZXR1cm5cbiAgICAgICAgICAgICksXG4gICAgICAgICAgICBjb21taXRIb29rRWZmZWN0TGlzdE1vdW50KEluc2VydGlvbiB8IEhhc0VmZmVjdCwgZmluaXNoZWRXb3JrKSxcbiAgICAgICAgICAgIGNvbW1pdEhvb2tMYXlvdXRVbm1vdW50RWZmZWN0cyhcbiAgICAgICAgICAgICAgZmluaXNoZWRXb3JrLFxuICAgICAgICAgICAgICBmaW5pc2hlZFdvcmsucmV0dXJuLFxuICAgICAgICAgICAgICBMYXlvdXQgfCBIYXNFZmZlY3RcbiAgICAgICAgICAgICkpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgcmVjdXJzaXZlbHlUcmF2ZXJzZU11dGF0aW9uRWZmZWN0cyhyb290LCBmaW5pc2hlZFdvcmspO1xuICAgICAgICAgIGNvbW1pdFJlY29uY2lsaWF0aW9uRWZmZWN0cyhmaW5pc2hlZFdvcmspO1xuICAgICAgICAgIGZsYWdzICYgNTEyICYmXG4gICAgICAgICAgICAob2Zmc2NyZWVuU3VidHJlZVdhc0hpZGRlbiB8fFxuICAgICAgICAgICAgICBudWxsID09PSBjdXJyZW50IHx8XG4gICAgICAgICAgICAgIHNhZmVseURldGFjaFJlZihjdXJyZW50LCBjdXJyZW50LnJldHVybikpO1xuICAgICAgICAgIGZsYWdzICYgNjQgJiZcbiAgICAgICAgICAgIG9mZnNjcmVlblN1YnRyZWVJc0hpZGRlbiAmJlxuICAgICAgICAgICAgKChmaW5pc2hlZFdvcmsgPSBmaW5pc2hlZFdvcmsudXBkYXRlUXVldWUpLFxuICAgICAgICAgICAgbnVsbCAhPT0gZmluaXNoZWRXb3JrICYmXG4gICAgICAgICAgICAgICgoZmxhZ3MgPSBmaW5pc2hlZFdvcmsuY2FsbGJhY2tzKSxcbiAgICAgICAgICAgICAgbnVsbCAhPT0gZmxhZ3MgJiZcbiAgICAgICAgICAgICAgICAoKGN1cnJlbnQgPSBmaW5pc2hlZFdvcmsuc2hhcmVkLmhpZGRlbkNhbGxiYWNrcyksXG4gICAgICAgICAgICAgICAgKGZpbmlzaGVkV29yay5zaGFyZWQuaGlkZGVuQ2FsbGJhY2tzID1cbiAgICAgICAgICAgICAgICAgIG51bGwgPT09IGN1cnJlbnQgPyBmbGFncyA6IGN1cnJlbnQuY29uY2F0KGZsYWdzKSkpKSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMjY6XG4gICAgICAgICAgaWYgKHN1cHBvcnRzUmVzb3VyY2VzKSB7XG4gICAgICAgICAgICB2YXIgaG9pc3RhYmxlUm9vdCA9IGN1cnJlbnRIb2lzdGFibGVSb290O1xuICAgICAgICAgICAgcmVjdXJzaXZlbHlUcmF2ZXJzZU11dGF0aW9uRWZmZWN0cyhyb290LCBmaW5pc2hlZFdvcmspO1xuICAgICAgICAgICAgY29tbWl0UmVjb25jaWxpYXRpb25FZmZlY3RzKGZpbmlzaGVkV29yayk7XG4gICAgICAgICAgICBmbGFncyAmIDUxMiAmJlxuICAgICAgICAgICAgICAob2Zmc2NyZWVuU3VidHJlZVdhc0hpZGRlbiB8fFxuICAgICAgICAgICAgICAgIG51bGwgPT09IGN1cnJlbnQgfHxcbiAgICAgICAgICAgICAgICBzYWZlbHlEZXRhY2hSZWYoY3VycmVudCwgY3VycmVudC5yZXR1cm4pKTtcbiAgICAgICAgICAgIGZsYWdzICYgNCAmJlxuICAgICAgICAgICAgICAoKGZsYWdzID0gbnVsbCAhPT0gY3VycmVudCA/IGN1cnJlbnQubWVtb2l6ZWRTdGF0ZSA6IG51bGwpLFxuICAgICAgICAgICAgICAocm9vdCA9IGZpbmlzaGVkV29yay5tZW1vaXplZFN0YXRlKSxcbiAgICAgICAgICAgICAgbnVsbCA9PT0gY3VycmVudFxuICAgICAgICAgICAgICAgID8gbnVsbCA9PT0gcm9vdFxuICAgICAgICAgICAgICAgICAgPyBudWxsID09PSBmaW5pc2hlZFdvcmsuc3RhdGVOb2RlXG4gICAgICAgICAgICAgICAgICAgID8gKGZpbmlzaGVkV29yay5zdGF0ZU5vZGUgPSBoeWRyYXRlSG9pc3RhYmxlKFxuICAgICAgICAgICAgICAgICAgICAgICAgaG9pc3RhYmxlUm9vdCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpbmlzaGVkV29yay50eXBlLFxuICAgICAgICAgICAgICAgICAgICAgICAgZmluaXNoZWRXb3JrLm1lbW9pemVkUHJvcHMsXG4gICAgICAgICAgICAgICAgICAgICAgICBmaW5pc2hlZFdvcmtcbiAgICAgICAgICAgICAgICAgICAgICApKVxuICAgICAgICAgICAgICAgICAgICA6IG1vdW50SG9pc3RhYmxlKFxuICAgICAgICAgICAgICAgICAgICAgICAgaG9pc3RhYmxlUm9vdCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpbmlzaGVkV29yay50eXBlLFxuICAgICAgICAgICAgICAgICAgICAgICAgZmluaXNoZWRXb3JrLnN0YXRlTm9kZVxuICAgICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgIDogKGZpbmlzaGVkV29yay5zdGF0ZU5vZGUgPSBhY3F1aXJlUmVzb3VyY2UoXG4gICAgICAgICAgICAgICAgICAgICAgaG9pc3RhYmxlUm9vdCxcbiAgICAgICAgICAgICAgICAgICAgICByb290LFxuICAgICAgICAgICAgICAgICAgICAgIGZpbmlzaGVkV29yay5tZW1vaXplZFByb3BzXG4gICAgICAgICAgICAgICAgICAgICkpXG4gICAgICAgICAgICAgICAgOiBmbGFncyAhPT0gcm9vdFxuICAgICAgICAgICAgICAgICAgPyAobnVsbCA9PT0gZmxhZ3NcbiAgICAgICAgICAgICAgICAgICAgICA/IG51bGwgIT09IGN1cnJlbnQuc3RhdGVOb2RlICYmXG4gICAgICAgICAgICAgICAgICAgICAgICB1bm1vdW50SG9pc3RhYmxlKGN1cnJlbnQuc3RhdGVOb2RlKVxuICAgICAgICAgICAgICAgICAgICAgIDogcmVsZWFzZVJlc291cmNlKGZsYWdzKSxcbiAgICAgICAgICAgICAgICAgICAgbnVsbCA9PT0gcm9vdFxuICAgICAgICAgICAgICAgICAgICAgID8gbW91bnRIb2lzdGFibGUoXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGhvaXN0YWJsZVJvb3QsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGZpbmlzaGVkV29yay50eXBlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBmaW5pc2hlZFdvcmsuc3RhdGVOb2RlXG4gICAgICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICAgICAgOiBhY3F1aXJlUmVzb3VyY2UoXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGhvaXN0YWJsZVJvb3QsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHJvb3QsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGZpbmlzaGVkV29yay5tZW1vaXplZFByb3BzXG4gICAgICAgICAgICAgICAgICAgICAgICApKVxuICAgICAgICAgICAgICAgICAgOiBudWxsID09PSByb290ICYmXG4gICAgICAgICAgICAgICAgICAgIG51bGwgIT09IGZpbmlzaGVkV29yay5zdGF0ZU5vZGUgJiZcbiAgICAgICAgICAgICAgICAgICAgY29tbWl0SG9zdFVwZGF0ZShcbiAgICAgICAgICAgICAgICAgICAgICBmaW5pc2hlZFdvcmssXG4gICAgICAgICAgICAgICAgICAgICAgZmluaXNoZWRXb3JrLm1lbW9pemVkUHJvcHMsXG4gICAgICAgICAgICAgICAgICAgICAgY3VycmVudC5tZW1vaXplZFByb3BzXG4gICAgICAgICAgICAgICAgICAgICkpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICBjYXNlIDI3OlxuICAgICAgICAgIGlmIChcbiAgICAgICAgICAgIHN1cHBvcnRzU2luZ2xldG9ucyAmJlxuICAgICAgICAgICAgZmxhZ3MgJiA0ICYmXG4gICAgICAgICAgICBudWxsID09PSBmaW5pc2hlZFdvcmsuYWx0ZXJuYXRlXG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICBob2lzdGFibGVSb290ID0gZmluaXNoZWRXb3JrLnN0YXRlTm9kZTtcbiAgICAgICAgICAgIHZhciBwcm9wcyA9IGZpbmlzaGVkV29yay5tZW1vaXplZFByb3BzO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgY2xlYXJTaW5nbGV0b24oaG9pc3RhYmxlUm9vdCksXG4gICAgICAgICAgICAgICAgcnVuV2l0aEZpYmVySW5ERVYoXG4gICAgICAgICAgICAgICAgICBmaW5pc2hlZFdvcmssXG4gICAgICAgICAgICAgICAgICBhY3F1aXJlU2luZ2xldG9uSW5zdGFuY2UsXG4gICAgICAgICAgICAgICAgICBmaW5pc2hlZFdvcmsudHlwZSxcbiAgICAgICAgICAgICAgICAgIHByb3BzLFxuICAgICAgICAgICAgICAgICAgaG9pc3RhYmxlUm9vdCxcbiAgICAgICAgICAgICAgICAgIGZpbmlzaGVkV29ya1xuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICBjYXB0dXJlQ29tbWl0UGhhc2VFcnJvcihmaW5pc2hlZFdvcmssIGZpbmlzaGVkV29yay5yZXR1cm4sIGVycm9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIGNhc2UgNTpcbiAgICAgICAgICByZWN1cnNpdmVseVRyYXZlcnNlTXV0YXRpb25FZmZlY3RzKHJvb3QsIGZpbmlzaGVkV29yayk7XG4gICAgICAgICAgY29tbWl0UmVjb25jaWxpYXRpb25FZmZlY3RzKGZpbmlzaGVkV29yayk7XG4gICAgICAgICAgZmxhZ3MgJiA1MTIgJiZcbiAgICAgICAgICAgIChvZmZzY3JlZW5TdWJ0cmVlV2FzSGlkZGVuIHx8XG4gICAgICAgICAgICAgIG51bGwgPT09IGN1cnJlbnQgfHxcbiAgICAgICAgICAgICAgc2FmZWx5RGV0YWNoUmVmKGN1cnJlbnQsIGN1cnJlbnQucmV0dXJuKSk7XG4gICAgICAgICAgaWYgKHN1cHBvcnRzTXV0YXRpb24pIHtcbiAgICAgICAgICAgIGlmIChmaW5pc2hlZFdvcmsuZmxhZ3MgJiAzMikge1xuICAgICAgICAgICAgICByb290ID0gZmluaXNoZWRXb3JrLnN0YXRlTm9kZTtcbiAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBydW5XaXRoRmliZXJJbkRFVihmaW5pc2hlZFdvcmssIHJlc2V0VGV4dENvbnRlbnQsIHJvb3QpO1xuICAgICAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIGNhcHR1cmVDb21taXRQaGFzZUVycm9yKFxuICAgICAgICAgICAgICAgICAgZmluaXNoZWRXb3JrLFxuICAgICAgICAgICAgICAgICAgZmluaXNoZWRXb3JrLnJldHVybixcbiAgICAgICAgICAgICAgICAgIGVycm9yXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZmxhZ3MgJiA0ICYmXG4gICAgICAgICAgICAgIG51bGwgIT0gZmluaXNoZWRXb3JrLnN0YXRlTm9kZSAmJlxuICAgICAgICAgICAgICAoKHJvb3QgPSBmaW5pc2hlZFdvcmsubWVtb2l6ZWRQcm9wcyksXG4gICAgICAgICAgICAgIGNvbW1pdEhvc3RVcGRhdGUoXG4gICAgICAgICAgICAgICAgZmluaXNoZWRXb3JrLFxuICAgICAgICAgICAgICAgIHJvb3QsXG4gICAgICAgICAgICAgICAgbnVsbCAhPT0gY3VycmVudCA/IGN1cnJlbnQubWVtb2l6ZWRQcm9wcyA6IHJvb3RcbiAgICAgICAgICAgICAgKSk7XG4gICAgICAgICAgICBmbGFncyAmIDEwMjQgJiZcbiAgICAgICAgICAgICAgKChuZWVkc0Zvcm1SZXNldCA9ICEwKSxcbiAgICAgICAgICAgICAgXCJmb3JtXCIgIT09IGZpbmlzaGVkV29yay50eXBlICYmXG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgICAgIFwiVW5leHBlY3RlZCBob3N0IGNvbXBvbmVudCB0eXBlLiBFeHBlY3RlZCBhIGZvcm0uIFRoaXMgaXMgYSBidWcgaW4gUmVhY3QuXCJcbiAgICAgICAgICAgICAgICApKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgNjpcbiAgICAgICAgICByZWN1cnNpdmVseVRyYXZlcnNlTXV0YXRpb25FZmZlY3RzKHJvb3QsIGZpbmlzaGVkV29yayk7XG4gICAgICAgICAgY29tbWl0UmVjb25jaWxpYXRpb25FZmZlY3RzKGZpbmlzaGVkV29yayk7XG4gICAgICAgICAgaWYgKGZsYWdzICYgNCAmJiBzdXBwb3J0c011dGF0aW9uKSB7XG4gICAgICAgICAgICBpZiAobnVsbCA9PT0gZmluaXNoZWRXb3JrLnN0YXRlTm9kZSlcbiAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXG4gICAgICAgICAgICAgICAgXCJUaGlzIHNob3VsZCBoYXZlIGEgdGV4dCBub2RlIGluaXRpYWxpemVkLiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLlwiXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICBmbGFncyA9IGZpbmlzaGVkV29yay5tZW1vaXplZFByb3BzO1xuICAgICAgICAgICAgY3VycmVudCA9IG51bGwgIT09IGN1cnJlbnQgPyBjdXJyZW50Lm1lbW9pemVkUHJvcHMgOiBmbGFncztcbiAgICAgICAgICAgIHJvb3QgPSBmaW5pc2hlZFdvcmsuc3RhdGVOb2RlO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgcnVuV2l0aEZpYmVySW5ERVYoXG4gICAgICAgICAgICAgICAgZmluaXNoZWRXb3JrLFxuICAgICAgICAgICAgICAgIGNvbW1pdFRleHRVcGRhdGUsXG4gICAgICAgICAgICAgICAgcm9vdCxcbiAgICAgICAgICAgICAgICBjdXJyZW50LFxuICAgICAgICAgICAgICAgIGZsYWdzXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICBjYXB0dXJlQ29tbWl0UGhhc2VFcnJvcihmaW5pc2hlZFdvcmssIGZpbmlzaGVkV29yay5yZXR1cm4sIGVycm9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMzpcbiAgICAgICAgICBob2lzdGFibGVSb290ID0gcHVzaE5lc3RlZEVmZmVjdER1cmF0aW9ucygpO1xuICAgICAgICAgIHN1cHBvcnRzUmVzb3VyY2VzXG4gICAgICAgICAgICA/IChwcmVwYXJlVG9Db21taXRIb2lzdGFibGVzKCksXG4gICAgICAgICAgICAgIChwcm9wcyA9IGN1cnJlbnRIb2lzdGFibGVSb290KSxcbiAgICAgICAgICAgICAgKGN1cnJlbnRIb2lzdGFibGVSb290ID0gZ2V0SG9pc3RhYmxlUm9vdChyb290LmNvbnRhaW5lckluZm8pKSxcbiAgICAgICAgICAgICAgcmVjdXJzaXZlbHlUcmF2ZXJzZU11dGF0aW9uRWZmZWN0cyhyb290LCBmaW5pc2hlZFdvcmspLFxuICAgICAgICAgICAgICAoY3VycmVudEhvaXN0YWJsZVJvb3QgPSBwcm9wcykpXG4gICAgICAgICAgICA6IHJlY3Vyc2l2ZWx5VHJhdmVyc2VNdXRhdGlvbkVmZmVjdHMocm9vdCwgZmluaXNoZWRXb3JrKTtcbiAgICAgICAgICBjb21taXRSZWNvbmNpbGlhdGlvbkVmZmVjdHMoZmluaXNoZWRXb3JrKTtcbiAgICAgICAgICBpZiAoZmxhZ3MgJiA0KSB7XG4gICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgIHN1cHBvcnRzTXV0YXRpb24gJiZcbiAgICAgICAgICAgICAgc3VwcG9ydHNIeWRyYXRpb24gJiZcbiAgICAgICAgICAgICAgbnVsbCAhPT0gY3VycmVudCAmJlxuICAgICAgICAgICAgICBjdXJyZW50Lm1lbW9pemVkU3RhdGUuaXNEZWh5ZHJhdGVkXG4gICAgICAgICAgICApXG4gICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcnVuV2l0aEZpYmVySW5ERVYoXG4gICAgICAgICAgICAgICAgICBmaW5pc2hlZFdvcmssXG4gICAgICAgICAgICAgICAgICBjb21taXRIeWRyYXRlZENvbnRhaW5lcixcbiAgICAgICAgICAgICAgICAgIHJvb3QuY29udGFpbmVySW5mb1xuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgY2FwdHVyZUNvbW1pdFBoYXNlRXJyb3IoXG4gICAgICAgICAgICAgICAgICBmaW5pc2hlZFdvcmssXG4gICAgICAgICAgICAgICAgICBmaW5pc2hlZFdvcmsucmV0dXJuLFxuICAgICAgICAgICAgICAgICAgZXJyb3JcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc3VwcG9ydHNQZXJzaXN0ZW5jZSkge1xuICAgICAgICAgICAgICBmbGFncyA9IHJvb3QuY29udGFpbmVySW5mbztcbiAgICAgICAgICAgICAgY3VycmVudCA9IHJvb3QucGVuZGluZ0NoaWxkcmVuO1xuICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHJ1bldpdGhGaWJlckluREVWKFxuICAgICAgICAgICAgICAgICAgZmluaXNoZWRXb3JrLFxuICAgICAgICAgICAgICAgICAgcmVwbGFjZUNvbnRhaW5lckNoaWxkcmVuLFxuICAgICAgICAgICAgICAgICAgZmxhZ3MsXG4gICAgICAgICAgICAgICAgICBjdXJyZW50XG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBjYXB0dXJlQ29tbWl0UGhhc2VFcnJvcihcbiAgICAgICAgICAgICAgICAgIGZpbmlzaGVkV29yayxcbiAgICAgICAgICAgICAgICAgIGZpbmlzaGVkV29yay5yZXR1cm4sXG4gICAgICAgICAgICAgICAgICBlcnJvclxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgbmVlZHNGb3JtUmVzZXQgJiZcbiAgICAgICAgICAgICgobmVlZHNGb3JtUmVzZXQgPSAhMSksIHJlY3Vyc2l2ZWx5UmVzZXRGb3JtcyhmaW5pc2hlZFdvcmspKTtcbiAgICAgICAgICByb290LmVmZmVjdER1cmF0aW9uICs9IHBvcE5lc3RlZEVmZmVjdER1cmF0aW9ucyhob2lzdGFibGVSb290KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSA0OlxuICAgICAgICAgIHN1cHBvcnRzUmVzb3VyY2VzXG4gICAgICAgICAgICA/ICgoY3VycmVudCA9IGN1cnJlbnRIb2lzdGFibGVSb290KSxcbiAgICAgICAgICAgICAgKGN1cnJlbnRIb2lzdGFibGVSb290ID0gZ2V0SG9pc3RhYmxlUm9vdChcbiAgICAgICAgICAgICAgICBmaW5pc2hlZFdvcmsuc3RhdGVOb2RlLmNvbnRhaW5lckluZm9cbiAgICAgICAgICAgICAgKSksXG4gICAgICAgICAgICAgIHJlY3Vyc2l2ZWx5VHJhdmVyc2VNdXRhdGlvbkVmZmVjdHMocm9vdCwgZmluaXNoZWRXb3JrKSxcbiAgICAgICAgICAgICAgY29tbWl0UmVjb25jaWxpYXRpb25FZmZlY3RzKGZpbmlzaGVkV29yayksXG4gICAgICAgICAgICAgIChjdXJyZW50SG9pc3RhYmxlUm9vdCA9IGN1cnJlbnQpKVxuICAgICAgICAgICAgOiAocmVjdXJzaXZlbHlUcmF2ZXJzZU11dGF0aW9uRWZmZWN0cyhyb290LCBmaW5pc2hlZFdvcmspLFxuICAgICAgICAgICAgICBjb21taXRSZWNvbmNpbGlhdGlvbkVmZmVjdHMoZmluaXNoZWRXb3JrKSk7XG4gICAgICAgICAgZmxhZ3MgJiA0ICYmXG4gICAgICAgICAgICBzdXBwb3J0c1BlcnNpc3RlbmNlICYmXG4gICAgICAgICAgICBjb21taXRIb3N0UG9ydGFsQ29udGFpbmVyQ2hpbGRyZW4oXG4gICAgICAgICAgICAgIGZpbmlzaGVkV29yay5zdGF0ZU5vZGUsXG4gICAgICAgICAgICAgIGZpbmlzaGVkV29yayxcbiAgICAgICAgICAgICAgZmluaXNoZWRXb3JrLnN0YXRlTm9kZS5wZW5kaW5nQ2hpbGRyZW5cbiAgICAgICAgICAgICk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMTI6XG4gICAgICAgICAgZmxhZ3MgPSBwdXNoTmVzdGVkRWZmZWN0RHVyYXRpb25zKCk7XG4gICAgICAgICAgcmVjdXJzaXZlbHlUcmF2ZXJzZU11dGF0aW9uRWZmZWN0cyhyb290LCBmaW5pc2hlZFdvcmspO1xuICAgICAgICAgIGNvbW1pdFJlY29uY2lsaWF0aW9uRWZmZWN0cyhmaW5pc2hlZFdvcmspO1xuICAgICAgICAgIGZpbmlzaGVkV29yay5zdGF0ZU5vZGUuZWZmZWN0RHVyYXRpb24gKz1cbiAgICAgICAgICAgIGJ1YmJsZU5lc3RlZEVmZmVjdER1cmF0aW9ucyhmbGFncyk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMTM6XG4gICAgICAgICAgcmVjdXJzaXZlbHlUcmF2ZXJzZU11dGF0aW9uRWZmZWN0cyhyb290LCBmaW5pc2hlZFdvcmspO1xuICAgICAgICAgIGNvbW1pdFJlY29uY2lsaWF0aW9uRWZmZWN0cyhmaW5pc2hlZFdvcmspO1xuICAgICAgICAgIGZpbmlzaGVkV29yay5jaGlsZC5mbGFncyAmIDgxOTIgJiZcbiAgICAgICAgICAgIChudWxsICE9PSBmaW5pc2hlZFdvcmsubWVtb2l6ZWRTdGF0ZSkgIT09XG4gICAgICAgICAgICAgIChudWxsICE9PSBjdXJyZW50ICYmIG51bGwgIT09IGN1cnJlbnQubWVtb2l6ZWRTdGF0ZSkgJiZcbiAgICAgICAgICAgIChnbG9iYWxNb3N0UmVjZW50RmFsbGJhY2tUaW1lID0gbm93JDEoKSk7XG4gICAgICAgICAgZmxhZ3MgJiA0ICYmXG4gICAgICAgICAgICAoKGZsYWdzID0gZmluaXNoZWRXb3JrLnVwZGF0ZVF1ZXVlKSxcbiAgICAgICAgICAgIG51bGwgIT09IGZsYWdzICYmXG4gICAgICAgICAgICAgICgoZmluaXNoZWRXb3JrLnVwZGF0ZVF1ZXVlID0gbnVsbCksXG4gICAgICAgICAgICAgIGF0dGFjaFN1c3BlbnNlUmV0cnlMaXN0ZW5lcnMoZmluaXNoZWRXb3JrLCBmbGFncykpKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAyMjpcbiAgICAgICAgICBmbGFncyAmIDUxMiAmJlxuICAgICAgICAgICAgKG9mZnNjcmVlblN1YnRyZWVXYXNIaWRkZW4gfHxcbiAgICAgICAgICAgICAgbnVsbCA9PT0gY3VycmVudCB8fFxuICAgICAgICAgICAgICBzYWZlbHlEZXRhY2hSZWYoY3VycmVudCwgY3VycmVudC5yZXR1cm4pKTtcbiAgICAgICAgICBob2lzdGFibGVSb290ID0gbnVsbCAhPT0gZmluaXNoZWRXb3JrLm1lbW9pemVkU3RhdGU7XG4gICAgICAgICAgdmFyIHdhc0hpZGRlbiA9IG51bGwgIT09IGN1cnJlbnQgJiYgbnVsbCAhPT0gY3VycmVudC5tZW1vaXplZFN0YXRlLFxuICAgICAgICAgICAgcHJldk9mZnNjcmVlblN1YnRyZWVJc0hpZGRlbiA9IG9mZnNjcmVlblN1YnRyZWVJc0hpZGRlbixcbiAgICAgICAgICAgIHByZXZPZmZzY3JlZW5TdWJ0cmVlV2FzSGlkZGVuID0gb2Zmc2NyZWVuU3VidHJlZVdhc0hpZGRlbjtcbiAgICAgICAgICBvZmZzY3JlZW5TdWJ0cmVlSXNIaWRkZW4gPVxuICAgICAgICAgICAgcHJldk9mZnNjcmVlblN1YnRyZWVJc0hpZGRlbiB8fCBob2lzdGFibGVSb290O1xuICAgICAgICAgIG9mZnNjcmVlblN1YnRyZWVXYXNIaWRkZW4gPVxuICAgICAgICAgICAgcHJldk9mZnNjcmVlblN1YnRyZWVXYXNIaWRkZW4gfHwgd2FzSGlkZGVuO1xuICAgICAgICAgIHJlY3Vyc2l2ZWx5VHJhdmVyc2VNdXRhdGlvbkVmZmVjdHMocm9vdCwgZmluaXNoZWRXb3JrKTtcbiAgICAgICAgICBvZmZzY3JlZW5TdWJ0cmVlV2FzSGlkZGVuID0gcHJldk9mZnNjcmVlblN1YnRyZWVXYXNIaWRkZW47XG4gICAgICAgICAgb2Zmc2NyZWVuU3VidHJlZUlzSGlkZGVuID0gcHJldk9mZnNjcmVlblN1YnRyZWVJc0hpZGRlbjtcbiAgICAgICAgICBjb21taXRSZWNvbmNpbGlhdGlvbkVmZmVjdHMoZmluaXNoZWRXb3JrKTtcbiAgICAgICAgICByb290ID0gZmluaXNoZWRXb3JrLnN0YXRlTm9kZTtcbiAgICAgICAgICByb290Ll9jdXJyZW50ID0gZmluaXNoZWRXb3JrO1xuICAgICAgICAgIHJvb3QuX3Zpc2liaWxpdHkgJj0gLTM7XG4gICAgICAgICAgcm9vdC5fdmlzaWJpbGl0eSB8PSByb290Ll9wZW5kaW5nVmlzaWJpbGl0eSAmIDI7XG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgZmxhZ3MgJiA4MTkyICYmXG4gICAgICAgICAgICAoKHJvb3QuX3Zpc2liaWxpdHkgPSBob2lzdGFibGVSb290XG4gICAgICAgICAgICAgID8gcm9vdC5fdmlzaWJpbGl0eSAmIC0yXG4gICAgICAgICAgICAgIDogcm9vdC5fdmlzaWJpbGl0eSB8IDEpLFxuICAgICAgICAgICAgaG9pc3RhYmxlUm9vdCAmJlxuICAgICAgICAgICAgICAoKHJvb3QgPSBvZmZzY3JlZW5TdWJ0cmVlSXNIaWRkZW4gfHwgb2Zmc2NyZWVuU3VidHJlZVdhc0hpZGRlbiksXG4gICAgICAgICAgICAgIG51bGwgPT09IGN1cnJlbnQgfHxcbiAgICAgICAgICAgICAgICB3YXNIaWRkZW4gfHxcbiAgICAgICAgICAgICAgICByb290IHx8XG4gICAgICAgICAgICAgICAgcmVjdXJzaXZlbHlUcmF2ZXJzZURpc2FwcGVhckxheW91dEVmZmVjdHMoZmluaXNoZWRXb3JrKSksXG4gICAgICAgICAgICBzdXBwb3J0c011dGF0aW9uICYmXG4gICAgICAgICAgICAgIChudWxsID09PSBmaW5pc2hlZFdvcmsubWVtb2l6ZWRQcm9wcyB8fFxuICAgICAgICAgICAgICAgIFwibWFudWFsXCIgIT09IGZpbmlzaGVkV29yay5tZW1vaXplZFByb3BzLm1vZGUpKVxuICAgICAgICAgIClcbiAgICAgICAgICAgIGE6IGlmICgoKGN1cnJlbnQgPSBudWxsKSwgc3VwcG9ydHNNdXRhdGlvbikpXG4gICAgICAgICAgICAgIGZvciAocm9vdCA9IGZpbmlzaGVkV29yazsgOyApIHtcbiAgICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgICA1ID09PSByb290LnRhZyB8fFxuICAgICAgICAgICAgICAgICAgKHN1cHBvcnRzUmVzb3VyY2VzICYmIDI2ID09PSByb290LnRhZykgfHxcbiAgICAgICAgICAgICAgICAgIChzdXBwb3J0c1NpbmdsZXRvbnMgJiYgMjcgPT09IHJvb3QudGFnKVxuICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgaWYgKG51bGwgPT09IGN1cnJlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgd2FzSGlkZGVuID0gY3VycmVudCA9IHJvb3Q7XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgKHByb3BzID0gd2FzSGlkZGVuLnN0YXRlTm9kZSksXG4gICAgICAgICAgICAgICAgICAgICAgICBob2lzdGFibGVSb290XG4gICAgICAgICAgICAgICAgICAgICAgICAgID8gcnVuV2l0aEZpYmVySW5ERVYod2FzSGlkZGVuLCBoaWRlSW5zdGFuY2UsIHByb3BzKVxuICAgICAgICAgICAgICAgICAgICAgICAgICA6IHJ1bldpdGhGaWJlckluREVWKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2FzSGlkZGVuLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdW5oaWRlSW5zdGFuY2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3YXNIaWRkZW4uc3RhdGVOb2RlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2FzSGlkZGVuLm1lbW9pemVkUHJvcHNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgIGNhcHR1cmVDb21taXRQaGFzZUVycm9yKFxuICAgICAgICAgICAgICAgICAgICAgICAgd2FzSGlkZGVuLFxuICAgICAgICAgICAgICAgICAgICAgICAgd2FzSGlkZGVuLnJldHVybixcbiAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yXG4gICAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoNiA9PT0gcm9vdC50YWcpIHtcbiAgICAgICAgICAgICAgICAgIGlmIChudWxsID09PSBjdXJyZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIHdhc0hpZGRlbiA9IHJvb3Q7XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgdmFyIGluc3RhbmNlID0gd2FzSGlkZGVuLnN0YXRlTm9kZTtcbiAgICAgICAgICAgICAgICAgICAgICBob2lzdGFibGVSb290XG4gICAgICAgICAgICAgICAgICAgICAgICA/IHJ1bldpdGhGaWJlckluREVWKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdhc0hpZGRlbixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBoaWRlVGV4dEluc3RhbmNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluc3RhbmNlXG4gICAgICAgICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgICAgICAgIDogcnVuV2l0aEZpYmVySW5ERVYoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd2FzSGlkZGVuLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVuaGlkZVRleHRJbnN0YW5jZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnN0YW5jZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3YXNIaWRkZW4ubWVtb2l6ZWRQcm9wc1xuICAgICAgICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgIGNhcHR1cmVDb21taXRQaGFzZUVycm9yKFxuICAgICAgICAgICAgICAgICAgICAgICAgd2FzSGlkZGVuLFxuICAgICAgICAgICAgICAgICAgICAgICAgd2FzSGlkZGVuLnJldHVybixcbiAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yXG4gICAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoXG4gICAgICAgICAgICAgICAgICAoKDIyICE9PSByb290LnRhZyAmJiAyMyAhPT0gcm9vdC50YWcpIHx8XG4gICAgICAgICAgICAgICAgICAgIG51bGwgPT09IHJvb3QubWVtb2l6ZWRTdGF0ZSB8fFxuICAgICAgICAgICAgICAgICAgICByb290ID09PSBmaW5pc2hlZFdvcmspICYmXG4gICAgICAgICAgICAgICAgICBudWxsICE9PSByb290LmNoaWxkXG4gICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICByb290LmNoaWxkLnJldHVybiA9IHJvb3Q7XG4gICAgICAgICAgICAgICAgICByb290ID0gcm9vdC5jaGlsZDtcbiAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAocm9vdCA9PT0gZmluaXNoZWRXb3JrKSBicmVhayBhO1xuICAgICAgICAgICAgICAgIGZvciAoOyBudWxsID09PSByb290LnNpYmxpbmc7ICkge1xuICAgICAgICAgICAgICAgICAgaWYgKG51bGwgPT09IHJvb3QucmV0dXJuIHx8IHJvb3QucmV0dXJuID09PSBmaW5pc2hlZFdvcmspXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrIGE7XG4gICAgICAgICAgICAgICAgICBjdXJyZW50ID09PSByb290ICYmIChjdXJyZW50ID0gbnVsbCk7XG4gICAgICAgICAgICAgICAgICByb290ID0gcm9vdC5yZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGN1cnJlbnQgPT09IHJvb3QgJiYgKGN1cnJlbnQgPSBudWxsKTtcbiAgICAgICAgICAgICAgICByb290LnNpYmxpbmcucmV0dXJuID0gcm9vdC5yZXR1cm47XG4gICAgICAgICAgICAgICAgcm9vdCA9IHJvb3Quc2libGluZztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgIGZsYWdzICYgNCAmJlxuICAgICAgICAgICAgKChmbGFncyA9IGZpbmlzaGVkV29yay51cGRhdGVRdWV1ZSksXG4gICAgICAgICAgICBudWxsICE9PSBmbGFncyAmJlxuICAgICAgICAgICAgICAoKGN1cnJlbnQgPSBmbGFncy5yZXRyeVF1ZXVlKSxcbiAgICAgICAgICAgICAgbnVsbCAhPT0gY3VycmVudCAmJlxuICAgICAgICAgICAgICAgICgoZmxhZ3MucmV0cnlRdWV1ZSA9IG51bGwpLFxuICAgICAgICAgICAgICAgIGF0dGFjaFN1c3BlbnNlUmV0cnlMaXN0ZW5lcnMoZmluaXNoZWRXb3JrLCBjdXJyZW50KSkpKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAxOTpcbiAgICAgICAgICByZWN1cnNpdmVseVRyYXZlcnNlTXV0YXRpb25FZmZlY3RzKHJvb3QsIGZpbmlzaGVkV29yayk7XG4gICAgICAgICAgY29tbWl0UmVjb25jaWxpYXRpb25FZmZlY3RzKGZpbmlzaGVkV29yayk7XG4gICAgICAgICAgZmxhZ3MgJiA0ICYmXG4gICAgICAgICAgICAoKGZsYWdzID0gZmluaXNoZWRXb3JrLnVwZGF0ZVF1ZXVlKSxcbiAgICAgICAgICAgIG51bGwgIT09IGZsYWdzICYmXG4gICAgICAgICAgICAgICgoZmluaXNoZWRXb3JrLnVwZGF0ZVF1ZXVlID0gbnVsbCksXG4gICAgICAgICAgICAgIGF0dGFjaFN1c3BlbnNlUmV0cnlMaXN0ZW5lcnMoZmluaXNoZWRXb3JrLCBmbGFncykpKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAyMTpcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICByZWN1cnNpdmVseVRyYXZlcnNlTXV0YXRpb25FZmZlY3RzKHJvb3QsIGZpbmlzaGVkV29yayksXG4gICAgICAgICAgICBjb21taXRSZWNvbmNpbGlhdGlvbkVmZmVjdHMoZmluaXNoZWRXb3JrKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gY29tbWl0UmVjb25jaWxpYXRpb25FZmZlY3RzKGZpbmlzaGVkV29yaykge1xuICAgICAgdmFyIGZsYWdzID0gZmluaXNoZWRXb3JrLmZsYWdzO1xuICAgICAgaWYgKGZsYWdzICYgMikge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHJ1bldpdGhGaWJlckluREVWKGZpbmlzaGVkV29yaywgY29tbWl0UGxhY2VtZW50LCBmaW5pc2hlZFdvcmspO1xuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgIGNhcHR1cmVDb21taXRQaGFzZUVycm9yKGZpbmlzaGVkV29yaywgZmluaXNoZWRXb3JrLnJldHVybiwgZXJyb3IpO1xuICAgICAgICB9XG4gICAgICAgIGZpbmlzaGVkV29yay5mbGFncyAmPSAtMztcbiAgICAgIH1cbiAgICAgIGZsYWdzICYgNDA5NiAmJiAoZmluaXNoZWRXb3JrLmZsYWdzICY9IC00MDk3KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcmVjdXJzaXZlbHlSZXNldEZvcm1zKHBhcmVudEZpYmVyKSB7XG4gICAgICBpZiAocGFyZW50RmliZXIuc3VidHJlZUZsYWdzICYgMTAyNClcbiAgICAgICAgZm9yIChwYXJlbnRGaWJlciA9IHBhcmVudEZpYmVyLmNoaWxkOyBudWxsICE9PSBwYXJlbnRGaWJlcjsgKSB7XG4gICAgICAgICAgdmFyIGZpYmVyID0gcGFyZW50RmliZXI7XG4gICAgICAgICAgcmVjdXJzaXZlbHlSZXNldEZvcm1zKGZpYmVyKTtcbiAgICAgICAgICA1ID09PSBmaWJlci50YWcgJiZcbiAgICAgICAgICAgIGZpYmVyLmZsYWdzICYgMTAyNCAmJlxuICAgICAgICAgICAgcmVzZXRGb3JtSW5zdGFuY2UoZmliZXIuc3RhdGVOb2RlKTtcbiAgICAgICAgICBwYXJlbnRGaWJlciA9IHBhcmVudEZpYmVyLnNpYmxpbmc7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gY29tbWl0TGF5b3V0RWZmZWN0cyhmaW5pc2hlZFdvcmssIHJvb3QsIGNvbW1pdHRlZExhbmVzKSB7XG4gICAgICBpblByb2dyZXNzTGFuZXMgPSBjb21taXR0ZWRMYW5lcztcbiAgICAgIGluUHJvZ3Jlc3NSb290ID0gcm9vdDtcbiAgICAgIGNvbW1pdExheW91dEVmZmVjdE9uRmliZXIocm9vdCwgZmluaXNoZWRXb3JrLmFsdGVybmF0ZSwgZmluaXNoZWRXb3JrKTtcbiAgICAgIGluUHJvZ3Jlc3NSb290ID0gaW5Qcm9ncmVzc0xhbmVzID0gbnVsbDtcbiAgICB9XG4gICAgZnVuY3Rpb24gcmVjdXJzaXZlbHlUcmF2ZXJzZUxheW91dEVmZmVjdHMocm9vdCwgcGFyZW50RmliZXIpIHtcbiAgICAgIGlmIChwYXJlbnRGaWJlci5zdWJ0cmVlRmxhZ3MgJiA4NzcyKVxuICAgICAgICBmb3IgKHBhcmVudEZpYmVyID0gcGFyZW50RmliZXIuY2hpbGQ7IG51bGwgIT09IHBhcmVudEZpYmVyOyApXG4gICAgICAgICAgY29tbWl0TGF5b3V0RWZmZWN0T25GaWJlcihyb290LCBwYXJlbnRGaWJlci5hbHRlcm5hdGUsIHBhcmVudEZpYmVyKSxcbiAgICAgICAgICAgIChwYXJlbnRGaWJlciA9IHBhcmVudEZpYmVyLnNpYmxpbmcpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBkaXNhcHBlYXJMYXlvdXRFZmZlY3RzKGZpbmlzaGVkV29yaykge1xuICAgICAgc3dpdGNoIChmaW5pc2hlZFdvcmsudGFnKSB7XG4gICAgICAgIGNhc2UgMDpcbiAgICAgICAgY2FzZSAxMTpcbiAgICAgICAgY2FzZSAxNDpcbiAgICAgICAgY2FzZSAxNTpcbiAgICAgICAgICBjb21taXRIb29rTGF5b3V0VW5tb3VudEVmZmVjdHMoXG4gICAgICAgICAgICBmaW5pc2hlZFdvcmssXG4gICAgICAgICAgICBmaW5pc2hlZFdvcmsucmV0dXJuLFxuICAgICAgICAgICAgTGF5b3V0XG4gICAgICAgICAgKTtcbiAgICAgICAgICByZWN1cnNpdmVseVRyYXZlcnNlRGlzYXBwZWFyTGF5b3V0RWZmZWN0cyhmaW5pc2hlZFdvcmspO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgc2FmZWx5RGV0YWNoUmVmKGZpbmlzaGVkV29yaywgZmluaXNoZWRXb3JrLnJldHVybik7XG4gICAgICAgICAgdmFyIGluc3RhbmNlID0gZmluaXNoZWRXb3JrLnN0YXRlTm9kZTtcbiAgICAgICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBpbnN0YW5jZS5jb21wb25lbnRXaWxsVW5tb3VudCAmJlxuICAgICAgICAgICAgc2FmZWx5Q2FsbENvbXBvbmVudFdpbGxVbm1vdW50KFxuICAgICAgICAgICAgICBmaW5pc2hlZFdvcmssXG4gICAgICAgICAgICAgIGZpbmlzaGVkV29yay5yZXR1cm4sXG4gICAgICAgICAgICAgIGluc3RhbmNlXG4gICAgICAgICAgICApO1xuICAgICAgICAgIHJlY3Vyc2l2ZWx5VHJhdmVyc2VEaXNhcHBlYXJMYXlvdXRFZmZlY3RzKGZpbmlzaGVkV29yayk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMjY6XG4gICAgICAgIGNhc2UgMjc6XG4gICAgICAgIGNhc2UgNTpcbiAgICAgICAgICBzYWZlbHlEZXRhY2hSZWYoZmluaXNoZWRXb3JrLCBmaW5pc2hlZFdvcmsucmV0dXJuKTtcbiAgICAgICAgICByZWN1cnNpdmVseVRyYXZlcnNlRGlzYXBwZWFyTGF5b3V0RWZmZWN0cyhmaW5pc2hlZFdvcmspO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDIyOlxuICAgICAgICAgIHNhZmVseURldGFjaFJlZihmaW5pc2hlZFdvcmssIGZpbmlzaGVkV29yay5yZXR1cm4pO1xuICAgICAgICAgIG51bGwgPT09IGZpbmlzaGVkV29yay5tZW1vaXplZFN0YXRlICYmXG4gICAgICAgICAgICByZWN1cnNpdmVseVRyYXZlcnNlRGlzYXBwZWFyTGF5b3V0RWZmZWN0cyhmaW5pc2hlZFdvcmspO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHJlY3Vyc2l2ZWx5VHJhdmVyc2VEaXNhcHBlYXJMYXlvdXRFZmZlY3RzKGZpbmlzaGVkV29yayk7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlY3Vyc2l2ZWx5VHJhdmVyc2VEaXNhcHBlYXJMYXlvdXRFZmZlY3RzKHBhcmVudEZpYmVyKSB7XG4gICAgICBmb3IgKHBhcmVudEZpYmVyID0gcGFyZW50RmliZXIuY2hpbGQ7IG51bGwgIT09IHBhcmVudEZpYmVyOyApXG4gICAgICAgIGRpc2FwcGVhckxheW91dEVmZmVjdHMocGFyZW50RmliZXIpLFxuICAgICAgICAgIChwYXJlbnRGaWJlciA9IHBhcmVudEZpYmVyLnNpYmxpbmcpO1xuICAgIH1cbiAgICBmdW5jdGlvbiByZWFwcGVhckxheW91dEVmZmVjdHMoXG4gICAgICBmaW5pc2hlZFJvb3QsXG4gICAgICBjdXJyZW50LFxuICAgICAgZmluaXNoZWRXb3JrLFxuICAgICAgaW5jbHVkZVdvcmtJblByb2dyZXNzRWZmZWN0c1xuICAgICkge1xuICAgICAgdmFyIGZsYWdzID0gZmluaXNoZWRXb3JrLmZsYWdzO1xuICAgICAgc3dpdGNoIChmaW5pc2hlZFdvcmsudGFnKSB7XG4gICAgICAgIGNhc2UgMDpcbiAgICAgICAgY2FzZSAxMTpcbiAgICAgICAgY2FzZSAxNTpcbiAgICAgICAgICByZWN1cnNpdmVseVRyYXZlcnNlUmVhcHBlYXJMYXlvdXRFZmZlY3RzKFxuICAgICAgICAgICAgZmluaXNoZWRSb290LFxuICAgICAgICAgICAgZmluaXNoZWRXb3JrLFxuICAgICAgICAgICAgaW5jbHVkZVdvcmtJblByb2dyZXNzRWZmZWN0c1xuICAgICAgICAgICk7XG4gICAgICAgICAgY29tbWl0SG9va0xheW91dEVmZmVjdHMoZmluaXNoZWRXb3JrLCBMYXlvdXQpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgcmVjdXJzaXZlbHlUcmF2ZXJzZVJlYXBwZWFyTGF5b3V0RWZmZWN0cyhcbiAgICAgICAgICAgIGZpbmlzaGVkUm9vdCxcbiAgICAgICAgICAgIGZpbmlzaGVkV29yayxcbiAgICAgICAgICAgIGluY2x1ZGVXb3JrSW5Qcm9ncmVzc0VmZmVjdHNcbiAgICAgICAgICApO1xuICAgICAgICAgIGN1cnJlbnQgPSBmaW5pc2hlZFdvcmsuc3RhdGVOb2RlO1xuICAgICAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIGN1cnJlbnQuY29tcG9uZW50RGlkTW91bnQgJiZcbiAgICAgICAgICAgIHJ1bldpdGhGaWJlckluREVWKFxuICAgICAgICAgICAgICBmaW5pc2hlZFdvcmssXG4gICAgICAgICAgICAgIGNhbGxDb21wb25lbnREaWRNb3VudEluREVWLFxuICAgICAgICAgICAgICBmaW5pc2hlZFdvcmssXG4gICAgICAgICAgICAgIGN1cnJlbnRcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgY3VycmVudCA9IGZpbmlzaGVkV29yay51cGRhdGVRdWV1ZTtcbiAgICAgICAgICBpZiAobnVsbCAhPT0gY3VycmVudCkge1xuICAgICAgICAgICAgZmluaXNoZWRSb290ID0gZmluaXNoZWRXb3JrLnN0YXRlTm9kZTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIHJ1bldpdGhGaWJlckluREVWKFxuICAgICAgICAgICAgICAgIGZpbmlzaGVkV29yayxcbiAgICAgICAgICAgICAgICBjb21taXRIaWRkZW5DYWxsYmFja3MsXG4gICAgICAgICAgICAgICAgY3VycmVudCxcbiAgICAgICAgICAgICAgICBmaW5pc2hlZFJvb3RcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgIGNhcHR1cmVDb21taXRQaGFzZUVycm9yKGZpbmlzaGVkV29yaywgZmluaXNoZWRXb3JrLnJldHVybiwgZXJyb3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpbmNsdWRlV29ya0luUHJvZ3Jlc3NFZmZlY3RzICYmXG4gICAgICAgICAgICBmbGFncyAmIDY0ICYmXG4gICAgICAgICAgICBjb21taXRDbGFzc0NhbGxiYWNrcyhmaW5pc2hlZFdvcmspO1xuICAgICAgICAgIHNhZmVseUF0dGFjaFJlZihmaW5pc2hlZFdvcmssIGZpbmlzaGVkV29yay5yZXR1cm4pO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDI2OlxuICAgICAgICBjYXNlIDI3OlxuICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgcmVjdXJzaXZlbHlUcmF2ZXJzZVJlYXBwZWFyTGF5b3V0RWZmZWN0cyhcbiAgICAgICAgICAgIGZpbmlzaGVkUm9vdCxcbiAgICAgICAgICAgIGZpbmlzaGVkV29yayxcbiAgICAgICAgICAgIGluY2x1ZGVXb3JrSW5Qcm9ncmVzc0VmZmVjdHNcbiAgICAgICAgICApO1xuICAgICAgICAgIGluY2x1ZGVXb3JrSW5Qcm9ncmVzc0VmZmVjdHMgJiZcbiAgICAgICAgICAgIG51bGwgPT09IGN1cnJlbnQgJiZcbiAgICAgICAgICAgIGZsYWdzICYgNCAmJlxuICAgICAgICAgICAgY29tbWl0SG9zdE1vdW50KGZpbmlzaGVkV29yayk7XG4gICAgICAgICAgc2FmZWx5QXR0YWNoUmVmKGZpbmlzaGVkV29yaywgZmluaXNoZWRXb3JrLnJldHVybik7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMTI6XG4gICAgICAgICAgaWYgKGluY2x1ZGVXb3JrSW5Qcm9ncmVzc0VmZmVjdHMgJiYgZmxhZ3MgJiA0KSB7XG4gICAgICAgICAgICBmbGFncyA9IHB1c2hOZXN0ZWRFZmZlY3REdXJhdGlvbnMoKTtcbiAgICAgICAgICAgIHJlY3Vyc2l2ZWx5VHJhdmVyc2VSZWFwcGVhckxheW91dEVmZmVjdHMoXG4gICAgICAgICAgICAgIGZpbmlzaGVkUm9vdCxcbiAgICAgICAgICAgICAgZmluaXNoZWRXb3JrLFxuICAgICAgICAgICAgICBpbmNsdWRlV29ya0luUHJvZ3Jlc3NFZmZlY3RzXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgaW5jbHVkZVdvcmtJblByb2dyZXNzRWZmZWN0cyA9IGZpbmlzaGVkV29yay5zdGF0ZU5vZGU7XG4gICAgICAgICAgICBpbmNsdWRlV29ya0luUHJvZ3Jlc3NFZmZlY3RzLmVmZmVjdER1cmF0aW9uICs9XG4gICAgICAgICAgICAgIGJ1YmJsZU5lc3RlZEVmZmVjdER1cmF0aW9ucyhmbGFncyk7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBydW5XaXRoRmliZXJJbkRFVihcbiAgICAgICAgICAgICAgICBmaW5pc2hlZFdvcmssXG4gICAgICAgICAgICAgICAgY29tbWl0UHJvZmlsZXIsXG4gICAgICAgICAgICAgICAgZmluaXNoZWRXb3JrLFxuICAgICAgICAgICAgICAgIGN1cnJlbnQsXG4gICAgICAgICAgICAgICAgY29tbWl0U3RhcnRUaW1lLFxuICAgICAgICAgICAgICAgIGluY2x1ZGVXb3JrSW5Qcm9ncmVzc0VmZmVjdHMuZWZmZWN0RHVyYXRpb25cbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgIGNhcHR1cmVDb21taXRQaGFzZUVycm9yKGZpbmlzaGVkV29yaywgZmluaXNoZWRXb3JrLnJldHVybiwgZXJyb3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZVxuICAgICAgICAgICAgcmVjdXJzaXZlbHlUcmF2ZXJzZVJlYXBwZWFyTGF5b3V0RWZmZWN0cyhcbiAgICAgICAgICAgICAgZmluaXNoZWRSb290LFxuICAgICAgICAgICAgICBmaW5pc2hlZFdvcmssXG4gICAgICAgICAgICAgIGluY2x1ZGVXb3JrSW5Qcm9ncmVzc0VmZmVjdHNcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMTM6XG4gICAgICAgICAgcmVjdXJzaXZlbHlUcmF2ZXJzZVJlYXBwZWFyTGF5b3V0RWZmZWN0cyhcbiAgICAgICAgICAgIGZpbmlzaGVkUm9vdCxcbiAgICAgICAgICAgIGZpbmlzaGVkV29yayxcbiAgICAgICAgICAgIGluY2x1ZGVXb3JrSW5Qcm9ncmVzc0VmZmVjdHNcbiAgICAgICAgICApO1xuICAgICAgICAgIGluY2x1ZGVXb3JrSW5Qcm9ncmVzc0VmZmVjdHMgJiZcbiAgICAgICAgICAgIGZsYWdzICYgNCAmJlxuICAgICAgICAgICAgY29tbWl0U3VzcGVuc2VIeWRyYXRpb25DYWxsYmFja3MoZmluaXNoZWRSb290LCBmaW5pc2hlZFdvcmspO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDIyOlxuICAgICAgICAgIG51bGwgPT09IGZpbmlzaGVkV29yay5tZW1vaXplZFN0YXRlICYmXG4gICAgICAgICAgICByZWN1cnNpdmVseVRyYXZlcnNlUmVhcHBlYXJMYXlvdXRFZmZlY3RzKFxuICAgICAgICAgICAgICBmaW5pc2hlZFJvb3QsXG4gICAgICAgICAgICAgIGZpbmlzaGVkV29yayxcbiAgICAgICAgICAgICAgaW5jbHVkZVdvcmtJblByb2dyZXNzRWZmZWN0c1xuICAgICAgICAgICAgKTtcbiAgICAgICAgICBzYWZlbHlBdHRhY2hSZWYoZmluaXNoZWRXb3JrLCBmaW5pc2hlZFdvcmsucmV0dXJuKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICByZWN1cnNpdmVseVRyYXZlcnNlUmVhcHBlYXJMYXlvdXRFZmZlY3RzKFxuICAgICAgICAgICAgZmluaXNoZWRSb290LFxuICAgICAgICAgICAgZmluaXNoZWRXb3JrLFxuICAgICAgICAgICAgaW5jbHVkZVdvcmtJblByb2dyZXNzRWZmZWN0c1xuICAgICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlY3Vyc2l2ZWx5VHJhdmVyc2VSZWFwcGVhckxheW91dEVmZmVjdHMoXG4gICAgICBmaW5pc2hlZFJvb3QsXG4gICAgICBwYXJlbnRGaWJlcixcbiAgICAgIGluY2x1ZGVXb3JrSW5Qcm9ncmVzc0VmZmVjdHNcbiAgICApIHtcbiAgICAgIGluY2x1ZGVXb3JrSW5Qcm9ncmVzc0VmZmVjdHMgPVxuICAgICAgICBpbmNsdWRlV29ya0luUHJvZ3Jlc3NFZmZlY3RzICYmIDAgIT09IChwYXJlbnRGaWJlci5zdWJ0cmVlRmxhZ3MgJiA4NzcyKTtcbiAgICAgIGZvciAocGFyZW50RmliZXIgPSBwYXJlbnRGaWJlci5jaGlsZDsgbnVsbCAhPT0gcGFyZW50RmliZXI7IClcbiAgICAgICAgcmVhcHBlYXJMYXlvdXRFZmZlY3RzKFxuICAgICAgICAgIGZpbmlzaGVkUm9vdCxcbiAgICAgICAgICBwYXJlbnRGaWJlci5hbHRlcm5hdGUsXG4gICAgICAgICAgcGFyZW50RmliZXIsXG4gICAgICAgICAgaW5jbHVkZVdvcmtJblByb2dyZXNzRWZmZWN0c1xuICAgICAgICApLFxuICAgICAgICAgIChwYXJlbnRGaWJlciA9IHBhcmVudEZpYmVyLnNpYmxpbmcpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjb21taXRPZmZzY3JlZW5QYXNzaXZlTW91bnRFZmZlY3RzKGN1cnJlbnQsIGZpbmlzaGVkV29yaykge1xuICAgICAgdmFyIHByZXZpb3VzQ2FjaGUgPSBudWxsO1xuICAgICAgbnVsbCAhPT0gY3VycmVudCAmJlxuICAgICAgICBudWxsICE9PSBjdXJyZW50Lm1lbW9pemVkU3RhdGUgJiZcbiAgICAgICAgbnVsbCAhPT0gY3VycmVudC5tZW1vaXplZFN0YXRlLmNhY2hlUG9vbCAmJlxuICAgICAgICAocHJldmlvdXNDYWNoZSA9IGN1cnJlbnQubWVtb2l6ZWRTdGF0ZS5jYWNoZVBvb2wucG9vbCk7XG4gICAgICBjdXJyZW50ID0gbnVsbDtcbiAgICAgIG51bGwgIT09IGZpbmlzaGVkV29yay5tZW1vaXplZFN0YXRlICYmXG4gICAgICAgIG51bGwgIT09IGZpbmlzaGVkV29yay5tZW1vaXplZFN0YXRlLmNhY2hlUG9vbCAmJlxuICAgICAgICAoY3VycmVudCA9IGZpbmlzaGVkV29yay5tZW1vaXplZFN0YXRlLmNhY2hlUG9vbC5wb29sKTtcbiAgICAgIGN1cnJlbnQgIT09IHByZXZpb3VzQ2FjaGUgJiZcbiAgICAgICAgKG51bGwgIT0gY3VycmVudCAmJiByZXRhaW5DYWNoZShjdXJyZW50KSxcbiAgICAgICAgbnVsbCAhPSBwcmV2aW91c0NhY2hlICYmIHJlbGVhc2VDYWNoZShwcmV2aW91c0NhY2hlKSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNvbW1pdENhY2hlUGFzc2l2ZU1vdW50RWZmZWN0KGN1cnJlbnQsIGZpbmlzaGVkV29yaykge1xuICAgICAgY3VycmVudCA9IG51bGw7XG4gICAgICBudWxsICE9PSBmaW5pc2hlZFdvcmsuYWx0ZXJuYXRlICYmXG4gICAgICAgIChjdXJyZW50ID0gZmluaXNoZWRXb3JrLmFsdGVybmF0ZS5tZW1vaXplZFN0YXRlLmNhY2hlKTtcbiAgICAgIGZpbmlzaGVkV29yayA9IGZpbmlzaGVkV29yay5tZW1vaXplZFN0YXRlLmNhY2hlO1xuICAgICAgZmluaXNoZWRXb3JrICE9PSBjdXJyZW50ICYmXG4gICAgICAgIChyZXRhaW5DYWNoZShmaW5pc2hlZFdvcmspLCBudWxsICE9IGN1cnJlbnQgJiYgcmVsZWFzZUNhY2hlKGN1cnJlbnQpKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcmVjdXJzaXZlbHlUcmF2ZXJzZVBhc3NpdmVNb3VudEVmZmVjdHMoXG4gICAgICByb290LFxuICAgICAgcGFyZW50RmliZXIsXG4gICAgICBjb21taXR0ZWRMYW5lcyxcbiAgICAgIGNvbW1pdHRlZFRyYW5zaXRpb25zXG4gICAgKSB7XG4gICAgICBpZiAocGFyZW50RmliZXIuc3VidHJlZUZsYWdzICYgMTAyNTYpXG4gICAgICAgIGZvciAocGFyZW50RmliZXIgPSBwYXJlbnRGaWJlci5jaGlsZDsgbnVsbCAhPT0gcGFyZW50RmliZXI7IClcbiAgICAgICAgICBjb21taXRQYXNzaXZlTW91bnRPbkZpYmVyKFxuICAgICAgICAgICAgcm9vdCxcbiAgICAgICAgICAgIHBhcmVudEZpYmVyLFxuICAgICAgICAgICAgY29tbWl0dGVkTGFuZXMsXG4gICAgICAgICAgICBjb21taXR0ZWRUcmFuc2l0aW9uc1xuICAgICAgICAgICksXG4gICAgICAgICAgICAocGFyZW50RmliZXIgPSBwYXJlbnRGaWJlci5zaWJsaW5nKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY29tbWl0UGFzc2l2ZU1vdW50T25GaWJlcihcbiAgICAgIGZpbmlzaGVkUm9vdCxcbiAgICAgIGZpbmlzaGVkV29yayxcbiAgICAgIGNvbW1pdHRlZExhbmVzLFxuICAgICAgY29tbWl0dGVkVHJhbnNpdGlvbnNcbiAgICApIHtcbiAgICAgIHZhciBmbGFncyA9IGZpbmlzaGVkV29yay5mbGFncztcbiAgICAgIHN3aXRjaCAoZmluaXNoZWRXb3JrLnRhZykge1xuICAgICAgICBjYXNlIDA6XG4gICAgICAgIGNhc2UgMTE6XG4gICAgICAgIGNhc2UgMTU6XG4gICAgICAgICAgcmVjdXJzaXZlbHlUcmF2ZXJzZVBhc3NpdmVNb3VudEVmZmVjdHMoXG4gICAgICAgICAgICBmaW5pc2hlZFJvb3QsXG4gICAgICAgICAgICBmaW5pc2hlZFdvcmssXG4gICAgICAgICAgICBjb21taXR0ZWRMYW5lcyxcbiAgICAgICAgICAgIGNvbW1pdHRlZFRyYW5zaXRpb25zXG4gICAgICAgICAgKTtcbiAgICAgICAgICBmbGFncyAmIDIwNDggJiZcbiAgICAgICAgICAgIGNvbW1pdEhvb2tQYXNzaXZlTW91bnRFZmZlY3RzKGZpbmlzaGVkV29yaywgUGFzc2l2ZSB8IEhhc0VmZmVjdCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMzpcbiAgICAgICAgICB2YXIgcHJldkVmZmVjdER1cmF0aW9uID0gcHVzaE5lc3RlZEVmZmVjdER1cmF0aW9ucygpO1xuICAgICAgICAgIHJlY3Vyc2l2ZWx5VHJhdmVyc2VQYXNzaXZlTW91bnRFZmZlY3RzKFxuICAgICAgICAgICAgZmluaXNoZWRSb290LFxuICAgICAgICAgICAgZmluaXNoZWRXb3JrLFxuICAgICAgICAgICAgY29tbWl0dGVkTGFuZXMsXG4gICAgICAgICAgICBjb21taXR0ZWRUcmFuc2l0aW9uc1xuICAgICAgICAgICk7XG4gICAgICAgICAgZmxhZ3MgJiAyMDQ4ICYmXG4gICAgICAgICAgICAoKGNvbW1pdHRlZExhbmVzID0gbnVsbCksXG4gICAgICAgICAgICBudWxsICE9PSBmaW5pc2hlZFdvcmsuYWx0ZXJuYXRlICYmXG4gICAgICAgICAgICAgIChjb21taXR0ZWRMYW5lcyA9IGZpbmlzaGVkV29yay5hbHRlcm5hdGUubWVtb2l6ZWRTdGF0ZS5jYWNoZSksXG4gICAgICAgICAgICAoZmluaXNoZWRXb3JrID0gZmluaXNoZWRXb3JrLm1lbW9pemVkU3RhdGUuY2FjaGUpLFxuICAgICAgICAgICAgZmluaXNoZWRXb3JrICE9PSBjb21taXR0ZWRMYW5lcyAmJlxuICAgICAgICAgICAgICAocmV0YWluQ2FjaGUoZmluaXNoZWRXb3JrKSxcbiAgICAgICAgICAgICAgbnVsbCAhPSBjb21taXR0ZWRMYW5lcyAmJiByZWxlYXNlQ2FjaGUoY29tbWl0dGVkTGFuZXMpKSk7XG4gICAgICAgICAgZmluaXNoZWRSb290LnBhc3NpdmVFZmZlY3REdXJhdGlvbiArPVxuICAgICAgICAgICAgcG9wTmVzdGVkRWZmZWN0RHVyYXRpb25zKHByZXZFZmZlY3REdXJhdGlvbik7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMTI6XG4gICAgICAgICAgaWYgKGZsYWdzICYgMjA0OCkge1xuICAgICAgICAgICAgcHJldkVmZmVjdER1cmF0aW9uID0gcHVzaE5lc3RlZEVmZmVjdER1cmF0aW9ucygpO1xuICAgICAgICAgICAgcmVjdXJzaXZlbHlUcmF2ZXJzZVBhc3NpdmVNb3VudEVmZmVjdHMoXG4gICAgICAgICAgICAgIGZpbmlzaGVkUm9vdCxcbiAgICAgICAgICAgICAgZmluaXNoZWRXb3JrLFxuICAgICAgICAgICAgICBjb21taXR0ZWRMYW5lcyxcbiAgICAgICAgICAgICAgY29tbWl0dGVkVHJhbnNpdGlvbnNcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBmaW5pc2hlZFJvb3QgPSBmaW5pc2hlZFdvcmsuc3RhdGVOb2RlO1xuICAgICAgICAgICAgZmluaXNoZWRSb290LnBhc3NpdmVFZmZlY3REdXJhdGlvbiArPVxuICAgICAgICAgICAgICBidWJibGVOZXN0ZWRFZmZlY3REdXJhdGlvbnMocHJldkVmZmVjdER1cmF0aW9uKTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIHJ1bldpdGhGaWJlckluREVWKFxuICAgICAgICAgICAgICAgIGZpbmlzaGVkV29yayxcbiAgICAgICAgICAgICAgICBjb21taXRQcm9maWxlclBvc3RDb21taXRJbXBsLFxuICAgICAgICAgICAgICAgIGZpbmlzaGVkV29yayxcbiAgICAgICAgICAgICAgICBmaW5pc2hlZFdvcmsuYWx0ZXJuYXRlLFxuICAgICAgICAgICAgICAgIGNvbW1pdFN0YXJ0VGltZSxcbiAgICAgICAgICAgICAgICBmaW5pc2hlZFJvb3QucGFzc2l2ZUVmZmVjdER1cmF0aW9uXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICBjYXB0dXJlQ29tbWl0UGhhc2VFcnJvcihmaW5pc2hlZFdvcmssIGZpbmlzaGVkV29yay5yZXR1cm4sIGVycm9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2VcbiAgICAgICAgICAgIHJlY3Vyc2l2ZWx5VHJhdmVyc2VQYXNzaXZlTW91bnRFZmZlY3RzKFxuICAgICAgICAgICAgICBmaW5pc2hlZFJvb3QsXG4gICAgICAgICAgICAgIGZpbmlzaGVkV29yayxcbiAgICAgICAgICAgICAgY29tbWl0dGVkTGFuZXMsXG4gICAgICAgICAgICAgIGNvbW1pdHRlZFRyYW5zaXRpb25zXG4gICAgICAgICAgICApO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDIzOlxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDIyOlxuICAgICAgICAgIHByZXZFZmZlY3REdXJhdGlvbiA9IGZpbmlzaGVkV29yay5zdGF0ZU5vZGU7XG4gICAgICAgICAgbnVsbCAhPT0gZmluaXNoZWRXb3JrLm1lbW9pemVkU3RhdGVcbiAgICAgICAgICAgID8gcHJldkVmZmVjdER1cmF0aW9uLl92aXNpYmlsaXR5ICYgNFxuICAgICAgICAgICAgICA/IHJlY3Vyc2l2ZWx5VHJhdmVyc2VQYXNzaXZlTW91bnRFZmZlY3RzKFxuICAgICAgICAgICAgICAgICAgZmluaXNoZWRSb290LFxuICAgICAgICAgICAgICAgICAgZmluaXNoZWRXb3JrLFxuICAgICAgICAgICAgICAgICAgY29tbWl0dGVkTGFuZXMsXG4gICAgICAgICAgICAgICAgICBjb21taXR0ZWRUcmFuc2l0aW9uc1xuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgOiByZWN1cnNpdmVseVRyYXZlcnNlQXRvbWljUGFzc2l2ZUVmZmVjdHMoXG4gICAgICAgICAgICAgICAgICBmaW5pc2hlZFJvb3QsXG4gICAgICAgICAgICAgICAgICBmaW5pc2hlZFdvcmtcbiAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICA6IHByZXZFZmZlY3REdXJhdGlvbi5fdmlzaWJpbGl0eSAmIDRcbiAgICAgICAgICAgICAgPyByZWN1cnNpdmVseVRyYXZlcnNlUGFzc2l2ZU1vdW50RWZmZWN0cyhcbiAgICAgICAgICAgICAgICAgIGZpbmlzaGVkUm9vdCxcbiAgICAgICAgICAgICAgICAgIGZpbmlzaGVkV29yayxcbiAgICAgICAgICAgICAgICAgIGNvbW1pdHRlZExhbmVzLFxuICAgICAgICAgICAgICAgICAgY29tbWl0dGVkVHJhbnNpdGlvbnNcbiAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgIDogKChwcmV2RWZmZWN0RHVyYXRpb24uX3Zpc2liaWxpdHkgfD0gNCksXG4gICAgICAgICAgICAgICAgcmVjdXJzaXZlbHlUcmF2ZXJzZVJlY29ubmVjdFBhc3NpdmVFZmZlY3RzKFxuICAgICAgICAgICAgICAgICAgZmluaXNoZWRSb290LFxuICAgICAgICAgICAgICAgICAgZmluaXNoZWRXb3JrLFxuICAgICAgICAgICAgICAgICAgY29tbWl0dGVkTGFuZXMsXG4gICAgICAgICAgICAgICAgICBjb21taXR0ZWRUcmFuc2l0aW9ucyxcbiAgICAgICAgICAgICAgICAgIDAgIT09IChmaW5pc2hlZFdvcmsuc3VidHJlZUZsYWdzICYgMTAyNTYpXG4gICAgICAgICAgICAgICAgKSk7XG4gICAgICAgICAgZmxhZ3MgJiAyMDQ4ICYmXG4gICAgICAgICAgICBjb21taXRPZmZzY3JlZW5QYXNzaXZlTW91bnRFZmZlY3RzKFxuICAgICAgICAgICAgICBmaW5pc2hlZFdvcmsuYWx0ZXJuYXRlLFxuICAgICAgICAgICAgICBmaW5pc2hlZFdvcmtcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMjQ6XG4gICAgICAgICAgcmVjdXJzaXZlbHlUcmF2ZXJzZVBhc3NpdmVNb3VudEVmZmVjdHMoXG4gICAgICAgICAgICBmaW5pc2hlZFJvb3QsXG4gICAgICAgICAgICBmaW5pc2hlZFdvcmssXG4gICAgICAgICAgICBjb21taXR0ZWRMYW5lcyxcbiAgICAgICAgICAgIGNvbW1pdHRlZFRyYW5zaXRpb25zXG4gICAgICAgICAgKTtcbiAgICAgICAgICBmbGFncyAmIDIwNDggJiZcbiAgICAgICAgICAgIGNvbW1pdENhY2hlUGFzc2l2ZU1vdW50RWZmZWN0KGZpbmlzaGVkV29yay5hbHRlcm5hdGUsIGZpbmlzaGVkV29yayk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgcmVjdXJzaXZlbHlUcmF2ZXJzZVBhc3NpdmVNb3VudEVmZmVjdHMoXG4gICAgICAgICAgICBmaW5pc2hlZFJvb3QsXG4gICAgICAgICAgICBmaW5pc2hlZFdvcmssXG4gICAgICAgICAgICBjb21taXR0ZWRMYW5lcyxcbiAgICAgICAgICAgIGNvbW1pdHRlZFRyYW5zaXRpb25zXG4gICAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gcmVjdXJzaXZlbHlUcmF2ZXJzZVJlY29ubmVjdFBhc3NpdmVFZmZlY3RzKFxuICAgICAgZmluaXNoZWRSb290LFxuICAgICAgcGFyZW50RmliZXIsXG4gICAgICBjb21taXR0ZWRMYW5lcyxcbiAgICAgIGNvbW1pdHRlZFRyYW5zaXRpb25zLFxuICAgICAgaW5jbHVkZVdvcmtJblByb2dyZXNzRWZmZWN0c1xuICAgICkge1xuICAgICAgaW5jbHVkZVdvcmtJblByb2dyZXNzRWZmZWN0cyA9XG4gICAgICAgIGluY2x1ZGVXb3JrSW5Qcm9ncmVzc0VmZmVjdHMgJiZcbiAgICAgICAgMCAhPT0gKHBhcmVudEZpYmVyLnN1YnRyZWVGbGFncyAmIDEwMjU2KTtcbiAgICAgIGZvciAocGFyZW50RmliZXIgPSBwYXJlbnRGaWJlci5jaGlsZDsgbnVsbCAhPT0gcGFyZW50RmliZXI7IClcbiAgICAgICAgcmVjb25uZWN0UGFzc2l2ZUVmZmVjdHMoXG4gICAgICAgICAgZmluaXNoZWRSb290LFxuICAgICAgICAgIHBhcmVudEZpYmVyLFxuICAgICAgICAgIGNvbW1pdHRlZExhbmVzLFxuICAgICAgICAgIGNvbW1pdHRlZFRyYW5zaXRpb25zLFxuICAgICAgICAgIGluY2x1ZGVXb3JrSW5Qcm9ncmVzc0VmZmVjdHNcbiAgICAgICAgKSxcbiAgICAgICAgICAocGFyZW50RmliZXIgPSBwYXJlbnRGaWJlci5zaWJsaW5nKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcmVjb25uZWN0UGFzc2l2ZUVmZmVjdHMoXG4gICAgICBmaW5pc2hlZFJvb3QsXG4gICAgICBmaW5pc2hlZFdvcmssXG4gICAgICBjb21taXR0ZWRMYW5lcyxcbiAgICAgIGNvbW1pdHRlZFRyYW5zaXRpb25zLFxuICAgICAgaW5jbHVkZVdvcmtJblByb2dyZXNzRWZmZWN0c1xuICAgICkge1xuICAgICAgdmFyIGZsYWdzID0gZmluaXNoZWRXb3JrLmZsYWdzO1xuICAgICAgc3dpdGNoIChmaW5pc2hlZFdvcmsudGFnKSB7XG4gICAgICAgIGNhc2UgMDpcbiAgICAgICAgY2FzZSAxMTpcbiAgICAgICAgY2FzZSAxNTpcbiAgICAgICAgICByZWN1cnNpdmVseVRyYXZlcnNlUmVjb25uZWN0UGFzc2l2ZUVmZmVjdHMoXG4gICAgICAgICAgICBmaW5pc2hlZFJvb3QsXG4gICAgICAgICAgICBmaW5pc2hlZFdvcmssXG4gICAgICAgICAgICBjb21taXR0ZWRMYW5lcyxcbiAgICAgICAgICAgIGNvbW1pdHRlZFRyYW5zaXRpb25zLFxuICAgICAgICAgICAgaW5jbHVkZVdvcmtJblByb2dyZXNzRWZmZWN0c1xuICAgICAgICAgICk7XG4gICAgICAgICAgY29tbWl0SG9va1Bhc3NpdmVNb3VudEVmZmVjdHMoZmluaXNoZWRXb3JrLCBQYXNzaXZlKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAyMzpcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAyMjpcbiAgICAgICAgICB2YXIgX2luc3RhbmNlMiA9IGZpbmlzaGVkV29yay5zdGF0ZU5vZGU7XG4gICAgICAgICAgbnVsbCAhPT0gZmluaXNoZWRXb3JrLm1lbW9pemVkU3RhdGVcbiAgICAgICAgICAgID8gX2luc3RhbmNlMi5fdmlzaWJpbGl0eSAmIDRcbiAgICAgICAgICAgICAgPyByZWN1cnNpdmVseVRyYXZlcnNlUmVjb25uZWN0UGFzc2l2ZUVmZmVjdHMoXG4gICAgICAgICAgICAgICAgICBmaW5pc2hlZFJvb3QsXG4gICAgICAgICAgICAgICAgICBmaW5pc2hlZFdvcmssXG4gICAgICAgICAgICAgICAgICBjb21taXR0ZWRMYW5lcyxcbiAgICAgICAgICAgICAgICAgIGNvbW1pdHRlZFRyYW5zaXRpb25zLFxuICAgICAgICAgICAgICAgICAgaW5jbHVkZVdvcmtJblByb2dyZXNzRWZmZWN0c1xuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgOiByZWN1cnNpdmVseVRyYXZlcnNlQXRvbWljUGFzc2l2ZUVmZmVjdHMoXG4gICAgICAgICAgICAgICAgICBmaW5pc2hlZFJvb3QsXG4gICAgICAgICAgICAgICAgICBmaW5pc2hlZFdvcmtcbiAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICA6ICgoX2luc3RhbmNlMi5fdmlzaWJpbGl0eSB8PSA0KSxcbiAgICAgICAgICAgICAgcmVjdXJzaXZlbHlUcmF2ZXJzZVJlY29ubmVjdFBhc3NpdmVFZmZlY3RzKFxuICAgICAgICAgICAgICAgIGZpbmlzaGVkUm9vdCxcbiAgICAgICAgICAgICAgICBmaW5pc2hlZFdvcmssXG4gICAgICAgICAgICAgICAgY29tbWl0dGVkTGFuZXMsXG4gICAgICAgICAgICAgICAgY29tbWl0dGVkVHJhbnNpdGlvbnMsXG4gICAgICAgICAgICAgICAgaW5jbHVkZVdvcmtJblByb2dyZXNzRWZmZWN0c1xuICAgICAgICAgICAgICApKTtcbiAgICAgICAgICBpbmNsdWRlV29ya0luUHJvZ3Jlc3NFZmZlY3RzICYmXG4gICAgICAgICAgICBmbGFncyAmIDIwNDggJiZcbiAgICAgICAgICAgIGNvbW1pdE9mZnNjcmVlblBhc3NpdmVNb3VudEVmZmVjdHMoXG4gICAgICAgICAgICAgIGZpbmlzaGVkV29yay5hbHRlcm5hdGUsXG4gICAgICAgICAgICAgIGZpbmlzaGVkV29ya1xuICAgICAgICAgICAgKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAyNDpcbiAgICAgICAgICByZWN1cnNpdmVseVRyYXZlcnNlUmVjb25uZWN0UGFzc2l2ZUVmZmVjdHMoXG4gICAgICAgICAgICBmaW5pc2hlZFJvb3QsXG4gICAgICAgICAgICBmaW5pc2hlZFdvcmssXG4gICAgICAgICAgICBjb21taXR0ZWRMYW5lcyxcbiAgICAgICAgICAgIGNvbW1pdHRlZFRyYW5zaXRpb25zLFxuICAgICAgICAgICAgaW5jbHVkZVdvcmtJblByb2dyZXNzRWZmZWN0c1xuICAgICAgICAgICk7XG4gICAgICAgICAgaW5jbHVkZVdvcmtJblByb2dyZXNzRWZmZWN0cyAmJlxuICAgICAgICAgICAgZmxhZ3MgJiAyMDQ4ICYmXG4gICAgICAgICAgICBjb21taXRDYWNoZVBhc3NpdmVNb3VudEVmZmVjdChmaW5pc2hlZFdvcmsuYWx0ZXJuYXRlLCBmaW5pc2hlZFdvcmspO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHJlY3Vyc2l2ZWx5VHJhdmVyc2VSZWNvbm5lY3RQYXNzaXZlRWZmZWN0cyhcbiAgICAgICAgICAgIGZpbmlzaGVkUm9vdCxcbiAgICAgICAgICAgIGZpbmlzaGVkV29yayxcbiAgICAgICAgICAgIGNvbW1pdHRlZExhbmVzLFxuICAgICAgICAgICAgY29tbWl0dGVkVHJhbnNpdGlvbnMsXG4gICAgICAgICAgICBpbmNsdWRlV29ya0luUHJvZ3Jlc3NFZmZlY3RzXG4gICAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gcmVjdXJzaXZlbHlUcmF2ZXJzZUF0b21pY1Bhc3NpdmVFZmZlY3RzKFxuICAgICAgZmluaXNoZWRSb290JGpzY29tcCQwLFxuICAgICAgcGFyZW50RmliZXJcbiAgICApIHtcbiAgICAgIGlmIChwYXJlbnRGaWJlci5zdWJ0cmVlRmxhZ3MgJiAxMDI1NilcbiAgICAgICAgZm9yIChwYXJlbnRGaWJlciA9IHBhcmVudEZpYmVyLmNoaWxkOyBudWxsICE9PSBwYXJlbnRGaWJlcjsgKSB7XG4gICAgICAgICAgdmFyIGZpbmlzaGVkUm9vdCA9IGZpbmlzaGVkUm9vdCRqc2NvbXAkMCxcbiAgICAgICAgICAgIGZpbmlzaGVkV29yayA9IHBhcmVudEZpYmVyLFxuICAgICAgICAgICAgZmxhZ3MgPSBmaW5pc2hlZFdvcmsuZmxhZ3M7XG4gICAgICAgICAgc3dpdGNoIChmaW5pc2hlZFdvcmsudGFnKSB7XG4gICAgICAgICAgICBjYXNlIDIyOlxuICAgICAgICAgICAgICByZWN1cnNpdmVseVRyYXZlcnNlQXRvbWljUGFzc2l2ZUVmZmVjdHMoXG4gICAgICAgICAgICAgICAgZmluaXNoZWRSb290LFxuICAgICAgICAgICAgICAgIGZpbmlzaGVkV29ya1xuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICBmbGFncyAmIDIwNDggJiZcbiAgICAgICAgICAgICAgICBjb21taXRPZmZzY3JlZW5QYXNzaXZlTW91bnRFZmZlY3RzKFxuICAgICAgICAgICAgICAgICAgZmluaXNoZWRXb3JrLmFsdGVybmF0ZSxcbiAgICAgICAgICAgICAgICAgIGZpbmlzaGVkV29ya1xuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAyNDpcbiAgICAgICAgICAgICAgcmVjdXJzaXZlbHlUcmF2ZXJzZUF0b21pY1Bhc3NpdmVFZmZlY3RzKFxuICAgICAgICAgICAgICAgIGZpbmlzaGVkUm9vdCxcbiAgICAgICAgICAgICAgICBmaW5pc2hlZFdvcmtcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgZmxhZ3MgJiAyMDQ4ICYmXG4gICAgICAgICAgICAgICAgY29tbWl0Q2FjaGVQYXNzaXZlTW91bnRFZmZlY3QoXG4gICAgICAgICAgICAgICAgICBmaW5pc2hlZFdvcmsuYWx0ZXJuYXRlLFxuICAgICAgICAgICAgICAgICAgZmluaXNoZWRXb3JrXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICByZWN1cnNpdmVseVRyYXZlcnNlQXRvbWljUGFzc2l2ZUVmZmVjdHMoXG4gICAgICAgICAgICAgICAgZmluaXNoZWRSb290LFxuICAgICAgICAgICAgICAgIGZpbmlzaGVkV29ya1xuICAgICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgICBwYXJlbnRGaWJlciA9IHBhcmVudEZpYmVyLnNpYmxpbmc7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gcmVjdXJzaXZlbHlBY2N1bXVsYXRlU3VzcGVuc2V5Q29tbWl0KHBhcmVudEZpYmVyKSB7XG4gICAgICBpZiAocGFyZW50RmliZXIuc3VidHJlZUZsYWdzICYgc3VzcGVuc2V5Q29tbWl0RmxhZylcbiAgICAgICAgZm9yIChwYXJlbnRGaWJlciA9IHBhcmVudEZpYmVyLmNoaWxkOyBudWxsICE9PSBwYXJlbnRGaWJlcjsgKVxuICAgICAgICAgIGFjY3VtdWxhdGVTdXNwZW5zZXlDb21taXRPbkZpYmVyKHBhcmVudEZpYmVyKSxcbiAgICAgICAgICAgIChwYXJlbnRGaWJlciA9IHBhcmVudEZpYmVyLnNpYmxpbmcpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBhY2N1bXVsYXRlU3VzcGVuc2V5Q29tbWl0T25GaWJlcihmaWJlcikge1xuICAgICAgc3dpdGNoIChmaWJlci50YWcpIHtcbiAgICAgICAgY2FzZSAyNjpcbiAgICAgICAgICByZWN1cnNpdmVseUFjY3VtdWxhdGVTdXNwZW5zZXlDb21taXQoZmliZXIpO1xuICAgICAgICAgIGZpYmVyLmZsYWdzICYgc3VzcGVuc2V5Q29tbWl0RmxhZyAmJlxuICAgICAgICAgICAgKG51bGwgIT09IGZpYmVyLm1lbW9pemVkU3RhdGVcbiAgICAgICAgICAgICAgPyBzdXNwZW5kUmVzb3VyY2UoXG4gICAgICAgICAgICAgICAgICBjdXJyZW50SG9pc3RhYmxlUm9vdCxcbiAgICAgICAgICAgICAgICAgIGZpYmVyLm1lbW9pemVkU3RhdGUsXG4gICAgICAgICAgICAgICAgICBmaWJlci5tZW1vaXplZFByb3BzXG4gICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICA6IHN1c3BlbmRJbnN0YW5jZShmaWJlci50eXBlLCBmaWJlci5tZW1vaXplZFByb3BzKSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgNTpcbiAgICAgICAgICByZWN1cnNpdmVseUFjY3VtdWxhdGVTdXNwZW5zZXlDb21taXQoZmliZXIpO1xuICAgICAgICAgIGZpYmVyLmZsYWdzICYgc3VzcGVuc2V5Q29tbWl0RmxhZyAmJlxuICAgICAgICAgICAgc3VzcGVuZEluc3RhbmNlKGZpYmVyLnR5cGUsIGZpYmVyLm1lbW9pemVkUHJvcHMpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDM6XG4gICAgICAgIGNhc2UgNDpcbiAgICAgICAgICBpZiAoc3VwcG9ydHNSZXNvdXJjZXMpIHtcbiAgICAgICAgICAgIHZhciBwcmV2aW91c0hvaXN0YWJsZVJvb3QgPSBjdXJyZW50SG9pc3RhYmxlUm9vdDtcbiAgICAgICAgICAgIGN1cnJlbnRIb2lzdGFibGVSb290ID0gZ2V0SG9pc3RhYmxlUm9vdChcbiAgICAgICAgICAgICAgZmliZXIuc3RhdGVOb2RlLmNvbnRhaW5lckluZm9cbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICByZWN1cnNpdmVseUFjY3VtdWxhdGVTdXNwZW5zZXlDb21taXQoZmliZXIpO1xuICAgICAgICAgICAgY3VycmVudEhvaXN0YWJsZVJvb3QgPSBwcmV2aW91c0hvaXN0YWJsZVJvb3Q7XG4gICAgICAgICAgfSBlbHNlIHJlY3Vyc2l2ZWx5QWNjdW11bGF0ZVN1c3BlbnNleUNvbW1pdChmaWJlcik7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMjI6XG4gICAgICAgICAgbnVsbCA9PT0gZmliZXIubWVtb2l6ZWRTdGF0ZSAmJlxuICAgICAgICAgICAgKChwcmV2aW91c0hvaXN0YWJsZVJvb3QgPSBmaWJlci5hbHRlcm5hdGUpLFxuICAgICAgICAgICAgbnVsbCAhPT0gcHJldmlvdXNIb2lzdGFibGVSb290ICYmXG4gICAgICAgICAgICBudWxsICE9PSBwcmV2aW91c0hvaXN0YWJsZVJvb3QubWVtb2l6ZWRTdGF0ZVxuICAgICAgICAgICAgICA/ICgocHJldmlvdXNIb2lzdGFibGVSb290ID0gc3VzcGVuc2V5Q29tbWl0RmxhZyksXG4gICAgICAgICAgICAgICAgKHN1c3BlbnNleUNvbW1pdEZsYWcgPSAxNjc3NzIxNiksXG4gICAgICAgICAgICAgICAgcmVjdXJzaXZlbHlBY2N1bXVsYXRlU3VzcGVuc2V5Q29tbWl0KGZpYmVyKSxcbiAgICAgICAgICAgICAgICAoc3VzcGVuc2V5Q29tbWl0RmxhZyA9IHByZXZpb3VzSG9pc3RhYmxlUm9vdCkpXG4gICAgICAgICAgICAgIDogcmVjdXJzaXZlbHlBY2N1bXVsYXRlU3VzcGVuc2V5Q29tbWl0KGZpYmVyKSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgcmVjdXJzaXZlbHlBY2N1bXVsYXRlU3VzcGVuc2V5Q29tbWl0KGZpYmVyKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gZGV0YWNoQWx0ZXJuYXRlU2libGluZ3MocGFyZW50RmliZXIpIHtcbiAgICAgIHZhciBwcmV2aW91c0ZpYmVyID0gcGFyZW50RmliZXIuYWx0ZXJuYXRlO1xuICAgICAgaWYgKFxuICAgICAgICBudWxsICE9PSBwcmV2aW91c0ZpYmVyICYmXG4gICAgICAgICgocGFyZW50RmliZXIgPSBwcmV2aW91c0ZpYmVyLmNoaWxkKSwgbnVsbCAhPT0gcGFyZW50RmliZXIpXG4gICAgICApIHtcbiAgICAgICAgcHJldmlvdXNGaWJlci5jaGlsZCA9IG51bGw7XG4gICAgICAgIGRvXG4gICAgICAgICAgKHByZXZpb3VzRmliZXIgPSBwYXJlbnRGaWJlci5zaWJsaW5nKSxcbiAgICAgICAgICAgIChwYXJlbnRGaWJlci5zaWJsaW5nID0gbnVsbCksXG4gICAgICAgICAgICAocGFyZW50RmliZXIgPSBwcmV2aW91c0ZpYmVyKTtcbiAgICAgICAgd2hpbGUgKG51bGwgIT09IHBhcmVudEZpYmVyKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gcmVjdXJzaXZlbHlUcmF2ZXJzZVBhc3NpdmVVbm1vdW50RWZmZWN0cyhwYXJlbnRGaWJlcikge1xuICAgICAgdmFyIGRlbGV0aW9ucyA9IHBhcmVudEZpYmVyLmRlbGV0aW9ucztcbiAgICAgIGlmICgwICE9PSAocGFyZW50RmliZXIuZmxhZ3MgJiAxNikpIHtcbiAgICAgICAgaWYgKG51bGwgIT09IGRlbGV0aW9ucylcbiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRlbGV0aW9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIGNoaWxkVG9EZWxldGUgPSBkZWxldGlvbnNbaV07XG4gICAgICAgICAgICBuZXh0RWZmZWN0ID0gY2hpbGRUb0RlbGV0ZTtcbiAgICAgICAgICAgIGNvbW1pdFBhc3NpdmVVbm1vdW50RWZmZWN0c0luc2lkZU9mRGVsZXRlZFRyZWVfYmVnaW4oXG4gICAgICAgICAgICAgIGNoaWxkVG9EZWxldGUsXG4gICAgICAgICAgICAgIHBhcmVudEZpYmVyXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgZGV0YWNoQWx0ZXJuYXRlU2libGluZ3MocGFyZW50RmliZXIpO1xuICAgICAgfVxuICAgICAgaWYgKHBhcmVudEZpYmVyLnN1YnRyZWVGbGFncyAmIDEwMjU2KVxuICAgICAgICBmb3IgKHBhcmVudEZpYmVyID0gcGFyZW50RmliZXIuY2hpbGQ7IG51bGwgIT09IHBhcmVudEZpYmVyOyApXG4gICAgICAgICAgY29tbWl0UGFzc2l2ZVVubW91bnRPbkZpYmVyKHBhcmVudEZpYmVyKSxcbiAgICAgICAgICAgIChwYXJlbnRGaWJlciA9IHBhcmVudEZpYmVyLnNpYmxpbmcpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjb21taXRQYXNzaXZlVW5tb3VudE9uRmliZXIoZmluaXNoZWRXb3JrKSB7XG4gICAgICBzd2l0Y2ggKGZpbmlzaGVkV29yay50YWcpIHtcbiAgICAgICAgY2FzZSAwOlxuICAgICAgICBjYXNlIDExOlxuICAgICAgICBjYXNlIDE1OlxuICAgICAgICAgIHJlY3Vyc2l2ZWx5VHJhdmVyc2VQYXNzaXZlVW5tb3VudEVmZmVjdHMoZmluaXNoZWRXb3JrKTtcbiAgICAgICAgICBmaW5pc2hlZFdvcmsuZmxhZ3MgJiAyMDQ4ICYmXG4gICAgICAgICAgICBjb21taXRIb29rUGFzc2l2ZVVubW91bnRFZmZlY3RzKFxuICAgICAgICAgICAgICBmaW5pc2hlZFdvcmssXG4gICAgICAgICAgICAgIGZpbmlzaGVkV29yay5yZXR1cm4sXG4gICAgICAgICAgICAgIFBhc3NpdmUgfCBIYXNFZmZlY3RcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMzpcbiAgICAgICAgICB2YXIgcHJldkVmZmVjdER1cmF0aW9uID0gcHVzaE5lc3RlZEVmZmVjdER1cmF0aW9ucygpO1xuICAgICAgICAgIHJlY3Vyc2l2ZWx5VHJhdmVyc2VQYXNzaXZlVW5tb3VudEVmZmVjdHMoZmluaXNoZWRXb3JrKTtcbiAgICAgICAgICBmaW5pc2hlZFdvcmsuc3RhdGVOb2RlLnBhc3NpdmVFZmZlY3REdXJhdGlvbiArPVxuICAgICAgICAgICAgcG9wTmVzdGVkRWZmZWN0RHVyYXRpb25zKHByZXZFZmZlY3REdXJhdGlvbik7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMTI6XG4gICAgICAgICAgcHJldkVmZmVjdER1cmF0aW9uID0gcHVzaE5lc3RlZEVmZmVjdER1cmF0aW9ucygpO1xuICAgICAgICAgIHJlY3Vyc2l2ZWx5VHJhdmVyc2VQYXNzaXZlVW5tb3VudEVmZmVjdHMoZmluaXNoZWRXb3JrKTtcbiAgICAgICAgICBmaW5pc2hlZFdvcmsuc3RhdGVOb2RlLnBhc3NpdmVFZmZlY3REdXJhdGlvbiArPVxuICAgICAgICAgICAgYnViYmxlTmVzdGVkRWZmZWN0RHVyYXRpb25zKHByZXZFZmZlY3REdXJhdGlvbik7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMjI6XG4gICAgICAgICAgcHJldkVmZmVjdER1cmF0aW9uID0gZmluaXNoZWRXb3JrLnN0YXRlTm9kZTtcbiAgICAgICAgICBudWxsICE9PSBmaW5pc2hlZFdvcmsubWVtb2l6ZWRTdGF0ZSAmJlxuICAgICAgICAgIHByZXZFZmZlY3REdXJhdGlvbi5fdmlzaWJpbGl0eSAmIDQgJiZcbiAgICAgICAgICAobnVsbCA9PT0gZmluaXNoZWRXb3JrLnJldHVybiB8fCAxMyAhPT0gZmluaXNoZWRXb3JrLnJldHVybi50YWcpXG4gICAgICAgICAgICA/ICgocHJldkVmZmVjdER1cmF0aW9uLl92aXNpYmlsaXR5ICY9IC01KSxcbiAgICAgICAgICAgICAgcmVjdXJzaXZlbHlUcmF2ZXJzZURpc2Nvbm5lY3RQYXNzaXZlRWZmZWN0cyhmaW5pc2hlZFdvcmspKVxuICAgICAgICAgICAgOiByZWN1cnNpdmVseVRyYXZlcnNlUGFzc2l2ZVVubW91bnRFZmZlY3RzKGZpbmlzaGVkV29yayk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgcmVjdXJzaXZlbHlUcmF2ZXJzZVBhc3NpdmVVbm1vdW50RWZmZWN0cyhmaW5pc2hlZFdvcmspO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiByZWN1cnNpdmVseVRyYXZlcnNlRGlzY29ubmVjdFBhc3NpdmVFZmZlY3RzKHBhcmVudEZpYmVyKSB7XG4gICAgICB2YXIgZGVsZXRpb25zID0gcGFyZW50RmliZXIuZGVsZXRpb25zO1xuICAgICAgaWYgKDAgIT09IChwYXJlbnRGaWJlci5mbGFncyAmIDE2KSkge1xuICAgICAgICBpZiAobnVsbCAhPT0gZGVsZXRpb25zKVxuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGVsZXRpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgY2hpbGRUb0RlbGV0ZSA9IGRlbGV0aW9uc1tpXTtcbiAgICAgICAgICAgIG5leHRFZmZlY3QgPSBjaGlsZFRvRGVsZXRlO1xuICAgICAgICAgICAgY29tbWl0UGFzc2l2ZVVubW91bnRFZmZlY3RzSW5zaWRlT2ZEZWxldGVkVHJlZV9iZWdpbihcbiAgICAgICAgICAgICAgY2hpbGRUb0RlbGV0ZSxcbiAgICAgICAgICAgICAgcGFyZW50RmliZXJcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICBkZXRhY2hBbHRlcm5hdGVTaWJsaW5ncyhwYXJlbnRGaWJlcik7XG4gICAgICB9XG4gICAgICBmb3IgKHBhcmVudEZpYmVyID0gcGFyZW50RmliZXIuY2hpbGQ7IG51bGwgIT09IHBhcmVudEZpYmVyOyApXG4gICAgICAgIGRpc2Nvbm5lY3RQYXNzaXZlRWZmZWN0KHBhcmVudEZpYmVyKSxcbiAgICAgICAgICAocGFyZW50RmliZXIgPSBwYXJlbnRGaWJlci5zaWJsaW5nKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZGlzY29ubmVjdFBhc3NpdmVFZmZlY3QoZmluaXNoZWRXb3JrKSB7XG4gICAgICBzd2l0Y2ggKGZpbmlzaGVkV29yay50YWcpIHtcbiAgICAgICAgY2FzZSAwOlxuICAgICAgICBjYXNlIDExOlxuICAgICAgICBjYXNlIDE1OlxuICAgICAgICAgIGNvbW1pdEhvb2tQYXNzaXZlVW5tb3VudEVmZmVjdHMoXG4gICAgICAgICAgICBmaW5pc2hlZFdvcmssXG4gICAgICAgICAgICBmaW5pc2hlZFdvcmsucmV0dXJuLFxuICAgICAgICAgICAgUGFzc2l2ZVxuICAgICAgICAgICk7XG4gICAgICAgICAgcmVjdXJzaXZlbHlUcmF2ZXJzZURpc2Nvbm5lY3RQYXNzaXZlRWZmZWN0cyhmaW5pc2hlZFdvcmspO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDIyOlxuICAgICAgICAgIHZhciBpbnN0YW5jZSA9IGZpbmlzaGVkV29yay5zdGF0ZU5vZGU7XG4gICAgICAgICAgaW5zdGFuY2UuX3Zpc2liaWxpdHkgJiA0ICYmXG4gICAgICAgICAgICAoKGluc3RhbmNlLl92aXNpYmlsaXR5ICY9IC01KSxcbiAgICAgICAgICAgIHJlY3Vyc2l2ZWx5VHJhdmVyc2VEaXNjb25uZWN0UGFzc2l2ZUVmZmVjdHMoZmluaXNoZWRXb3JrKSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgcmVjdXJzaXZlbHlUcmF2ZXJzZURpc2Nvbm5lY3RQYXNzaXZlRWZmZWN0cyhmaW5pc2hlZFdvcmspO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBjb21taXRQYXNzaXZlVW5tb3VudEVmZmVjdHNJbnNpZGVPZkRlbGV0ZWRUcmVlX2JlZ2luKFxuICAgICAgZGVsZXRlZFN1YnRyZWVSb290LFxuICAgICAgbmVhcmVzdE1vdW50ZWRBbmNlc3RvclxuICAgICkge1xuICAgICAgZm9yICg7IG51bGwgIT09IG5leHRFZmZlY3Q7ICkge1xuICAgICAgICB2YXIgZmliZXIgPSBuZXh0RWZmZWN0LFxuICAgICAgICAgIGN1cnJlbnQgPSBmaWJlcjtcbiAgICAgICAgc3dpdGNoIChjdXJyZW50LnRhZykge1xuICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICBjYXNlIDExOlxuICAgICAgICAgIGNhc2UgMTU6XG4gICAgICAgICAgICBjb21taXRIb29rUGFzc2l2ZVVubW91bnRFZmZlY3RzKFxuICAgICAgICAgICAgICBjdXJyZW50LFxuICAgICAgICAgICAgICBuZWFyZXN0TW91bnRlZEFuY2VzdG9yLFxuICAgICAgICAgICAgICBQYXNzaXZlXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAyMzpcbiAgICAgICAgICBjYXNlIDIyOlxuICAgICAgICAgICAgbnVsbCAhPT0gY3VycmVudC5tZW1vaXplZFN0YXRlICYmXG4gICAgICAgICAgICAgIG51bGwgIT09IGN1cnJlbnQubWVtb2l6ZWRTdGF0ZS5jYWNoZVBvb2wgJiZcbiAgICAgICAgICAgICAgKChjdXJyZW50ID0gY3VycmVudC5tZW1vaXplZFN0YXRlLmNhY2hlUG9vbC5wb29sKSxcbiAgICAgICAgICAgICAgbnVsbCAhPSBjdXJyZW50ICYmIHJldGFpbkNhY2hlKGN1cnJlbnQpKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgMjQ6XG4gICAgICAgICAgICByZWxlYXNlQ2FjaGUoY3VycmVudC5tZW1vaXplZFN0YXRlLmNhY2hlKTtcbiAgICAgICAgfVxuICAgICAgICBjdXJyZW50ID0gZmliZXIuY2hpbGQ7XG4gICAgICAgIGlmIChudWxsICE9PSBjdXJyZW50KSAoY3VycmVudC5yZXR1cm4gPSBmaWJlciksIChuZXh0RWZmZWN0ID0gY3VycmVudCk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICBhOiBmb3IgKGZpYmVyID0gZGVsZXRlZFN1YnRyZWVSb290OyBudWxsICE9PSBuZXh0RWZmZWN0OyApIHtcbiAgICAgICAgICAgIGN1cnJlbnQgPSBuZXh0RWZmZWN0O1xuICAgICAgICAgICAgdmFyIHNpYmxpbmcgPSBjdXJyZW50LnNpYmxpbmcsXG4gICAgICAgICAgICAgIHJldHVybkZpYmVyID0gY3VycmVudC5yZXR1cm47XG4gICAgICAgICAgICBkZXRhY2hGaWJlckFmdGVyRWZmZWN0cyhjdXJyZW50KTtcbiAgICAgICAgICAgIGlmIChjdXJyZW50ID09PSBmaWJlcikge1xuICAgICAgICAgICAgICBuZXh0RWZmZWN0ID0gbnVsbDtcbiAgICAgICAgICAgICAgYnJlYWsgYTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChudWxsICE9PSBzaWJsaW5nKSB7XG4gICAgICAgICAgICAgIHNpYmxpbmcucmV0dXJuID0gcmV0dXJuRmliZXI7XG4gICAgICAgICAgICAgIG5leHRFZmZlY3QgPSBzaWJsaW5nO1xuICAgICAgICAgICAgICBicmVhayBhO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbmV4dEVmZmVjdCA9IHJldHVybkZpYmVyO1xuICAgICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gZmluZEZpYmVyUm9vdEZvckhvc3RSb290KGhvc3RSb290KSB7XG4gICAgICB2YXIgbWF5YmVGaWJlciA9IGdldEluc3RhbmNlRnJvbU5vZGUoaG9zdFJvb3QpO1xuICAgICAgaWYgKG51bGwgIT0gbWF5YmVGaWJlcikge1xuICAgICAgICBpZiAoXCJzdHJpbmdcIiAhPT0gdHlwZW9mIG1heWJlRmliZXIubWVtb2l6ZWRQcm9wc1tcImRhdGEtdGVzdG5hbWVcIl0pXG4gICAgICAgICAgdGhyb3cgRXJyb3IoXG4gICAgICAgICAgICBcIkludmFsaWQgaG9zdCByb290IHNwZWNpZmllZC4gU2hvdWxkIGJlIGVpdGhlciBhIFJlYWN0IGNvbnRhaW5lciBvciBhIG5vZGUgd2l0aCBhIHRlc3RuYW1lIGF0dHJpYnV0ZS5cIlxuICAgICAgICAgICk7XG4gICAgICAgIHJldHVybiBtYXliZUZpYmVyO1xuICAgICAgfVxuICAgICAgaG9zdFJvb3QgPSBmaW5kRmliZXJSb290KGhvc3RSb290KTtcbiAgICAgIGlmIChudWxsID09PSBob3N0Um9vdClcbiAgICAgICAgdGhyb3cgRXJyb3IoXG4gICAgICAgICAgXCJDb3VsZCBub3QgZmluZCBSZWFjdCBjb250YWluZXIgd2l0aGluIHNwZWNpZmllZCBob3N0IHN1YnRyZWUuXCJcbiAgICAgICAgKTtcbiAgICAgIHJldHVybiBob3N0Um9vdC5zdGF0ZU5vZGUuY3VycmVudDtcbiAgICB9XG4gICAgZnVuY3Rpb24gbWF0Y2hTZWxlY3RvcihmaWJlciRqc2NvbXAkMCwgc2VsZWN0b3IpIHtcbiAgICAgIHZhciB0YWcgPSBmaWJlciRqc2NvbXAkMC50YWc7XG4gICAgICBzd2l0Y2ggKHNlbGVjdG9yLiQkdHlwZW9mKSB7XG4gICAgICAgIGNhc2UgQ09NUE9ORU5UX1RZUEU6XG4gICAgICAgICAgaWYgKGZpYmVyJGpzY29tcCQwLnR5cGUgPT09IHNlbGVjdG9yLnZhbHVlKSByZXR1cm4gITA7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgSEFTX1BTRVVET19DTEFTU19UWVBFOlxuICAgICAgICAgIGE6IHtcbiAgICAgICAgICAgIHNlbGVjdG9yID0gc2VsZWN0b3IudmFsdWU7XG4gICAgICAgICAgICBmaWJlciRqc2NvbXAkMCA9IFtmaWJlciRqc2NvbXAkMCwgMF07XG4gICAgICAgICAgICBmb3IgKHRhZyA9IDA7IHRhZyA8IGZpYmVyJGpzY29tcCQwLmxlbmd0aDsgKSB7XG4gICAgICAgICAgICAgIHZhciBmaWJlciA9IGZpYmVyJGpzY29tcCQwW3RhZysrXSxcbiAgICAgICAgICAgICAgICB0YWckanNjb21wJDAgPSBmaWJlci50YWcsXG4gICAgICAgICAgICAgICAgc2VsZWN0b3JJbmRleCA9IGZpYmVyJGpzY29tcCQwW3RhZysrXSxcbiAgICAgICAgICAgICAgICBzZWxlY3RvciRqc2NvbXAkMCA9IHNlbGVjdG9yW3NlbGVjdG9ySW5kZXhdO1xuICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgKDUgIT09IHRhZyRqc2NvbXAkMCAmJlxuICAgICAgICAgICAgICAgICAgMjYgIT09IHRhZyRqc2NvbXAkMCAmJlxuICAgICAgICAgICAgICAgICAgMjcgIT09IHRhZyRqc2NvbXAkMCkgfHxcbiAgICAgICAgICAgICAgICAhaXNIaWRkZW5TdWJ0cmVlKGZpYmVyKVxuICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICBmb3IgKFxuICAgICAgICAgICAgICAgICAgO1xuICAgICAgICAgICAgICAgICAgbnVsbCAhPSBzZWxlY3RvciRqc2NvbXAkMCAmJlxuICAgICAgICAgICAgICAgICAgbWF0Y2hTZWxlY3RvcihmaWJlciwgc2VsZWN0b3IkanNjb21wJDApO1xuXG4gICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgc2VsZWN0b3JJbmRleCsrLFxuICAgICAgICAgICAgICAgICAgICAoc2VsZWN0b3IkanNjb21wJDAgPSBzZWxlY3RvcltzZWxlY3RvckluZGV4XSk7XG4gICAgICAgICAgICAgICAgaWYgKHNlbGVjdG9ySW5kZXggPT09IHNlbGVjdG9yLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgc2VsZWN0b3IgPSAhMDtcbiAgICAgICAgICAgICAgICAgIGJyZWFrIGE7XG4gICAgICAgICAgICAgICAgfSBlbHNlXG4gICAgICAgICAgICAgICAgICBmb3IgKGZpYmVyID0gZmliZXIuY2hpbGQ7IG51bGwgIT09IGZpYmVyOyApXG4gICAgICAgICAgICAgICAgICAgIGZpYmVyJGpzY29tcCQwLnB1c2goZmliZXIsIHNlbGVjdG9ySW5kZXgpLFxuICAgICAgICAgICAgICAgICAgICAgIChmaWJlciA9IGZpYmVyLnNpYmxpbmcpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzZWxlY3RvciA9ICExO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gc2VsZWN0b3I7XG4gICAgICAgIGNhc2UgUk9MRV9UWVBFOlxuICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICg1ID09PSB0YWcgfHwgMjYgPT09IHRhZyB8fCAyNyA9PT0gdGFnKSAmJlxuICAgICAgICAgICAgbWF0Y2hBY2Nlc3NpYmlsaXR5Um9sZShmaWJlciRqc2NvbXAkMC5zdGF0ZU5vZGUsIHNlbGVjdG9yLnZhbHVlKVxuICAgICAgICAgIClcbiAgICAgICAgICAgIHJldHVybiAhMDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBURVhUX1RZUEU6XG4gICAgICAgICAgaWYgKDUgPT09IHRhZyB8fCA2ID09PSB0YWcgfHwgMjYgPT09IHRhZyB8fCAyNyA9PT0gdGFnKVxuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAoKGZpYmVyJGpzY29tcCQwID0gZ2V0VGV4dENvbnRlbnQoZmliZXIkanNjb21wJDApKSxcbiAgICAgICAgICAgICAgbnVsbCAhPT0gZmliZXIkanNjb21wJDAgJiZcbiAgICAgICAgICAgICAgICAwIDw9IGZpYmVyJGpzY29tcCQwLmluZGV4T2Yoc2VsZWN0b3IudmFsdWUpKVxuICAgICAgICAgICAgKVxuICAgICAgICAgICAgICByZXR1cm4gITA7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgVEVTVF9OQU1FX1RZUEU6XG4gICAgICAgICAgaWYgKDUgPT09IHRhZyB8fCAyNiA9PT0gdGFnIHx8IDI3ID09PSB0YWcpXG4gICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICgoZmliZXIkanNjb21wJDAgPSBmaWJlciRqc2NvbXAkMC5tZW1vaXplZFByb3BzW1wiZGF0YS10ZXN0bmFtZVwiXSksXG4gICAgICAgICAgICAgIFwic3RyaW5nXCIgPT09IHR5cGVvZiBmaWJlciRqc2NvbXAkMCAmJlxuICAgICAgICAgICAgICAgIGZpYmVyJGpzY29tcCQwLnRvTG93ZXJDYXNlKCkgPT09IHNlbGVjdG9yLnZhbHVlLnRvTG93ZXJDYXNlKCkpXG4gICAgICAgICAgICApXG4gICAgICAgICAgICAgIHJldHVybiAhMDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICB0aHJvdyBFcnJvcihcIkludmFsaWQgc2VsZWN0b3IgdHlwZSBzcGVjaWZpZWQuXCIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuICExO1xuICAgIH1cbiAgICBmdW5jdGlvbiBzZWxlY3RvclRvU3RyaW5nKHNlbGVjdG9yKSB7XG4gICAgICBzd2l0Y2ggKHNlbGVjdG9yLiQkdHlwZW9mKSB7XG4gICAgICAgIGNhc2UgQ09NUE9ORU5UX1RZUEU6XG4gICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIFwiPFwiICsgKGdldENvbXBvbmVudE5hbWVGcm9tVHlwZShzZWxlY3Rvci52YWx1ZSkgfHwgXCJVbmtub3duXCIpICsgXCI+XCJcbiAgICAgICAgICApO1xuICAgICAgICBjYXNlIEhBU19QU0VVRE9fQ0xBU1NfVFlQRTpcbiAgICAgICAgICByZXR1cm4gXCI6aGFzKFwiICsgKHNlbGVjdG9yVG9TdHJpbmcoc2VsZWN0b3IpIHx8IFwiXCIpICsgXCIpXCI7XG4gICAgICAgIGNhc2UgUk9MRV9UWVBFOlxuICAgICAgICAgIHJldHVybiAnW3JvbGU9XCInICsgc2VsZWN0b3IudmFsdWUgKyAnXCJdJztcbiAgICAgICAgY2FzZSBURVhUX1RZUEU6XG4gICAgICAgICAgcmV0dXJuICdcIicgKyBzZWxlY3Rvci52YWx1ZSArICdcIic7XG4gICAgICAgIGNhc2UgVEVTVF9OQU1FX1RZUEU6XG4gICAgICAgICAgcmV0dXJuICdbZGF0YS10ZXN0bmFtZT1cIicgKyBzZWxlY3Rvci52YWx1ZSArICdcIl0nO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHRocm93IEVycm9yKFwiSW52YWxpZCBzZWxlY3RvciB0eXBlIHNwZWNpZmllZC5cIik7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGZpbmRQYXRocyhyb290LCBzZWxlY3RvcnMpIHtcbiAgICAgIHZhciBtYXRjaGluZ0ZpYmVycyA9IFtdO1xuICAgICAgcm9vdCA9IFtyb290LCAwXTtcbiAgICAgIGZvciAodmFyIGluZGV4ID0gMDsgaW5kZXggPCByb290Lmxlbmd0aDsgKSB7XG4gICAgICAgIHZhciBmaWJlciA9IHJvb3RbaW5kZXgrK10sXG4gICAgICAgICAgdGFnID0gZmliZXIudGFnLFxuICAgICAgICAgIHNlbGVjdG9ySW5kZXggPSByb290W2luZGV4KytdLFxuICAgICAgICAgIHNlbGVjdG9yID0gc2VsZWN0b3JzW3NlbGVjdG9ySW5kZXhdO1xuICAgICAgICBpZiAoXG4gICAgICAgICAgKDUgIT09IHRhZyAmJiAyNiAhPT0gdGFnICYmIDI3ICE9PSB0YWcpIHx8XG4gICAgICAgICAgIWlzSGlkZGVuU3VidHJlZShmaWJlcilcbiAgICAgICAgKSB7XG4gICAgICAgICAgZm9yICg7IG51bGwgIT0gc2VsZWN0b3IgJiYgbWF0Y2hTZWxlY3RvcihmaWJlciwgc2VsZWN0b3IpOyApXG4gICAgICAgICAgICBzZWxlY3RvckluZGV4KyssIChzZWxlY3RvciA9IHNlbGVjdG9yc1tzZWxlY3RvckluZGV4XSk7XG4gICAgICAgICAgaWYgKHNlbGVjdG9ySW5kZXggPT09IHNlbGVjdG9ycy5sZW5ndGgpIG1hdGNoaW5nRmliZXJzLnB1c2goZmliZXIpO1xuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIGZvciAoZmliZXIgPSBmaWJlci5jaGlsZDsgbnVsbCAhPT0gZmliZXI7IClcbiAgICAgICAgICAgICAgcm9vdC5wdXNoKGZpYmVyLCBzZWxlY3RvckluZGV4KSwgKGZpYmVyID0gZmliZXIuc2libGluZyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBtYXRjaGluZ0ZpYmVycztcbiAgICB9XG4gICAgZnVuY3Rpb24gZmluZEFsbE5vZGVzKGhvc3RSb290LCBzZWxlY3RvcnMpIHtcbiAgICAgIGlmICghc3VwcG9ydHNUZXN0U2VsZWN0b3JzKVxuICAgICAgICB0aHJvdyBFcnJvcihcIlRlc3Qgc2VsZWN0b3IgQVBJIGlzIG5vdCBzdXBwb3J0ZWQgYnkgdGhpcyByZW5kZXJlci5cIik7XG4gICAgICBob3N0Um9vdCA9IGZpbmRGaWJlclJvb3RGb3JIb3N0Um9vdChob3N0Um9vdCk7XG4gICAgICBob3N0Um9vdCA9IGZpbmRQYXRocyhob3N0Um9vdCwgc2VsZWN0b3JzKTtcbiAgICAgIHNlbGVjdG9ycyA9IFtdO1xuICAgICAgaG9zdFJvb3QgPSBBcnJheS5mcm9tKGhvc3RSb290KTtcbiAgICAgIGZvciAodmFyIGluZGV4ID0gMDsgaW5kZXggPCBob3N0Um9vdC5sZW5ndGg7ICkge1xuICAgICAgICB2YXIgbm9kZSA9IGhvc3RSb290W2luZGV4KytdLFxuICAgICAgICAgIHRhZyA9IG5vZGUudGFnO1xuICAgICAgICBpZiAoNSA9PT0gdGFnIHx8IDI2ID09PSB0YWcgfHwgMjcgPT09IHRhZylcbiAgICAgICAgICBpc0hpZGRlblN1YnRyZWUobm9kZSkgfHwgc2VsZWN0b3JzLnB1c2gobm9kZS5zdGF0ZU5vZGUpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgZm9yIChub2RlID0gbm9kZS5jaGlsZDsgbnVsbCAhPT0gbm9kZTsgKVxuICAgICAgICAgICAgaG9zdFJvb3QucHVzaChub2RlKSwgKG5vZGUgPSBub2RlLnNpYmxpbmcpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHNlbGVjdG9ycztcbiAgICB9XG4gICAgZnVuY3Rpb24gb25Db21taXRSb290KCkge1xuICAgICAgc3VwcG9ydHNUZXN0U2VsZWN0b3JzICYmXG4gICAgICAgIGNvbW1pdEhvb2tzLmZvckVhY2goZnVuY3Rpb24gKGNvbW1pdEhvb2spIHtcbiAgICAgICAgICByZXR1cm4gY29tbWl0SG9vaygpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gaXNDb25jdXJyZW50QWN0RW52aXJvbm1lbnQoKSB7XG4gICAgICB2YXIgaXNSZWFjdEFjdEVudmlyb25tZW50R2xvYmFsID1cbiAgICAgICAgXCJ1bmRlZmluZWRcIiAhPT0gdHlwZW9mIElTX1JFQUNUX0FDVF9FTlZJUk9OTUVOVFxuICAgICAgICAgID8gSVNfUkVBQ1RfQUNUX0VOVklST05NRU5UXG4gICAgICAgICAgOiB2b2lkIDA7XG4gICAgICBpc1JlYWN0QWN0RW52aXJvbm1lbnRHbG9iYWwgfHxcbiAgICAgICAgbnVsbCA9PT0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuYWN0UXVldWUgfHxcbiAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICBcIlRoZSBjdXJyZW50IHRlc3RpbmcgZW52aXJvbm1lbnQgaXMgbm90IGNvbmZpZ3VyZWQgdG8gc3VwcG9ydCBhY3QoLi4uKVwiXG4gICAgICAgICk7XG4gICAgICByZXR1cm4gaXNSZWFjdEFjdEVudmlyb25tZW50R2xvYmFsO1xuICAgIH1cbiAgICBmdW5jdGlvbiByZXF1ZXN0VXBkYXRlTGFuZShmaWJlcikge1xuICAgICAgaWYgKFxuICAgICAgICAoZXhlY3V0aW9uQ29udGV4dCAmIFJlbmRlckNvbnRleHQpICE9PSBOb0NvbnRleHQgJiZcbiAgICAgICAgMCAhPT0gd29ya0luUHJvZ3Jlc3NSb290UmVuZGVyTGFuZXNcbiAgICAgIClcbiAgICAgICAgcmV0dXJuIHdvcmtJblByb2dyZXNzUm9vdFJlbmRlckxhbmVzICYgLXdvcmtJblByb2dyZXNzUm9vdFJlbmRlckxhbmVzO1xuICAgICAgdmFyIHRyYW5zaXRpb24gPSBSZWFjdFNoYXJlZEludGVybmFscy5UO1xuICAgICAgcmV0dXJuIG51bGwgIT09IHRyYW5zaXRpb25cbiAgICAgICAgPyAodHJhbnNpdGlvbi5fdXBkYXRlZEZpYmVycyB8fCAodHJhbnNpdGlvbi5fdXBkYXRlZEZpYmVycyA9IG5ldyBTZXQoKSksXG4gICAgICAgICAgdHJhbnNpdGlvbi5fdXBkYXRlZEZpYmVycy5hZGQoZmliZXIpLFxuICAgICAgICAgIChmaWJlciA9IGN1cnJlbnRFbnRhbmdsZWRMYW5lKSxcbiAgICAgICAgICAwICE9PSBmaWJlciA/IGZpYmVyIDogcmVxdWVzdFRyYW5zaXRpb25MYW5lKCkpXG4gICAgICAgIDogcmVzb2x2ZVVwZGF0ZVByaW9yaXR5KCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlcXVlc3REZWZlcnJlZExhbmUoKSB7XG4gICAgICAwID09PSB3b3JrSW5Qcm9ncmVzc0RlZmVycmVkTGFuZSAmJlxuICAgICAgICAod29ya0luUHJvZ3Jlc3NEZWZlcnJlZExhbmUgPVxuICAgICAgICAgIDAgPT09ICh3b3JrSW5Qcm9ncmVzc1Jvb3RSZW5kZXJMYW5lcyAmIDUzNjg3MDkxMikgfHwgaXNIeWRyYXRpbmdcbiAgICAgICAgICAgID8gY2xhaW1OZXh0VHJhbnNpdGlvbkxhbmUoKVxuICAgICAgICAgICAgOiA1MzY4NzA5MTIpO1xuICAgICAgdmFyIHN1c3BlbnNlSGFuZGxlciA9IHN1c3BlbnNlSGFuZGxlclN0YWNrQ3Vyc29yLmN1cnJlbnQ7XG4gICAgICBudWxsICE9PSBzdXNwZW5zZUhhbmRsZXIgJiYgKHN1c3BlbnNlSGFuZGxlci5mbGFncyB8PSAzMik7XG4gICAgICByZXR1cm4gd29ya0luUHJvZ3Jlc3NEZWZlcnJlZExhbmU7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHNjaGVkdWxlVXBkYXRlT25GaWJlcihyb290LCBmaWJlciwgbGFuZSkge1xuICAgICAgaXNSdW5uaW5nSW5zZXJ0aW9uRWZmZWN0ICYmXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXCJ1c2VJbnNlcnRpb25FZmZlY3QgbXVzdCBub3Qgc2NoZWR1bGUgdXBkYXRlcy5cIik7XG4gICAgICBpc0ZsdXNoaW5nUGFzc2l2ZUVmZmVjdHMgJiYgKGRpZFNjaGVkdWxlVXBkYXRlRHVyaW5nUGFzc2l2ZUVmZmVjdHMgPSAhMCk7XG4gICAgICBpZiAoXG4gICAgICAgIChyb290ID09PSB3b3JrSW5Qcm9ncmVzc1Jvb3QgJiZcbiAgICAgICAgICB3b3JrSW5Qcm9ncmVzc1N1c3BlbmRlZFJlYXNvbiA9PT0gU3VzcGVuZGVkT25EYXRhKSB8fFxuICAgICAgICBudWxsICE9PSByb290LmNhbmNlbFBlbmRpbmdDb21taXRcbiAgICAgIClcbiAgICAgICAgcHJlcGFyZUZyZXNoU3RhY2socm9vdCwgMCksXG4gICAgICAgICAgbWFya1Jvb3RTdXNwZW5kZWQoXG4gICAgICAgICAgICByb290LFxuICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3NSb290UmVuZGVyTGFuZXMsXG4gICAgICAgICAgICB3b3JrSW5Qcm9ncmVzc0RlZmVycmVkTGFuZSxcbiAgICAgICAgICAgICExXG4gICAgICAgICAgKTtcbiAgICAgIG1hcmtSb290VXBkYXRlZCQxKHJvb3QsIGxhbmUpO1xuICAgICAgaWYgKFxuICAgICAgICAwICE9PSAoZXhlY3V0aW9uQ29udGV4dCAmIFJlbmRlckNvbnRleHQpICYmXG4gICAgICAgIHJvb3QgPT09IHdvcmtJblByb2dyZXNzUm9vdFxuICAgICAgKSB7XG4gICAgICAgIGlmIChpc1JlbmRlcmluZylcbiAgICAgICAgICBzd2l0Y2ggKGZpYmVyLnRhZykge1xuICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgY2FzZSAxMTpcbiAgICAgICAgICAgIGNhc2UgMTU6XG4gICAgICAgICAgICAgIHJvb3QgPVxuICAgICAgICAgICAgICAgICh3b3JrSW5Qcm9ncmVzcyAmJiBnZXRDb21wb25lbnROYW1lRnJvbUZpYmVyKHdvcmtJblByb2dyZXNzKSkgfHxcbiAgICAgICAgICAgICAgICBcIlVua25vd25cIjtcbiAgICAgICAgICAgICAgZGlkV2FybkFib3V0VXBkYXRlSW5SZW5kZXJGb3JBbm90aGVyQ29tcG9uZW50Lmhhcyhyb290KSB8fFxuICAgICAgICAgICAgICAgIChkaWRXYXJuQWJvdXRVcGRhdGVJblJlbmRlckZvckFub3RoZXJDb21wb25lbnQuYWRkKHJvb3QpLFxuICAgICAgICAgICAgICAgIChmaWJlciA9IGdldENvbXBvbmVudE5hbWVGcm9tRmliZXIoZmliZXIpIHx8IFwiVW5rbm93blwiKSxcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICAgICAgXCJDYW5ub3QgdXBkYXRlIGEgY29tcG9uZW50IChgJXNgKSB3aGlsZSByZW5kZXJpbmcgYSBkaWZmZXJlbnQgY29tcG9uZW50IChgJXNgKS4gVG8gbG9jYXRlIHRoZSBiYWQgc2V0U3RhdGUoKSBjYWxsIGluc2lkZSBgJXNgLCBmb2xsb3cgdGhlIHN0YWNrIHRyYWNlIGFzIGRlc2NyaWJlZCBpbiBodHRwczovL3JlYWN0LmRldi9saW5rL3NldHN0YXRlLWluLXJlbmRlclwiLFxuICAgICAgICAgICAgICAgICAgZmliZXIsXG4gICAgICAgICAgICAgICAgICByb290LFxuICAgICAgICAgICAgICAgICAgcm9vdFxuICAgICAgICAgICAgICAgICkpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgZGlkV2FybkFib3V0VXBkYXRlSW5SZW5kZXIgfHxcbiAgICAgICAgICAgICAgICAoY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgICAgIFwiQ2Fubm90IHVwZGF0ZSBkdXJpbmcgYW4gZXhpc3Rpbmcgc3RhdGUgdHJhbnNpdGlvbiAoc3VjaCBhcyB3aXRoaW4gYHJlbmRlcmApLiBSZW5kZXIgbWV0aG9kcyBzaG91bGQgYmUgYSBwdXJlIGZ1bmN0aW9uIG9mIHByb3BzIGFuZCBzdGF0ZS5cIlxuICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgKGRpZFdhcm5BYm91dFVwZGF0ZUluUmVuZGVyID0gITApKTtcbiAgICAgICAgICB9XG4gICAgICB9IGVsc2VcbiAgICAgICAgaXNEZXZUb29sc1ByZXNlbnQgJiYgYWRkRmliZXJUb0xhbmVzTWFwKHJvb3QsIGZpYmVyLCBsYW5lKSxcbiAgICAgICAgICB3YXJuSWZVcGRhdGVzTm90V3JhcHBlZFdpdGhBY3RERVYoZmliZXIpLFxuICAgICAgICAgIHJvb3QgPT09IHdvcmtJblByb2dyZXNzUm9vdCAmJlxuICAgICAgICAgICAgKChleGVjdXRpb25Db250ZXh0ICYgUmVuZGVyQ29udGV4dCkgPT09IE5vQ29udGV4dCAmJlxuICAgICAgICAgICAgICAod29ya0luUHJvZ3Jlc3NSb290SW50ZXJsZWF2ZWRVcGRhdGVkTGFuZXMgfD0gbGFuZSksXG4gICAgICAgICAgICB3b3JrSW5Qcm9ncmVzc1Jvb3RFeGl0U3RhdHVzID09PSBSb290U3VzcGVuZGVkV2l0aERlbGF5ICYmXG4gICAgICAgICAgICAgIG1hcmtSb290U3VzcGVuZGVkKFxuICAgICAgICAgICAgICAgIHJvb3QsXG4gICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3NSb290UmVuZGVyTGFuZXMsXG4gICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3NEZWZlcnJlZExhbmUsXG4gICAgICAgICAgICAgICAgITFcbiAgICAgICAgICAgICAgKSksXG4gICAgICAgICAgZW5zdXJlUm9vdElzU2NoZWR1bGVkKHJvb3QpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBwZXJmb3JtV29ya09uUm9vdChyb290LCBsYW5lcywgZm9yY2VTeW5jKSB7XG4gICAgICBpZiAoKGV4ZWN1dGlvbkNvbnRleHQgJiAoUmVuZGVyQ29udGV4dCB8IENvbW1pdENvbnRleHQpKSAhPT0gTm9Db250ZXh0KVxuICAgICAgICB0aHJvdyBFcnJvcihcIlNob3VsZCBub3QgYWxyZWFkeSBiZSB3b3JraW5nLlwiKTtcbiAgICAgIHZhciBzaG91bGRUaW1lU2xpY2UgPVxuICAgICAgICAgICghZm9yY2VTeW5jICYmXG4gICAgICAgICAgICAwID09PSAobGFuZXMgJiA2MCkgJiZcbiAgICAgICAgICAgIDAgPT09IChsYW5lcyAmIHJvb3QuZXhwaXJlZExhbmVzKSkgfHxcbiAgICAgICAgICBjaGVja0lmUm9vdElzUHJlcmVuZGVyaW5nKHJvb3QsIGxhbmVzKSxcbiAgICAgICAgZXhpdFN0YXR1cyA9IHNob3VsZFRpbWVTbGljZVxuICAgICAgICAgID8gcmVuZGVyUm9vdENvbmN1cnJlbnQocm9vdCwgbGFuZXMpXG4gICAgICAgICAgOiByZW5kZXJSb290U3luYyhyb290LCBsYW5lcywgITApLFxuICAgICAgICByZW5kZXJXYXNDb25jdXJyZW50ID0gc2hvdWxkVGltZVNsaWNlO1xuICAgICAgZG8ge1xuICAgICAgICBpZiAoZXhpdFN0YXR1cyA9PT0gUm9vdEluUHJvZ3Jlc3MpIHtcbiAgICAgICAgICB3b3JrSW5Qcm9ncmVzc1Jvb3RJc1ByZXJlbmRlcmluZyAmJlxuICAgICAgICAgICAgIXNob3VsZFRpbWVTbGljZSAmJlxuICAgICAgICAgICAgbWFya1Jvb3RTdXNwZW5kZWQocm9vdCwgbGFuZXMsIDAsICExKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfSBlbHNlIGlmIChleGl0U3RhdHVzID09PSBSb290RGlkTm90Q29tcGxldGUpXG4gICAgICAgICAgbWFya1Jvb3RTdXNwZW5kZWQoXG4gICAgICAgICAgICByb290LFxuICAgICAgICAgICAgbGFuZXMsXG4gICAgICAgICAgICAwLFxuICAgICAgICAgICAgIXdvcmtJblByb2dyZXNzUm9vdERpZFNraXBTdXNwZW5kZWRTaWJsaW5nc1xuICAgICAgICAgICk7XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIGZvcmNlU3luYyA9IHJvb3QuY3VycmVudC5hbHRlcm5hdGU7XG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgcmVuZGVyV2FzQ29uY3VycmVudCAmJlxuICAgICAgICAgICAgIWlzUmVuZGVyQ29uc2lzdGVudFdpdGhFeHRlcm5hbFN0b3Jlcyhmb3JjZVN5bmMpXG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICBleGl0U3RhdHVzID0gcmVuZGVyUm9vdFN5bmMocm9vdCwgbGFuZXMsICExKTtcbiAgICAgICAgICAgIHJlbmRlcldhc0NvbmN1cnJlbnQgPSAhMTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoZXhpdFN0YXR1cyA9PT0gUm9vdEVycm9yZWQpIHtcbiAgICAgICAgICAgIHJlbmRlcldhc0NvbmN1cnJlbnQgPSBsYW5lcztcbiAgICAgICAgICAgIGlmIChyb290LmVycm9yUmVjb3ZlcnlEaXNhYmxlZExhbmVzICYgcmVuZGVyV2FzQ29uY3VycmVudClcbiAgICAgICAgICAgICAgdmFyIGVycm9yUmV0cnlMYW5lcyA9IDA7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgIChlcnJvclJldHJ5TGFuZXMgPSByb290LnBlbmRpbmdMYW5lcyAmIC01MzY4NzA5MTMpLFxuICAgICAgICAgICAgICAgIChlcnJvclJldHJ5TGFuZXMgPVxuICAgICAgICAgICAgICAgICAgMCAhPT0gZXJyb3JSZXRyeUxhbmVzXG4gICAgICAgICAgICAgICAgICAgID8gZXJyb3JSZXRyeUxhbmVzXG4gICAgICAgICAgICAgICAgICAgIDogZXJyb3JSZXRyeUxhbmVzICYgNTM2ODcwOTEyXG4gICAgICAgICAgICAgICAgICAgICAgPyA1MzY4NzA5MTJcbiAgICAgICAgICAgICAgICAgICAgICA6IDApO1xuICAgICAgICAgICAgaWYgKDAgIT09IGVycm9yUmV0cnlMYW5lcykge1xuICAgICAgICAgICAgICBsYW5lcyA9IGVycm9yUmV0cnlMYW5lcztcbiAgICAgICAgICAgICAgYToge1xuICAgICAgICAgICAgICAgIGV4aXRTdGF0dXMgPSByb290O1xuICAgICAgICAgICAgICAgIHZhciBlcnJvclJldHJ5TGFuZXMkanNjb21wJDAgPSBlcnJvclJldHJ5TGFuZXM7XG4gICAgICAgICAgICAgICAgZXJyb3JSZXRyeUxhbmVzID0gd29ya0luUHJvZ3Jlc3NSb290Q29uY3VycmVudEVycm9ycztcbiAgICAgICAgICAgICAgICB2YXIgd2FzUm9vdERlaHlkcmF0ZWQgPVxuICAgICAgICAgICAgICAgICAgc3VwcG9ydHNIeWRyYXRpb24gJiZcbiAgICAgICAgICAgICAgICAgIGV4aXRTdGF0dXMuY3VycmVudC5tZW1vaXplZFN0YXRlLmlzRGVoeWRyYXRlZDtcbiAgICAgICAgICAgICAgICB3YXNSb290RGVoeWRyYXRlZCAmJlxuICAgICAgICAgICAgICAgICAgKHByZXBhcmVGcmVzaFN0YWNrKFxuICAgICAgICAgICAgICAgICAgICBleGl0U3RhdHVzLFxuICAgICAgICAgICAgICAgICAgICBlcnJvclJldHJ5TGFuZXMkanNjb21wJDBcbiAgICAgICAgICAgICAgICAgICkuZmxhZ3MgfD0gMjU2KTtcbiAgICAgICAgICAgICAgICBlcnJvclJldHJ5TGFuZXMkanNjb21wJDAgPSByZW5kZXJSb290U3luYyhcbiAgICAgICAgICAgICAgICAgIGV4aXRTdGF0dXMsXG4gICAgICAgICAgICAgICAgICBlcnJvclJldHJ5TGFuZXMkanNjb21wJDAsXG4gICAgICAgICAgICAgICAgICAhMVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgaWYgKGVycm9yUmV0cnlMYW5lcyRqc2NvbXAkMCAhPT0gUm9vdEVycm9yZWQpIHtcbiAgICAgICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3NSb290RGlkQXR0YWNoUGluZ0xpc3RlbmVyICYmXG4gICAgICAgICAgICAgICAgICAgICF3YXNSb290RGVoeWRyYXRlZFxuICAgICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICAgIGV4aXRTdGF0dXMuZXJyb3JSZWNvdmVyeURpc2FibGVkTGFuZXMgfD1cbiAgICAgICAgICAgICAgICAgICAgICByZW5kZXJXYXNDb25jdXJyZW50O1xuICAgICAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzc1Jvb3RJbnRlcmxlYXZlZFVwZGF0ZWRMYW5lcyB8PVxuICAgICAgICAgICAgICAgICAgICAgIHJlbmRlcldhc0NvbmN1cnJlbnQ7XG4gICAgICAgICAgICAgICAgICAgIGV4aXRTdGF0dXMgPSBSb290U3VzcGVuZGVkV2l0aERlbGF5O1xuICAgICAgICAgICAgICAgICAgICBicmVhayBhO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgZXhpdFN0YXR1cyA9IHdvcmtJblByb2dyZXNzUm9vdFJlY292ZXJhYmxlRXJyb3JzO1xuICAgICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3NSb290UmVjb3ZlcmFibGVFcnJvcnMgPSBlcnJvclJldHJ5TGFuZXM7XG4gICAgICAgICAgICAgICAgICBudWxsICE9PSBleGl0U3RhdHVzICYmIHF1ZXVlUmVjb3ZlcmFibGVFcnJvcnMoZXhpdFN0YXR1cyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGV4aXRTdGF0dXMgPSBlcnJvclJldHJ5TGFuZXMkanNjb21wJDA7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmVuZGVyV2FzQ29uY3VycmVudCA9ICExO1xuICAgICAgICAgICAgICBpZiAoZXhpdFN0YXR1cyAhPT0gUm9vdEVycm9yZWQpIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoZXhpdFN0YXR1cyA9PT0gUm9vdEZhdGFsRXJyb3JlZCkge1xuICAgICAgICAgICAgcHJlcGFyZUZyZXNoU3RhY2socm9vdCwgMCk7XG4gICAgICAgICAgICBtYXJrUm9vdFN1c3BlbmRlZChyb290LCBsYW5lcywgMCwgITApO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGE6IHtcbiAgICAgICAgICAgIHNob3VsZFRpbWVTbGljZSA9IHJvb3Q7XG4gICAgICAgICAgICBzd2l0Y2ggKGV4aXRTdGF0dXMpIHtcbiAgICAgICAgICAgICAgY2FzZSBSb290SW5Qcm9ncmVzczpcbiAgICAgICAgICAgICAgY2FzZSBSb290RmF0YWxFcnJvcmVkOlxuICAgICAgICAgICAgICAgIHRocm93IEVycm9yKFwiUm9vdCBkaWQgbm90IGNvbXBsZXRlLiBUaGlzIGlzIGEgYnVnIGluIFJlYWN0LlwiKTtcbiAgICAgICAgICAgICAgY2FzZSBSb290U3VzcGVuZGVkV2l0aERlbGF5OlxuICAgICAgICAgICAgICAgIGlmICgobGFuZXMgJiA0MTk0MTc2KSA9PT0gbGFuZXMpIHtcbiAgICAgICAgICAgICAgICAgIG1hcmtSb290U3VzcGVuZGVkKFxuICAgICAgICAgICAgICAgICAgICBzaG91bGRUaW1lU2xpY2UsXG4gICAgICAgICAgICAgICAgICAgIGxhbmVzLFxuICAgICAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzc0RlZmVycmVkTGFuZSxcbiAgICAgICAgICAgICAgICAgICAgIXdvcmtJblByb2dyZXNzUm9vdERpZFNraXBTdXNwZW5kZWRTaWJsaW5nc1xuICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgIGJyZWFrIGE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBjYXNlIFJvb3RFcnJvcmVkOlxuICAgICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzUm9vdFJlY292ZXJhYmxlRXJyb3JzID0gbnVsbDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgY2FzZSBSb290U3VzcGVuZGVkOlxuICAgICAgICAgICAgICBjYXNlIFJvb3RDb21wbGV0ZWQ6XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJVbmtub3duIHJvb3QgZXhpdCBzdGF0dXMuXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2hvdWxkVGltZVNsaWNlLmZpbmlzaGVkV29yayA9IGZvcmNlU3luYztcbiAgICAgICAgICAgIHNob3VsZFRpbWVTbGljZS5maW5pc2hlZExhbmVzID0gbGFuZXM7XG4gICAgICAgICAgICBpZiAobnVsbCAhPT0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuYWN0UXVldWUpXG4gICAgICAgICAgICAgIGNvbW1pdFJvb3QoXG4gICAgICAgICAgICAgICAgc2hvdWxkVGltZVNsaWNlLFxuICAgICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzUm9vdFJlY292ZXJhYmxlRXJyb3JzLFxuICAgICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzVHJhbnNpdGlvbnMsXG4gICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3NSb290RGlkSW5jbHVkZVJlY3Vyc2l2ZVJlbmRlclVwZGF0ZSxcbiAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzc0RlZmVycmVkTGFuZSxcbiAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzc1Jvb3RJbnRlcmxlYXZlZFVwZGF0ZWRMYW5lcyxcbiAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzc1N1c3BlbmRlZFJldHJ5TGFuZXMsXG4gICAgICAgICAgICAgICAgSU1NRURJQVRFX0NPTU1JVCxcbiAgICAgICAgICAgICAgICAtMCxcbiAgICAgICAgICAgICAgICAwXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgIChsYW5lcyAmIDYyOTE0NTYwKSA9PT0gbGFuZXMgJiZcbiAgICAgICAgICAgICAgICAoKGV4aXRTdGF0dXMgPVxuICAgICAgICAgICAgICAgICAgZ2xvYmFsTW9zdFJlY2VudEZhbGxiYWNrVGltZSArXG4gICAgICAgICAgICAgICAgICBGQUxMQkFDS19USFJPVFRMRV9NUyAtXG4gICAgICAgICAgICAgICAgICBub3ckMSgpKSxcbiAgICAgICAgICAgICAgICAxMCA8IGV4aXRTdGF0dXMpXG4gICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIG1hcmtSb290U3VzcGVuZGVkKFxuICAgICAgICAgICAgICAgICAgc2hvdWxkVGltZVNsaWNlLFxuICAgICAgICAgICAgICAgICAgbGFuZXMsXG4gICAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzc0RlZmVycmVkTGFuZSxcbiAgICAgICAgICAgICAgICAgICF3b3JrSW5Qcm9ncmVzc1Jvb3REaWRTa2lwU3VzcGVuZGVkU2libGluZ3NcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIGlmICgwICE9PSBnZXROZXh0TGFuZXMoc2hvdWxkVGltZVNsaWNlLCAwKSkgYnJlYWsgYTtcbiAgICAgICAgICAgICAgICBzaG91bGRUaW1lU2xpY2UudGltZW91dEhhbmRsZSA9IHNjaGVkdWxlVGltZW91dChcbiAgICAgICAgICAgICAgICAgIGNvbW1pdFJvb3RXaGVuUmVhZHkuYmluZChcbiAgICAgICAgICAgICAgICAgICAgbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgc2hvdWxkVGltZVNsaWNlLFxuICAgICAgICAgICAgICAgICAgICBmb3JjZVN5bmMsXG4gICAgICAgICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzUm9vdFJlY292ZXJhYmxlRXJyb3JzLFxuICAgICAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzc1RyYW5zaXRpb25zLFxuICAgICAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzc1Jvb3REaWRJbmNsdWRlUmVjdXJzaXZlUmVuZGVyVXBkYXRlLFxuICAgICAgICAgICAgICAgICAgICBsYW5lcyxcbiAgICAgICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3NEZWZlcnJlZExhbmUsXG4gICAgICAgICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzUm9vdEludGVybGVhdmVkVXBkYXRlZExhbmVzLFxuICAgICAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzc1N1c3BlbmRlZFJldHJ5TGFuZXMsXG4gICAgICAgICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzUm9vdERpZFNraXBTdXNwZW5kZWRTaWJsaW5ncyxcbiAgICAgICAgICAgICAgICAgICAgVEhST1RUTEVEX0NPTU1JVCxcbiAgICAgICAgICAgICAgICAgICAgLTAsXG4gICAgICAgICAgICAgICAgICAgIDBcbiAgICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgICBleGl0U3RhdHVzXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICBicmVhayBhO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGNvbW1pdFJvb3RXaGVuUmVhZHkoXG4gICAgICAgICAgICAgICAgc2hvdWxkVGltZVNsaWNlLFxuICAgICAgICAgICAgICAgIGZvcmNlU3luYyxcbiAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzc1Jvb3RSZWNvdmVyYWJsZUVycm9ycyxcbiAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzc1RyYW5zaXRpb25zLFxuICAgICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzUm9vdERpZEluY2x1ZGVSZWN1cnNpdmVSZW5kZXJVcGRhdGUsXG4gICAgICAgICAgICAgICAgbGFuZXMsXG4gICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3NEZWZlcnJlZExhbmUsXG4gICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3NSb290SW50ZXJsZWF2ZWRVcGRhdGVkTGFuZXMsXG4gICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3NTdXNwZW5kZWRSZXRyeUxhbmVzLFxuICAgICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzUm9vdERpZFNraXBTdXNwZW5kZWRTaWJsaW5ncyxcbiAgICAgICAgICAgICAgICBJTU1FRElBVEVfQ09NTUlULFxuICAgICAgICAgICAgICAgIC0wLFxuICAgICAgICAgICAgICAgIDBcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICB9IHdoaWxlICgxKTtcbiAgICAgIGVuc3VyZVJvb3RJc1NjaGVkdWxlZChyb290KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcXVldWVSZWNvdmVyYWJsZUVycm9ycyhlcnJvcnMpIHtcbiAgICAgIG51bGwgPT09IHdvcmtJblByb2dyZXNzUm9vdFJlY292ZXJhYmxlRXJyb3JzXG4gICAgICAgID8gKHdvcmtJblByb2dyZXNzUm9vdFJlY292ZXJhYmxlRXJyb3JzID0gZXJyb3JzKVxuICAgICAgICA6IHdvcmtJblByb2dyZXNzUm9vdFJlY292ZXJhYmxlRXJyb3JzLnB1c2guYXBwbHkoXG4gICAgICAgICAgICB3b3JrSW5Qcm9ncmVzc1Jvb3RSZWNvdmVyYWJsZUVycm9ycyxcbiAgICAgICAgICAgIGVycm9yc1xuICAgICAgICAgICk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNvbW1pdFJvb3RXaGVuUmVhZHkoXG4gICAgICByb290LFxuICAgICAgZmluaXNoZWRXb3JrLFxuICAgICAgcmVjb3ZlcmFibGVFcnJvcnMsXG4gICAgICB0cmFuc2l0aW9ucyxcbiAgICAgIGRpZEluY2x1ZGVSZW5kZXJQaGFzZVVwZGF0ZSxcbiAgICAgIGxhbmVzLFxuICAgICAgc3Bhd25lZExhbmUsXG4gICAgICB1cGRhdGVkTGFuZXMsXG4gICAgICBzdXNwZW5kZWRSZXRyeUxhbmVzLFxuICAgICAgZGlkU2tpcFN1c3BlbmRlZFNpYmxpbmdzLFxuICAgICAgc3VzcGVuZGVkQ29tbWl0UmVhc29uLFxuICAgICAgY29tcGxldGVkUmVuZGVyU3RhcnRUaW1lLFxuICAgICAgY29tcGxldGVkUmVuZGVyRW5kVGltZVxuICAgICkge1xuICAgICAgdmFyIHN1YnRyZWVGbGFncyA9IGZpbmlzaGVkV29yay5zdWJ0cmVlRmxhZ3M7XG4gICAgICBpZiAoc3VidHJlZUZsYWdzICYgODE5MiB8fCAxNjc4NTQwOCA9PT0gKHN1YnRyZWVGbGFncyAmIDE2Nzg1NDA4KSlcbiAgICAgICAgaWYgKFxuICAgICAgICAgIChzdGFydFN1c3BlbmRpbmdDb21taXQoKSxcbiAgICAgICAgICBhY2N1bXVsYXRlU3VzcGVuc2V5Q29tbWl0T25GaWJlcihmaW5pc2hlZFdvcmspLFxuICAgICAgICAgIChmaW5pc2hlZFdvcmsgPSB3YWl0Rm9yQ29tbWl0VG9CZVJlYWR5KCkpLFxuICAgICAgICAgIG51bGwgIT09IGZpbmlzaGVkV29yaylcbiAgICAgICAgKSB7XG4gICAgICAgICAgcm9vdC5jYW5jZWxQZW5kaW5nQ29tbWl0ID0gZmluaXNoZWRXb3JrKFxuICAgICAgICAgICAgY29tbWl0Um9vdC5iaW5kKFxuICAgICAgICAgICAgICBudWxsLFxuICAgICAgICAgICAgICByb290LFxuICAgICAgICAgICAgICByZWNvdmVyYWJsZUVycm9ycyxcbiAgICAgICAgICAgICAgdHJhbnNpdGlvbnMsXG4gICAgICAgICAgICAgIGRpZEluY2x1ZGVSZW5kZXJQaGFzZVVwZGF0ZSxcbiAgICAgICAgICAgICAgc3Bhd25lZExhbmUsXG4gICAgICAgICAgICAgIHVwZGF0ZWRMYW5lcyxcbiAgICAgICAgICAgICAgc3VzcGVuZGVkUmV0cnlMYW5lcyxcbiAgICAgICAgICAgICAgU1VTUEVOREVEX0NPTU1JVCxcbiAgICAgICAgICAgICAgY29tcGxldGVkUmVuZGVyU3RhcnRUaW1lLFxuICAgICAgICAgICAgICBjb21wbGV0ZWRSZW5kZXJFbmRUaW1lXG4gICAgICAgICAgICApXG4gICAgICAgICAgKTtcbiAgICAgICAgICBtYXJrUm9vdFN1c3BlbmRlZChcbiAgICAgICAgICAgIHJvb3QsXG4gICAgICAgICAgICBsYW5lcyxcbiAgICAgICAgICAgIHNwYXduZWRMYW5lLFxuICAgICAgICAgICAgIWRpZFNraXBTdXNwZW5kZWRTaWJsaW5nc1xuICAgICAgICAgICk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICBjb21taXRSb290KFxuICAgICAgICByb290LFxuICAgICAgICByZWNvdmVyYWJsZUVycm9ycyxcbiAgICAgICAgdHJhbnNpdGlvbnMsXG4gICAgICAgIGRpZEluY2x1ZGVSZW5kZXJQaGFzZVVwZGF0ZSxcbiAgICAgICAgc3Bhd25lZExhbmUsXG4gICAgICAgIHVwZGF0ZWRMYW5lcyxcbiAgICAgICAgc3VzcGVuZGVkUmV0cnlMYW5lcyxcbiAgICAgICAgc3VzcGVuZGVkQ29tbWl0UmVhc29uLFxuICAgICAgICBjb21wbGV0ZWRSZW5kZXJTdGFydFRpbWUsXG4gICAgICAgIGNvbXBsZXRlZFJlbmRlckVuZFRpbWVcbiAgICAgICk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGlzUmVuZGVyQ29uc2lzdGVudFdpdGhFeHRlcm5hbFN0b3JlcyhmaW5pc2hlZFdvcmspIHtcbiAgICAgIGZvciAodmFyIG5vZGUgPSBmaW5pc2hlZFdvcms7IDsgKSB7XG4gICAgICAgIHZhciB0YWcgPSBub2RlLnRhZztcbiAgICAgICAgaWYgKFxuICAgICAgICAgICgwID09PSB0YWcgfHwgMTEgPT09IHRhZyB8fCAxNSA9PT0gdGFnKSAmJlxuICAgICAgICAgIG5vZGUuZmxhZ3MgJiAxNjM4NCAmJlxuICAgICAgICAgICgodGFnID0gbm9kZS51cGRhdGVRdWV1ZSksXG4gICAgICAgICAgbnVsbCAhPT0gdGFnICYmICgodGFnID0gdGFnLnN0b3JlcyksIG51bGwgIT09IHRhZykpXG4gICAgICAgIClcbiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRhZy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIGNoZWNrID0gdGFnW2ldLFxuICAgICAgICAgICAgICBnZXRTbmFwc2hvdCA9IGNoZWNrLmdldFNuYXBzaG90O1xuICAgICAgICAgICAgY2hlY2sgPSBjaGVjay52YWx1ZTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIGlmICghb2JqZWN0SXMoZ2V0U25hcHNob3QoKSwgY2hlY2spKSByZXR1cm4gITE7XG4gICAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICByZXR1cm4gITE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB0YWcgPSBub2RlLmNoaWxkO1xuICAgICAgICBpZiAobm9kZS5zdWJ0cmVlRmxhZ3MgJiAxNjM4NCAmJiBudWxsICE9PSB0YWcpXG4gICAgICAgICAgKHRhZy5yZXR1cm4gPSBub2RlKSwgKG5vZGUgPSB0YWcpO1xuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBpZiAobm9kZSA9PT0gZmluaXNoZWRXb3JrKSBicmVhaztcbiAgICAgICAgICBmb3IgKDsgbnVsbCA9PT0gbm9kZS5zaWJsaW5nOyApIHtcbiAgICAgICAgICAgIGlmIChudWxsID09PSBub2RlLnJldHVybiB8fCBub2RlLnJldHVybiA9PT0gZmluaXNoZWRXb3JrKSByZXR1cm4gITA7XG4gICAgICAgICAgICBub2RlID0gbm9kZS5yZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIG5vZGUuc2libGluZy5yZXR1cm4gPSBub2RlLnJldHVybjtcbiAgICAgICAgICBub2RlID0gbm9kZS5zaWJsaW5nO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gITA7XG4gICAgfVxuICAgIGZ1bmN0aW9uIG1hcmtSb290U3VzcGVuZGVkKFxuICAgICAgcm9vdCxcbiAgICAgIHN1c3BlbmRlZExhbmVzLFxuICAgICAgc3Bhd25lZExhbmUsXG4gICAgICBkaWRBdHRlbXB0RW50aXJlVHJlZVxuICAgICkge1xuICAgICAgc3VzcGVuZGVkTGFuZXMgJj0gfndvcmtJblByb2dyZXNzUm9vdFBpbmdlZExhbmVzO1xuICAgICAgc3VzcGVuZGVkTGFuZXMgJj0gfndvcmtJblByb2dyZXNzUm9vdEludGVybGVhdmVkVXBkYXRlZExhbmVzO1xuICAgICAgcm9vdC5zdXNwZW5kZWRMYW5lcyB8PSBzdXNwZW5kZWRMYW5lcztcbiAgICAgIHJvb3QucGluZ2VkTGFuZXMgJj0gfnN1c3BlbmRlZExhbmVzO1xuICAgICAgZGlkQXR0ZW1wdEVudGlyZVRyZWUgJiYgKHJvb3Qud2FybUxhbmVzIHw9IHN1c3BlbmRlZExhbmVzKTtcbiAgICAgIGRpZEF0dGVtcHRFbnRpcmVUcmVlID0gcm9vdC5leHBpcmF0aW9uVGltZXM7XG4gICAgICBmb3IgKHZhciBsYW5lcyA9IHN1c3BlbmRlZExhbmVzOyAwIDwgbGFuZXM7ICkge1xuICAgICAgICB2YXIgaW5kZXggPSAzMSAtIGNsejMyKGxhbmVzKSxcbiAgICAgICAgICBsYW5lID0gMSA8PCBpbmRleDtcbiAgICAgICAgZGlkQXR0ZW1wdEVudGlyZVRyZWVbaW5kZXhdID0gLTE7XG4gICAgICAgIGxhbmVzICY9IH5sYW5lO1xuICAgICAgfVxuICAgICAgMCAhPT0gc3Bhd25lZExhbmUgJiZcbiAgICAgICAgbWFya1NwYXduZWREZWZlcnJlZExhbmUocm9vdCwgc3Bhd25lZExhbmUsIHN1c3BlbmRlZExhbmVzKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZmx1c2hTeW5jV29yaygpIHtcbiAgICAgIHJldHVybiAoZXhlY3V0aW9uQ29udGV4dCAmIChSZW5kZXJDb250ZXh0IHwgQ29tbWl0Q29udGV4dCkpID09PSBOb0NvbnRleHRcbiAgICAgICAgPyAoZmx1c2hTeW5jV29ya0Fjcm9zc1Jvb3RzX2ltcGwoMCwgITEpLCAhMSlcbiAgICAgICAgOiAhMDtcbiAgICB9XG4gICAgZnVuY3Rpb24gcmVzZXRXb3JrSW5Qcm9ncmVzc1N0YWNrKCkge1xuICAgICAgaWYgKG51bGwgIT09IHdvcmtJblByb2dyZXNzKSB7XG4gICAgICAgIGlmICh3b3JrSW5Qcm9ncmVzc1N1c3BlbmRlZFJlYXNvbiA9PT0gTm90U3VzcGVuZGVkKVxuICAgICAgICAgIHZhciBpbnRlcnJ1cHRlZFdvcmsgPSB3b3JrSW5Qcm9ncmVzcy5yZXR1cm47XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAoaW50ZXJydXB0ZWRXb3JrID0gd29ya0luUHJvZ3Jlc3MpLFxuICAgICAgICAgICAgcmVzZXRDb250ZXh0RGVwZW5kZW5jaWVzKCksXG4gICAgICAgICAgICByZXNldEhvb2tzT25VbndpbmQoaW50ZXJydXB0ZWRXb3JrKSxcbiAgICAgICAgICAgICh0aGVuYWJsZVN0YXRlJDEgPSBudWxsKSxcbiAgICAgICAgICAgICh0aGVuYWJsZUluZGV4Q291bnRlciQxID0gMCksXG4gICAgICAgICAgICAoaW50ZXJydXB0ZWRXb3JrID0gd29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICBmb3IgKDsgbnVsbCAhPT0gaW50ZXJydXB0ZWRXb3JrOyApXG4gICAgICAgICAgdW53aW5kSW50ZXJydXB0ZWRXb3JrKGludGVycnVwdGVkV29yay5hbHRlcm5hdGUsIGludGVycnVwdGVkV29yayksXG4gICAgICAgICAgICAoaW50ZXJydXB0ZWRXb3JrID0gaW50ZXJydXB0ZWRXb3JrLnJldHVybik7XG4gICAgICAgIHdvcmtJblByb2dyZXNzID0gbnVsbDtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gcHJlcGFyZUZyZXNoU3RhY2socm9vdCwgbGFuZXMpIHtcbiAgICAgIHJvb3QuZmluaXNoZWRXb3JrID0gbnVsbDtcbiAgICAgIHJvb3QuZmluaXNoZWRMYW5lcyA9IDA7XG4gICAgICB2YXIgdGltZW91dEhhbmRsZSA9IHJvb3QudGltZW91dEhhbmRsZTtcbiAgICAgIHRpbWVvdXRIYW5kbGUgIT09IG5vVGltZW91dCAmJlxuICAgICAgICAoKHJvb3QudGltZW91dEhhbmRsZSA9IG5vVGltZW91dCksIGNhbmNlbFRpbWVvdXQodGltZW91dEhhbmRsZSkpO1xuICAgICAgdGltZW91dEhhbmRsZSA9IHJvb3QuY2FuY2VsUGVuZGluZ0NvbW1pdDtcbiAgICAgIG51bGwgIT09IHRpbWVvdXRIYW5kbGUgJiZcbiAgICAgICAgKChyb290LmNhbmNlbFBlbmRpbmdDb21taXQgPSBudWxsKSwgdGltZW91dEhhbmRsZSgpKTtcbiAgICAgIHJlc2V0V29ya0luUHJvZ3Jlc3NTdGFjaygpO1xuICAgICAgd29ya0luUHJvZ3Jlc3NSb290ID0gcm9vdDtcbiAgICAgIHdvcmtJblByb2dyZXNzID0gdGltZW91dEhhbmRsZSA9IGNyZWF0ZVdvcmtJblByb2dyZXNzKHJvb3QuY3VycmVudCwgbnVsbCk7XG4gICAgICB3b3JrSW5Qcm9ncmVzc1Jvb3RSZW5kZXJMYW5lcyA9IGxhbmVzO1xuICAgICAgd29ya0luUHJvZ3Jlc3NTdXNwZW5kZWRSZWFzb24gPSBOb3RTdXNwZW5kZWQ7XG4gICAgICB3b3JrSW5Qcm9ncmVzc1Rocm93blZhbHVlID0gbnVsbDtcbiAgICAgIHdvcmtJblByb2dyZXNzUm9vdERpZFNraXBTdXNwZW5kZWRTaWJsaW5ncyA9ICExO1xuICAgICAgd29ya0luUHJvZ3Jlc3NSb290SXNQcmVyZW5kZXJpbmcgPSBjaGVja0lmUm9vdElzUHJlcmVuZGVyaW5nKHJvb3QsIGxhbmVzKTtcbiAgICAgIHdvcmtJblByb2dyZXNzUm9vdERpZEF0dGFjaFBpbmdMaXN0ZW5lciA9ICExO1xuICAgICAgd29ya0luUHJvZ3Jlc3NSb290RXhpdFN0YXR1cyA9IFJvb3RJblByb2dyZXNzO1xuICAgICAgd29ya0luUHJvZ3Jlc3NTdXNwZW5kZWRSZXRyeUxhbmVzID1cbiAgICAgICAgd29ya0luUHJvZ3Jlc3NEZWZlcnJlZExhbmUgPVxuICAgICAgICB3b3JrSW5Qcm9ncmVzc1Jvb3RQaW5nZWRMYW5lcyA9XG4gICAgICAgIHdvcmtJblByb2dyZXNzUm9vdEludGVybGVhdmVkVXBkYXRlZExhbmVzID1cbiAgICAgICAgd29ya0luUHJvZ3Jlc3NSb290U2tpcHBlZExhbmVzID1cbiAgICAgICAgICAwO1xuICAgICAgd29ya0luUHJvZ3Jlc3NSb290UmVjb3ZlcmFibGVFcnJvcnMgPSB3b3JrSW5Qcm9ncmVzc1Jvb3RDb25jdXJyZW50RXJyb3JzID1cbiAgICAgICAgbnVsbDtcbiAgICAgIHdvcmtJblByb2dyZXNzUm9vdERpZEluY2x1ZGVSZWN1cnNpdmVSZW5kZXJVcGRhdGUgPSAhMTtcbiAgICAgIDAgIT09IChsYW5lcyAmIDgpICYmIChsYW5lcyB8PSBsYW5lcyAmIDMyKTtcbiAgICAgIHZhciBhbGxFbnRhbmdsZWRMYW5lcyA9IHJvb3QuZW50YW5nbGVkTGFuZXM7XG4gICAgICBpZiAoMCAhPT0gYWxsRW50YW5nbGVkTGFuZXMpXG4gICAgICAgIGZvciAoXG4gICAgICAgICAgcm9vdCA9IHJvb3QuZW50YW5nbGVtZW50cywgYWxsRW50YW5nbGVkTGFuZXMgJj0gbGFuZXM7XG4gICAgICAgICAgMCA8IGFsbEVudGFuZ2xlZExhbmVzO1xuXG4gICAgICAgICkge1xuICAgICAgICAgIHZhciBpbmRleCA9IDMxIC0gY2x6MzIoYWxsRW50YW5nbGVkTGFuZXMpLFxuICAgICAgICAgICAgbGFuZSA9IDEgPDwgaW5kZXg7XG4gICAgICAgICAgbGFuZXMgfD0gcm9vdFtpbmRleF07XG4gICAgICAgICAgYWxsRW50YW5nbGVkTGFuZXMgJj0gfmxhbmU7XG4gICAgICAgIH1cbiAgICAgIGVudGFuZ2xlZFJlbmRlckxhbmVzID0gbGFuZXM7XG4gICAgICBmaW5pc2hRdWV1ZWluZ0NvbmN1cnJlbnRVcGRhdGVzKCk7XG4gICAgICBSZWFjdFN0cmljdE1vZGVXYXJuaW5ncy5kaXNjYXJkUGVuZGluZ1dhcm5pbmdzKCk7XG4gICAgICByZXR1cm4gdGltZW91dEhhbmRsZTtcbiAgICB9XG4gICAgZnVuY3Rpb24gaGFuZGxlVGhyb3cocm9vdCwgdGhyb3duVmFsdWUpIHtcbiAgICAgIGN1cnJlbnRseVJlbmRlcmluZ0ZpYmVyJDEgPSBudWxsO1xuICAgICAgUmVhY3RTaGFyZWRJbnRlcm5hbHMuSCA9IENvbnRleHRPbmx5RGlzcGF0Y2hlcjtcbiAgICAgIFJlYWN0U2hhcmVkSW50ZXJuYWxzLmdldEN1cnJlbnRTdGFjayA9IG51bGw7XG4gICAgICBpc1JlbmRlcmluZyA9ICExO1xuICAgICAgY3VycmVudCA9IG51bGw7XG4gICAgICB0aHJvd25WYWx1ZSA9PT0gU3VzcGVuc2VFeGNlcHRpb25cbiAgICAgICAgPyAoKHRocm93blZhbHVlID0gZ2V0U3VzcGVuZGVkVGhlbmFibGUoKSksXG4gICAgICAgICAgKHdvcmtJblByb2dyZXNzU3VzcGVuZGVkUmVhc29uID0gU3VzcGVuZGVkT25JbW1lZGlhdGUpKVxuICAgICAgICA6IHRocm93blZhbHVlID09PSBTdXNwZW5zZXlDb21taXRFeGNlcHRpb25cbiAgICAgICAgICA/ICgodGhyb3duVmFsdWUgPSBnZXRTdXNwZW5kZWRUaGVuYWJsZSgpKSxcbiAgICAgICAgICAgICh3b3JrSW5Qcm9ncmVzc1N1c3BlbmRlZFJlYXNvbiA9IFN1c3BlbmRlZE9uSW5zdGFuY2UpKVxuICAgICAgICAgIDogKHdvcmtJblByb2dyZXNzU3VzcGVuZGVkUmVhc29uID1cbiAgICAgICAgICAgICAgdGhyb3duVmFsdWUgPT09IFNlbGVjdGl2ZUh5ZHJhdGlvbkV4Y2VwdGlvblxuICAgICAgICAgICAgICAgID8gU3VzcGVuZGVkT25IeWRyYXRpb25cbiAgICAgICAgICAgICAgICA6IG51bGwgIT09IHRocm93blZhbHVlICYmXG4gICAgICAgICAgICAgICAgICAgIFwib2JqZWN0XCIgPT09IHR5cGVvZiB0aHJvd25WYWx1ZSAmJlxuICAgICAgICAgICAgICAgICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiB0aHJvd25WYWx1ZS50aGVuXG4gICAgICAgICAgICAgICAgICA/IFN1c3BlbmRlZE9uRGVwcmVjYXRlZFRocm93UHJvbWlzZVxuICAgICAgICAgICAgICAgICAgOiBTdXNwZW5kZWRPbkVycm9yKTtcbiAgICAgIHdvcmtJblByb2dyZXNzVGhyb3duVmFsdWUgPSB0aHJvd25WYWx1ZTtcbiAgICAgIHZhciBlcnJvcmVkV29yayA9IHdvcmtJblByb2dyZXNzO1xuICAgICAgaWYgKG51bGwgPT09IGVycm9yZWRXb3JrKVxuICAgICAgICAod29ya0luUHJvZ3Jlc3NSb290RXhpdFN0YXR1cyA9IFJvb3RGYXRhbEVycm9yZWQpLFxuICAgICAgICAgIGxvZ1VuY2F1Z2h0RXJyb3IoXG4gICAgICAgICAgICByb290LFxuICAgICAgICAgICAgY3JlYXRlQ2FwdHVyZWRWYWx1ZUF0RmliZXIodGhyb3duVmFsdWUsIHJvb3QuY3VycmVudClcbiAgICAgICAgICApO1xuICAgICAgZWxzZVxuICAgICAgICBzd2l0Y2ggKFxuICAgICAgICAgIChlcnJvcmVkV29yay5tb2RlICYgMiAmJlxuICAgICAgICAgICAgc3RvcFByb2ZpbGVyVGltZXJJZlJ1bm5pbmdBbmRSZWNvcmREdXJhdGlvbihlcnJvcmVkV29yayksXG4gICAgICAgICAgbWFya0NvbXBvbmVudFJlbmRlclN0b3BwZWQoKSxcbiAgICAgICAgICB3b3JrSW5Qcm9ncmVzc1N1c3BlbmRlZFJlYXNvbilcbiAgICAgICAgKSB7XG4gICAgICAgICAgY2FzZSBTdXNwZW5kZWRPbkVycm9yOlxuICAgICAgICAgICAgbnVsbCAhPT0gaW5qZWN0ZWRQcm9maWxpbmdIb29rcyAmJlxuICAgICAgICAgICAgICBcImZ1bmN0aW9uXCIgPT09XG4gICAgICAgICAgICAgICAgdHlwZW9mIGluamVjdGVkUHJvZmlsaW5nSG9va3MubWFya0NvbXBvbmVudEVycm9yZWQgJiZcbiAgICAgICAgICAgICAgaW5qZWN0ZWRQcm9maWxpbmdIb29rcy5tYXJrQ29tcG9uZW50RXJyb3JlZChcbiAgICAgICAgICAgICAgICBlcnJvcmVkV29yayxcbiAgICAgICAgICAgICAgICB0aHJvd25WYWx1ZSxcbiAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzc1Jvb3RSZW5kZXJMYW5lc1xuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBTdXNwZW5kZWRPbkRhdGE6XG4gICAgICAgICAgY2FzZSBTdXNwZW5kZWRPbkltbWVkaWF0ZTpcbiAgICAgICAgICBjYXNlIFN1c3BlbmRlZE9uRGVwcmVjYXRlZFRocm93UHJvbWlzZTpcbiAgICAgICAgICBjYXNlIFN1c3BlbmRlZEFuZFJlYWR5VG9Db250aW51ZTpcbiAgICAgICAgICAgIG51bGwgIT09IGluamVjdGVkUHJvZmlsaW5nSG9va3MgJiZcbiAgICAgICAgICAgICAgXCJmdW5jdGlvblwiID09PVxuICAgICAgICAgICAgICAgIHR5cGVvZiBpbmplY3RlZFByb2ZpbGluZ0hvb2tzLm1hcmtDb21wb25lbnRTdXNwZW5kZWQgJiZcbiAgICAgICAgICAgICAgaW5qZWN0ZWRQcm9maWxpbmdIb29rcy5tYXJrQ29tcG9uZW50U3VzcGVuZGVkKFxuICAgICAgICAgICAgICAgIGVycm9yZWRXb3JrLFxuICAgICAgICAgICAgICAgIHRocm93blZhbHVlLFxuICAgICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzUm9vdFJlbmRlckxhbmVzXG4gICAgICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gc2hvdWxkUmVtYWluT25QcmV2aW91c1NjcmVlbigpIHtcbiAgICAgIHZhciBoYW5kbGVyID0gc3VzcGVuc2VIYW5kbGVyU3RhY2tDdXJzb3IuY3VycmVudDtcbiAgICAgIHJldHVybiBudWxsID09PSBoYW5kbGVyXG4gICAgICAgID8gITBcbiAgICAgICAgOiAod29ya0luUHJvZ3Jlc3NSb290UmVuZGVyTGFuZXMgJiA0MTk0MTc2KSA9PT1cbiAgICAgICAgICAgIHdvcmtJblByb2dyZXNzUm9vdFJlbmRlckxhbmVzXG4gICAgICAgICAgPyBudWxsID09PSBzaGVsbEJvdW5kYXJ5XG4gICAgICAgICAgICA/ICEwXG4gICAgICAgICAgICA6ICExXG4gICAgICAgICAgOiAod29ya0luUHJvZ3Jlc3NSb290UmVuZGVyTGFuZXMgJiA2MjkxNDU2MCkgPT09XG4gICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3NSb290UmVuZGVyTGFuZXMgfHxcbiAgICAgICAgICAgICAgMCAhPT0gKHdvcmtJblByb2dyZXNzUm9vdFJlbmRlckxhbmVzICYgNTM2ODcwOTEyKVxuICAgICAgICAgICAgPyBoYW5kbGVyID09PSBzaGVsbEJvdW5kYXJ5XG4gICAgICAgICAgICA6ICExO1xuICAgIH1cbiAgICBmdW5jdGlvbiBwdXNoRGlzcGF0Y2hlcigpIHtcbiAgICAgIHZhciBwcmV2RGlzcGF0Y2hlciA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLkg7XG4gICAgICBSZWFjdFNoYXJlZEludGVybmFscy5IID0gQ29udGV4dE9ubHlEaXNwYXRjaGVyO1xuICAgICAgcmV0dXJuIG51bGwgPT09IHByZXZEaXNwYXRjaGVyID8gQ29udGV4dE9ubHlEaXNwYXRjaGVyIDogcHJldkRpc3BhdGNoZXI7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHB1c2hBc3luY0Rpc3BhdGNoZXIoKSB7XG4gICAgICB2YXIgcHJldkFzeW5jRGlzcGF0Y2hlciA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLkE7XG4gICAgICBSZWFjdFNoYXJlZEludGVybmFscy5BID0gRGVmYXVsdEFzeW5jRGlzcGF0Y2hlcjtcbiAgICAgIHJldHVybiBwcmV2QXN5bmNEaXNwYXRjaGVyO1xuICAgIH1cbiAgICBmdW5jdGlvbiByZW5kZXJEaWRTdXNwZW5kRGVsYXlJZlBvc3NpYmxlKCkge1xuICAgICAgd29ya0luUHJvZ3Jlc3NSb290RXhpdFN0YXR1cyA9IFJvb3RTdXNwZW5kZWRXaXRoRGVsYXk7XG4gICAgICB3b3JrSW5Qcm9ncmVzc1Jvb3REaWRTa2lwU3VzcGVuZGVkU2libGluZ3MgfHxcbiAgICAgICAgKCh3b3JrSW5Qcm9ncmVzc1Jvb3RSZW5kZXJMYW5lcyAmIDQxOTQxNzYpICE9PVxuICAgICAgICAgIHdvcmtJblByb2dyZXNzUm9vdFJlbmRlckxhbmVzICYmXG4gICAgICAgICAgbnVsbCAhPT0gc3VzcGVuc2VIYW5kbGVyU3RhY2tDdXJzb3IuY3VycmVudCkgfHxcbiAgICAgICAgKHdvcmtJblByb2dyZXNzUm9vdElzUHJlcmVuZGVyaW5nID0gITApO1xuICAgICAgKDAgPT09ICh3b3JrSW5Qcm9ncmVzc1Jvb3RTa2lwcGVkTGFuZXMgJiAxMzQyMTc3MjcpICYmXG4gICAgICAgIDAgPT09ICh3b3JrSW5Qcm9ncmVzc1Jvb3RJbnRlcmxlYXZlZFVwZGF0ZWRMYW5lcyAmIDEzNDIxNzcyNykpIHx8XG4gICAgICAgIG51bGwgPT09IHdvcmtJblByb2dyZXNzUm9vdCB8fFxuICAgICAgICBtYXJrUm9vdFN1c3BlbmRlZChcbiAgICAgICAgICB3b3JrSW5Qcm9ncmVzc1Jvb3QsXG4gICAgICAgICAgd29ya0luUHJvZ3Jlc3NSb290UmVuZGVyTGFuZXMsXG4gICAgICAgICAgd29ya0luUHJvZ3Jlc3NEZWZlcnJlZExhbmUsXG4gICAgICAgICAgITFcbiAgICAgICAgKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcmVuZGVyUm9vdFN5bmMocm9vdCwgbGFuZXMsIHNob3VsZFlpZWxkRm9yUHJlcmVuZGVyaW5nKSB7XG4gICAgICB2YXIgcHJldkV4ZWN1dGlvbkNvbnRleHQgPSBleGVjdXRpb25Db250ZXh0O1xuICAgICAgZXhlY3V0aW9uQ29udGV4dCB8PSBSZW5kZXJDb250ZXh0O1xuICAgICAgdmFyIHByZXZEaXNwYXRjaGVyID0gcHVzaERpc3BhdGNoZXIoKSxcbiAgICAgICAgcHJldkFzeW5jRGlzcGF0Y2hlciA9IHB1c2hBc3luY0Rpc3BhdGNoZXIoKTtcbiAgICAgIGlmIChcbiAgICAgICAgd29ya0luUHJvZ3Jlc3NSb290ICE9PSByb290IHx8XG4gICAgICAgIHdvcmtJblByb2dyZXNzUm9vdFJlbmRlckxhbmVzICE9PSBsYW5lc1xuICAgICAgKSB7XG4gICAgICAgIGlmIChpc0RldlRvb2xzUHJlc2VudCkge1xuICAgICAgICAgIHZhciBtZW1vaXplZFVwZGF0ZXJzID0gcm9vdC5tZW1vaXplZFVwZGF0ZXJzO1xuICAgICAgICAgIDAgPCBtZW1vaXplZFVwZGF0ZXJzLnNpemUgJiZcbiAgICAgICAgICAgIChyZXN0b3JlUGVuZGluZ1VwZGF0ZXJzKHJvb3QsIHdvcmtJblByb2dyZXNzUm9vdFJlbmRlckxhbmVzKSxcbiAgICAgICAgICAgIG1lbW9pemVkVXBkYXRlcnMuY2xlYXIoKSk7XG4gICAgICAgICAgbW92ZVBlbmRpbmdGaWJlcnNUb01lbW9pemVkKHJvb3QsIGxhbmVzKTtcbiAgICAgICAgfVxuICAgICAgICB3b3JrSW5Qcm9ncmVzc1RyYW5zaXRpb25zID0gbnVsbDtcbiAgICAgICAgcHJlcGFyZUZyZXNoU3RhY2socm9vdCwgbGFuZXMpO1xuICAgICAgfVxuICAgICAgbWFya1JlbmRlclN0YXJ0ZWQobGFuZXMpO1xuICAgICAgbGFuZXMgPSAhMTtcbiAgICAgIG1lbW9pemVkVXBkYXRlcnMgPSB3b3JrSW5Qcm9ncmVzc1Jvb3RFeGl0U3RhdHVzO1xuICAgICAgYTogZG9cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgICB3b3JrSW5Qcm9ncmVzc1N1c3BlbmRlZFJlYXNvbiAhPT0gTm90U3VzcGVuZGVkICYmXG4gICAgICAgICAgICBudWxsICE9PSB3b3JrSW5Qcm9ncmVzc1xuICAgICAgICAgICkge1xuICAgICAgICAgICAgdmFyIHVuaXRPZldvcmsgPSB3b3JrSW5Qcm9ncmVzcyxcbiAgICAgICAgICAgICAgdGhyb3duVmFsdWUgPSB3b3JrSW5Qcm9ncmVzc1Rocm93blZhbHVlO1xuICAgICAgICAgICAgc3dpdGNoICh3b3JrSW5Qcm9ncmVzc1N1c3BlbmRlZFJlYXNvbikge1xuICAgICAgICAgICAgICBjYXNlIFN1c3BlbmRlZE9uSHlkcmF0aW9uOlxuICAgICAgICAgICAgICAgIHJlc2V0V29ya0luUHJvZ3Jlc3NTdGFjaygpO1xuICAgICAgICAgICAgICAgIG1lbW9pemVkVXBkYXRlcnMgPSBSb290RGlkTm90Q29tcGxldGU7XG4gICAgICAgICAgICAgICAgYnJlYWsgYTtcbiAgICAgICAgICAgICAgY2FzZSBTdXNwZW5kZWRPbkltbWVkaWF0ZTpcbiAgICAgICAgICAgICAgY2FzZSBTdXNwZW5kZWRPbkRhdGE6XG4gICAgICAgICAgICAgIGNhc2UgU3VzcGVuZGVkT25EZXByZWNhdGVkVGhyb3dQcm9taXNlOlxuICAgICAgICAgICAgICAgIG51bGwgPT09IHN1c3BlbnNlSGFuZGxlclN0YWNrQ3Vyc29yLmN1cnJlbnQgJiYgKGxhbmVzID0gITApO1xuICAgICAgICAgICAgICAgIHZhciByZWFzb24gPSB3b3JrSW5Qcm9ncmVzc1N1c3BlbmRlZFJlYXNvbjtcbiAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzc1N1c3BlbmRlZFJlYXNvbiA9IE5vdFN1c3BlbmRlZDtcbiAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzc1Rocm93blZhbHVlID0gbnVsbDtcbiAgICAgICAgICAgICAgICB0aHJvd0FuZFVud2luZFdvcmtMb29wKHJvb3QsIHVuaXRPZldvcmssIHRocm93blZhbHVlLCByZWFzb24pO1xuICAgICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAgIHNob3VsZFlpZWxkRm9yUHJlcmVuZGVyaW5nICYmXG4gICAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzc1Jvb3RJc1ByZXJlbmRlcmluZ1xuICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgbWVtb2l6ZWRVcGRhdGVycyA9IFJvb3RJblByb2dyZXNzO1xuICAgICAgICAgICAgICAgICAgYnJlYWsgYTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgKHJlYXNvbiA9IHdvcmtJblByb2dyZXNzU3VzcGVuZGVkUmVhc29uKSxcbiAgICAgICAgICAgICAgICAgICh3b3JrSW5Qcm9ncmVzc1N1c3BlbmRlZFJlYXNvbiA9IE5vdFN1c3BlbmRlZCksXG4gICAgICAgICAgICAgICAgICAod29ya0luUHJvZ3Jlc3NUaHJvd25WYWx1ZSA9IG51bGwpLFxuICAgICAgICAgICAgICAgICAgdGhyb3dBbmRVbndpbmRXb3JrTG9vcChyb290LCB1bml0T2ZXb3JrLCB0aHJvd25WYWx1ZSwgcmVhc29uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgd29ya0xvb3BTeW5jKCk7XG4gICAgICAgICAgbWVtb2l6ZWRVcGRhdGVycyA9IHdvcmtJblByb2dyZXNzUm9vdEV4aXRTdGF0dXM7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH0gY2F0Y2ggKHRocm93blZhbHVlJDQpIHtcbiAgICAgICAgICBoYW5kbGVUaHJvdyhyb290LCB0aHJvd25WYWx1ZSQ0KTtcbiAgICAgICAgfVxuICAgICAgd2hpbGUgKDEpO1xuICAgICAgbGFuZXMgJiYgcm9vdC5zaGVsbFN1c3BlbmRDb3VudGVyKys7XG4gICAgICByZXNldENvbnRleHREZXBlbmRlbmNpZXMoKTtcbiAgICAgIGV4ZWN1dGlvbkNvbnRleHQgPSBwcmV2RXhlY3V0aW9uQ29udGV4dDtcbiAgICAgIFJlYWN0U2hhcmVkSW50ZXJuYWxzLkggPSBwcmV2RGlzcGF0Y2hlcjtcbiAgICAgIFJlYWN0U2hhcmVkSW50ZXJuYWxzLkEgPSBwcmV2QXN5bmNEaXNwYXRjaGVyO1xuICAgICAgbWFya1JlbmRlclN0b3BwZWQoKTtcbiAgICAgIG51bGwgPT09IHdvcmtJblByb2dyZXNzICYmXG4gICAgICAgICgod29ya0luUHJvZ3Jlc3NSb290ID0gbnVsbCksXG4gICAgICAgICh3b3JrSW5Qcm9ncmVzc1Jvb3RSZW5kZXJMYW5lcyA9IDApLFxuICAgICAgICBmaW5pc2hRdWV1ZWluZ0NvbmN1cnJlbnRVcGRhdGVzKCkpO1xuICAgICAgcmV0dXJuIG1lbW9pemVkVXBkYXRlcnM7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHdvcmtMb29wU3luYygpIHtcbiAgICAgIGZvciAoOyBudWxsICE9PSB3b3JrSW5Qcm9ncmVzczsgKSBwZXJmb3JtVW5pdE9mV29yayh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlbmRlclJvb3RDb25jdXJyZW50KHJvb3QsIGxhbmVzKSB7XG4gICAgICB2YXIgcHJldkV4ZWN1dGlvbkNvbnRleHQgPSBleGVjdXRpb25Db250ZXh0O1xuICAgICAgZXhlY3V0aW9uQ29udGV4dCB8PSBSZW5kZXJDb250ZXh0O1xuICAgICAgdmFyIHByZXZEaXNwYXRjaGVyID0gcHVzaERpc3BhdGNoZXIoKSxcbiAgICAgICAgcHJldkFzeW5jRGlzcGF0Y2hlciA9IHB1c2hBc3luY0Rpc3BhdGNoZXIoKTtcbiAgICAgIGlmIChcbiAgICAgICAgd29ya0luUHJvZ3Jlc3NSb290ICE9PSByb290IHx8XG4gICAgICAgIHdvcmtJblByb2dyZXNzUm9vdFJlbmRlckxhbmVzICE9PSBsYW5lc1xuICAgICAgKSB7XG4gICAgICAgIGlmIChpc0RldlRvb2xzUHJlc2VudCkge1xuICAgICAgICAgIHZhciBtZW1vaXplZFVwZGF0ZXJzID0gcm9vdC5tZW1vaXplZFVwZGF0ZXJzO1xuICAgICAgICAgIDAgPCBtZW1vaXplZFVwZGF0ZXJzLnNpemUgJiZcbiAgICAgICAgICAgIChyZXN0b3JlUGVuZGluZ1VwZGF0ZXJzKHJvb3QsIHdvcmtJblByb2dyZXNzUm9vdFJlbmRlckxhbmVzKSxcbiAgICAgICAgICAgIG1lbW9pemVkVXBkYXRlcnMuY2xlYXIoKSk7XG4gICAgICAgICAgbW92ZVBlbmRpbmdGaWJlcnNUb01lbW9pemVkKHJvb3QsIGxhbmVzKTtcbiAgICAgICAgfVxuICAgICAgICB3b3JrSW5Qcm9ncmVzc1RyYW5zaXRpb25zID0gbnVsbDtcbiAgICAgICAgd29ya0luUHJvZ3Jlc3NSb290UmVuZGVyVGFyZ2V0VGltZSA9IG5vdyQxKCkgKyBSRU5ERVJfVElNRU9VVF9NUztcbiAgICAgICAgcHJlcGFyZUZyZXNoU3RhY2socm9vdCwgbGFuZXMpO1xuICAgICAgfSBlbHNlXG4gICAgICAgIHdvcmtJblByb2dyZXNzUm9vdElzUHJlcmVuZGVyaW5nID0gY2hlY2tJZlJvb3RJc1ByZXJlbmRlcmluZyhcbiAgICAgICAgICByb290LFxuICAgICAgICAgIGxhbmVzXG4gICAgICAgICk7XG4gICAgICBtYXJrUmVuZGVyU3RhcnRlZChsYW5lcyk7XG4gICAgICBhOiBkb1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGlmIChcbiAgICAgICAgICAgIHdvcmtJblByb2dyZXNzU3VzcGVuZGVkUmVhc29uICE9PSBOb3RTdXNwZW5kZWQgJiZcbiAgICAgICAgICAgIG51bGwgIT09IHdvcmtJblByb2dyZXNzXG4gICAgICAgICAgKVxuICAgICAgICAgICAgYjogc3dpdGNoIChcbiAgICAgICAgICAgICAgKChsYW5lcyA9IHdvcmtJblByb2dyZXNzKSxcbiAgICAgICAgICAgICAgKG1lbW9pemVkVXBkYXRlcnMgPSB3b3JrSW5Qcm9ncmVzc1Rocm93blZhbHVlKSxcbiAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3NTdXNwZW5kZWRSZWFzb24pXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgY2FzZSBTdXNwZW5kZWRPbkVycm9yOlxuICAgICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzU3VzcGVuZGVkUmVhc29uID0gTm90U3VzcGVuZGVkO1xuICAgICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzVGhyb3duVmFsdWUgPSBudWxsO1xuICAgICAgICAgICAgICAgIHRocm93QW5kVW53aW5kV29ya0xvb3AoXG4gICAgICAgICAgICAgICAgICByb290LFxuICAgICAgICAgICAgICAgICAgbGFuZXMsXG4gICAgICAgICAgICAgICAgICBtZW1vaXplZFVwZGF0ZXJzLFxuICAgICAgICAgICAgICAgICAgU3VzcGVuZGVkT25FcnJvclxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGNhc2UgU3VzcGVuZGVkT25EYXRhOlxuICAgICAgICAgICAgICAgIGlmIChpc1RoZW5hYmxlUmVzb2x2ZWQobWVtb2l6ZWRVcGRhdGVycykpIHtcbiAgICAgICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzU3VzcGVuZGVkUmVhc29uID0gTm90U3VzcGVuZGVkO1xuICAgICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3NUaHJvd25WYWx1ZSA9IG51bGw7XG4gICAgICAgICAgICAgICAgICByZXBsYXlTdXNwZW5kZWRVbml0T2ZXb3JrKGxhbmVzKTtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsYW5lcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzU3VzcGVuZGVkUmVhc29uID09PSBTdXNwZW5kZWRPbkRhdGEgJiZcbiAgICAgICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3NSb290ID09PSByb290ICYmXG4gICAgICAgICAgICAgICAgICAgICh3b3JrSW5Qcm9ncmVzc1N1c3BlbmRlZFJlYXNvbiA9XG4gICAgICAgICAgICAgICAgICAgICAgU3VzcGVuZGVkQW5kUmVhZHlUb0NvbnRpbnVlKTtcbiAgICAgICAgICAgICAgICAgIGVuc3VyZVJvb3RJc1NjaGVkdWxlZChyb290KTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIG1lbW9pemVkVXBkYXRlcnMudGhlbihsYW5lcywgbGFuZXMpO1xuICAgICAgICAgICAgICAgIGJyZWFrIGE7XG4gICAgICAgICAgICAgIGNhc2UgU3VzcGVuZGVkT25JbW1lZGlhdGU6XG4gICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3NTdXNwZW5kZWRSZWFzb24gPSBTdXNwZW5kZWRBbmRSZWFkeVRvQ29udGludWU7XG4gICAgICAgICAgICAgICAgYnJlYWsgYTtcbiAgICAgICAgICAgICAgY2FzZSBTdXNwZW5kZWRPbkluc3RhbmNlOlxuICAgICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzU3VzcGVuZGVkUmVhc29uID1cbiAgICAgICAgICAgICAgICAgIFN1c3BlbmRlZE9uSW5zdGFuY2VBbmRSZWFkeVRvQ29udGludWU7XG4gICAgICAgICAgICAgICAgYnJlYWsgYTtcbiAgICAgICAgICAgICAgY2FzZSBTdXNwZW5kZWRBbmRSZWFkeVRvQ29udGludWU6XG4gICAgICAgICAgICAgICAgaXNUaGVuYWJsZVJlc29sdmVkKG1lbW9pemVkVXBkYXRlcnMpXG4gICAgICAgICAgICAgICAgICA/ICgod29ya0luUHJvZ3Jlc3NTdXNwZW5kZWRSZWFzb24gPSBOb3RTdXNwZW5kZWQpLFxuICAgICAgICAgICAgICAgICAgICAod29ya0luUHJvZ3Jlc3NUaHJvd25WYWx1ZSA9IG51bGwpLFxuICAgICAgICAgICAgICAgICAgICByZXBsYXlTdXNwZW5kZWRVbml0T2ZXb3JrKGxhbmVzKSlcbiAgICAgICAgICAgICAgICAgIDogKCh3b3JrSW5Qcm9ncmVzc1N1c3BlbmRlZFJlYXNvbiA9IE5vdFN1c3BlbmRlZCksXG4gICAgICAgICAgICAgICAgICAgICh3b3JrSW5Qcm9ncmVzc1Rocm93blZhbHVlID0gbnVsbCksXG4gICAgICAgICAgICAgICAgICAgIHRocm93QW5kVW53aW5kV29ya0xvb3AoXG4gICAgICAgICAgICAgICAgICAgICAgcm9vdCxcbiAgICAgICAgICAgICAgICAgICAgICBsYW5lcyxcbiAgICAgICAgICAgICAgICAgICAgICBtZW1vaXplZFVwZGF0ZXJzLFxuICAgICAgICAgICAgICAgICAgICAgIFN1c3BlbmRlZEFuZFJlYWR5VG9Db250aW51ZVxuICAgICAgICAgICAgICAgICAgICApKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgY2FzZSBTdXNwZW5kZWRPbkluc3RhbmNlQW5kUmVhZHlUb0NvbnRpbnVlOlxuICAgICAgICAgICAgICAgIHZhciByZXNvdXJjZSA9IG51bGw7XG4gICAgICAgICAgICAgICAgc3dpdGNoICh3b3JrSW5Qcm9ncmVzcy50YWcpIHtcbiAgICAgICAgICAgICAgICAgIGNhc2UgMjY6XG4gICAgICAgICAgICAgICAgICAgIHJlc291cmNlID0gd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZTtcbiAgICAgICAgICAgICAgICAgIGNhc2UgNTpcbiAgICAgICAgICAgICAgICAgIGNhc2UgMjc6XG4gICAgICAgICAgICAgICAgICAgIHZhciBob3N0RmliZXIgPSB3b3JrSW5Qcm9ncmVzcyxcbiAgICAgICAgICAgICAgICAgICAgICB0eXBlID0gaG9zdEZpYmVyLnR5cGUsXG4gICAgICAgICAgICAgICAgICAgICAgcHJvcHMgPSBob3N0RmliZXIucGVuZGluZ1Byb3BzO1xuICAgICAgICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgICAgICAgcmVzb3VyY2VcbiAgICAgICAgICAgICAgICAgICAgICAgID8gcHJlbG9hZFJlc291cmNlKHJlc291cmNlKVxuICAgICAgICAgICAgICAgICAgICAgICAgOiBwcmVsb2FkSW5zdGFuY2UodHlwZSwgcHJvcHMpXG4gICAgICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzU3VzcGVuZGVkUmVhc29uID0gTm90U3VzcGVuZGVkO1xuICAgICAgICAgICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzVGhyb3duVmFsdWUgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgIHZhciBzaWJsaW5nID0gaG9zdEZpYmVyLnNpYmxpbmc7XG4gICAgICAgICAgICAgICAgICAgICAgaWYgKG51bGwgIT09IHNpYmxpbmcpIHdvcmtJblByb2dyZXNzID0gc2libGluZztcbiAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciByZXR1cm5GaWJlciA9IGhvc3RGaWJlci5yZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICBudWxsICE9PSByZXR1cm5GaWJlclxuICAgICAgICAgICAgICAgICAgICAgICAgICA/ICgod29ya0luUHJvZ3Jlc3MgPSByZXR1cm5GaWJlciksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29tcGxldGVVbml0T2ZXb3JrKHJldHVybkZpYmVyKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgOiAod29ya0luUHJvZ3Jlc3MgPSBudWxsKTtcbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgYnJlYWsgYjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgICAgICAgICAgXCJVbmV4cGVjdGVkIHR5cGUgb2YgZmliZXIgdHJpZ2dlcmVkIGEgc3VzcGVuc2V5IGNvbW1pdC4gVGhpcyBpcyBhIGJ1ZyBpbiBSZWFjdC5cIlxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzc1N1c3BlbmRlZFJlYXNvbiA9IE5vdFN1c3BlbmRlZDtcbiAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzc1Rocm93blZhbHVlID0gbnVsbDtcbiAgICAgICAgICAgICAgICB0aHJvd0FuZFVud2luZFdvcmtMb29wKFxuICAgICAgICAgICAgICAgICAgcm9vdCxcbiAgICAgICAgICAgICAgICAgIGxhbmVzLFxuICAgICAgICAgICAgICAgICAgbWVtb2l6ZWRVcGRhdGVycyxcbiAgICAgICAgICAgICAgICAgIFN1c3BlbmRlZE9uSW5zdGFuY2VBbmRSZWFkeVRvQ29udGludWVcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBjYXNlIFN1c3BlbmRlZE9uRGVwcmVjYXRlZFRocm93UHJvbWlzZTpcbiAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzc1N1c3BlbmRlZFJlYXNvbiA9IE5vdFN1c3BlbmRlZDtcbiAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzc1Rocm93blZhbHVlID0gbnVsbDtcbiAgICAgICAgICAgICAgICB0aHJvd0FuZFVud2luZFdvcmtMb29wKFxuICAgICAgICAgICAgICAgICAgcm9vdCxcbiAgICAgICAgICAgICAgICAgIGxhbmVzLFxuICAgICAgICAgICAgICAgICAgbWVtb2l6ZWRVcGRhdGVycyxcbiAgICAgICAgICAgICAgICAgIFN1c3BlbmRlZE9uRGVwcmVjYXRlZFRocm93UHJvbWlzZVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGNhc2UgU3VzcGVuZGVkT25IeWRyYXRpb246XG4gICAgICAgICAgICAgICAgcmVzZXRXb3JrSW5Qcm9ncmVzc1N0YWNrKCk7XG4gICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3NSb290RXhpdFN0YXR1cyA9IFJvb3REaWROb3RDb21wbGV0ZTtcbiAgICAgICAgICAgICAgICBicmVhayBhO1xuICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHRocm93IEVycm9yKFxuICAgICAgICAgICAgICAgICAgXCJVbmV4cGVjdGVkIFN1c3BlbmRlZFJlYXNvbi4gVGhpcyBpcyBhIGJ1ZyBpbiBSZWFjdC5cIlxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgbnVsbCAhPT0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuYWN0UXVldWVcbiAgICAgICAgICAgID8gd29ya0xvb3BTeW5jKClcbiAgICAgICAgICAgIDogd29ya0xvb3BDb25jdXJyZW50KCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH0gY2F0Y2ggKHRocm93blZhbHVlJDUpIHtcbiAgICAgICAgICBoYW5kbGVUaHJvdyhyb290LCB0aHJvd25WYWx1ZSQ1KTtcbiAgICAgICAgfVxuICAgICAgd2hpbGUgKDEpO1xuICAgICAgcmVzZXRDb250ZXh0RGVwZW5kZW5jaWVzKCk7XG4gICAgICBSZWFjdFNoYXJlZEludGVybmFscy5IID0gcHJldkRpc3BhdGNoZXI7XG4gICAgICBSZWFjdFNoYXJlZEludGVybmFscy5BID0gcHJldkFzeW5jRGlzcGF0Y2hlcjtcbiAgICAgIGV4ZWN1dGlvbkNvbnRleHQgPSBwcmV2RXhlY3V0aW9uQ29udGV4dDtcbiAgICAgIGlmIChudWxsICE9PSB3b3JrSW5Qcm9ncmVzcylcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICBudWxsICE9PSBpbmplY3RlZFByb2ZpbGluZ0hvb2tzICYmXG4gICAgICAgICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBpbmplY3RlZFByb2ZpbGluZ0hvb2tzLm1hcmtSZW5kZXJZaWVsZGVkICYmXG4gICAgICAgICAgICBpbmplY3RlZFByb2ZpbGluZ0hvb2tzLm1hcmtSZW5kZXJZaWVsZGVkKCksXG4gICAgICAgICAgUm9vdEluUHJvZ3Jlc3NcbiAgICAgICAgKTtcbiAgICAgIG1hcmtSZW5kZXJTdG9wcGVkKCk7XG4gICAgICB3b3JrSW5Qcm9ncmVzc1Jvb3QgPSBudWxsO1xuICAgICAgd29ya0luUHJvZ3Jlc3NSb290UmVuZGVyTGFuZXMgPSAwO1xuICAgICAgZmluaXNoUXVldWVpbmdDb25jdXJyZW50VXBkYXRlcygpO1xuICAgICAgcmV0dXJuIHdvcmtJblByb2dyZXNzUm9vdEV4aXRTdGF0dXM7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHdvcmtMb29wQ29uY3VycmVudCgpIHtcbiAgICAgIGZvciAoOyBudWxsICE9PSB3b3JrSW5Qcm9ncmVzcyAmJiAhc2hvdWxkWWllbGQoKTsgKVxuICAgICAgICBwZXJmb3JtVW5pdE9mV29yayh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHBlcmZvcm1Vbml0T2ZXb3JrKHVuaXRPZldvcmspIHtcbiAgICAgIHZhciBjdXJyZW50ID0gdW5pdE9mV29yay5hbHRlcm5hdGU7XG4gICAgICAodW5pdE9mV29yay5tb2RlICYgMikgIT09IE5vTW9kZVxuICAgICAgICA/IChzdGFydFByb2ZpbGVyVGltZXIodW5pdE9mV29yayksXG4gICAgICAgICAgKGN1cnJlbnQgPSBydW5XaXRoRmliZXJJbkRFVihcbiAgICAgICAgICAgIHVuaXRPZldvcmssXG4gICAgICAgICAgICBiZWdpbldvcmssXG4gICAgICAgICAgICBjdXJyZW50LFxuICAgICAgICAgICAgdW5pdE9mV29yayxcbiAgICAgICAgICAgIGVudGFuZ2xlZFJlbmRlckxhbmVzXG4gICAgICAgICAgKSksXG4gICAgICAgICAgc3RvcFByb2ZpbGVyVGltZXJJZlJ1bm5pbmdBbmRSZWNvcmREdXJhdGlvbih1bml0T2ZXb3JrKSlcbiAgICAgICAgOiAoY3VycmVudCA9IHJ1bldpdGhGaWJlckluREVWKFxuICAgICAgICAgICAgdW5pdE9mV29yayxcbiAgICAgICAgICAgIGJlZ2luV29yayxcbiAgICAgICAgICAgIGN1cnJlbnQsXG4gICAgICAgICAgICB1bml0T2ZXb3JrLFxuICAgICAgICAgICAgZW50YW5nbGVkUmVuZGVyTGFuZXNcbiAgICAgICAgICApKTtcbiAgICAgIHVuaXRPZldvcmsubWVtb2l6ZWRQcm9wcyA9IHVuaXRPZldvcmsucGVuZGluZ1Byb3BzO1xuICAgICAgbnVsbCA9PT0gY3VycmVudFxuICAgICAgICA/IGNvbXBsZXRlVW5pdE9mV29yayh1bml0T2ZXb3JrKVxuICAgICAgICA6ICh3b3JrSW5Qcm9ncmVzcyA9IGN1cnJlbnQpO1xuICAgIH1cbiAgICBmdW5jdGlvbiByZXBsYXlTdXNwZW5kZWRVbml0T2ZXb3JrKHVuaXRPZldvcmspIHtcbiAgICAgIHZhciBuZXh0ID0gcnVuV2l0aEZpYmVySW5ERVYodW5pdE9mV29yaywgcmVwbGF5QmVnaW5Xb3JrLCB1bml0T2ZXb3JrKTtcbiAgICAgIHVuaXRPZldvcmsubWVtb2l6ZWRQcm9wcyA9IHVuaXRPZldvcmsucGVuZGluZ1Byb3BzO1xuICAgICAgbnVsbCA9PT0gbmV4dCA/IGNvbXBsZXRlVW5pdE9mV29yayh1bml0T2ZXb3JrKSA6ICh3b3JrSW5Qcm9ncmVzcyA9IG5leHQpO1xuICAgIH1cbiAgICBmdW5jdGlvbiByZXBsYXlCZWdpbldvcmsodW5pdE9mV29yaykge1xuICAgICAgdmFyIGN1cnJlbnQgPSB1bml0T2ZXb3JrLmFsdGVybmF0ZSxcbiAgICAgICAgaXNQcm9maWxpbmdNb2RlID0gKHVuaXRPZldvcmsubW9kZSAmIDIpICE9PSBOb01vZGU7XG4gICAgICBpc1Byb2ZpbGluZ01vZGUgJiYgc3RhcnRQcm9maWxlclRpbWVyKHVuaXRPZldvcmspO1xuICAgICAgc3dpdGNoICh1bml0T2ZXb3JrLnRhZykge1xuICAgICAgICBjYXNlIDE1OlxuICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgY3VycmVudCA9IHJlcGxheUZ1bmN0aW9uQ29tcG9uZW50KFxuICAgICAgICAgICAgY3VycmVudCxcbiAgICAgICAgICAgIHVuaXRPZldvcmssXG4gICAgICAgICAgICB1bml0T2ZXb3JrLnBlbmRpbmdQcm9wcyxcbiAgICAgICAgICAgIHVuaXRPZldvcmsudHlwZSxcbiAgICAgICAgICAgIHZvaWQgMCxcbiAgICAgICAgICAgIHdvcmtJblByb2dyZXNzUm9vdFJlbmRlckxhbmVzXG4gICAgICAgICAgKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAxMTpcbiAgICAgICAgICBjdXJyZW50ID0gcmVwbGF5RnVuY3Rpb25Db21wb25lbnQoXG4gICAgICAgICAgICBjdXJyZW50LFxuICAgICAgICAgICAgdW5pdE9mV29yayxcbiAgICAgICAgICAgIHVuaXRPZldvcmsucGVuZGluZ1Byb3BzLFxuICAgICAgICAgICAgdW5pdE9mV29yay50eXBlLnJlbmRlcixcbiAgICAgICAgICAgIHVuaXRPZldvcmsucmVmLFxuICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3NSb290UmVuZGVyTGFuZXNcbiAgICAgICAgICApO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgcmVzZXRIb29rc09uVW53aW5kKHVuaXRPZldvcmspO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHVud2luZEludGVycnVwdGVkV29yayhjdXJyZW50LCB1bml0T2ZXb3JrKSxcbiAgICAgICAgICAgICh1bml0T2ZXb3JrID0gd29ya0luUHJvZ3Jlc3MgPVxuICAgICAgICAgICAgICByZXNldFdvcmtJblByb2dyZXNzKHVuaXRPZldvcmssIGVudGFuZ2xlZFJlbmRlckxhbmVzKSksXG4gICAgICAgICAgICAoY3VycmVudCA9IGJlZ2luV29yayhjdXJyZW50LCB1bml0T2ZXb3JrLCBlbnRhbmdsZWRSZW5kZXJMYW5lcykpO1xuICAgICAgfVxuICAgICAgaXNQcm9maWxpbmdNb2RlICYmXG4gICAgICAgIHN0b3BQcm9maWxlclRpbWVySWZSdW5uaW5nQW5kUmVjb3JkRHVyYXRpb24odW5pdE9mV29yayk7XG4gICAgICByZXR1cm4gY3VycmVudDtcbiAgICB9XG4gICAgZnVuY3Rpb24gdGhyb3dBbmRVbndpbmRXb3JrTG9vcChcbiAgICAgIHJvb3QsXG4gICAgICB1bml0T2ZXb3JrLFxuICAgICAgdGhyb3duVmFsdWUsXG4gICAgICBzdXNwZW5kZWRSZWFzb25cbiAgICApIHtcbiAgICAgIHJlc2V0Q29udGV4dERlcGVuZGVuY2llcygpO1xuICAgICAgcmVzZXRIb29rc09uVW53aW5kKHVuaXRPZldvcmspO1xuICAgICAgdGhlbmFibGVTdGF0ZSQxID0gbnVsbDtcbiAgICAgIHRoZW5hYmxlSW5kZXhDb3VudGVyJDEgPSAwO1xuICAgICAgdmFyIHJldHVybkZpYmVyID0gdW5pdE9mV29yay5yZXR1cm47XG4gICAgICB0cnkge1xuICAgICAgICBpZiAoXG4gICAgICAgICAgdGhyb3dFeGNlcHRpb24oXG4gICAgICAgICAgICByb290LFxuICAgICAgICAgICAgcmV0dXJuRmliZXIsXG4gICAgICAgICAgICB1bml0T2ZXb3JrLFxuICAgICAgICAgICAgdGhyb3duVmFsdWUsXG4gICAgICAgICAgICB3b3JrSW5Qcm9ncmVzc1Jvb3RSZW5kZXJMYW5lc1xuICAgICAgICAgIClcbiAgICAgICAgKSB7XG4gICAgICAgICAgd29ya0luUHJvZ3Jlc3NSb290RXhpdFN0YXR1cyA9IFJvb3RGYXRhbEVycm9yZWQ7XG4gICAgICAgICAgbG9nVW5jYXVnaHRFcnJvcihcbiAgICAgICAgICAgIHJvb3QsXG4gICAgICAgICAgICBjcmVhdGVDYXB0dXJlZFZhbHVlQXRGaWJlcih0aHJvd25WYWx1ZSwgcm9vdC5jdXJyZW50KVxuICAgICAgICAgICk7XG4gICAgICAgICAgd29ya0luUHJvZ3Jlc3MgPSBudWxsO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgaWYgKG51bGwgIT09IHJldHVybkZpYmVyKSB0aHJvdyAoKHdvcmtJblByb2dyZXNzID0gcmV0dXJuRmliZXIpLCBlcnJvcik7XG4gICAgICAgIHdvcmtJblByb2dyZXNzUm9vdEV4aXRTdGF0dXMgPSBSb290RmF0YWxFcnJvcmVkO1xuICAgICAgICBsb2dVbmNhdWdodEVycm9yKFxuICAgICAgICAgIHJvb3QsXG4gICAgICAgICAgY3JlYXRlQ2FwdHVyZWRWYWx1ZUF0RmliZXIodGhyb3duVmFsdWUsIHJvb3QuY3VycmVudClcbiAgICAgICAgKTtcbiAgICAgICAgd29ya0luUHJvZ3Jlc3MgPSBudWxsO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAodW5pdE9mV29yay5mbGFncyAmIDMyNzY4KSB7XG4gICAgICAgIGlmIChpc0h5ZHJhdGluZyB8fCBzdXNwZW5kZWRSZWFzb24gPT09IFN1c3BlbmRlZE9uRXJyb3IpIHJvb3QgPSAhMDtcbiAgICAgICAgZWxzZSBpZiAoXG4gICAgICAgICAgd29ya0luUHJvZ3Jlc3NSb290SXNQcmVyZW5kZXJpbmcgfHxcbiAgICAgICAgICAwICE9PSAod29ya0luUHJvZ3Jlc3NSb290UmVuZGVyTGFuZXMgJiA1MzY4NzA5MTIpXG4gICAgICAgIClcbiAgICAgICAgICByb290ID0gITE7XG4gICAgICAgIGVsc2UgaWYgKFxuICAgICAgICAgICgod29ya0luUHJvZ3Jlc3NSb290RGlkU2tpcFN1c3BlbmRlZFNpYmxpbmdzID0gcm9vdCA9ICEwKSxcbiAgICAgICAgICBzdXNwZW5kZWRSZWFzb24gPT09IFN1c3BlbmRlZE9uRGF0YSB8fFxuICAgICAgICAgICAgc3VzcGVuZGVkUmVhc29uID09PSBTdXNwZW5kZWRPbkltbWVkaWF0ZSB8fFxuICAgICAgICAgICAgc3VzcGVuZGVkUmVhc29uID09PSBTdXNwZW5kZWRPbkRlcHJlY2F0ZWRUaHJvd1Byb21pc2UpXG4gICAgICAgIClcbiAgICAgICAgICAoc3VzcGVuZGVkUmVhc29uID0gc3VzcGVuc2VIYW5kbGVyU3RhY2tDdXJzb3IuY3VycmVudCksXG4gICAgICAgICAgICBudWxsICE9PSBzdXNwZW5kZWRSZWFzb24gJiZcbiAgICAgICAgICAgICAgMTMgPT09IHN1c3BlbmRlZFJlYXNvbi50YWcgJiZcbiAgICAgICAgICAgICAgKHN1c3BlbmRlZFJlYXNvbi5mbGFncyB8PSAxNjM4NCk7XG4gICAgICAgIHVud2luZFVuaXRPZldvcmsodW5pdE9mV29yaywgcm9vdCk7XG4gICAgICB9IGVsc2UgY29tcGxldGVVbml0T2ZXb3JrKHVuaXRPZldvcmspO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjb21wbGV0ZVVuaXRPZldvcmsodW5pdE9mV29yaykge1xuICAgICAgdmFyIGNvbXBsZXRlZFdvcmsgPSB1bml0T2ZXb3JrO1xuICAgICAgZG8ge1xuICAgICAgICBpZiAoMCAhPT0gKGNvbXBsZXRlZFdvcmsuZmxhZ3MgJiAzMjc2OCkpIHtcbiAgICAgICAgICB1bndpbmRVbml0T2ZXb3JrKFxuICAgICAgICAgICAgY29tcGxldGVkV29yayxcbiAgICAgICAgICAgIHdvcmtJblByb2dyZXNzUm9vdERpZFNraXBTdXNwZW5kZWRTaWJsaW5nc1xuICAgICAgICAgICk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBjdXJyZW50ID0gY29tcGxldGVkV29yay5hbHRlcm5hdGU7XG4gICAgICAgIHVuaXRPZldvcmsgPSBjb21wbGV0ZWRXb3JrLnJldHVybjtcbiAgICAgICAgc3RhcnRQcm9maWxlclRpbWVyKGNvbXBsZXRlZFdvcmspO1xuICAgICAgICBjdXJyZW50ID0gcnVuV2l0aEZpYmVySW5ERVYoXG4gICAgICAgICAgY29tcGxldGVkV29yayxcbiAgICAgICAgICBjb21wbGV0ZVdvcmssXG4gICAgICAgICAgY3VycmVudCxcbiAgICAgICAgICBjb21wbGV0ZWRXb3JrLFxuICAgICAgICAgIGVudGFuZ2xlZFJlbmRlckxhbmVzXG4gICAgICAgICk7XG4gICAgICAgIChjb21wbGV0ZWRXb3JrLm1vZGUgJiAyKSAhPT0gTm9Nb2RlICYmXG4gICAgICAgICAgc3RvcFByb2ZpbGVyVGltZXJJZlJ1bm5pbmdBbmRSZWNvcmRJbmNvbXBsZXRlRHVyYXRpb24oY29tcGxldGVkV29yayk7XG4gICAgICAgIGlmIChudWxsICE9PSBjdXJyZW50KSB7XG4gICAgICAgICAgd29ya0luUHJvZ3Jlc3MgPSBjdXJyZW50O1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb21wbGV0ZWRXb3JrID0gY29tcGxldGVkV29yay5zaWJsaW5nO1xuICAgICAgICBpZiAobnVsbCAhPT0gY29tcGxldGVkV29yaykge1xuICAgICAgICAgIHdvcmtJblByb2dyZXNzID0gY29tcGxldGVkV29yaztcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgd29ya0luUHJvZ3Jlc3MgPSBjb21wbGV0ZWRXb3JrID0gdW5pdE9mV29yaztcbiAgICAgIH0gd2hpbGUgKG51bGwgIT09IGNvbXBsZXRlZFdvcmspO1xuICAgICAgd29ya0luUHJvZ3Jlc3NSb290RXhpdFN0YXR1cyA9PT0gUm9vdEluUHJvZ3Jlc3MgJiZcbiAgICAgICAgKHdvcmtJblByb2dyZXNzUm9vdEV4aXRTdGF0dXMgPSBSb290Q29tcGxldGVkKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gdW53aW5kVW5pdE9mV29yayh1bml0T2ZXb3JrLCBza2lwU2libGluZ3MpIHtcbiAgICAgIGRvIHtcbiAgICAgICAgdmFyIG5leHQgPSB1bndpbmRXb3JrKHVuaXRPZldvcmsuYWx0ZXJuYXRlLCB1bml0T2ZXb3JrKTtcbiAgICAgICAgaWYgKG51bGwgIT09IG5leHQpIHtcbiAgICAgICAgICBuZXh0LmZsYWdzICY9IDMyNzY3O1xuICAgICAgICAgIHdvcmtJblByb2dyZXNzID0gbmV4dDtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCh1bml0T2ZXb3JrLm1vZGUgJiAyKSAhPT0gTm9Nb2RlKSB7XG4gICAgICAgICAgc3RvcFByb2ZpbGVyVGltZXJJZlJ1bm5pbmdBbmRSZWNvcmRJbmNvbXBsZXRlRHVyYXRpb24odW5pdE9mV29yayk7XG4gICAgICAgICAgbmV4dCA9IHVuaXRPZldvcmsuYWN0dWFsRHVyYXRpb247XG4gICAgICAgICAgZm9yICh2YXIgY2hpbGQgPSB1bml0T2ZXb3JrLmNoaWxkOyBudWxsICE9PSBjaGlsZDsgKVxuICAgICAgICAgICAgKG5leHQgKz0gY2hpbGQuYWN0dWFsRHVyYXRpb24pLCAoY2hpbGQgPSBjaGlsZC5zaWJsaW5nKTtcbiAgICAgICAgICB1bml0T2ZXb3JrLmFjdHVhbER1cmF0aW9uID0gbmV4dDtcbiAgICAgICAgfVxuICAgICAgICBuZXh0ID0gdW5pdE9mV29yay5yZXR1cm47XG4gICAgICAgIG51bGwgIT09IG5leHQgJiZcbiAgICAgICAgICAoKG5leHQuZmxhZ3MgfD0gMzI3NjgpLFxuICAgICAgICAgIChuZXh0LnN1YnRyZWVGbGFncyA9IDApLFxuICAgICAgICAgIChuZXh0LmRlbGV0aW9ucyA9IG51bGwpKTtcbiAgICAgICAgaWYgKFxuICAgICAgICAgICFza2lwU2libGluZ3MgJiZcbiAgICAgICAgICAoKHVuaXRPZldvcmsgPSB1bml0T2ZXb3JrLnNpYmxpbmcpLCBudWxsICE9PSB1bml0T2ZXb3JrKVxuICAgICAgICApIHtcbiAgICAgICAgICB3b3JrSW5Qcm9ncmVzcyA9IHVuaXRPZldvcms7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHdvcmtJblByb2dyZXNzID0gdW5pdE9mV29yayA9IG5leHQ7XG4gICAgICB9IHdoaWxlIChudWxsICE9PSB1bml0T2ZXb3JrKTtcbiAgICAgIHdvcmtJblByb2dyZXNzUm9vdEV4aXRTdGF0dXMgPSBSb290RGlkTm90Q29tcGxldGU7XG4gICAgICB3b3JrSW5Qcm9ncmVzcyA9IG51bGw7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNvbW1pdFJvb3QoXG4gICAgICByb290LFxuICAgICAgcmVjb3ZlcmFibGVFcnJvcnMsXG4gICAgICB0cmFuc2l0aW9ucyxcbiAgICAgIGRpZEluY2x1ZGVSZW5kZXJQaGFzZVVwZGF0ZSxcbiAgICAgIHNwYXduZWRMYW5lLFxuICAgICAgdXBkYXRlZExhbmVzLFxuICAgICAgc3VzcGVuZGVkUmV0cnlMYW5lcyxcbiAgICAgIHN1c3BlbmRlZENvbW1pdFJlYXNvbixcbiAgICAgIGNvbXBsZXRlZFJlbmRlclN0YXJ0VGltZSxcbiAgICAgIGNvbXBsZXRlZFJlbmRlckVuZFRpbWVcbiAgICApIHtcbiAgICAgIHZhciBwcmV2VHJhbnNpdGlvbiA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlQsXG4gICAgICAgIHByZXZpb3VzVXBkYXRlTGFuZVByaW9yaXR5ID0gZ2V0Q3VycmVudFVwZGF0ZVByaW9yaXR5KCk7XG4gICAgICB0cnkge1xuICAgICAgICBzZXRDdXJyZW50VXBkYXRlUHJpb3JpdHkoMiksXG4gICAgICAgICAgKFJlYWN0U2hhcmVkSW50ZXJuYWxzLlQgPSBudWxsKSxcbiAgICAgICAgICBjb21taXRSb290SW1wbChcbiAgICAgICAgICAgIHJvb3QsXG4gICAgICAgICAgICByZWNvdmVyYWJsZUVycm9ycyxcbiAgICAgICAgICAgIHRyYW5zaXRpb25zLFxuICAgICAgICAgICAgZGlkSW5jbHVkZVJlbmRlclBoYXNlVXBkYXRlLFxuICAgICAgICAgICAgcHJldmlvdXNVcGRhdGVMYW5lUHJpb3JpdHksXG4gICAgICAgICAgICBzcGF3bmVkTGFuZSxcbiAgICAgICAgICAgIHVwZGF0ZWRMYW5lcyxcbiAgICAgICAgICAgIHN1c3BlbmRlZFJldHJ5TGFuZXMsXG4gICAgICAgICAgICBzdXNwZW5kZWRDb21taXRSZWFzb24sXG4gICAgICAgICAgICBjb21wbGV0ZWRSZW5kZXJTdGFydFRpbWUsXG4gICAgICAgICAgICBjb21wbGV0ZWRSZW5kZXJFbmRUaW1lXG4gICAgICAgICAgKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIChSZWFjdFNoYXJlZEludGVybmFscy5UID0gcHJldlRyYW5zaXRpb24pLFxuICAgICAgICAgIHNldEN1cnJlbnRVcGRhdGVQcmlvcml0eShwcmV2aW91c1VwZGF0ZUxhbmVQcmlvcml0eSk7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNvbW1pdFJvb3RJbXBsKFxuICAgICAgcm9vdCxcbiAgICAgIHJlY292ZXJhYmxlRXJyb3JzLFxuICAgICAgdHJhbnNpdGlvbnMsXG4gICAgICBkaWRJbmNsdWRlUmVuZGVyUGhhc2VVcGRhdGUsXG4gICAgICByZW5kZXJQcmlvcml0eUxldmVsLFxuICAgICAgc3Bhd25lZExhbmUsXG4gICAgICB1cGRhdGVkTGFuZXMsXG4gICAgICBzdXNwZW5kZWRSZXRyeUxhbmVzXG4gICAgKSB7XG4gICAgICBkbyBmbHVzaFBhc3NpdmVFZmZlY3RzKCk7XG4gICAgICB3aGlsZSAobnVsbCAhPT0gcm9vdFdpdGhQZW5kaW5nUGFzc2l2ZUVmZmVjdHMpO1xuICAgICAgUmVhY3RTdHJpY3RNb2RlV2FybmluZ3MuZmx1c2hMZWdhY3lDb250ZXh0V2FybmluZygpO1xuICAgICAgUmVhY3RTdHJpY3RNb2RlV2FybmluZ3MuZmx1c2hQZW5kaW5nVW5zYWZlTGlmZWN5Y2xlV2FybmluZ3MoKTtcbiAgICAgIGlmICgoZXhlY3V0aW9uQ29udGV4dCAmIChSZW5kZXJDb250ZXh0IHwgQ29tbWl0Q29udGV4dCkpICE9PSBOb0NvbnRleHQpXG4gICAgICAgIHRocm93IEVycm9yKFwiU2hvdWxkIG5vdCBhbHJlYWR5IGJlIHdvcmtpbmcuXCIpO1xuICAgICAgdmFyIGZpbmlzaGVkV29yayA9IHJvb3QuZmluaXNoZWRXb3JrO1xuICAgICAgZGlkSW5jbHVkZVJlbmRlclBoYXNlVXBkYXRlID0gcm9vdC5maW5pc2hlZExhbmVzO1xuICAgICAgbnVsbCAhPT0gaW5qZWN0ZWRQcm9maWxpbmdIb29rcyAmJlxuICAgICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBpbmplY3RlZFByb2ZpbGluZ0hvb2tzLm1hcmtDb21taXRTdGFydGVkICYmXG4gICAgICAgIGluamVjdGVkUHJvZmlsaW5nSG9va3MubWFya0NvbW1pdFN0YXJ0ZWQoZGlkSW5jbHVkZVJlbmRlclBoYXNlVXBkYXRlKTtcbiAgICAgIGlmIChudWxsID09PSBmaW5pc2hlZFdvcmspIHJldHVybiBtYXJrQ29tbWl0U3RvcHBlZCgpLCBudWxsO1xuICAgICAgMCA9PT0gZGlkSW5jbHVkZVJlbmRlclBoYXNlVXBkYXRlICYmXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgXCJyb290LmZpbmlzaGVkTGFuZXMgc2hvdWxkIG5vdCBiZSBlbXB0eSBkdXJpbmcgYSBjb21taXQuIFRoaXMgaXMgYSBidWcgaW4gUmVhY3QuXCJcbiAgICAgICAgKTtcbiAgICAgIHJvb3QuZmluaXNoZWRXb3JrID0gbnVsbDtcbiAgICAgIHJvb3QuZmluaXNoZWRMYW5lcyA9IDA7XG4gICAgICBpZiAoZmluaXNoZWRXb3JrID09PSByb290LmN1cnJlbnQpXG4gICAgICAgIHRocm93IEVycm9yKFxuICAgICAgICAgIFwiQ2Fubm90IGNvbW1pdCB0aGUgc2FtZSB0cmVlIGFzIGJlZm9yZS4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS5cIlxuICAgICAgICApO1xuICAgICAgcm9vdC5jYWxsYmFja05vZGUgPSBudWxsO1xuICAgICAgcm9vdC5jYWxsYmFja1ByaW9yaXR5ID0gMDtcbiAgICAgIHJvb3QuY2FuY2VsUGVuZGluZ0NvbW1pdCA9IG51bGw7XG4gICAgICB2YXIgcmVtYWluaW5nTGFuZXMgPSBmaW5pc2hlZFdvcmsubGFuZXMgfCBmaW5pc2hlZFdvcmsuY2hpbGRMYW5lcztcbiAgICAgIHJlbWFpbmluZ0xhbmVzIHw9IGNvbmN1cnJlbnRseVVwZGF0ZWRMYW5lcztcbiAgICAgIG1hcmtSb290RmluaXNoZWQoXG4gICAgICAgIHJvb3QsXG4gICAgICAgIGRpZEluY2x1ZGVSZW5kZXJQaGFzZVVwZGF0ZSxcbiAgICAgICAgcmVtYWluaW5nTGFuZXMsXG4gICAgICAgIHNwYXduZWRMYW5lLFxuICAgICAgICB1cGRhdGVkTGFuZXMsXG4gICAgICAgIHN1c3BlbmRlZFJldHJ5TGFuZXNcbiAgICAgICk7XG4gICAgICByb290ID09PSB3b3JrSW5Qcm9ncmVzc1Jvb3QgJiZcbiAgICAgICAgKCh3b3JrSW5Qcm9ncmVzcyA9IHdvcmtJblByb2dyZXNzUm9vdCA9IG51bGwpLFxuICAgICAgICAod29ya0luUHJvZ3Jlc3NSb290UmVuZGVyTGFuZXMgPSAwKSk7XG4gICAgICAoMCA9PT0gKGZpbmlzaGVkV29yay5zdWJ0cmVlRmxhZ3MgJiAxMDI1NikgJiZcbiAgICAgICAgMCA9PT0gKGZpbmlzaGVkV29yay5mbGFncyAmIDEwMjU2KSkgfHxcbiAgICAgICAgcm9vdERvZXNIYXZlUGFzc2l2ZUVmZmVjdHMgfHxcbiAgICAgICAgKChyb290RG9lc0hhdmVQYXNzaXZlRWZmZWN0cyA9ICEwKSxcbiAgICAgICAgKHBlbmRpbmdQYXNzaXZlRWZmZWN0c1JlbWFpbmluZ0xhbmVzID0gcmVtYWluaW5nTGFuZXMpLFxuICAgICAgICAocGVuZGluZ1Bhc3NpdmVUcmFuc2l0aW9ucyA9IHRyYW5zaXRpb25zKSxcbiAgICAgICAgc2NoZWR1bGVDYWxsYmFjayhOb3JtYWxQcmlvcml0eSQxLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgZmx1c2hQYXNzaXZlRWZmZWN0cyghMCk7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH0pKTtcbiAgICAgIGNvbW1pdFN0YXJ0VGltZSA9IG5vdygpO1xuICAgICAgdHJhbnNpdGlvbnMgPSAwICE9PSAoZmluaXNoZWRXb3JrLmZsYWdzICYgMTU5OTApO1xuICAgICAgMCAhPT0gKGZpbmlzaGVkV29yay5zdWJ0cmVlRmxhZ3MgJiAxNTk5MCkgfHwgdHJhbnNpdGlvbnNcbiAgICAgICAgPyAoKHRyYW5zaXRpb25zID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuVCksXG4gICAgICAgICAgKFJlYWN0U2hhcmVkSW50ZXJuYWxzLlQgPSBudWxsKSxcbiAgICAgICAgICAoc3Bhd25lZExhbmUgPSBnZXRDdXJyZW50VXBkYXRlUHJpb3JpdHkoKSksXG4gICAgICAgICAgc2V0Q3VycmVudFVwZGF0ZVByaW9yaXR5KDIpLFxuICAgICAgICAgICh1cGRhdGVkTGFuZXMgPSBleGVjdXRpb25Db250ZXh0KSxcbiAgICAgICAgICAoZXhlY3V0aW9uQ29udGV4dCB8PSBDb21taXRDb250ZXh0KSxcbiAgICAgICAgICBjb21taXRCZWZvcmVNdXRhdGlvbkVmZmVjdHMocm9vdCwgZmluaXNoZWRXb3JrKSxcbiAgICAgICAgICBjb21taXRNdXRhdGlvbkVmZmVjdHMoXG4gICAgICAgICAgICByb290LFxuICAgICAgICAgICAgZmluaXNoZWRXb3JrLFxuICAgICAgICAgICAgZGlkSW5jbHVkZVJlbmRlclBoYXNlVXBkYXRlXG4gICAgICAgICAgKSxcbiAgICAgICAgICByZXNldEFmdGVyQ29tbWl0KHJvb3QuY29udGFpbmVySW5mbyksXG4gICAgICAgICAgKHJvb3QuY3VycmVudCA9IGZpbmlzaGVkV29yayksXG4gICAgICAgICAgbnVsbCAhPT0gaW5qZWN0ZWRQcm9maWxpbmdIb29rcyAmJlxuICAgICAgICAgICAgXCJmdW5jdGlvblwiID09PVxuICAgICAgICAgICAgICB0eXBlb2YgaW5qZWN0ZWRQcm9maWxpbmdIb29rcy5tYXJrTGF5b3V0RWZmZWN0c1N0YXJ0ZWQgJiZcbiAgICAgICAgICAgIGluamVjdGVkUHJvZmlsaW5nSG9va3MubWFya0xheW91dEVmZmVjdHNTdGFydGVkKFxuICAgICAgICAgICAgICBkaWRJbmNsdWRlUmVuZGVyUGhhc2VVcGRhdGVcbiAgICAgICAgICAgICksXG4gICAgICAgICAgY29tbWl0TGF5b3V0RWZmZWN0cyhmaW5pc2hlZFdvcmssIHJvb3QsIGRpZEluY2x1ZGVSZW5kZXJQaGFzZVVwZGF0ZSksXG4gICAgICAgICAgbnVsbCAhPT0gaW5qZWN0ZWRQcm9maWxpbmdIb29rcyAmJlxuICAgICAgICAgICAgXCJmdW5jdGlvblwiID09PVxuICAgICAgICAgICAgICB0eXBlb2YgaW5qZWN0ZWRQcm9maWxpbmdIb29rcy5tYXJrTGF5b3V0RWZmZWN0c1N0b3BwZWQgJiZcbiAgICAgICAgICAgIGluamVjdGVkUHJvZmlsaW5nSG9va3MubWFya0xheW91dEVmZmVjdHNTdG9wcGVkKCksXG4gICAgICAgICAgcmVxdWVzdFBhaW50KCksXG4gICAgICAgICAgKGV4ZWN1dGlvbkNvbnRleHQgPSB1cGRhdGVkTGFuZXMpLFxuICAgICAgICAgIHNldEN1cnJlbnRVcGRhdGVQcmlvcml0eShzcGF3bmVkTGFuZSksXG4gICAgICAgICAgKFJlYWN0U2hhcmVkSW50ZXJuYWxzLlQgPSB0cmFuc2l0aW9ucykpXG4gICAgICAgIDogKHJvb3QuY3VycmVudCA9IGZpbmlzaGVkV29yayk7XG4gICAgICAodHJhbnNpdGlvbnMgPSByb290RG9lc0hhdmVQYXNzaXZlRWZmZWN0cylcbiAgICAgICAgPyAoKHJvb3REb2VzSGF2ZVBhc3NpdmVFZmZlY3RzID0gITEpLFxuICAgICAgICAgIChyb290V2l0aFBlbmRpbmdQYXNzaXZlRWZmZWN0cyA9IHJvb3QpLFxuICAgICAgICAgIChwZW5kaW5nUGFzc2l2ZUVmZmVjdHNMYW5lcyA9IGRpZEluY2x1ZGVSZW5kZXJQaGFzZVVwZGF0ZSkpXG4gICAgICAgIDogKHJlbGVhc2VSb290UG9vbGVkQ2FjaGUocm9vdCwgcmVtYWluaW5nTGFuZXMpLFxuICAgICAgICAgIChuZXN0ZWRQYXNzaXZlVXBkYXRlQ291bnQgPSAwKSxcbiAgICAgICAgICAocm9vdFdpdGhQYXNzaXZlTmVzdGVkVXBkYXRlcyA9IG51bGwpKTtcbiAgICAgIHJlbWFpbmluZ0xhbmVzID0gcm9vdC5wZW5kaW5nTGFuZXM7XG4gICAgICAwID09PSByZW1haW5pbmdMYW5lcyAmJiAobGVnYWN5RXJyb3JCb3VuZGFyaWVzVGhhdEFscmVhZHlGYWlsZWQgPSBudWxsKTtcbiAgICAgIHRyYW5zaXRpb25zIHx8IGNvbW1pdERvdWJsZUludm9rZUVmZmVjdHNJbkRFVihyb290KTtcbiAgICAgIG9uQ29tbWl0Um9vdCQxKGZpbmlzaGVkV29yay5zdGF0ZU5vZGUsIHJlbmRlclByaW9yaXR5TGV2ZWwpO1xuICAgICAgaXNEZXZUb29sc1ByZXNlbnQgJiYgcm9vdC5tZW1vaXplZFVwZGF0ZXJzLmNsZWFyKCk7XG4gICAgICBvbkNvbW1pdFJvb3QoKTtcbiAgICAgIGVuc3VyZVJvb3RJc1NjaGVkdWxlZChyb290KTtcbiAgICAgIGlmIChudWxsICE9PSByZWNvdmVyYWJsZUVycm9ycylcbiAgICAgICAgZm9yIChcbiAgICAgICAgICByZW5kZXJQcmlvcml0eUxldmVsID0gcm9vdC5vblJlY292ZXJhYmxlRXJyb3IsIGZpbmlzaGVkV29yayA9IDA7XG4gICAgICAgICAgZmluaXNoZWRXb3JrIDwgcmVjb3ZlcmFibGVFcnJvcnMubGVuZ3RoO1xuICAgICAgICAgIGZpbmlzaGVkV29yaysrXG4gICAgICAgIClcbiAgICAgICAgICAocmVtYWluaW5nTGFuZXMgPSByZWNvdmVyYWJsZUVycm9yc1tmaW5pc2hlZFdvcmtdKSxcbiAgICAgICAgICAgICh0cmFuc2l0aW9ucyA9IG1ha2VFcnJvckluZm8ocmVtYWluaW5nTGFuZXMuc3RhY2spKSxcbiAgICAgICAgICAgIHJ1bldpdGhGaWJlckluREVWKFxuICAgICAgICAgICAgICByZW1haW5pbmdMYW5lcy5zb3VyY2UsXG4gICAgICAgICAgICAgIHJlbmRlclByaW9yaXR5TGV2ZWwsXG4gICAgICAgICAgICAgIHJlbWFpbmluZ0xhbmVzLnZhbHVlLFxuICAgICAgICAgICAgICB0cmFuc2l0aW9uc1xuICAgICAgICAgICAgKTtcbiAgICAgIDAgIT09IChwZW5kaW5nUGFzc2l2ZUVmZmVjdHNMYW5lcyAmIDMpICYmIGZsdXNoUGFzc2l2ZUVmZmVjdHMoKTtcbiAgICAgIHJlbWFpbmluZ0xhbmVzID0gcm9vdC5wZW5kaW5nTGFuZXM7XG4gICAgICAwICE9PSAoZGlkSW5jbHVkZVJlbmRlclBoYXNlVXBkYXRlICYgNDE5NDIxOCkgJiZcbiAgICAgIDAgIT09IChyZW1haW5pbmdMYW5lcyAmIDQyKVxuICAgICAgICA/ICgobmVzdGVkVXBkYXRlU2NoZWR1bGVkID0gITApLFxuICAgICAgICAgIHJvb3QgPT09IHJvb3RXaXRoTmVzdGVkVXBkYXRlc1xuICAgICAgICAgICAgPyBuZXN0ZWRVcGRhdGVDb3VudCsrXG4gICAgICAgICAgICA6ICgobmVzdGVkVXBkYXRlQ291bnQgPSAwKSwgKHJvb3RXaXRoTmVzdGVkVXBkYXRlcyA9IHJvb3QpKSlcbiAgICAgICAgOiAobmVzdGVkVXBkYXRlQ291bnQgPSAwKTtcbiAgICAgIGZsdXNoU3luY1dvcmtBY3Jvc3NSb290c19pbXBsKDAsICExKTtcbiAgICAgIG1hcmtDb21taXRTdG9wcGVkKCk7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgZnVuY3Rpb24gbWFrZUVycm9ySW5mbyhjb21wb25lbnRTdGFjaykge1xuICAgICAgY29tcG9uZW50U3RhY2sgPSB7IGNvbXBvbmVudFN0YWNrOiBjb21wb25lbnRTdGFjayB9O1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGNvbXBvbmVudFN0YWNrLCBcImRpZ2VzdFwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAnWW91IGFyZSBhY2Nlc3NpbmcgXCJkaWdlc3RcIiBmcm9tIHRoZSBlcnJvckluZm8gb2JqZWN0IHBhc3NlZCB0byBvblJlY292ZXJhYmxlRXJyb3IuIFRoaXMgcHJvcGVydHkgaXMgbm8gbG9uZ2VyIHByb3ZpZGVkIGFzIHBhcnQgb2YgZXJyb3JJbmZvIGJ1dCBjYW4gYmUgYWNjZXNzZWQgYXMgYSBwcm9wZXJ0eSBvZiB0aGUgRXJyb3IgaW5zdGFuY2UgaXRzZWxmLidcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBjb21wb25lbnRTdGFjaztcbiAgICB9XG4gICAgZnVuY3Rpb24gcmVsZWFzZVJvb3RQb29sZWRDYWNoZShyb290LCByZW1haW5pbmdMYW5lcykge1xuICAgICAgMCA9PT0gKHJvb3QucG9vbGVkQ2FjaGVMYW5lcyAmPSByZW1haW5pbmdMYW5lcykgJiZcbiAgICAgICAgKChyZW1haW5pbmdMYW5lcyA9IHJvb3QucG9vbGVkQ2FjaGUpLFxuICAgICAgICBudWxsICE9IHJlbWFpbmluZ0xhbmVzICYmXG4gICAgICAgICAgKChyb290LnBvb2xlZENhY2hlID0gbnVsbCksIHJlbGVhc2VDYWNoZShyZW1haW5pbmdMYW5lcykpKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZmx1c2hQYXNzaXZlRWZmZWN0cygpIHtcbiAgICAgIGlmIChudWxsICE9PSByb290V2l0aFBlbmRpbmdQYXNzaXZlRWZmZWN0cykge1xuICAgICAgICB2YXIgcm9vdCA9IHJvb3RXaXRoUGVuZGluZ1Bhc3NpdmVFZmZlY3RzLFxuICAgICAgICAgIHJlbWFpbmluZ0xhbmVzID0gcGVuZGluZ1Bhc3NpdmVFZmZlY3RzUmVtYWluaW5nTGFuZXM7XG4gICAgICAgIHBlbmRpbmdQYXNzaXZlRWZmZWN0c1JlbWFpbmluZ0xhbmVzID0gMDtcbiAgICAgICAgdmFyIHJlbmRlclByaW9yaXR5ID0gbGFuZXNUb0V2ZW50UHJpb3JpdHkocGVuZGluZ1Bhc3NpdmVFZmZlY3RzTGFuZXMpLFxuICAgICAgICAgIHByaW9yaXR5ID0gMzIgPiByZW5kZXJQcmlvcml0eSA/IDMyIDogcmVuZGVyUHJpb3JpdHk7XG4gICAgICAgIHJlbmRlclByaW9yaXR5ID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuVDtcbiAgICAgICAgdmFyIHByZXZpb3VzUHJpb3JpdHkgPSBnZXRDdXJyZW50VXBkYXRlUHJpb3JpdHkoKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBzZXRDdXJyZW50VXBkYXRlUHJpb3JpdHkocHJpb3JpdHkpO1xuICAgICAgICAgIFJlYWN0U2hhcmVkSW50ZXJuYWxzLlQgPSBudWxsO1xuICAgICAgICAgIGlmIChudWxsID09PSByb290V2l0aFBlbmRpbmdQYXNzaXZlRWZmZWN0cylcbiAgICAgICAgICAgIHZhciBKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQgPSAhMTtcbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHByaW9yaXR5ID0gcGVuZGluZ1Bhc3NpdmVUcmFuc2l0aW9ucztcbiAgICAgICAgICAgIHBlbmRpbmdQYXNzaXZlVHJhbnNpdGlvbnMgPSBudWxsO1xuICAgICAgICAgICAgdmFyIHJvb3QkanNjb21wJDAgPSByb290V2l0aFBlbmRpbmdQYXNzaXZlRWZmZWN0cyxcbiAgICAgICAgICAgICAgbGFuZXMgPSBwZW5kaW5nUGFzc2l2ZUVmZmVjdHNMYW5lcztcbiAgICAgICAgICAgIHJvb3RXaXRoUGVuZGluZ1Bhc3NpdmVFZmZlY3RzID0gbnVsbDtcbiAgICAgICAgICAgIHBlbmRpbmdQYXNzaXZlRWZmZWN0c0xhbmVzID0gMDtcbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgKGV4ZWN1dGlvbkNvbnRleHQgJiAoUmVuZGVyQ29udGV4dCB8IENvbW1pdENvbnRleHQpKSAhPT1cbiAgICAgICAgICAgICAgTm9Db250ZXh0XG4gICAgICAgICAgICApXG4gICAgICAgICAgICAgIHRocm93IEVycm9yKFxuICAgICAgICAgICAgICAgIFwiQ2Fubm90IGZsdXNoIHBhc3NpdmUgZWZmZWN0cyB3aGlsZSBhbHJlYWR5IHJlbmRlcmluZy5cIlxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgaXNGbHVzaGluZ1Bhc3NpdmVFZmZlY3RzID0gITA7XG4gICAgICAgICAgICBkaWRTY2hlZHVsZVVwZGF0ZUR1cmluZ1Bhc3NpdmVFZmZlY3RzID0gITE7XG4gICAgICAgICAgICBudWxsICE9PSBpbmplY3RlZFByb2ZpbGluZ0hvb2tzICYmXG4gICAgICAgICAgICAgIFwiZnVuY3Rpb25cIiA9PT1cbiAgICAgICAgICAgICAgICB0eXBlb2YgaW5qZWN0ZWRQcm9maWxpbmdIb29rcy5tYXJrUGFzc2l2ZUVmZmVjdHNTdGFydGVkICYmXG4gICAgICAgICAgICAgIGluamVjdGVkUHJvZmlsaW5nSG9va3MubWFya1Bhc3NpdmVFZmZlY3RzU3RhcnRlZChsYW5lcyk7XG4gICAgICAgICAgICB2YXIgcHJldkV4ZWN1dGlvbkNvbnRleHQgPSBleGVjdXRpb25Db250ZXh0O1xuICAgICAgICAgICAgZXhlY3V0aW9uQ29udGV4dCB8PSBDb21taXRDb250ZXh0O1xuICAgICAgICAgICAgY29tbWl0UGFzc2l2ZVVubW91bnRPbkZpYmVyKHJvb3QkanNjb21wJDAuY3VycmVudCk7XG4gICAgICAgICAgICBjb21taXRQYXNzaXZlTW91bnRPbkZpYmVyKFxuICAgICAgICAgICAgICByb290JGpzY29tcCQwLFxuICAgICAgICAgICAgICByb290JGpzY29tcCQwLmN1cnJlbnQsXG4gICAgICAgICAgICAgIGxhbmVzLFxuICAgICAgICAgICAgICBwcmlvcml0eVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIG51bGwgIT09IGluamVjdGVkUHJvZmlsaW5nSG9va3MgJiZcbiAgICAgICAgICAgICAgXCJmdW5jdGlvblwiID09PVxuICAgICAgICAgICAgICAgIHR5cGVvZiBpbmplY3RlZFByb2ZpbGluZ0hvb2tzLm1hcmtQYXNzaXZlRWZmZWN0c1N0b3BwZWQgJiZcbiAgICAgICAgICAgICAgaW5qZWN0ZWRQcm9maWxpbmdIb29rcy5tYXJrUGFzc2l2ZUVmZmVjdHNTdG9wcGVkKCk7XG4gICAgICAgICAgICBjb21taXREb3VibGVJbnZva2VFZmZlY3RzSW5ERVYocm9vdCRqc2NvbXAkMCk7XG4gICAgICAgICAgICBleGVjdXRpb25Db250ZXh0ID0gcHJldkV4ZWN1dGlvbkNvbnRleHQ7XG4gICAgICAgICAgICBmbHVzaFN5bmNXb3JrQWNyb3NzUm9vdHNfaW1wbCgwLCAhMSk7XG4gICAgICAgICAgICBkaWRTY2hlZHVsZVVwZGF0ZUR1cmluZ1Bhc3NpdmVFZmZlY3RzXG4gICAgICAgICAgICAgID8gcm9vdCRqc2NvbXAkMCA9PT0gcm9vdFdpdGhQYXNzaXZlTmVzdGVkVXBkYXRlc1xuICAgICAgICAgICAgICAgID8gbmVzdGVkUGFzc2l2ZVVwZGF0ZUNvdW50KytcbiAgICAgICAgICAgICAgICA6ICgobmVzdGVkUGFzc2l2ZVVwZGF0ZUNvdW50ID0gMCksXG4gICAgICAgICAgICAgICAgICAocm9vdFdpdGhQYXNzaXZlTmVzdGVkVXBkYXRlcyA9IHJvb3QkanNjb21wJDApKVxuICAgICAgICAgICAgICA6IChuZXN0ZWRQYXNzaXZlVXBkYXRlQ291bnQgPSAwKTtcbiAgICAgICAgICAgIGRpZFNjaGVkdWxlVXBkYXRlRHVyaW5nUGFzc2l2ZUVmZmVjdHMgPSBpc0ZsdXNoaW5nUGFzc2l2ZUVmZmVjdHMgPVxuICAgICAgICAgICAgICAhMTtcbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgaW5qZWN0ZWRIb29rICYmXG4gICAgICAgICAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIGluamVjdGVkSG9vay5vblBvc3RDb21taXRGaWJlclJvb3RcbiAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBpbmplY3RlZEhvb2sub25Qb3N0Q29tbWl0RmliZXJSb290KHJlbmRlcmVySUQsIHJvb3QkanNjb21wJDApO1xuICAgICAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICBoYXNMb2dnZWRFcnJvciB8fFxuICAgICAgICAgICAgICAgICAgKChoYXNMb2dnZWRFcnJvciA9ICEwKSxcbiAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgICAgICAgIFwiUmVhY3QgaW5zdHJ1bWVudGF0aW9uIGVuY291bnRlcmVkIGFuIGVycm9yOiAlc1wiLFxuICAgICAgICAgICAgICAgICAgICBlcnJcbiAgICAgICAgICAgICAgICAgICkpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgc3RhdGVOb2RlID0gcm9vdCRqc2NvbXAkMC5jdXJyZW50LnN0YXRlTm9kZTtcbiAgICAgICAgICAgIHN0YXRlTm9kZS5lZmZlY3REdXJhdGlvbiA9IDA7XG4gICAgICAgICAgICBzdGF0ZU5vZGUucGFzc2l2ZUVmZmVjdER1cmF0aW9uID0gMDtcbiAgICAgICAgICAgIEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCA9ICEwO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0O1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIHNldEN1cnJlbnRVcGRhdGVQcmlvcml0eShwcmV2aW91c1ByaW9yaXR5KSxcbiAgICAgICAgICAgIChSZWFjdFNoYXJlZEludGVybmFscy5UID0gcmVuZGVyUHJpb3JpdHkpLFxuICAgICAgICAgICAgcmVsZWFzZVJvb3RQb29sZWRDYWNoZShyb290LCByZW1haW5pbmdMYW5lcyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiAhMTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY2FwdHVyZUNvbW1pdFBoYXNlRXJyb3JPblJvb3Qocm9vdEZpYmVyLCBzb3VyY2VGaWJlciwgZXJyb3IpIHtcbiAgICAgIHNvdXJjZUZpYmVyID0gY3JlYXRlQ2FwdHVyZWRWYWx1ZUF0RmliZXIoZXJyb3IsIHNvdXJjZUZpYmVyKTtcbiAgICAgIHNvdXJjZUZpYmVyID0gY3JlYXRlUm9vdEVycm9yVXBkYXRlKHJvb3RGaWJlci5zdGF0ZU5vZGUsIHNvdXJjZUZpYmVyLCAyKTtcbiAgICAgIHJvb3RGaWJlciA9IGVucXVldWVVcGRhdGUocm9vdEZpYmVyLCBzb3VyY2VGaWJlciwgMik7XG4gICAgICBudWxsICE9PSByb290RmliZXIgJiZcbiAgICAgICAgKG1hcmtSb290VXBkYXRlZCQxKHJvb3RGaWJlciwgMiksIGVuc3VyZVJvb3RJc1NjaGVkdWxlZChyb290RmliZXIpKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY2FwdHVyZUNvbW1pdFBoYXNlRXJyb3IoXG4gICAgICBzb3VyY2VGaWJlcixcbiAgICAgIG5lYXJlc3RNb3VudGVkQW5jZXN0b3IsXG4gICAgICBlcnJvclxuICAgICkge1xuICAgICAgaXNSdW5uaW5nSW5zZXJ0aW9uRWZmZWN0ID0gITE7XG4gICAgICBpZiAoMyA9PT0gc291cmNlRmliZXIudGFnKVxuICAgICAgICBjYXB0dXJlQ29tbWl0UGhhc2VFcnJvck9uUm9vdChzb3VyY2VGaWJlciwgc291cmNlRmliZXIsIGVycm9yKTtcbiAgICAgIGVsc2Uge1xuICAgICAgICBmb3IgKDsgbnVsbCAhPT0gbmVhcmVzdE1vdW50ZWRBbmNlc3RvcjsgKSB7XG4gICAgICAgICAgaWYgKDMgPT09IG5lYXJlc3RNb3VudGVkQW5jZXN0b3IudGFnKSB7XG4gICAgICAgICAgICBjYXB0dXJlQ29tbWl0UGhhc2VFcnJvck9uUm9vdChcbiAgICAgICAgICAgICAgbmVhcmVzdE1vdW50ZWRBbmNlc3RvcixcbiAgICAgICAgICAgICAgc291cmNlRmliZXIsXG4gICAgICAgICAgICAgIGVycm9yXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoMSA9PT0gbmVhcmVzdE1vdW50ZWRBbmNlc3Rvci50YWcpIHtcbiAgICAgICAgICAgIHZhciBpbnN0YW5jZSA9IG5lYXJlc3RNb3VudGVkQW5jZXN0b3Iuc3RhdGVOb2RlO1xuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICBcImZ1bmN0aW9uXCIgPT09XG4gICAgICAgICAgICAgICAgdHlwZW9mIG5lYXJlc3RNb3VudGVkQW5jZXN0b3IudHlwZS5nZXREZXJpdmVkU3RhdGVGcm9tRXJyb3IgfHxcbiAgICAgICAgICAgICAgKFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIGluc3RhbmNlLmNvbXBvbmVudERpZENhdGNoICYmXG4gICAgICAgICAgICAgICAgKG51bGwgPT09IGxlZ2FjeUVycm9yQm91bmRhcmllc1RoYXRBbHJlYWR5RmFpbGVkIHx8XG4gICAgICAgICAgICAgICAgICAhbGVnYWN5RXJyb3JCb3VuZGFyaWVzVGhhdEFscmVhZHlGYWlsZWQuaGFzKGluc3RhbmNlKSkpXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgc291cmNlRmliZXIgPSBjcmVhdGVDYXB0dXJlZFZhbHVlQXRGaWJlcihlcnJvciwgc291cmNlRmliZXIpO1xuICAgICAgICAgICAgICBlcnJvciA9IGNyZWF0ZUNsYXNzRXJyb3JVcGRhdGUoMik7XG4gICAgICAgICAgICAgIGluc3RhbmNlID0gZW5xdWV1ZVVwZGF0ZShuZWFyZXN0TW91bnRlZEFuY2VzdG9yLCBlcnJvciwgMik7XG4gICAgICAgICAgICAgIG51bGwgIT09IGluc3RhbmNlICYmXG4gICAgICAgICAgICAgICAgKGluaXRpYWxpemVDbGFzc0Vycm9yVXBkYXRlKFxuICAgICAgICAgICAgICAgICAgZXJyb3IsXG4gICAgICAgICAgICAgICAgICBpbnN0YW5jZSxcbiAgICAgICAgICAgICAgICAgIG5lYXJlc3RNb3VudGVkQW5jZXN0b3IsXG4gICAgICAgICAgICAgICAgICBzb3VyY2VGaWJlclxuICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgbWFya1Jvb3RVcGRhdGVkJDEoaW5zdGFuY2UsIDIpLFxuICAgICAgICAgICAgICAgIGVuc3VyZVJvb3RJc1NjaGVkdWxlZChpbnN0YW5jZSkpO1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIG5lYXJlc3RNb3VudGVkQW5jZXN0b3IgPSBuZWFyZXN0TW91bnRlZEFuY2VzdG9yLnJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgIFwiSW50ZXJuYWwgUmVhY3QgZXJyb3I6IEF0dGVtcHRlZCB0byBjYXB0dXJlIGEgY29tbWl0IHBoYXNlIGVycm9yIGluc2lkZSBhIGRldGFjaGVkIHRyZWUuIFRoaXMgaW5kaWNhdGVzIGEgYnVnIGluIFJlYWN0LiBQb3RlbnRpYWwgY2F1c2VzIGluY2x1ZGUgZGVsZXRpbmcgdGhlIHNhbWUgZmliZXIgbW9yZSB0aGFuIG9uY2UsIGNvbW1pdHRpbmcgYW4gYWxyZWFkeS1maW5pc2hlZCB0cmVlLCBvciBhbiBpbmNvbnNpc3RlbnQgcmV0dXJuIHBvaW50ZXIuXFxuXFxuRXJyb3IgbWVzc2FnZTpcXG5cXG4lc1wiLFxuICAgICAgICAgIGVycm9yXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGF0dGFjaFBpbmdMaXN0ZW5lcihyb290LCB3YWtlYWJsZSwgbGFuZXMpIHtcbiAgICAgIHZhciBwaW5nQ2FjaGUgPSByb290LnBpbmdDYWNoZTtcbiAgICAgIGlmIChudWxsID09PSBwaW5nQ2FjaGUpIHtcbiAgICAgICAgcGluZ0NhY2hlID0gcm9vdC5waW5nQ2FjaGUgPSBuZXcgUG9zc2libHlXZWFrTWFwKCk7XG4gICAgICAgIHZhciB0aHJlYWRJRHMgPSBuZXcgU2V0KCk7XG4gICAgICAgIHBpbmdDYWNoZS5zZXQod2FrZWFibGUsIHRocmVhZElEcyk7XG4gICAgICB9IGVsc2VcbiAgICAgICAgKHRocmVhZElEcyA9IHBpbmdDYWNoZS5nZXQod2FrZWFibGUpKSxcbiAgICAgICAgICB2b2lkIDAgPT09IHRocmVhZElEcyAmJlxuICAgICAgICAgICAgKCh0aHJlYWRJRHMgPSBuZXcgU2V0KCkpLCBwaW5nQ2FjaGUuc2V0KHdha2VhYmxlLCB0aHJlYWRJRHMpKTtcbiAgICAgIHRocmVhZElEcy5oYXMobGFuZXMpIHx8XG4gICAgICAgICgod29ya0luUHJvZ3Jlc3NSb290RGlkQXR0YWNoUGluZ0xpc3RlbmVyID0gITApLFxuICAgICAgICB0aHJlYWRJRHMuYWRkKGxhbmVzKSxcbiAgICAgICAgKHBpbmdDYWNoZSA9IHBpbmdTdXNwZW5kZWRSb290LmJpbmQobnVsbCwgcm9vdCwgd2FrZWFibGUsIGxhbmVzKSksXG4gICAgICAgIGlzRGV2VG9vbHNQcmVzZW50ICYmIHJlc3RvcmVQZW5kaW5nVXBkYXRlcnMocm9vdCwgbGFuZXMpLFxuICAgICAgICB3YWtlYWJsZS50aGVuKHBpbmdDYWNoZSwgcGluZ0NhY2hlKSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHBpbmdTdXNwZW5kZWRSb290KHJvb3QsIHdha2VhYmxlLCBwaW5nZWRMYW5lcykge1xuICAgICAgdmFyIHBpbmdDYWNoZSA9IHJvb3QucGluZ0NhY2hlO1xuICAgICAgbnVsbCAhPT0gcGluZ0NhY2hlICYmIHBpbmdDYWNoZS5kZWxldGUod2FrZWFibGUpO1xuICAgICAgcm9vdC5waW5nZWRMYW5lcyB8PSByb290LnN1c3BlbmRlZExhbmVzICYgcGluZ2VkTGFuZXM7XG4gICAgICByb290Lndhcm1MYW5lcyAmPSB+cGluZ2VkTGFuZXM7XG4gICAgICBpc0NvbmN1cnJlbnRBY3RFbnZpcm9ubWVudCgpICYmXG4gICAgICAgIG51bGwgPT09IFJlYWN0U2hhcmVkSW50ZXJuYWxzLmFjdFF1ZXVlICYmXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgXCJBIHN1c3BlbmRlZCByZXNvdXJjZSBmaW5pc2hlZCBsb2FkaW5nIGluc2lkZSBhIHRlc3QsIGJ1dCB0aGUgZXZlbnQgd2FzIG5vdCB3cmFwcGVkIGluIGFjdCguLi4pLlxcblxcbldoZW4gdGVzdGluZywgY29kZSB0aGF0IHJlc29sdmVzIHN1c3BlbmRlZCBkYXRhIHNob3VsZCBiZSB3cmFwcGVkIGludG8gYWN0KC4uLik6XFxuXFxuYWN0KCgpID0+IHtcXG4gIC8qIGZpbmlzaCBsb2FkaW5nIHN1c3BlbmRlZCBkYXRhICovXFxufSk7XFxuLyogYXNzZXJ0IG9uIHRoZSBvdXRwdXQgKi9cXG5cXG5UaGlzIGVuc3VyZXMgdGhhdCB5b3UncmUgdGVzdGluZyB0aGUgYmVoYXZpb3IgdGhlIHVzZXIgd291bGQgc2VlIGluIHRoZSBicm93c2VyLiBMZWFybiBtb3JlIGF0IGh0dHBzOi8vcmVhY3QuZGV2L2xpbmsvd3JhcC10ZXN0cy13aXRoLWFjdFwiXG4gICAgICAgICk7XG4gICAgICB3b3JrSW5Qcm9ncmVzc1Jvb3QgPT09IHJvb3QgJiZcbiAgICAgICAgKHdvcmtJblByb2dyZXNzUm9vdFJlbmRlckxhbmVzICYgcGluZ2VkTGFuZXMpID09PSBwaW5nZWRMYW5lcyAmJlxuICAgICAgICAod29ya0luUHJvZ3Jlc3NSb290RXhpdFN0YXR1cyA9PT0gUm9vdFN1c3BlbmRlZFdpdGhEZWxheSB8fFxuICAgICAgICAod29ya0luUHJvZ3Jlc3NSb290RXhpdFN0YXR1cyA9PT0gUm9vdFN1c3BlbmRlZCAmJlxuICAgICAgICAgICh3b3JrSW5Qcm9ncmVzc1Jvb3RSZW5kZXJMYW5lcyAmIDYyOTE0NTYwKSA9PT1cbiAgICAgICAgICAgIHdvcmtJblByb2dyZXNzUm9vdFJlbmRlckxhbmVzICYmXG4gICAgICAgICAgbm93JDEoKSAtIGdsb2JhbE1vc3RSZWNlbnRGYWxsYmFja1RpbWUgPCBGQUxMQkFDS19USFJPVFRMRV9NUylcbiAgICAgICAgICA/IChleGVjdXRpb25Db250ZXh0ICYgUmVuZGVyQ29udGV4dCkgPT09IE5vQ29udGV4dCAmJlxuICAgICAgICAgICAgcHJlcGFyZUZyZXNoU3RhY2socm9vdCwgMClcbiAgICAgICAgICA6ICh3b3JrSW5Qcm9ncmVzc1Jvb3RQaW5nZWRMYW5lcyB8PSBwaW5nZWRMYW5lcyksXG4gICAgICAgIHdvcmtJblByb2dyZXNzU3VzcGVuZGVkUmV0cnlMYW5lcyA9PT0gd29ya0luUHJvZ3Jlc3NSb290UmVuZGVyTGFuZXMgJiZcbiAgICAgICAgICAod29ya0luUHJvZ3Jlc3NTdXNwZW5kZWRSZXRyeUxhbmVzID0gMCkpO1xuICAgICAgZW5zdXJlUm9vdElzU2NoZWR1bGVkKHJvb3QpO1xuICAgIH1cbiAgICBmdW5jdGlvbiByZXRyeVRpbWVkT3V0Qm91bmRhcnkoYm91bmRhcnlGaWJlciwgcmV0cnlMYW5lKSB7XG4gICAgICAwID09PSByZXRyeUxhbmUgJiYgKHJldHJ5TGFuZSA9IGNsYWltTmV4dFJldHJ5TGFuZSgpKTtcbiAgICAgIGJvdW5kYXJ5RmliZXIgPSBlbnF1ZXVlQ29uY3VycmVudFJlbmRlckZvckxhbmUoYm91bmRhcnlGaWJlciwgcmV0cnlMYW5lKTtcbiAgICAgIG51bGwgIT09IGJvdW5kYXJ5RmliZXIgJiZcbiAgICAgICAgKG1hcmtSb290VXBkYXRlZCQxKGJvdW5kYXJ5RmliZXIsIHJldHJ5TGFuZSksXG4gICAgICAgIGVuc3VyZVJvb3RJc1NjaGVkdWxlZChib3VuZGFyeUZpYmVyKSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJldHJ5RGVoeWRyYXRlZFN1c3BlbnNlQm91bmRhcnkoYm91bmRhcnlGaWJlcikge1xuICAgICAgdmFyIHN1c3BlbnNlU3RhdGUgPSBib3VuZGFyeUZpYmVyLm1lbW9pemVkU3RhdGUsXG4gICAgICAgIHJldHJ5TGFuZSA9IDA7XG4gICAgICBudWxsICE9PSBzdXNwZW5zZVN0YXRlICYmIChyZXRyeUxhbmUgPSBzdXNwZW5zZVN0YXRlLnJldHJ5TGFuZSk7XG4gICAgICByZXRyeVRpbWVkT3V0Qm91bmRhcnkoYm91bmRhcnlGaWJlciwgcmV0cnlMYW5lKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcmVzb2x2ZVJldHJ5V2FrZWFibGUoYm91bmRhcnlGaWJlciwgd2FrZWFibGUpIHtcbiAgICAgIHZhciByZXRyeUxhbmUgPSAwO1xuICAgICAgc3dpdGNoIChib3VuZGFyeUZpYmVyLnRhZykge1xuICAgICAgICBjYXNlIDEzOlxuICAgICAgICAgIHZhciByZXRyeUNhY2hlID0gYm91bmRhcnlGaWJlci5zdGF0ZU5vZGU7XG4gICAgICAgICAgdmFyIHN1c3BlbnNlU3RhdGUgPSBib3VuZGFyeUZpYmVyLm1lbW9pemVkU3RhdGU7XG4gICAgICAgICAgbnVsbCAhPT0gc3VzcGVuc2VTdGF0ZSAmJiAocmV0cnlMYW5lID0gc3VzcGVuc2VTdGF0ZS5yZXRyeUxhbmUpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDE5OlxuICAgICAgICAgIHJldHJ5Q2FjaGUgPSBib3VuZGFyeUZpYmVyLnN0YXRlTm9kZTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAyMjpcbiAgICAgICAgICByZXRyeUNhY2hlID0gYm91bmRhcnlGaWJlci5zdGF0ZU5vZGUuX3JldHJ5Q2FjaGU7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgdGhyb3cgRXJyb3IoXG4gICAgICAgICAgICBcIlBpbmdlZCB1bmtub3duIHN1c3BlbnNlIGJvdW5kYXJ5IHR5cGUuIFRoaXMgaXMgcHJvYmFibHkgYSBidWcgaW4gUmVhY3QuXCJcbiAgICAgICAgICApO1xuICAgICAgfVxuICAgICAgbnVsbCAhPT0gcmV0cnlDYWNoZSAmJiByZXRyeUNhY2hlLmRlbGV0ZSh3YWtlYWJsZSk7XG4gICAgICByZXRyeVRpbWVkT3V0Qm91bmRhcnkoYm91bmRhcnlGaWJlciwgcmV0cnlMYW5lKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcmVjdXJzaXZlbHlUcmF2ZXJzZUFuZERvdWJsZUludm9rZUVmZmVjdHNJbkRFVihcbiAgICAgIHJvb3QkanNjb21wJDAsXG4gICAgICBwYXJlbnRGaWJlcixcbiAgICAgIGlzSW5TdHJpY3RNb2RlXG4gICAgKSB7XG4gICAgICBpZiAoMCAhPT0gKHBhcmVudEZpYmVyLnN1YnRyZWVGbGFncyAmIDMzNTYyNjI0KSlcbiAgICAgICAgZm9yIChwYXJlbnRGaWJlciA9IHBhcmVudEZpYmVyLmNoaWxkOyBudWxsICE9PSBwYXJlbnRGaWJlcjsgKSB7XG4gICAgICAgICAgdmFyIHJvb3QgPSByb290JGpzY29tcCQwLFxuICAgICAgICAgICAgZmliZXIgPSBwYXJlbnRGaWJlcixcbiAgICAgICAgICAgIGlzU3RyaWN0TW9kZUZpYmVyID0gZmliZXIudHlwZSA9PT0gUkVBQ1RfU1RSSUNUX01PREVfVFlQRTtcbiAgICAgICAgICBpc1N0cmljdE1vZGVGaWJlciA9IGlzSW5TdHJpY3RNb2RlIHx8IGlzU3RyaWN0TW9kZUZpYmVyO1xuICAgICAgICAgIDIyICE9PSBmaWJlci50YWdcbiAgICAgICAgICAgID8gZmliZXIuZmxhZ3MgJiAzMzU1NDQzMlxuICAgICAgICAgICAgICA/IGlzU3RyaWN0TW9kZUZpYmVyICYmXG4gICAgICAgICAgICAgICAgcnVuV2l0aEZpYmVySW5ERVYoXG4gICAgICAgICAgICAgICAgICBmaWJlcixcbiAgICAgICAgICAgICAgICAgIGRvdWJsZUludm9rZUVmZmVjdHNPbkZpYmVyLFxuICAgICAgICAgICAgICAgICAgcm9vdCxcbiAgICAgICAgICAgICAgICAgIGZpYmVyLFxuICAgICAgICAgICAgICAgICAgKGZpYmVyLm1vZGUgJiA2NCkgPT09IE5vTW9kZVxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgOiByZWN1cnNpdmVseVRyYXZlcnNlQW5kRG91YmxlSW52b2tlRWZmZWN0c0luREVWKFxuICAgICAgICAgICAgICAgICAgcm9vdCxcbiAgICAgICAgICAgICAgICAgIGZpYmVyLFxuICAgICAgICAgICAgICAgICAgaXNTdHJpY3RNb2RlRmliZXJcbiAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICA6IG51bGwgPT09IGZpYmVyLm1lbW9pemVkU3RhdGUgJiZcbiAgICAgICAgICAgICAgKGlzU3RyaWN0TW9kZUZpYmVyICYmIGZpYmVyLmZsYWdzICYgODE5MlxuICAgICAgICAgICAgICAgID8gcnVuV2l0aEZpYmVySW5ERVYoXG4gICAgICAgICAgICAgICAgICAgIGZpYmVyLFxuICAgICAgICAgICAgICAgICAgICBkb3VibGVJbnZva2VFZmZlY3RzT25GaWJlcixcbiAgICAgICAgICAgICAgICAgICAgcm9vdCxcbiAgICAgICAgICAgICAgICAgICAgZmliZXJcbiAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICA6IGZpYmVyLnN1YnRyZWVGbGFncyAmIDMzNTU0NDMyICYmXG4gICAgICAgICAgICAgICAgICBydW5XaXRoRmliZXJJbkRFVihcbiAgICAgICAgICAgICAgICAgICAgZmliZXIsXG4gICAgICAgICAgICAgICAgICAgIHJlY3Vyc2l2ZWx5VHJhdmVyc2VBbmREb3VibGVJbnZva2VFZmZlY3RzSW5ERVYsXG4gICAgICAgICAgICAgICAgICAgIHJvb3QsXG4gICAgICAgICAgICAgICAgICAgIGZpYmVyLFxuICAgICAgICAgICAgICAgICAgICBpc1N0cmljdE1vZGVGaWJlclxuICAgICAgICAgICAgICAgICAgKSk7XG4gICAgICAgICAgcGFyZW50RmliZXIgPSBwYXJlbnRGaWJlci5zaWJsaW5nO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGRvdWJsZUludm9rZUVmZmVjdHNPbkZpYmVyKHJvb3QsIGZpYmVyKSB7XG4gICAgICB2YXIgc2hvdWxkRG91YmxlSW52b2tlUGFzc2l2ZUVmZmVjdHMgPVxuICAgICAgICAyIDwgYXJndW1lbnRzLmxlbmd0aCAmJiB2b2lkIDAgIT09IGFyZ3VtZW50c1syXSA/IGFyZ3VtZW50c1syXSA6ICEwO1xuICAgICAgc2V0SXNTdHJpY3RNb2RlRm9yRGV2dG9vbHMoITApO1xuICAgICAgdHJ5IHtcbiAgICAgICAgZGlzYXBwZWFyTGF5b3V0RWZmZWN0cyhmaWJlciksXG4gICAgICAgICAgc2hvdWxkRG91YmxlSW52b2tlUGFzc2l2ZUVmZmVjdHMgJiYgZGlzY29ubmVjdFBhc3NpdmVFZmZlY3QoZmliZXIpLFxuICAgICAgICAgIHJlYXBwZWFyTGF5b3V0RWZmZWN0cyhyb290LCBmaWJlci5hbHRlcm5hdGUsIGZpYmVyLCAhMSksXG4gICAgICAgICAgc2hvdWxkRG91YmxlSW52b2tlUGFzc2l2ZUVmZmVjdHMgJiZcbiAgICAgICAgICAgIHJlY29ubmVjdFBhc3NpdmVFZmZlY3RzKHJvb3QsIGZpYmVyLCAwLCBudWxsLCAhMSk7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBzZXRJc1N0cmljdE1vZGVGb3JEZXZ0b29scyghMSk7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNvbW1pdERvdWJsZUludm9rZUVmZmVjdHNJbkRFVihyb290KSB7XG4gICAgICB2YXIgZG91YmxlSW52b2tlRWZmZWN0cyA9ICEwO1xuICAgICAgcm9vdC5jdXJyZW50Lm1vZGUgJiAyNCB8fCAoZG91YmxlSW52b2tlRWZmZWN0cyA9ICExKTtcbiAgICAgIHJlY3Vyc2l2ZWx5VHJhdmVyc2VBbmREb3VibGVJbnZva2VFZmZlY3RzSW5ERVYoXG4gICAgICAgIHJvb3QsXG4gICAgICAgIHJvb3QuY3VycmVudCxcbiAgICAgICAgZG91YmxlSW52b2tlRWZmZWN0c1xuICAgICAgKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gd2FybkFib3V0VXBkYXRlT25Ob3RZZXRNb3VudGVkRmliZXJJbkRFVihmaWJlcikge1xuICAgICAgaWYgKChleGVjdXRpb25Db250ZXh0ICYgUmVuZGVyQ29udGV4dCkgPT09IE5vQ29udGV4dCkge1xuICAgICAgICB2YXIgdGFnID0gZmliZXIudGFnO1xuICAgICAgICBpZiAoXG4gICAgICAgICAgMyA9PT0gdGFnIHx8XG4gICAgICAgICAgMSA9PT0gdGFnIHx8XG4gICAgICAgICAgMCA9PT0gdGFnIHx8XG4gICAgICAgICAgMTEgPT09IHRhZyB8fFxuICAgICAgICAgIDE0ID09PSB0YWcgfHxcbiAgICAgICAgICAxNSA9PT0gdGFnXG4gICAgICAgICkge1xuICAgICAgICAgIHRhZyA9IGdldENvbXBvbmVudE5hbWVGcm9tRmliZXIoZmliZXIpIHx8IFwiUmVhY3RDb21wb25lbnRcIjtcbiAgICAgICAgICBpZiAobnVsbCAhPT0gZGlkV2FyblN0YXRlVXBkYXRlRm9yTm90WWV0TW91bnRlZENvbXBvbmVudCkge1xuICAgICAgICAgICAgaWYgKGRpZFdhcm5TdGF0ZVVwZGF0ZUZvck5vdFlldE1vdW50ZWRDb21wb25lbnQuaGFzKHRhZykpIHJldHVybjtcbiAgICAgICAgICAgIGRpZFdhcm5TdGF0ZVVwZGF0ZUZvck5vdFlldE1vdW50ZWRDb21wb25lbnQuYWRkKHRhZyk7XG4gICAgICAgICAgfSBlbHNlIGRpZFdhcm5TdGF0ZVVwZGF0ZUZvck5vdFlldE1vdW50ZWRDb21wb25lbnQgPSBuZXcgU2V0KFt0YWddKTtcbiAgICAgICAgICBydW5XaXRoRmliZXJJbkRFVihmaWJlciwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgXCJDYW4ndCBwZXJmb3JtIGEgUmVhY3Qgc3RhdGUgdXBkYXRlIG9uIGEgY29tcG9uZW50IHRoYXQgaGFzbid0IG1vdW50ZWQgeWV0LiBUaGlzIGluZGljYXRlcyB0aGF0IHlvdSBoYXZlIGEgc2lkZS1lZmZlY3QgaW4geW91ciByZW5kZXIgZnVuY3Rpb24gdGhhdCBhc3luY2hyb25vdXNseSBsYXRlciBjYWxscyB0cmllcyB0byB1cGRhdGUgdGhlIGNvbXBvbmVudC4gTW92ZSB0aGlzIHdvcmsgdG8gdXNlRWZmZWN0IGluc3RlYWQuXCJcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gcmVzdG9yZVBlbmRpbmdVcGRhdGVycyhyb290LCBsYW5lcykge1xuICAgICAgaXNEZXZUb29sc1ByZXNlbnQgJiZcbiAgICAgICAgcm9vdC5tZW1vaXplZFVwZGF0ZXJzLmZvckVhY2goZnVuY3Rpb24gKHNjaGVkdWxpbmdGaWJlcikge1xuICAgICAgICAgIGFkZEZpYmVyVG9MYW5lc01hcChyb290LCBzY2hlZHVsaW5nRmliZXIsIGxhbmVzKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHNjaGVkdWxlQ2FsbGJhY2socHJpb3JpdHlMZXZlbCwgY2FsbGJhY2spIHtcbiAgICAgIHZhciBhY3RRdWV1ZSA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLmFjdFF1ZXVlO1xuICAgICAgcmV0dXJuIG51bGwgIT09IGFjdFF1ZXVlXG4gICAgICAgID8gKGFjdFF1ZXVlLnB1c2goY2FsbGJhY2spLCBmYWtlQWN0Q2FsbGJhY2tOb2RlKVxuICAgICAgICA6IHNjaGVkdWxlQ2FsbGJhY2skMyhwcmlvcml0eUxldmVsLCBjYWxsYmFjayk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHdhcm5JZlVwZGF0ZXNOb3RXcmFwcGVkV2l0aEFjdERFVihmaWJlcikge1xuICAgICAgaXNDb25jdXJyZW50QWN0RW52aXJvbm1lbnQoKSAmJlxuICAgICAgICBudWxsID09PSBSZWFjdFNoYXJlZEludGVybmFscy5hY3RRdWV1ZSAmJlxuICAgICAgICBydW5XaXRoRmliZXJJbkRFVihmaWJlciwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICBcIkFuIHVwZGF0ZSB0byAlcyBpbnNpZGUgYSB0ZXN0IHdhcyBub3Qgd3JhcHBlZCBpbiBhY3QoLi4uKS5cXG5cXG5XaGVuIHRlc3RpbmcsIGNvZGUgdGhhdCBjYXVzZXMgUmVhY3Qgc3RhdGUgdXBkYXRlcyBzaG91bGQgYmUgd3JhcHBlZCBpbnRvIGFjdCguLi4pOlxcblxcbmFjdCgoKSA9PiB7XFxuICAvKiBmaXJlIGV2ZW50cyB0aGF0IHVwZGF0ZSBzdGF0ZSAqL1xcbn0pO1xcbi8qIGFzc2VydCBvbiB0aGUgb3V0cHV0ICovXFxuXFxuVGhpcyBlbnN1cmVzIHRoYXQgeW91J3JlIHRlc3RpbmcgdGhlIGJlaGF2aW9yIHRoZSB1c2VyIHdvdWxkIHNlZSBpbiB0aGUgYnJvd3Nlci4gTGVhcm4gbW9yZSBhdCBodHRwczovL3JlYWN0LmRldi9saW5rL3dyYXAtdGVzdHMtd2l0aC1hY3RcIixcbiAgICAgICAgICAgIGdldENvbXBvbmVudE5hbWVGcm9tRmliZXIoZmliZXIpXG4gICAgICAgICAgKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlc29sdmVGdW5jdGlvbkZvckhvdFJlbG9hZGluZyh0eXBlKSB7XG4gICAgICBpZiAobnVsbCA9PT0gcmVzb2x2ZUZhbWlseSkgcmV0dXJuIHR5cGU7XG4gICAgICB2YXIgZmFtaWx5ID0gcmVzb2x2ZUZhbWlseSh0eXBlKTtcbiAgICAgIHJldHVybiB2b2lkIDAgPT09IGZhbWlseSA/IHR5cGUgOiBmYW1pbHkuY3VycmVudDtcbiAgICB9XG4gICAgZnVuY3Rpb24gcmVzb2x2ZUZvcndhcmRSZWZGb3JIb3RSZWxvYWRpbmcodHlwZSkge1xuICAgICAgaWYgKG51bGwgPT09IHJlc29sdmVGYW1pbHkpIHJldHVybiB0eXBlO1xuICAgICAgdmFyIGZhbWlseSA9IHJlc29sdmVGYW1pbHkodHlwZSk7XG4gICAgICByZXR1cm4gdm9pZCAwID09PSBmYW1pbHlcbiAgICAgICAgPyBudWxsICE9PSB0eXBlICYmXG4gICAgICAgICAgdm9pZCAwICE9PSB0eXBlICYmXG4gICAgICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgdHlwZS5yZW5kZXIgJiZcbiAgICAgICAgICAoKGZhbWlseSA9IHJlc29sdmVGdW5jdGlvbkZvckhvdFJlbG9hZGluZyh0eXBlLnJlbmRlcikpLFxuICAgICAgICAgIHR5cGUucmVuZGVyICE9PSBmYW1pbHkpXG4gICAgICAgICAgPyAoKGZhbWlseSA9IHsgJCR0eXBlb2Y6IFJFQUNUX0ZPUldBUkRfUkVGX1RZUEUsIHJlbmRlcjogZmFtaWx5IH0pLFxuICAgICAgICAgICAgdm9pZCAwICE9PSB0eXBlLmRpc3BsYXlOYW1lICYmXG4gICAgICAgICAgICAgIChmYW1pbHkuZGlzcGxheU5hbWUgPSB0eXBlLmRpc3BsYXlOYW1lKSxcbiAgICAgICAgICAgIGZhbWlseSlcbiAgICAgICAgICA6IHR5cGVcbiAgICAgICAgOiBmYW1pbHkuY3VycmVudDtcbiAgICB9XG4gICAgZnVuY3Rpb24gaXNDb21wYXRpYmxlRmFtaWx5Rm9ySG90UmVsb2FkaW5nKGZpYmVyLCBlbGVtZW50KSB7XG4gICAgICBpZiAobnVsbCA9PT0gcmVzb2x2ZUZhbWlseSkgcmV0dXJuICExO1xuICAgICAgdmFyIHByZXZUeXBlID0gZmliZXIuZWxlbWVudFR5cGU7XG4gICAgICBlbGVtZW50ID0gZWxlbWVudC50eXBlO1xuICAgICAgdmFyIG5lZWRzQ29tcGFyZUZhbWlsaWVzID0gITEsXG4gICAgICAgICQkdHlwZW9mTmV4dFR5cGUgPVxuICAgICAgICAgIFwib2JqZWN0XCIgPT09IHR5cGVvZiBlbGVtZW50ICYmIG51bGwgIT09IGVsZW1lbnRcbiAgICAgICAgICAgID8gZWxlbWVudC4kJHR5cGVvZlxuICAgICAgICAgICAgOiBudWxsO1xuICAgICAgc3dpdGNoIChmaWJlci50YWcpIHtcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIGVsZW1lbnQgJiYgKG5lZWRzQ29tcGFyZUZhbWlsaWVzID0gITApO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgZWxlbWVudFxuICAgICAgICAgICAgPyAobmVlZHNDb21wYXJlRmFtaWxpZXMgPSAhMClcbiAgICAgICAgICAgIDogJCR0eXBlb2ZOZXh0VHlwZSA9PT0gUkVBQ1RfTEFaWV9UWVBFICYmXG4gICAgICAgICAgICAgIChuZWVkc0NvbXBhcmVGYW1pbGllcyA9ICEwKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAxMTpcbiAgICAgICAgICAkJHR5cGVvZk5leHRUeXBlID09PSBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFXG4gICAgICAgICAgICA/IChuZWVkc0NvbXBhcmVGYW1pbGllcyA9ICEwKVxuICAgICAgICAgICAgOiAkJHR5cGVvZk5leHRUeXBlID09PSBSRUFDVF9MQVpZX1RZUEUgJiZcbiAgICAgICAgICAgICAgKG5lZWRzQ29tcGFyZUZhbWlsaWVzID0gITApO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDE0OlxuICAgICAgICBjYXNlIDE1OlxuICAgICAgICAgICQkdHlwZW9mTmV4dFR5cGUgPT09IFJFQUNUX01FTU9fVFlQRVxuICAgICAgICAgICAgPyAobmVlZHNDb21wYXJlRmFtaWxpZXMgPSAhMClcbiAgICAgICAgICAgIDogJCR0eXBlb2ZOZXh0VHlwZSA9PT0gUkVBQ1RfTEFaWV9UWVBFICYmXG4gICAgICAgICAgICAgIChuZWVkc0NvbXBhcmVGYW1pbGllcyA9ICEwKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICByZXR1cm4gITE7XG4gICAgICB9XG4gICAgICByZXR1cm4gbmVlZHNDb21wYXJlRmFtaWxpZXMgJiZcbiAgICAgICAgKChmaWJlciA9IHJlc29sdmVGYW1pbHkocHJldlR5cGUpKSxcbiAgICAgICAgdm9pZCAwICE9PSBmaWJlciAmJiBmaWJlciA9PT0gcmVzb2x2ZUZhbWlseShlbGVtZW50KSlcbiAgICAgICAgPyAhMFxuICAgICAgICA6ICExO1xuICAgIH1cbiAgICBmdW5jdGlvbiBtYXJrRmFpbGVkRXJyb3JCb3VuZGFyeUZvckhvdFJlbG9hZGluZyhmaWJlcikge1xuICAgICAgbnVsbCAhPT0gcmVzb2x2ZUZhbWlseSAmJlxuICAgICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBXZWFrU2V0ICYmXG4gICAgICAgIChudWxsID09PSBmYWlsZWRCb3VuZGFyaWVzICYmIChmYWlsZWRCb3VuZGFyaWVzID0gbmV3IFdlYWtTZXQoKSksXG4gICAgICAgIGZhaWxlZEJvdW5kYXJpZXMuYWRkKGZpYmVyKSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHNjaGVkdWxlRmliZXJzV2l0aEZhbWlsaWVzUmVjdXJzaXZlbHkoXG4gICAgICBmaWJlcixcbiAgICAgIHVwZGF0ZWRGYW1pbGllcyxcbiAgICAgIHN0YWxlRmFtaWxpZXNcbiAgICApIHtcbiAgICAgIHZhciBhbHRlcm5hdGUgPSBmaWJlci5hbHRlcm5hdGUsXG4gICAgICAgIGNoaWxkID0gZmliZXIuY2hpbGQsXG4gICAgICAgIHNpYmxpbmcgPSBmaWJlci5zaWJsaW5nLFxuICAgICAgICB0YWcgPSBmaWJlci50YWcsXG4gICAgICAgIHR5cGUgPSBmaWJlci50eXBlLFxuICAgICAgICBjYW5kaWRhdGVUeXBlID0gbnVsbDtcbiAgICAgIHN3aXRjaCAodGFnKSB7XG4gICAgICAgIGNhc2UgMDpcbiAgICAgICAgY2FzZSAxNTpcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgIGNhbmRpZGF0ZVR5cGUgPSB0eXBlO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDExOlxuICAgICAgICAgIGNhbmRpZGF0ZVR5cGUgPSB0eXBlLnJlbmRlcjtcbiAgICAgIH1cbiAgICAgIGlmIChudWxsID09PSByZXNvbHZlRmFtaWx5KVxuICAgICAgICB0aHJvdyBFcnJvcihcIkV4cGVjdGVkIHJlc29sdmVGYW1pbHkgdG8gYmUgc2V0IGR1cmluZyBob3QgcmVsb2FkLlwiKTtcbiAgICAgIHZhciBuZWVkc1JlbmRlciA9ICExO1xuICAgICAgdHlwZSA9ICExO1xuICAgICAgbnVsbCAhPT0gY2FuZGlkYXRlVHlwZSAmJlxuICAgICAgICAoKGNhbmRpZGF0ZVR5cGUgPSByZXNvbHZlRmFtaWx5KGNhbmRpZGF0ZVR5cGUpKSxcbiAgICAgICAgdm9pZCAwICE9PSBjYW5kaWRhdGVUeXBlICYmXG4gICAgICAgICAgKHN0YWxlRmFtaWxpZXMuaGFzKGNhbmRpZGF0ZVR5cGUpXG4gICAgICAgICAgICA/ICh0eXBlID0gITApXG4gICAgICAgICAgICA6IHVwZGF0ZWRGYW1pbGllcy5oYXMoY2FuZGlkYXRlVHlwZSkgJiZcbiAgICAgICAgICAgICAgKDEgPT09IHRhZyA/ICh0eXBlID0gITApIDogKG5lZWRzUmVuZGVyID0gITApKSkpO1xuICAgICAgbnVsbCAhPT0gZmFpbGVkQm91bmRhcmllcyAmJlxuICAgICAgICAoZmFpbGVkQm91bmRhcmllcy5oYXMoZmliZXIpIHx8XG4gICAgICAgICAgKG51bGwgIT09IGFsdGVybmF0ZSAmJiBmYWlsZWRCb3VuZGFyaWVzLmhhcyhhbHRlcm5hdGUpKSkgJiZcbiAgICAgICAgKHR5cGUgPSAhMCk7XG4gICAgICB0eXBlICYmIChmaWJlci5fZGVidWdOZWVkc1JlbW91bnQgPSAhMCk7XG4gICAgICBpZiAodHlwZSB8fCBuZWVkc1JlbmRlcilcbiAgICAgICAgKGFsdGVybmF0ZSA9IGVucXVldWVDb25jdXJyZW50UmVuZGVyRm9yTGFuZShmaWJlciwgMikpLFxuICAgICAgICAgIG51bGwgIT09IGFsdGVybmF0ZSAmJiBzY2hlZHVsZVVwZGF0ZU9uRmliZXIoYWx0ZXJuYXRlLCBmaWJlciwgMik7XG4gICAgICBudWxsID09PSBjaGlsZCB8fFxuICAgICAgICB0eXBlIHx8XG4gICAgICAgIHNjaGVkdWxlRmliZXJzV2l0aEZhbWlsaWVzUmVjdXJzaXZlbHkoXG4gICAgICAgICAgY2hpbGQsXG4gICAgICAgICAgdXBkYXRlZEZhbWlsaWVzLFxuICAgICAgICAgIHN0YWxlRmFtaWxpZXNcbiAgICAgICAgKTtcbiAgICAgIG51bGwgIT09IHNpYmxpbmcgJiZcbiAgICAgICAgc2NoZWR1bGVGaWJlcnNXaXRoRmFtaWxpZXNSZWN1cnNpdmVseShcbiAgICAgICAgICBzaWJsaW5nLFxuICAgICAgICAgIHVwZGF0ZWRGYW1pbGllcyxcbiAgICAgICAgICBzdGFsZUZhbWlsaWVzXG4gICAgICAgICk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIEZpYmVyTm9kZSh0YWcsIHBlbmRpbmdQcm9wcywga2V5LCBtb2RlKSB7XG4gICAgICB0aGlzLnRhZyA9IHRhZztcbiAgICAgIHRoaXMua2V5ID0ga2V5O1xuICAgICAgdGhpcy5zaWJsaW5nID1cbiAgICAgICAgdGhpcy5jaGlsZCA9XG4gICAgICAgIHRoaXMucmV0dXJuID1cbiAgICAgICAgdGhpcy5zdGF0ZU5vZGUgPVxuICAgICAgICB0aGlzLnR5cGUgPVxuICAgICAgICB0aGlzLmVsZW1lbnRUeXBlID1cbiAgICAgICAgICBudWxsO1xuICAgICAgdGhpcy5pbmRleCA9IDA7XG4gICAgICB0aGlzLnJlZkNsZWFudXAgPSB0aGlzLnJlZiA9IG51bGw7XG4gICAgICB0aGlzLnBlbmRpbmdQcm9wcyA9IHBlbmRpbmdQcm9wcztcbiAgICAgIHRoaXMuZGVwZW5kZW5jaWVzID1cbiAgICAgICAgdGhpcy5tZW1vaXplZFN0YXRlID1cbiAgICAgICAgdGhpcy51cGRhdGVRdWV1ZSA9XG4gICAgICAgIHRoaXMubWVtb2l6ZWRQcm9wcyA9XG4gICAgICAgICAgbnVsbDtcbiAgICAgIHRoaXMubW9kZSA9IG1vZGU7XG4gICAgICB0aGlzLnN1YnRyZWVGbGFncyA9IHRoaXMuZmxhZ3MgPSAwO1xuICAgICAgdGhpcy5kZWxldGlvbnMgPSBudWxsO1xuICAgICAgdGhpcy5jaGlsZExhbmVzID0gdGhpcy5sYW5lcyA9IDA7XG4gICAgICB0aGlzLmFsdGVybmF0ZSA9IG51bGw7XG4gICAgICB0aGlzLmFjdHVhbER1cmF0aW9uID0gLTA7XG4gICAgICB0aGlzLmFjdHVhbFN0YXJ0VGltZSA9IC0xLjE7XG4gICAgICB0aGlzLnRyZWVCYXNlRHVyYXRpb24gPSB0aGlzLnNlbGZCYXNlRHVyYXRpb24gPSAtMDtcbiAgICAgIHRoaXMuX2RlYnVnT3duZXIgPSB0aGlzLl9kZWJ1Z0luZm8gPSBudWxsO1xuICAgICAgdGhpcy5fZGVidWdOZWVkc1JlbW91bnQgPSAhMTtcbiAgICAgIHRoaXMuX2RlYnVnSG9va1R5cGVzID0gbnVsbDtcbiAgICAgIGhhc0JhZE1hcFBvbHlmaWxsIHx8XG4gICAgICAgIFwiZnVuY3Rpb25cIiAhPT0gdHlwZW9mIE9iamVjdC5wcmV2ZW50RXh0ZW5zaW9ucyB8fFxuICAgICAgICBPYmplY3QucHJldmVudEV4dGVuc2lvbnModGhpcyk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHNob3VsZENvbnN0cnVjdChDb21wb25lbnQpIHtcbiAgICAgIENvbXBvbmVudCA9IENvbXBvbmVudC5wcm90b3R5cGU7XG4gICAgICByZXR1cm4gISghQ29tcG9uZW50IHx8ICFDb21wb25lbnQuaXNSZWFjdENvbXBvbmVudCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNyZWF0ZVdvcmtJblByb2dyZXNzKGN1cnJlbnQsIHBlbmRpbmdQcm9wcykge1xuICAgICAgdmFyIHdvcmtJblByb2dyZXNzID0gY3VycmVudC5hbHRlcm5hdGU7XG4gICAgICBudWxsID09PSB3b3JrSW5Qcm9ncmVzc1xuICAgICAgICA/ICgod29ya0luUHJvZ3Jlc3MgPSBjcmVhdGVGaWJlcihcbiAgICAgICAgICAgIGN1cnJlbnQudGFnLFxuICAgICAgICAgICAgcGVuZGluZ1Byb3BzLFxuICAgICAgICAgICAgY3VycmVudC5rZXksXG4gICAgICAgICAgICBjdXJyZW50Lm1vZGVcbiAgICAgICAgICApKSxcbiAgICAgICAgICAod29ya0luUHJvZ3Jlc3MuZWxlbWVudFR5cGUgPSBjdXJyZW50LmVsZW1lbnRUeXBlKSxcbiAgICAgICAgICAod29ya0luUHJvZ3Jlc3MudHlwZSA9IGN1cnJlbnQudHlwZSksXG4gICAgICAgICAgKHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZSA9IGN1cnJlbnQuc3RhdGVOb2RlKSxcbiAgICAgICAgICAod29ya0luUHJvZ3Jlc3MuX2RlYnVnT3duZXIgPSBjdXJyZW50Ll9kZWJ1Z093bmVyKSxcbiAgICAgICAgICAod29ya0luUHJvZ3Jlc3MuX2RlYnVnSG9va1R5cGVzID0gY3VycmVudC5fZGVidWdIb29rVHlwZXMpLFxuICAgICAgICAgICh3b3JrSW5Qcm9ncmVzcy5hbHRlcm5hdGUgPSBjdXJyZW50KSxcbiAgICAgICAgICAoY3VycmVudC5hbHRlcm5hdGUgPSB3b3JrSW5Qcm9ncmVzcykpXG4gICAgICAgIDogKCh3b3JrSW5Qcm9ncmVzcy5wZW5kaW5nUHJvcHMgPSBwZW5kaW5nUHJvcHMpLFxuICAgICAgICAgICh3b3JrSW5Qcm9ncmVzcy50eXBlID0gY3VycmVudC50eXBlKSxcbiAgICAgICAgICAod29ya0luUHJvZ3Jlc3MuZmxhZ3MgPSAwKSxcbiAgICAgICAgICAod29ya0luUHJvZ3Jlc3Muc3VidHJlZUZsYWdzID0gMCksXG4gICAgICAgICAgKHdvcmtJblByb2dyZXNzLmRlbGV0aW9ucyA9IG51bGwpLFxuICAgICAgICAgICh3b3JrSW5Qcm9ncmVzcy5hY3R1YWxEdXJhdGlvbiA9IC0wKSxcbiAgICAgICAgICAod29ya0luUHJvZ3Jlc3MuYWN0dWFsU3RhcnRUaW1lID0gLTEuMSkpO1xuICAgICAgd29ya0luUHJvZ3Jlc3MuZmxhZ3MgPSBjdXJyZW50LmZsYWdzICYgMzE0NTcyODA7XG4gICAgICB3b3JrSW5Qcm9ncmVzcy5jaGlsZExhbmVzID0gY3VycmVudC5jaGlsZExhbmVzO1xuICAgICAgd29ya0luUHJvZ3Jlc3MubGFuZXMgPSBjdXJyZW50LmxhbmVzO1xuICAgICAgd29ya0luUHJvZ3Jlc3MuY2hpbGQgPSBjdXJyZW50LmNoaWxkO1xuICAgICAgd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRQcm9wcyA9IGN1cnJlbnQubWVtb2l6ZWRQcm9wcztcbiAgICAgIHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGUgPSBjdXJyZW50Lm1lbW9pemVkU3RhdGU7XG4gICAgICB3b3JrSW5Qcm9ncmVzcy51cGRhdGVRdWV1ZSA9IGN1cnJlbnQudXBkYXRlUXVldWU7XG4gICAgICBwZW5kaW5nUHJvcHMgPSBjdXJyZW50LmRlcGVuZGVuY2llcztcbiAgICAgIHdvcmtJblByb2dyZXNzLmRlcGVuZGVuY2llcyA9XG4gICAgICAgIG51bGwgPT09IHBlbmRpbmdQcm9wc1xuICAgICAgICAgID8gbnVsbFxuICAgICAgICAgIDoge1xuICAgICAgICAgICAgICBsYW5lczogcGVuZGluZ1Byb3BzLmxhbmVzLFxuICAgICAgICAgICAgICBmaXJzdENvbnRleHQ6IHBlbmRpbmdQcm9wcy5maXJzdENvbnRleHQsXG4gICAgICAgICAgICAgIF9kZWJ1Z1RoZW5hYmxlU3RhdGU6IHBlbmRpbmdQcm9wcy5fZGVidWdUaGVuYWJsZVN0YXRlXG4gICAgICAgICAgICB9O1xuICAgICAgd29ya0luUHJvZ3Jlc3Muc2libGluZyA9IGN1cnJlbnQuc2libGluZztcbiAgICAgIHdvcmtJblByb2dyZXNzLmluZGV4ID0gY3VycmVudC5pbmRleDtcbiAgICAgIHdvcmtJblByb2dyZXNzLnJlZiA9IGN1cnJlbnQucmVmO1xuICAgICAgd29ya0luUHJvZ3Jlc3MucmVmQ2xlYW51cCA9IGN1cnJlbnQucmVmQ2xlYW51cDtcbiAgICAgIHdvcmtJblByb2dyZXNzLnNlbGZCYXNlRHVyYXRpb24gPSBjdXJyZW50LnNlbGZCYXNlRHVyYXRpb247XG4gICAgICB3b3JrSW5Qcm9ncmVzcy50cmVlQmFzZUR1cmF0aW9uID0gY3VycmVudC50cmVlQmFzZUR1cmF0aW9uO1xuICAgICAgd29ya0luUHJvZ3Jlc3MuX2RlYnVnSW5mbyA9IGN1cnJlbnQuX2RlYnVnSW5mbztcbiAgICAgIHdvcmtJblByb2dyZXNzLl9kZWJ1Z05lZWRzUmVtb3VudCA9IGN1cnJlbnQuX2RlYnVnTmVlZHNSZW1vdW50O1xuICAgICAgc3dpdGNoICh3b3JrSW5Qcm9ncmVzcy50YWcpIHtcbiAgICAgICAgY2FzZSAwOlxuICAgICAgICBjYXNlIDE1OlxuICAgICAgICAgIHdvcmtJblByb2dyZXNzLnR5cGUgPSByZXNvbHZlRnVuY3Rpb25Gb3JIb3RSZWxvYWRpbmcoY3VycmVudC50eXBlKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgIHdvcmtJblByb2dyZXNzLnR5cGUgPSByZXNvbHZlRnVuY3Rpb25Gb3JIb3RSZWxvYWRpbmcoY3VycmVudC50eXBlKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAxMTpcbiAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy50eXBlID0gcmVzb2x2ZUZvcndhcmRSZWZGb3JIb3RSZWxvYWRpbmcoY3VycmVudC50eXBlKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB3b3JrSW5Qcm9ncmVzcztcbiAgICB9XG4gICAgZnVuY3Rpb24gcmVzZXRXb3JrSW5Qcm9ncmVzcyh3b3JrSW5Qcm9ncmVzcywgcmVuZGVyTGFuZXMpIHtcbiAgICAgIHdvcmtJblByb2dyZXNzLmZsYWdzICY9IDMxNDU3MjgyO1xuICAgICAgdmFyIGN1cnJlbnQgPSB3b3JrSW5Qcm9ncmVzcy5hbHRlcm5hdGU7XG4gICAgICBudWxsID09PSBjdXJyZW50XG4gICAgICAgID8gKCh3b3JrSW5Qcm9ncmVzcy5jaGlsZExhbmVzID0gMCksXG4gICAgICAgICAgKHdvcmtJblByb2dyZXNzLmxhbmVzID0gcmVuZGVyTGFuZXMpLFxuICAgICAgICAgICh3b3JrSW5Qcm9ncmVzcy5jaGlsZCA9IG51bGwpLFxuICAgICAgICAgICh3b3JrSW5Qcm9ncmVzcy5zdWJ0cmVlRmxhZ3MgPSAwKSxcbiAgICAgICAgICAod29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRQcm9wcyA9IG51bGwpLFxuICAgICAgICAgICh3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlID0gbnVsbCksXG4gICAgICAgICAgKHdvcmtJblByb2dyZXNzLnVwZGF0ZVF1ZXVlID0gbnVsbCksXG4gICAgICAgICAgKHdvcmtJblByb2dyZXNzLmRlcGVuZGVuY2llcyA9IG51bGwpLFxuICAgICAgICAgICh3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGUgPSBudWxsKSxcbiAgICAgICAgICAod29ya0luUHJvZ3Jlc3Muc2VsZkJhc2VEdXJhdGlvbiA9IDApLFxuICAgICAgICAgICh3b3JrSW5Qcm9ncmVzcy50cmVlQmFzZUR1cmF0aW9uID0gMCkpXG4gICAgICAgIDogKCh3b3JrSW5Qcm9ncmVzcy5jaGlsZExhbmVzID0gY3VycmVudC5jaGlsZExhbmVzKSxcbiAgICAgICAgICAod29ya0luUHJvZ3Jlc3MubGFuZXMgPSBjdXJyZW50LmxhbmVzKSxcbiAgICAgICAgICAod29ya0luUHJvZ3Jlc3MuY2hpbGQgPSBjdXJyZW50LmNoaWxkKSxcbiAgICAgICAgICAod29ya0luUHJvZ3Jlc3Muc3VidHJlZUZsYWdzID0gMCksXG4gICAgICAgICAgKHdvcmtJblByb2dyZXNzLmRlbGV0aW9ucyA9IG51bGwpLFxuICAgICAgICAgICh3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFByb3BzID0gY3VycmVudC5tZW1vaXplZFByb3BzKSxcbiAgICAgICAgICAod29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZSA9IGN1cnJlbnQubWVtb2l6ZWRTdGF0ZSksXG4gICAgICAgICAgKHdvcmtJblByb2dyZXNzLnVwZGF0ZVF1ZXVlID0gY3VycmVudC51cGRhdGVRdWV1ZSksXG4gICAgICAgICAgKHdvcmtJblByb2dyZXNzLnR5cGUgPSBjdXJyZW50LnR5cGUpLFxuICAgICAgICAgIChyZW5kZXJMYW5lcyA9IGN1cnJlbnQuZGVwZW5kZW5jaWVzKSxcbiAgICAgICAgICAod29ya0luUHJvZ3Jlc3MuZGVwZW5kZW5jaWVzID1cbiAgICAgICAgICAgIG51bGwgPT09IHJlbmRlckxhbmVzXG4gICAgICAgICAgICAgID8gbnVsbFxuICAgICAgICAgICAgICA6IHtcbiAgICAgICAgICAgICAgICAgIGxhbmVzOiByZW5kZXJMYW5lcy5sYW5lcyxcbiAgICAgICAgICAgICAgICAgIGZpcnN0Q29udGV4dDogcmVuZGVyTGFuZXMuZmlyc3RDb250ZXh0LFxuICAgICAgICAgICAgICAgICAgX2RlYnVnVGhlbmFibGVTdGF0ZTogcmVuZGVyTGFuZXMuX2RlYnVnVGhlbmFibGVTdGF0ZVxuICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICh3b3JrSW5Qcm9ncmVzcy5zZWxmQmFzZUR1cmF0aW9uID0gY3VycmVudC5zZWxmQmFzZUR1cmF0aW9uKSxcbiAgICAgICAgICAod29ya0luUHJvZ3Jlc3MudHJlZUJhc2VEdXJhdGlvbiA9IGN1cnJlbnQudHJlZUJhc2VEdXJhdGlvbikpO1xuICAgICAgcmV0dXJuIHdvcmtJblByb2dyZXNzO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjcmVhdGVGaWJlckZyb21UeXBlQW5kUHJvcHMoXG4gICAgICB0eXBlLFxuICAgICAga2V5LFxuICAgICAgcGVuZGluZ1Byb3BzLFxuICAgICAgb3duZXIsXG4gICAgICBtb2RlLFxuICAgICAgbGFuZXNcbiAgICApIHtcbiAgICAgIHZhciBmaWJlclRhZyA9IDAsXG4gICAgICAgIHJlc29sdmVkVHlwZSA9IHR5cGU7XG4gICAgICBpZiAoXCJmdW5jdGlvblwiID09PSB0eXBlb2YgdHlwZSlcbiAgICAgICAgc2hvdWxkQ29uc3RydWN0KHR5cGUpICYmIChmaWJlclRhZyA9IDEpLFxuICAgICAgICAgIChyZXNvbHZlZFR5cGUgPSByZXNvbHZlRnVuY3Rpb25Gb3JIb3RSZWxvYWRpbmcocmVzb2x2ZWRUeXBlKSk7XG4gICAgICBlbHNlIGlmIChcInN0cmluZ1wiID09PSB0eXBlb2YgdHlwZSlcbiAgICAgICAgc3VwcG9ydHNSZXNvdXJjZXMgJiYgc3VwcG9ydHNTaW5nbGV0b25zXG4gICAgICAgICAgPyAoKGZpYmVyVGFnID0gZ2V0SG9zdENvbnRleHQoKSksXG4gICAgICAgICAgICAoZmliZXJUYWcgPSBpc0hvc3RIb2lzdGFibGVUeXBlKHR5cGUsIHBlbmRpbmdQcm9wcywgZmliZXJUYWcpXG4gICAgICAgICAgICAgID8gMjZcbiAgICAgICAgICAgICAgOiBpc0hvc3RTaW5nbGV0b25UeXBlKHR5cGUpXG4gICAgICAgICAgICAgICAgPyAyN1xuICAgICAgICAgICAgICAgIDogNSkpXG4gICAgICAgICAgOiBzdXBwb3J0c1Jlc291cmNlc1xuICAgICAgICAgICAgPyAoKGZpYmVyVGFnID0gZ2V0SG9zdENvbnRleHQoKSksXG4gICAgICAgICAgICAgIChmaWJlclRhZyA9IGlzSG9zdEhvaXN0YWJsZVR5cGUodHlwZSwgcGVuZGluZ1Byb3BzLCBmaWJlclRhZylcbiAgICAgICAgICAgICAgICA/IDI2XG4gICAgICAgICAgICAgICAgOiA1KSlcbiAgICAgICAgICAgIDogKGZpYmVyVGFnID0gc3VwcG9ydHNTaW5nbGV0b25zXG4gICAgICAgICAgICAgICAgPyBpc0hvc3RTaW5nbGV0b25UeXBlKHR5cGUpXG4gICAgICAgICAgICAgICAgICA/IDI3XG4gICAgICAgICAgICAgICAgICA6IDVcbiAgICAgICAgICAgICAgICA6IDUpO1xuICAgICAgZWxzZVxuICAgICAgICBhOiBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgICBjYXNlIFJFQUNUX0ZSQUdNRU5UX1RZUEU6XG4gICAgICAgICAgICByZXR1cm4gY3JlYXRlRmliZXJGcm9tRnJhZ21lbnQoXG4gICAgICAgICAgICAgIHBlbmRpbmdQcm9wcy5jaGlsZHJlbixcbiAgICAgICAgICAgICAgbW9kZSxcbiAgICAgICAgICAgICAgbGFuZXMsXG4gICAgICAgICAgICAgIGtleVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICBjYXNlIFJFQUNUX1NUUklDVF9NT0RFX1RZUEU6XG4gICAgICAgICAgICBmaWJlclRhZyA9IDg7XG4gICAgICAgICAgICBtb2RlIHw9IDI0O1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBSRUFDVF9QUk9GSUxFUl9UWVBFOlxuICAgICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICAgKHR5cGUgPSBwZW5kaW5nUHJvcHMpLFxuICAgICAgICAgICAgICAob3duZXIgPSBtb2RlKSxcbiAgICAgICAgICAgICAgXCJzdHJpbmdcIiAhPT0gdHlwZW9mIHR5cGUuaWQgJiZcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICAgICAgJ1Byb2ZpbGVyIG11c3Qgc3BlY2lmeSBhbiBcImlkXCIgb2YgdHlwZSBgc3RyaW5nYCBhcyBhIHByb3AuIFJlY2VpdmVkIHRoZSB0eXBlIGAlc2AgaW5zdGVhZC4nLFxuICAgICAgICAgICAgICAgICAgdHlwZW9mIHR5cGUuaWRcbiAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAoa2V5ID0gY3JlYXRlRmliZXIoMTIsIHR5cGUsIGtleSwgb3duZXIgfCAyKSksXG4gICAgICAgICAgICAgIChrZXkuZWxlbWVudFR5cGUgPSBSRUFDVF9QUk9GSUxFUl9UWVBFKSxcbiAgICAgICAgICAgICAgKGtleS5sYW5lcyA9IGxhbmVzKSxcbiAgICAgICAgICAgICAgKGtleS5zdGF0ZU5vZGUgPSB7IGVmZmVjdER1cmF0aW9uOiAwLCBwYXNzaXZlRWZmZWN0RHVyYXRpb246IDAgfSksXG4gICAgICAgICAgICAgIGtleVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICBjYXNlIFJFQUNUX1NVU1BFTlNFX1RZUEU6XG4gICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICAoa2V5ID0gY3JlYXRlRmliZXIoMTMsIHBlbmRpbmdQcm9wcywga2V5LCBtb2RlKSksXG4gICAgICAgICAgICAgIChrZXkuZWxlbWVudFR5cGUgPSBSRUFDVF9TVVNQRU5TRV9UWVBFKSxcbiAgICAgICAgICAgICAgKGtleS5sYW5lcyA9IGxhbmVzKSxcbiAgICAgICAgICAgICAga2V5XG4gICAgICAgICAgICApO1xuICAgICAgICAgIGNhc2UgUkVBQ1RfU1VTUEVOU0VfTElTVF9UWVBFOlxuICAgICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICAgKGtleSA9IGNyZWF0ZUZpYmVyKDE5LCBwZW5kaW5nUHJvcHMsIGtleSwgbW9kZSkpLFxuICAgICAgICAgICAgICAoa2V5LmVsZW1lbnRUeXBlID0gUkVBQ1RfU1VTUEVOU0VfTElTVF9UWVBFKSxcbiAgICAgICAgICAgICAgKGtleS5sYW5lcyA9IGxhbmVzKSxcbiAgICAgICAgICAgICAga2V5XG4gICAgICAgICAgICApO1xuICAgICAgICAgIGNhc2UgUkVBQ1RfT0ZGU0NSRUVOX1RZUEU6XG4gICAgICAgICAgICByZXR1cm4gY3JlYXRlRmliZXJGcm9tT2Zmc2NyZWVuKHBlbmRpbmdQcm9wcywgbW9kZSwgbGFuZXMsIGtleSk7XG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIGlmIChcIm9iamVjdFwiID09PSB0eXBlb2YgdHlwZSAmJiBudWxsICE9PSB0eXBlKVxuICAgICAgICAgICAgICBzd2l0Y2ggKHR5cGUuJCR0eXBlb2YpIHtcbiAgICAgICAgICAgICAgICBjYXNlIFJFQUNUX1BST1ZJREVSX1RZUEU6XG4gICAgICAgICAgICAgICAgY2FzZSBSRUFDVF9DT05URVhUX1RZUEU6XG4gICAgICAgICAgICAgICAgICBmaWJlclRhZyA9IDEwO1xuICAgICAgICAgICAgICAgICAgYnJlYWsgYTtcbiAgICAgICAgICAgICAgICBjYXNlIFJFQUNUX0NPTlNVTUVSX1RZUEU6XG4gICAgICAgICAgICAgICAgICBmaWJlclRhZyA9IDk7XG4gICAgICAgICAgICAgICAgICBicmVhayBhO1xuICAgICAgICAgICAgICAgIGNhc2UgUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRTpcbiAgICAgICAgICAgICAgICAgIGZpYmVyVGFnID0gMTE7XG4gICAgICAgICAgICAgICAgICByZXNvbHZlZFR5cGUgPSByZXNvbHZlRm9yd2FyZFJlZkZvckhvdFJlbG9hZGluZyhyZXNvbHZlZFR5cGUpO1xuICAgICAgICAgICAgICAgICAgYnJlYWsgYTtcbiAgICAgICAgICAgICAgICBjYXNlIFJFQUNUX01FTU9fVFlQRTpcbiAgICAgICAgICAgICAgICAgIGZpYmVyVGFnID0gMTQ7XG4gICAgICAgICAgICAgICAgICBicmVhayBhO1xuICAgICAgICAgICAgICAgIGNhc2UgUkVBQ1RfTEFaWV9UWVBFOlxuICAgICAgICAgICAgICAgICAgZmliZXJUYWcgPSAxNjtcbiAgICAgICAgICAgICAgICAgIHJlc29sdmVkVHlwZSA9IG51bGw7XG4gICAgICAgICAgICAgICAgICBicmVhayBhO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICByZXNvbHZlZFR5cGUgPSBcIlwiO1xuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICB2b2lkIDAgPT09IHR5cGUgfHxcbiAgICAgICAgICAgICAgKFwib2JqZWN0XCIgPT09IHR5cGVvZiB0eXBlICYmXG4gICAgICAgICAgICAgICAgbnVsbCAhPT0gdHlwZSAmJlxuICAgICAgICAgICAgICAgIDAgPT09IE9iamVjdC5rZXlzKHR5cGUpLmxlbmd0aClcbiAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgcmVzb2x2ZWRUeXBlICs9XG4gICAgICAgICAgICAgICAgXCIgWW91IGxpa2VseSBmb3Jnb3QgdG8gZXhwb3J0IHlvdXIgY29tcG9uZW50IGZyb20gdGhlIGZpbGUgaXQncyBkZWZpbmVkIGluLCBvciB5b3UgbWlnaHQgaGF2ZSBtaXhlZCB1cCBkZWZhdWx0IGFuZCBuYW1lZCBpbXBvcnRzLlwiO1xuICAgICAgICAgICAgbnVsbCA9PT0gdHlwZVxuICAgICAgICAgICAgICA/IChwZW5kaW5nUHJvcHMgPSBcIm51bGxcIilcbiAgICAgICAgICAgICAgOiBpc0FycmF5SW1wbCh0eXBlKVxuICAgICAgICAgICAgICAgID8gKHBlbmRpbmdQcm9wcyA9IFwiYXJyYXlcIilcbiAgICAgICAgICAgICAgICA6IHZvaWQgMCAhPT0gdHlwZSAmJiB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9FTEVNRU5UX1RZUEVcbiAgICAgICAgICAgICAgICAgID8gKChwZW5kaW5nUHJvcHMgPVxuICAgICAgICAgICAgICAgICAgICAgIFwiPFwiICtcbiAgICAgICAgICAgICAgICAgICAgICAoZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUudHlwZSkgfHwgXCJVbmtub3duXCIpICtcbiAgICAgICAgICAgICAgICAgICAgICBcIiAvPlwiKSxcbiAgICAgICAgICAgICAgICAgICAgKHJlc29sdmVkVHlwZSA9XG4gICAgICAgICAgICAgICAgICAgICAgXCIgRGlkIHlvdSBhY2NpZGVudGFsbHkgZXhwb3J0IGEgSlNYIGxpdGVyYWwgaW5zdGVhZCBvZiBhIGNvbXBvbmVudD9cIikpXG4gICAgICAgICAgICAgICAgICA6IChwZW5kaW5nUHJvcHMgPSB0eXBlb2YgdHlwZSk7XG4gICAgICAgICAgICBmaWJlclRhZyA9IG93bmVyXG4gICAgICAgICAgICAgID8gXCJudW1iZXJcIiA9PT0gdHlwZW9mIG93bmVyLnRhZ1xuICAgICAgICAgICAgICAgID8gZ2V0Q29tcG9uZW50TmFtZUZyb21GaWJlcihvd25lcilcbiAgICAgICAgICAgICAgICA6IFwic3RyaW5nXCIgPT09IHR5cGVvZiBvd25lci5uYW1lXG4gICAgICAgICAgICAgICAgICA/IG93bmVyLm5hbWVcbiAgICAgICAgICAgICAgICAgIDogbnVsbFxuICAgICAgICAgICAgICA6IG51bGw7XG4gICAgICAgICAgICBmaWJlclRhZyAmJlxuICAgICAgICAgICAgICAocmVzb2x2ZWRUeXBlICs9XG4gICAgICAgICAgICAgICAgXCJcXG5cXG5DaGVjayB0aGUgcmVuZGVyIG1ldGhvZCBvZiBgXCIgKyBmaWJlclRhZyArIFwiYC5cIik7XG4gICAgICAgICAgICBmaWJlclRhZyA9IDI5O1xuICAgICAgICAgICAgcGVuZGluZ1Byb3BzID0gRXJyb3IoXG4gICAgICAgICAgICAgIFwiRWxlbWVudCB0eXBlIGlzIGludmFsaWQ6IGV4cGVjdGVkIGEgc3RyaW5nIChmb3IgYnVpbHQtaW4gY29tcG9uZW50cykgb3IgYSBjbGFzcy9mdW5jdGlvbiAoZm9yIGNvbXBvc2l0ZSBjb21wb25lbnRzKSBidXQgZ290OiBcIiArXG4gICAgICAgICAgICAgICAgKHBlbmRpbmdQcm9wcyArIFwiLlwiICsgcmVzb2x2ZWRUeXBlKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIHJlc29sdmVkVHlwZSA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgIGtleSA9IGNyZWF0ZUZpYmVyKGZpYmVyVGFnLCBwZW5kaW5nUHJvcHMsIGtleSwgbW9kZSk7XG4gICAgICBrZXkuZWxlbWVudFR5cGUgPSB0eXBlO1xuICAgICAga2V5LnR5cGUgPSByZXNvbHZlZFR5cGU7XG4gICAgICBrZXkubGFuZXMgPSBsYW5lcztcbiAgICAgIGtleS5fZGVidWdPd25lciA9IG93bmVyO1xuICAgICAgcmV0dXJuIGtleTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY3JlYXRlRmliZXJGcm9tRWxlbWVudChlbGVtZW50LCBtb2RlLCBsYW5lcykge1xuICAgICAgbW9kZSA9IGNyZWF0ZUZpYmVyRnJvbVR5cGVBbmRQcm9wcyhcbiAgICAgICAgZWxlbWVudC50eXBlLFxuICAgICAgICBlbGVtZW50LmtleSxcbiAgICAgICAgZWxlbWVudC5wcm9wcyxcbiAgICAgICAgZWxlbWVudC5fb3duZXIsXG4gICAgICAgIG1vZGUsXG4gICAgICAgIGxhbmVzXG4gICAgICApO1xuICAgICAgbW9kZS5fZGVidWdPd25lciA9IGVsZW1lbnQuX293bmVyO1xuICAgICAgcmV0dXJuIG1vZGU7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNyZWF0ZUZpYmVyRnJvbUZyYWdtZW50KGVsZW1lbnRzLCBtb2RlLCBsYW5lcywga2V5KSB7XG4gICAgICBlbGVtZW50cyA9IGNyZWF0ZUZpYmVyKDcsIGVsZW1lbnRzLCBrZXksIG1vZGUpO1xuICAgICAgZWxlbWVudHMubGFuZXMgPSBsYW5lcztcbiAgICAgIHJldHVybiBlbGVtZW50cztcbiAgICB9XG4gICAgZnVuY3Rpb24gY3JlYXRlRmliZXJGcm9tT2Zmc2NyZWVuKHBlbmRpbmdQcm9wcywgbW9kZSwgbGFuZXMsIGtleSkge1xuICAgICAgcGVuZGluZ1Byb3BzID0gY3JlYXRlRmliZXIoMjIsIHBlbmRpbmdQcm9wcywga2V5LCBtb2RlKTtcbiAgICAgIHBlbmRpbmdQcm9wcy5lbGVtZW50VHlwZSA9IFJFQUNUX09GRlNDUkVFTl9UWVBFO1xuICAgICAgcGVuZGluZ1Byb3BzLmxhbmVzID0gbGFuZXM7XG4gICAgICB2YXIgcHJpbWFyeUNoaWxkSW5zdGFuY2UgPSB7XG4gICAgICAgIF92aXNpYmlsaXR5OiAxLFxuICAgICAgICBfcGVuZGluZ1Zpc2liaWxpdHk6IDEsXG4gICAgICAgIF9wZW5kaW5nTWFya2VyczogbnVsbCxcbiAgICAgICAgX3JldHJ5Q2FjaGU6IG51bGwsXG4gICAgICAgIF90cmFuc2l0aW9uczogbnVsbCxcbiAgICAgICAgX2N1cnJlbnQ6IG51bGwsXG4gICAgICAgIGRldGFjaDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHZhciBpbnN0YW5jZSA9IHByaW1hcnlDaGlsZEluc3RhbmNlLFxuICAgICAgICAgICAgZmliZXIgPSBpbnN0YW5jZS5fY3VycmVudDtcbiAgICAgICAgICBpZiAobnVsbCA9PT0gZmliZXIpXG4gICAgICAgICAgICB0aHJvdyBFcnJvcihcbiAgICAgICAgICAgICAgXCJDYWxsaW5nIE9mZnNjcmVlbi5kZXRhY2ggYmVmb3JlIGluc3RhbmNlIGhhbmRsZSBoYXMgYmVlbiBzZXQuXCJcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgaWYgKDAgPT09IChpbnN0YW5jZS5fcGVuZGluZ1Zpc2liaWxpdHkgJiAyKSkge1xuICAgICAgICAgICAgdmFyIHJvb3QgPSBlbnF1ZXVlQ29uY3VycmVudFJlbmRlckZvckxhbmUoZmliZXIsIDIpO1xuICAgICAgICAgICAgbnVsbCAhPT0gcm9vdCAmJlxuICAgICAgICAgICAgICAoKGluc3RhbmNlLl9wZW5kaW5nVmlzaWJpbGl0eSB8PSAyKSxcbiAgICAgICAgICAgICAgc2NoZWR1bGVVcGRhdGVPbkZpYmVyKHJvb3QsIGZpYmVyLCAyKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBhdHRhY2g6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB2YXIgaW5zdGFuY2UgPSBwcmltYXJ5Q2hpbGRJbnN0YW5jZSxcbiAgICAgICAgICAgIGZpYmVyID0gaW5zdGFuY2UuX2N1cnJlbnQ7XG4gICAgICAgICAgaWYgKG51bGwgPT09IGZpYmVyKVxuICAgICAgICAgICAgdGhyb3cgRXJyb3IoXG4gICAgICAgICAgICAgIFwiQ2FsbGluZyBPZmZzY3JlZW4uZGV0YWNoIGJlZm9yZSBpbnN0YW5jZSBoYW5kbGUgaGFzIGJlZW4gc2V0LlwiXG4gICAgICAgICAgICApO1xuICAgICAgICAgIGlmICgwICE9PSAoaW5zdGFuY2UuX3BlbmRpbmdWaXNpYmlsaXR5ICYgMikpIHtcbiAgICAgICAgICAgIHZhciByb290ID0gZW5xdWV1ZUNvbmN1cnJlbnRSZW5kZXJGb3JMYW5lKGZpYmVyLCAyKTtcbiAgICAgICAgICAgIG51bGwgIT09IHJvb3QgJiZcbiAgICAgICAgICAgICAgKChpbnN0YW5jZS5fcGVuZGluZ1Zpc2liaWxpdHkgJj0gLTMpLFxuICAgICAgICAgICAgICBzY2hlZHVsZVVwZGF0ZU9uRmliZXIocm9vdCwgZmliZXIsIDIpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICBwZW5kaW5nUHJvcHMuc3RhdGVOb2RlID0gcHJpbWFyeUNoaWxkSW5zdGFuY2U7XG4gICAgICByZXR1cm4gcGVuZGluZ1Byb3BzO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjcmVhdGVGaWJlckZyb21UZXh0KGNvbnRlbnQsIG1vZGUsIGxhbmVzKSB7XG4gICAgICBjb250ZW50ID0gY3JlYXRlRmliZXIoNiwgY29udGVudCwgbnVsbCwgbW9kZSk7XG4gICAgICBjb250ZW50LmxhbmVzID0gbGFuZXM7XG4gICAgICByZXR1cm4gY29udGVudDtcbiAgICB9XG4gICAgZnVuY3Rpb24gY3JlYXRlRmliZXJGcm9tUG9ydGFsKHBvcnRhbCwgbW9kZSwgbGFuZXMpIHtcbiAgICAgIG1vZGUgPSBjcmVhdGVGaWJlcihcbiAgICAgICAgNCxcbiAgICAgICAgbnVsbCAhPT0gcG9ydGFsLmNoaWxkcmVuID8gcG9ydGFsLmNoaWxkcmVuIDogW10sXG4gICAgICAgIHBvcnRhbC5rZXksXG4gICAgICAgIG1vZGVcbiAgICAgICk7XG4gICAgICBtb2RlLmxhbmVzID0gbGFuZXM7XG4gICAgICBtb2RlLnN0YXRlTm9kZSA9IHtcbiAgICAgICAgY29udGFpbmVySW5mbzogcG9ydGFsLmNvbnRhaW5lckluZm8sXG4gICAgICAgIHBlbmRpbmdDaGlsZHJlbjogbnVsbCxcbiAgICAgICAgaW1wbGVtZW50YXRpb246IHBvcnRhbC5pbXBsZW1lbnRhdGlvblxuICAgICAgfTtcbiAgICAgIHJldHVybiBtb2RlO1xuICAgIH1cbiAgICBmdW5jdGlvbiBGaWJlclJvb3ROb2RlKFxuICAgICAgY29udGFpbmVySW5mbyxcbiAgICAgIHRhZyxcbiAgICAgIGh5ZHJhdGUsXG4gICAgICBpZGVudGlmaWVyUHJlZml4LFxuICAgICAgb25VbmNhdWdodEVycm9yLFxuICAgICAgb25DYXVnaHRFcnJvcixcbiAgICAgIG9uUmVjb3ZlcmFibGVFcnJvcixcbiAgICAgIGZvcm1TdGF0ZVxuICAgICkge1xuICAgICAgdGhpcy50YWcgPSAxO1xuICAgICAgdGhpcy5jb250YWluZXJJbmZvID0gY29udGFpbmVySW5mbztcbiAgICAgIHRoaXMuZmluaXNoZWRXb3JrID1cbiAgICAgICAgdGhpcy5waW5nQ2FjaGUgPVxuICAgICAgICB0aGlzLmN1cnJlbnQgPVxuICAgICAgICB0aGlzLnBlbmRpbmdDaGlsZHJlbiA9XG4gICAgICAgICAgbnVsbDtcbiAgICAgIHRoaXMudGltZW91dEhhbmRsZSA9IG5vVGltZW91dDtcbiAgICAgIHRoaXMuY2FsbGJhY2tOb2RlID1cbiAgICAgICAgdGhpcy5uZXh0ID1cbiAgICAgICAgdGhpcy5wZW5kaW5nQ29udGV4dCA9XG4gICAgICAgIHRoaXMuY29udGV4dCA9XG4gICAgICAgIHRoaXMuY2FuY2VsUGVuZGluZ0NvbW1pdCA9XG4gICAgICAgICAgbnVsbDtcbiAgICAgIHRoaXMuY2FsbGJhY2tQcmlvcml0eSA9IDA7XG4gICAgICB0aGlzLmV4cGlyYXRpb25UaW1lcyA9IGNyZWF0ZUxhbmVNYXAoLTEpO1xuICAgICAgdGhpcy5lbnRhbmdsZWRMYW5lcyA9XG4gICAgICAgIHRoaXMuc2hlbGxTdXNwZW5kQ291bnRlciA9XG4gICAgICAgIHRoaXMuZXJyb3JSZWNvdmVyeURpc2FibGVkTGFuZXMgPVxuICAgICAgICB0aGlzLmZpbmlzaGVkTGFuZXMgPVxuICAgICAgICB0aGlzLmV4cGlyZWRMYW5lcyA9XG4gICAgICAgIHRoaXMud2FybUxhbmVzID1cbiAgICAgICAgdGhpcy5waW5nZWRMYW5lcyA9XG4gICAgICAgIHRoaXMuc3VzcGVuZGVkTGFuZXMgPVxuICAgICAgICB0aGlzLnBlbmRpbmdMYW5lcyA9XG4gICAgICAgICAgMDtcbiAgICAgIHRoaXMuZW50YW5nbGVtZW50cyA9IGNyZWF0ZUxhbmVNYXAoMCk7XG4gICAgICB0aGlzLmhpZGRlblVwZGF0ZXMgPSBjcmVhdGVMYW5lTWFwKG51bGwpO1xuICAgICAgdGhpcy5pZGVudGlmaWVyUHJlZml4ID0gaWRlbnRpZmllclByZWZpeDtcbiAgICAgIHRoaXMub25VbmNhdWdodEVycm9yID0gb25VbmNhdWdodEVycm9yO1xuICAgICAgdGhpcy5vbkNhdWdodEVycm9yID0gb25DYXVnaHRFcnJvcjtcbiAgICAgIHRoaXMub25SZWNvdmVyYWJsZUVycm9yID0gb25SZWNvdmVyYWJsZUVycm9yO1xuICAgICAgdGhpcy5wb29sZWRDYWNoZSA9IG51bGw7XG4gICAgICB0aGlzLnBvb2xlZENhY2hlTGFuZXMgPSAwO1xuICAgICAgdGhpcy5mb3JtU3RhdGUgPSBmb3JtU3RhdGU7XG4gICAgICB0aGlzLmluY29tcGxldGVUcmFuc2l0aW9ucyA9IG5ldyBNYXAoKTtcbiAgICAgIHRoaXMucGFzc2l2ZUVmZmVjdER1cmF0aW9uID0gdGhpcy5lZmZlY3REdXJhdGlvbiA9IC0wO1xuICAgICAgdGhpcy5tZW1vaXplZFVwZGF0ZXJzID0gbmV3IFNldCgpO1xuICAgICAgY29udGFpbmVySW5mbyA9IHRoaXMucGVuZGluZ1VwZGF0ZXJzTGFuZU1hcCA9IFtdO1xuICAgICAgZm9yICh0YWcgPSAwOyAzMSA+IHRhZzsgdGFnKyspIGNvbnRhaW5lckluZm8ucHVzaChuZXcgU2V0KCkpO1xuICAgICAgdGhpcy5fZGVidWdSb290VHlwZSA9IGh5ZHJhdGUgPyBcImh5ZHJhdGVSb290KClcIiA6IFwiY3JlYXRlUm9vdCgpXCI7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNyZWF0ZUZpYmVyUm9vdChcbiAgICAgIGNvbnRhaW5lckluZm8sXG4gICAgICB0YWcsXG4gICAgICBoeWRyYXRlLFxuICAgICAgaW5pdGlhbENoaWxkcmVuLFxuICAgICAgaHlkcmF0aW9uQ2FsbGJhY2tzLFxuICAgICAgaXNTdHJpY3RNb2RlLFxuICAgICAgaWRlbnRpZmllclByZWZpeCxcbiAgICAgIG9uVW5jYXVnaHRFcnJvcixcbiAgICAgIG9uQ2F1Z2h0RXJyb3IsXG4gICAgICBvblJlY292ZXJhYmxlRXJyb3IsXG4gICAgICB0cmFuc2l0aW9uQ2FsbGJhY2tzLFxuICAgICAgZm9ybVN0YXRlXG4gICAgKSB7XG4gICAgICBjb250YWluZXJJbmZvID0gbmV3IEZpYmVyUm9vdE5vZGUoXG4gICAgICAgIGNvbnRhaW5lckluZm8sXG4gICAgICAgIHRhZyxcbiAgICAgICAgaHlkcmF0ZSxcbiAgICAgICAgaWRlbnRpZmllclByZWZpeCxcbiAgICAgICAgb25VbmNhdWdodEVycm9yLFxuICAgICAgICBvbkNhdWdodEVycm9yLFxuICAgICAgICBvblJlY292ZXJhYmxlRXJyb3IsXG4gICAgICAgIGZvcm1TdGF0ZVxuICAgICAgKTtcbiAgICAgIHRhZyA9IDE7XG4gICAgICAhMCA9PT0gaXNTdHJpY3RNb2RlICYmICh0YWcgfD0gMjQpO1xuICAgICAgaXNEZXZUb29sc1ByZXNlbnQgJiYgKHRhZyB8PSAyKTtcbiAgICAgIGlzU3RyaWN0TW9kZSA9IGNyZWF0ZUZpYmVyKDMsIG51bGwsIG51bGwsIHRhZyk7XG4gICAgICBjb250YWluZXJJbmZvLmN1cnJlbnQgPSBpc1N0cmljdE1vZGU7XG4gICAgICBpc1N0cmljdE1vZGUuc3RhdGVOb2RlID0gY29udGFpbmVySW5mbztcbiAgICAgIHRhZyA9IGNyZWF0ZUNhY2hlKCk7XG4gICAgICByZXRhaW5DYWNoZSh0YWcpO1xuICAgICAgY29udGFpbmVySW5mby5wb29sZWRDYWNoZSA9IHRhZztcbiAgICAgIHJldGFpbkNhY2hlKHRhZyk7XG4gICAgICBpc1N0cmljdE1vZGUubWVtb2l6ZWRTdGF0ZSA9IHtcbiAgICAgICAgZWxlbWVudDogaW5pdGlhbENoaWxkcmVuLFxuICAgICAgICBpc0RlaHlkcmF0ZWQ6IGh5ZHJhdGUsXG4gICAgICAgIGNhY2hlOiB0YWdcbiAgICAgIH07XG4gICAgICBpbml0aWFsaXplVXBkYXRlUXVldWUoaXNTdHJpY3RNb2RlKTtcbiAgICAgIHJldHVybiBjb250YWluZXJJbmZvO1xuICAgIH1cbiAgICBmdW5jdGlvbiB0ZXN0U3RyaW5nQ29lcmNpb24odmFsdWUpIHtcbiAgICAgIHJldHVybiBcIlwiICsgdmFsdWU7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGdldENvbnRleHRGb3JTdWJ0cmVlKHBhcmVudENvbXBvbmVudCkge1xuICAgICAgaWYgKCFwYXJlbnRDb21wb25lbnQpIHJldHVybiBlbXB0eUNvbnRleHRPYmplY3Q7XG4gICAgICBwYXJlbnRDb21wb25lbnQgPSBlbXB0eUNvbnRleHRPYmplY3Q7XG4gICAgICByZXR1cm4gcGFyZW50Q29tcG9uZW50O1xuICAgIH1cbiAgICBmdW5jdGlvbiB1cGRhdGVDb250YWluZXJTeW5jKFxuICAgICAgZWxlbWVudCxcbiAgICAgIGNvbnRhaW5lcixcbiAgICAgIHBhcmVudENvbXBvbmVudCxcbiAgICAgIGNhbGxiYWNrXG4gICAgKSB7XG4gICAgICAwID09PSBjb250YWluZXIudGFnICYmIGZsdXNoUGFzc2l2ZUVmZmVjdHMoKTtcbiAgICAgIHVwZGF0ZUNvbnRhaW5lckltcGwoXG4gICAgICAgIGNvbnRhaW5lci5jdXJyZW50LFxuICAgICAgICAyLFxuICAgICAgICBlbGVtZW50LFxuICAgICAgICBjb250YWluZXIsXG4gICAgICAgIHBhcmVudENvbXBvbmVudCxcbiAgICAgICAgY2FsbGJhY2tcbiAgICAgICk7XG4gICAgICByZXR1cm4gMjtcbiAgICB9XG4gICAgZnVuY3Rpb24gdXBkYXRlQ29udGFpbmVySW1wbChcbiAgICAgIHJvb3RGaWJlcixcbiAgICAgIGxhbmUsXG4gICAgICBlbGVtZW50LFxuICAgICAgY29udGFpbmVyLFxuICAgICAgcGFyZW50Q29tcG9uZW50LFxuICAgICAgY2FsbGJhY2tcbiAgICApIHtcbiAgICAgIGlmIChcbiAgICAgICAgaW5qZWN0ZWRIb29rICYmXG4gICAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIGluamVjdGVkSG9vay5vblNjaGVkdWxlRmliZXJSb290XG4gICAgICApXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgaW5qZWN0ZWRIb29rLm9uU2NoZWR1bGVGaWJlclJvb3QocmVuZGVyZXJJRCwgY29udGFpbmVyLCBlbGVtZW50KTtcbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgaGFzTG9nZ2VkRXJyb3IgfHxcbiAgICAgICAgICAgICgoaGFzTG9nZ2VkRXJyb3IgPSAhMCksXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICBcIlJlYWN0IGluc3RydW1lbnRhdGlvbiBlbmNvdW50ZXJlZCBhbiBlcnJvcjogJXNcIixcbiAgICAgICAgICAgICAgZXJyXG4gICAgICAgICAgICApKTtcbiAgICAgICAgfVxuICAgICAgbnVsbCAhPT0gaW5qZWN0ZWRQcm9maWxpbmdIb29rcyAmJlxuICAgICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBpbmplY3RlZFByb2ZpbGluZ0hvb2tzLm1hcmtSZW5kZXJTY2hlZHVsZWQgJiZcbiAgICAgICAgaW5qZWN0ZWRQcm9maWxpbmdIb29rcy5tYXJrUmVuZGVyU2NoZWR1bGVkKGxhbmUpO1xuICAgICAgcGFyZW50Q29tcG9uZW50ID0gZ2V0Q29udGV4dEZvclN1YnRyZWUocGFyZW50Q29tcG9uZW50KTtcbiAgICAgIG51bGwgPT09IGNvbnRhaW5lci5jb250ZXh0XG4gICAgICAgID8gKGNvbnRhaW5lci5jb250ZXh0ID0gcGFyZW50Q29tcG9uZW50KVxuICAgICAgICA6IChjb250YWluZXIucGVuZGluZ0NvbnRleHQgPSBwYXJlbnRDb21wb25lbnQpO1xuICAgICAgaXNSZW5kZXJpbmcgJiZcbiAgICAgICAgbnVsbCAhPT0gY3VycmVudCAmJlxuICAgICAgICAhZGlkV2FybkFib3V0TmVzdGVkVXBkYXRlcyAmJlxuICAgICAgICAoKGRpZFdhcm5BYm91dE5lc3RlZFVwZGF0ZXMgPSAhMCksXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgXCJSZW5kZXIgbWV0aG9kcyBzaG91bGQgYmUgYSBwdXJlIGZ1bmN0aW9uIG9mIHByb3BzIGFuZCBzdGF0ZTsgdHJpZ2dlcmluZyBuZXN0ZWQgY29tcG9uZW50IHVwZGF0ZXMgZnJvbSByZW5kZXIgaXMgbm90IGFsbG93ZWQuIElmIG5lY2Vzc2FyeSwgdHJpZ2dlciBuZXN0ZWQgdXBkYXRlcyBpbiBjb21wb25lbnREaWRVcGRhdGUuXFxuXFxuQ2hlY2sgdGhlIHJlbmRlciBtZXRob2Qgb2YgJXMuXCIsXG4gICAgICAgICAgZ2V0Q29tcG9uZW50TmFtZUZyb21GaWJlcihjdXJyZW50KSB8fCBcIlVua25vd25cIlxuICAgICAgICApKTtcbiAgICAgIGNvbnRhaW5lciA9IGNyZWF0ZVVwZGF0ZShsYW5lKTtcbiAgICAgIGNvbnRhaW5lci5wYXlsb2FkID0geyBlbGVtZW50OiBlbGVtZW50IH07XG4gICAgICBjYWxsYmFjayA9IHZvaWQgMCA9PT0gY2FsbGJhY2sgPyBudWxsIDogY2FsbGJhY2s7XG4gICAgICBudWxsICE9PSBjYWxsYmFjayAmJlxuICAgICAgICAoXCJmdW5jdGlvblwiICE9PSB0eXBlb2YgY2FsbGJhY2sgJiZcbiAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgXCJFeHBlY3RlZCB0aGUgbGFzdCBvcHRpb25hbCBgY2FsbGJhY2tgIGFyZ3VtZW50IHRvIGJlIGEgZnVuY3Rpb24uIEluc3RlYWQgcmVjZWl2ZWQ6ICVzLlwiLFxuICAgICAgICAgICAgY2FsbGJhY2tcbiAgICAgICAgICApLFxuICAgICAgICAoY29udGFpbmVyLmNhbGxiYWNrID0gY2FsbGJhY2spKTtcbiAgICAgIGVsZW1lbnQgPSBlbnF1ZXVlVXBkYXRlKHJvb3RGaWJlciwgY29udGFpbmVyLCBsYW5lKTtcbiAgICAgIG51bGwgIT09IGVsZW1lbnQgJiZcbiAgICAgICAgKHNjaGVkdWxlVXBkYXRlT25GaWJlcihlbGVtZW50LCByb290RmliZXIsIGxhbmUpLFxuICAgICAgICBlbnRhbmdsZVRyYW5zaXRpb25zKGVsZW1lbnQsIHJvb3RGaWJlciwgbGFuZSkpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBtYXJrUmV0cnlMYW5lSW1wbChmaWJlciwgcmV0cnlMYW5lKSB7XG4gICAgICBmaWJlciA9IGZpYmVyLm1lbW9pemVkU3RhdGU7XG4gICAgICBpZiAobnVsbCAhPT0gZmliZXIgJiYgbnVsbCAhPT0gZmliZXIuZGVoeWRyYXRlZCkge1xuICAgICAgICB2YXIgYSA9IGZpYmVyLnJldHJ5TGFuZTtcbiAgICAgICAgZmliZXIucmV0cnlMYW5lID0gMCAhPT0gYSAmJiBhIDwgcmV0cnlMYW5lID8gYSA6IHJldHJ5TGFuZTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gbWFya1JldHJ5TGFuZUlmTm90SHlkcmF0ZWQoZmliZXIsIHJldHJ5TGFuZSkge1xuICAgICAgbWFya1JldHJ5TGFuZUltcGwoZmliZXIsIHJldHJ5TGFuZSk7XG4gICAgICAoZmliZXIgPSBmaWJlci5hbHRlcm5hdGUpICYmIG1hcmtSZXRyeUxhbmVJbXBsKGZpYmVyLCByZXRyeUxhbmUpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBnZXRDdXJyZW50RmliZXJGb3JEZXZUb29scygpIHtcbiAgICAgIHJldHVybiBjdXJyZW50O1xuICAgIH1cbiAgICBmdW5jdGlvbiBnZXRMYW5lTGFiZWxNYXAoKSB7XG4gICAgICBmb3IgKHZhciBtYXAgPSBuZXcgTWFwKCksIGxhbmUgPSAxLCBpbmRleCA9IDA7IDMxID4gaW5kZXg7IGluZGV4KyspIHtcbiAgICAgICAgdmFyIGxhYmVsID0gZ2V0TGFiZWxGb3JMYW5lKGxhbmUpO1xuICAgICAgICBtYXAuc2V0KGxhbmUsIGxhYmVsKTtcbiAgICAgICAgbGFuZSAqPSAyO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG1hcDtcbiAgICB9XG4gICAgdmFyIGV4cG9ydHMgPSB7fTtcbiAgICAoXCJ1c2Ugc3RyaWN0XCIpO1xuICAgIHZhciBSZWFjdCA9IHJlcXVpcmUoXCJyZWFjdFwiKSxcbiAgICAgIFNjaGVkdWxlciA9IHJlcXVpcmUoXCJzY2hlZHVsZXJcIiksXG4gICAgICBhc3NpZ24gPSBPYmplY3QuYXNzaWduLFxuICAgICAgUkVBQ1RfTEVHQUNZX0VMRU1FTlRfVFlQRSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5lbGVtZW50XCIpLFxuICAgICAgUkVBQ1RfRUxFTUVOVF9UWVBFID0gU3ltYm9sLmZvcihcInJlYWN0LnRyYW5zaXRpb25hbC5lbGVtZW50XCIpLFxuICAgICAgUkVBQ1RfUE9SVEFMX1RZUEUgPSBTeW1ib2wuZm9yKFwicmVhY3QucG9ydGFsXCIpLFxuICAgICAgUkVBQ1RfRlJBR01FTlRfVFlQRSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5mcmFnbWVudFwiKSxcbiAgICAgIFJFQUNUX1NUUklDVF9NT0RFX1RZUEUgPSBTeW1ib2wuZm9yKFwicmVhY3Quc3RyaWN0X21vZGVcIiksXG4gICAgICBSRUFDVF9QUk9GSUxFUl9UWVBFID0gU3ltYm9sLmZvcihcInJlYWN0LnByb2ZpbGVyXCIpLFxuICAgICAgUkVBQ1RfUFJPVklERVJfVFlQRSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5wcm92aWRlclwiKSxcbiAgICAgIFJFQUNUX0NPTlNVTUVSX1RZUEUgPSBTeW1ib2wuZm9yKFwicmVhY3QuY29uc3VtZXJcIiksXG4gICAgICBSRUFDVF9DT05URVhUX1RZUEUgPSBTeW1ib2wuZm9yKFwicmVhY3QuY29udGV4dFwiKSxcbiAgICAgIFJFQUNUX0ZPUldBUkRfUkVGX1RZUEUgPSBTeW1ib2wuZm9yKFwicmVhY3QuZm9yd2FyZF9yZWZcIiksXG4gICAgICBSRUFDVF9TVVNQRU5TRV9UWVBFID0gU3ltYm9sLmZvcihcInJlYWN0LnN1c3BlbnNlXCIpLFxuICAgICAgUkVBQ1RfU1VTUEVOU0VfTElTVF9UWVBFID0gU3ltYm9sLmZvcihcInJlYWN0LnN1c3BlbnNlX2xpc3RcIiksXG4gICAgICBSRUFDVF9NRU1PX1RZUEUgPSBTeW1ib2wuZm9yKFwicmVhY3QubWVtb1wiKSxcbiAgICAgIFJFQUNUX0xBWllfVFlQRSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5sYXp5XCIpO1xuICAgIFN5bWJvbC5mb3IoXCJyZWFjdC5zY29wZVwiKTtcbiAgICBTeW1ib2wuZm9yKFwicmVhY3QuZGVidWdfdHJhY2VfbW9kZVwiKTtcbiAgICB2YXIgUkVBQ1RfT0ZGU0NSRUVOX1RZUEUgPSBTeW1ib2wuZm9yKFwicmVhY3Qub2Zmc2NyZWVuXCIpO1xuICAgIFN5bWJvbC5mb3IoXCJyZWFjdC5sZWdhY3lfaGlkZGVuXCIpO1xuICAgIFN5bWJvbC5mb3IoXCJyZWFjdC50cmFjaW5nX21hcmtlclwiKTtcbiAgICB2YXIgUkVBQ1RfTUVNT19DQUNIRV9TRU5USU5FTCA9IFN5bWJvbC5mb3IoXCJyZWFjdC5tZW1vX2NhY2hlX3NlbnRpbmVsXCIpLFxuICAgICAgTUFZQkVfSVRFUkFUT1JfU1lNQk9MID0gU3ltYm9sLml0ZXJhdG9yLFxuICAgICAgUkVBQ1RfQ0xJRU5UX1JFRkVSRU5DRSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5jbGllbnQucmVmZXJlbmNlXCIpLFxuICAgICAgUmVhY3RTaGFyZWRJbnRlcm5hbHMgPVxuICAgICAgICBSZWFjdC5fX0NMSUVOVF9JTlRFUk5BTFNfRE9fTk9UX1VTRV9PUl9XQVJOX1VTRVJTX1RIRVlfQ0FOTk9UX1VQR1JBREUsXG4gICAgICBkaXNhYmxlZERlcHRoID0gMCxcbiAgICAgIHByZXZMb2csXG4gICAgICBwcmV2SW5mbyxcbiAgICAgIHByZXZXYXJuLFxuICAgICAgcHJldkVycm9yLFxuICAgICAgcHJldkdyb3VwLFxuICAgICAgcHJldkdyb3VwQ29sbGFwc2VkLFxuICAgICAgcHJldkdyb3VwRW5kO1xuICAgIGRpc2FibGVkTG9nLl9fcmVhY3REaXNhYmxlZExvZyA9ICEwO1xuICAgIHZhciBwcmVmaXgsXG4gICAgICBzdWZmaXgsXG4gICAgICByZWVudHJ5ID0gITE7XG4gICAgdmFyIGNvbXBvbmVudEZyYW1lQ2FjaGUgPSBuZXcgKFxuICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgV2Vha01hcCA/IFdlYWtNYXAgOiBNYXBcbiAgICApKCk7XG4gICAgdmFyIGN1cnJlbnQgPSBudWxsLFxuICAgICAgaXNSZW5kZXJpbmcgPSAhMSxcbiAgICAgIGlzQXJyYXlJbXBsID0gQXJyYXkuaXNBcnJheSxcbiAgICAgIHJlbmRlcmVyVmVyc2lvbiA9ICQkJGNvbmZpZy5yZW5kZXJlclZlcnNpb24sXG4gICAgICByZW5kZXJlclBhY2thZ2VOYW1lID0gJCQkY29uZmlnLnJlbmRlcmVyUGFja2FnZU5hbWUsXG4gICAgICBleHRyYURldlRvb2xzQ29uZmlnID0gJCQkY29uZmlnLmV4dHJhRGV2VG9vbHNDb25maWcsXG4gICAgICBnZXRQdWJsaWNJbnN0YW5jZSA9ICQkJGNvbmZpZy5nZXRQdWJsaWNJbnN0YW5jZSxcbiAgICAgIGdldFJvb3RIb3N0Q29udGV4dCA9ICQkJGNvbmZpZy5nZXRSb290SG9zdENvbnRleHQsXG4gICAgICBnZXRDaGlsZEhvc3RDb250ZXh0ID0gJCQkY29uZmlnLmdldENoaWxkSG9zdENvbnRleHQsXG4gICAgICBwcmVwYXJlRm9yQ29tbWl0ID0gJCQkY29uZmlnLnByZXBhcmVGb3JDb21taXQsXG4gICAgICByZXNldEFmdGVyQ29tbWl0ID0gJCQkY29uZmlnLnJlc2V0QWZ0ZXJDb21taXQsXG4gICAgICBjcmVhdGVJbnN0YW5jZSA9ICQkJGNvbmZpZy5jcmVhdGVJbnN0YW5jZSxcbiAgICAgIGFwcGVuZEluaXRpYWxDaGlsZCA9ICQkJGNvbmZpZy5hcHBlbmRJbml0aWFsQ2hpbGQsXG4gICAgICBmaW5hbGl6ZUluaXRpYWxDaGlsZHJlbiA9ICQkJGNvbmZpZy5maW5hbGl6ZUluaXRpYWxDaGlsZHJlbixcbiAgICAgIHNob3VsZFNldFRleHRDb250ZW50ID0gJCQkY29uZmlnLnNob3VsZFNldFRleHRDb250ZW50LFxuICAgICAgY3JlYXRlVGV4dEluc3RhbmNlID0gJCQkY29uZmlnLmNyZWF0ZVRleHRJbnN0YW5jZSxcbiAgICAgIHNjaGVkdWxlVGltZW91dCA9ICQkJGNvbmZpZy5zY2hlZHVsZVRpbWVvdXQsXG4gICAgICBjYW5jZWxUaW1lb3V0ID0gJCQkY29uZmlnLmNhbmNlbFRpbWVvdXQsXG4gICAgICBub1RpbWVvdXQgPSAkJCRjb25maWcubm9UaW1lb3V0LFxuICAgICAgaXNQcmltYXJ5UmVuZGVyZXIgPSAkJCRjb25maWcuaXNQcmltYXJ5UmVuZGVyZXI7XG4gICAgJCQkY29uZmlnLndhcm5zSWZOb3RBY3Rpbmc7XG4gICAgdmFyIHN1cHBvcnRzTXV0YXRpb24gPSAkJCRjb25maWcuc3VwcG9ydHNNdXRhdGlvbixcbiAgICAgIHN1cHBvcnRzUGVyc2lzdGVuY2UgPSAkJCRjb25maWcuc3VwcG9ydHNQZXJzaXN0ZW5jZSxcbiAgICAgIHN1cHBvcnRzSHlkcmF0aW9uID0gJCQkY29uZmlnLnN1cHBvcnRzSHlkcmF0aW9uLFxuICAgICAgZ2V0SW5zdGFuY2VGcm9tTm9kZSA9ICQkJGNvbmZpZy5nZXRJbnN0YW5jZUZyb21Ob2RlO1xuICAgICQkJGNvbmZpZy5iZWZvcmVBY3RpdmVJbnN0YW5jZUJsdXI7XG4gICAgJCQkY29uZmlnLmFmdGVyQWN0aXZlSW5zdGFuY2VCbHVyO1xuICAgIHZhciBwcmVwYXJlUG9ydGFsTW91bnQgPSAkJCRjb25maWcucHJlcGFyZVBvcnRhbE1vdW50O1xuICAgICQkJGNvbmZpZy5wcmVwYXJlU2NvcGVVcGRhdGU7XG4gICAgJCQkY29uZmlnLmdldEluc3RhbmNlRnJvbVNjb3BlO1xuICAgIHZhciBzZXRDdXJyZW50VXBkYXRlUHJpb3JpdHkgPSAkJCRjb25maWcuc2V0Q3VycmVudFVwZGF0ZVByaW9yaXR5LFxuICAgICAgZ2V0Q3VycmVudFVwZGF0ZVByaW9yaXR5ID0gJCQkY29uZmlnLmdldEN1cnJlbnRVcGRhdGVQcmlvcml0eSxcbiAgICAgIHJlc29sdmVVcGRhdGVQcmlvcml0eSA9ICQkJGNvbmZpZy5yZXNvbHZlVXBkYXRlUHJpb3JpdHk7XG4gICAgJCQkY29uZmlnLnJlc29sdmVFdmVudFR5cGU7XG4gICAgJCQkY29uZmlnLnJlc29sdmVFdmVudFRpbWVTdGFtcDtcbiAgICB2YXIgc2hvdWxkQXR0ZW1wdEVhZ2VyVHJhbnNpdGlvbiA9ICQkJGNvbmZpZy5zaG91bGRBdHRlbXB0RWFnZXJUcmFuc2l0aW9uLFxuICAgICAgZGV0YWNoRGVsZXRlZEluc3RhbmNlID0gJCQkY29uZmlnLmRldGFjaERlbGV0ZWRJbnN0YW5jZTtcbiAgICAkJCRjb25maWcucmVxdWVzdFBvc3RQYWludENhbGxiYWNrO1xuICAgIHZhciBtYXlTdXNwZW5kQ29tbWl0ID0gJCQkY29uZmlnLm1heVN1c3BlbmRDb21taXQsXG4gICAgICBwcmVsb2FkSW5zdGFuY2UgPSAkJCRjb25maWcucHJlbG9hZEluc3RhbmNlLFxuICAgICAgc3RhcnRTdXNwZW5kaW5nQ29tbWl0ID0gJCQkY29uZmlnLnN0YXJ0U3VzcGVuZGluZ0NvbW1pdCxcbiAgICAgIHN1c3BlbmRJbnN0YW5jZSA9ICQkJGNvbmZpZy5zdXNwZW5kSW5zdGFuY2UsXG4gICAgICB3YWl0Rm9yQ29tbWl0VG9CZVJlYWR5ID0gJCQkY29uZmlnLndhaXRGb3JDb21taXRUb0JlUmVhZHksXG4gICAgICBOb3RQZW5kaW5nVHJhbnNpdGlvbiA9ICQkJGNvbmZpZy5Ob3RQZW5kaW5nVHJhbnNpdGlvbixcbiAgICAgIEhvc3RUcmFuc2l0aW9uQ29udGV4dCA9ICQkJGNvbmZpZy5Ib3N0VHJhbnNpdGlvbkNvbnRleHQsXG4gICAgICByZXNldEZvcm1JbnN0YW5jZSA9ICQkJGNvbmZpZy5yZXNldEZvcm1JbnN0YW5jZSxcbiAgICAgIGJpbmRUb0NvbnNvbGUgPSAkJCRjb25maWcuYmluZFRvQ29uc29sZSxcbiAgICAgIHN1cHBvcnRzTWljcm90YXNrcyA9ICQkJGNvbmZpZy5zdXBwb3J0c01pY3JvdGFza3MsXG4gICAgICBzY2hlZHVsZU1pY3JvdGFzayA9ICQkJGNvbmZpZy5zY2hlZHVsZU1pY3JvdGFzayxcbiAgICAgIHN1cHBvcnRzVGVzdFNlbGVjdG9ycyA9ICQkJGNvbmZpZy5zdXBwb3J0c1Rlc3RTZWxlY3RvcnMsXG4gICAgICBmaW5kRmliZXJSb290ID0gJCQkY29uZmlnLmZpbmRGaWJlclJvb3QsXG4gICAgICBnZXRCb3VuZGluZ1JlY3QgPSAkJCRjb25maWcuZ2V0Qm91bmRpbmdSZWN0LFxuICAgICAgZ2V0VGV4dENvbnRlbnQgPSAkJCRjb25maWcuZ2V0VGV4dENvbnRlbnQsXG4gICAgICBpc0hpZGRlblN1YnRyZWUgPSAkJCRjb25maWcuaXNIaWRkZW5TdWJ0cmVlLFxuICAgICAgbWF0Y2hBY2Nlc3NpYmlsaXR5Um9sZSA9ICQkJGNvbmZpZy5tYXRjaEFjY2Vzc2liaWxpdHlSb2xlLFxuICAgICAgc2V0Rm9jdXNJZkZvY3VzYWJsZSA9ICQkJGNvbmZpZy5zZXRGb2N1c0lmRm9jdXNhYmxlLFxuICAgICAgc2V0dXBJbnRlcnNlY3Rpb25PYnNlcnZlciA9ICQkJGNvbmZpZy5zZXR1cEludGVyc2VjdGlvbk9ic2VydmVyLFxuICAgICAgYXBwZW5kQ2hpbGQgPSAkJCRjb25maWcuYXBwZW5kQ2hpbGQsXG4gICAgICBhcHBlbmRDaGlsZFRvQ29udGFpbmVyID0gJCQkY29uZmlnLmFwcGVuZENoaWxkVG9Db250YWluZXIsXG4gICAgICBjb21taXRUZXh0VXBkYXRlID0gJCQkY29uZmlnLmNvbW1pdFRleHRVcGRhdGUsXG4gICAgICBjb21taXRNb3VudCA9ICQkJGNvbmZpZy5jb21taXRNb3VudCxcbiAgICAgIGNvbW1pdFVwZGF0ZSA9ICQkJGNvbmZpZy5jb21taXRVcGRhdGUsXG4gICAgICBpbnNlcnRCZWZvcmUgPSAkJCRjb25maWcuaW5zZXJ0QmVmb3JlLFxuICAgICAgaW5zZXJ0SW5Db250YWluZXJCZWZvcmUgPSAkJCRjb25maWcuaW5zZXJ0SW5Db250YWluZXJCZWZvcmUsXG4gICAgICByZW1vdmVDaGlsZCA9ICQkJGNvbmZpZy5yZW1vdmVDaGlsZCxcbiAgICAgIHJlbW92ZUNoaWxkRnJvbUNvbnRhaW5lciA9ICQkJGNvbmZpZy5yZW1vdmVDaGlsZEZyb21Db250YWluZXIsXG4gICAgICByZXNldFRleHRDb250ZW50ID0gJCQkY29uZmlnLnJlc2V0VGV4dENvbnRlbnQsXG4gICAgICBoaWRlSW5zdGFuY2UgPSAkJCRjb25maWcuaGlkZUluc3RhbmNlLFxuICAgICAgaGlkZVRleHRJbnN0YW5jZSA9ICQkJGNvbmZpZy5oaWRlVGV4dEluc3RhbmNlLFxuICAgICAgdW5oaWRlSW5zdGFuY2UgPSAkJCRjb25maWcudW5oaWRlSW5zdGFuY2UsXG4gICAgICB1bmhpZGVUZXh0SW5zdGFuY2UgPSAkJCRjb25maWcudW5oaWRlVGV4dEluc3RhbmNlLFxuICAgICAgY2xlYXJDb250YWluZXIgPSAkJCRjb25maWcuY2xlYXJDb250YWluZXIsXG4gICAgICBjbG9uZUluc3RhbmNlID0gJCQkY29uZmlnLmNsb25lSW5zdGFuY2UsXG4gICAgICBjcmVhdGVDb250YWluZXJDaGlsZFNldCA9ICQkJGNvbmZpZy5jcmVhdGVDb250YWluZXJDaGlsZFNldCxcbiAgICAgIGFwcGVuZENoaWxkVG9Db250YWluZXJDaGlsZFNldCA9ICQkJGNvbmZpZy5hcHBlbmRDaGlsZFRvQ29udGFpbmVyQ2hpbGRTZXQsXG4gICAgICBmaW5hbGl6ZUNvbnRhaW5lckNoaWxkcmVuID0gJCQkY29uZmlnLmZpbmFsaXplQ29udGFpbmVyQ2hpbGRyZW4sXG4gICAgICByZXBsYWNlQ29udGFpbmVyQ2hpbGRyZW4gPSAkJCRjb25maWcucmVwbGFjZUNvbnRhaW5lckNoaWxkcmVuLFxuICAgICAgY2xvbmVIaWRkZW5JbnN0YW5jZSA9ICQkJGNvbmZpZy5jbG9uZUhpZGRlbkluc3RhbmNlLFxuICAgICAgY2xvbmVIaWRkZW5UZXh0SW5zdGFuY2UgPSAkJCRjb25maWcuY2xvbmVIaWRkZW5UZXh0SW5zdGFuY2UsXG4gICAgICBpc1N1c3BlbnNlSW5zdGFuY2VQZW5kaW5nID0gJCQkY29uZmlnLmlzU3VzcGVuc2VJbnN0YW5jZVBlbmRpbmcsXG4gICAgICBpc1N1c3BlbnNlSW5zdGFuY2VGYWxsYmFjayA9ICQkJGNvbmZpZy5pc1N1c3BlbnNlSW5zdGFuY2VGYWxsYmFjayxcbiAgICAgIGdldFN1c3BlbnNlSW5zdGFuY2VGYWxsYmFja0Vycm9yRGV0YWlscyA9XG4gICAgICAgICQkJGNvbmZpZy5nZXRTdXNwZW5zZUluc3RhbmNlRmFsbGJhY2tFcnJvckRldGFpbHMsXG4gICAgICByZWdpc3RlclN1c3BlbnNlSW5zdGFuY2VSZXRyeSA9ICQkJGNvbmZpZy5yZWdpc3RlclN1c3BlbnNlSW5zdGFuY2VSZXRyeSxcbiAgICAgIGNhbkh5ZHJhdGVGb3JtU3RhdGVNYXJrZXIgPSAkJCRjb25maWcuY2FuSHlkcmF0ZUZvcm1TdGF0ZU1hcmtlcixcbiAgICAgIGlzRm9ybVN0YXRlTWFya2VyTWF0Y2hpbmcgPSAkJCRjb25maWcuaXNGb3JtU3RhdGVNYXJrZXJNYXRjaGluZyxcbiAgICAgIGdldE5leHRIeWRyYXRhYmxlU2libGluZyA9ICQkJGNvbmZpZy5nZXROZXh0SHlkcmF0YWJsZVNpYmxpbmcsXG4gICAgICBnZXRGaXJzdEh5ZHJhdGFibGVDaGlsZCA9ICQkJGNvbmZpZy5nZXRGaXJzdEh5ZHJhdGFibGVDaGlsZCxcbiAgICAgIGdldEZpcnN0SHlkcmF0YWJsZUNoaWxkV2l0aGluQ29udGFpbmVyID1cbiAgICAgICAgJCQkY29uZmlnLmdldEZpcnN0SHlkcmF0YWJsZUNoaWxkV2l0aGluQ29udGFpbmVyLFxuICAgICAgZ2V0Rmlyc3RIeWRyYXRhYmxlQ2hpbGRXaXRoaW5TdXNwZW5zZUluc3RhbmNlID1cbiAgICAgICAgJCQkY29uZmlnLmdldEZpcnN0SHlkcmF0YWJsZUNoaWxkV2l0aGluU3VzcGVuc2VJbnN0YW5jZSxcbiAgICAgIGNhbkh5ZHJhdGVJbnN0YW5jZSA9ICQkJGNvbmZpZy5jYW5IeWRyYXRlSW5zdGFuY2UsXG4gICAgICBjYW5IeWRyYXRlVGV4dEluc3RhbmNlID0gJCQkY29uZmlnLmNhbkh5ZHJhdGVUZXh0SW5zdGFuY2UsXG4gICAgICBjYW5IeWRyYXRlU3VzcGVuc2VJbnN0YW5jZSA9ICQkJGNvbmZpZy5jYW5IeWRyYXRlU3VzcGVuc2VJbnN0YW5jZSxcbiAgICAgIGh5ZHJhdGVJbnN0YW5jZSA9ICQkJGNvbmZpZy5oeWRyYXRlSW5zdGFuY2UsXG4gICAgICBoeWRyYXRlVGV4dEluc3RhbmNlID0gJCQkY29uZmlnLmh5ZHJhdGVUZXh0SW5zdGFuY2UsXG4gICAgICBoeWRyYXRlU3VzcGVuc2VJbnN0YW5jZSA9ICQkJGNvbmZpZy5oeWRyYXRlU3VzcGVuc2VJbnN0YW5jZSxcbiAgICAgIGdldE5leHRIeWRyYXRhYmxlSW5zdGFuY2VBZnRlclN1c3BlbnNlSW5zdGFuY2UgPVxuICAgICAgICAkJCRjb25maWcuZ2V0TmV4dEh5ZHJhdGFibGVJbnN0YW5jZUFmdGVyU3VzcGVuc2VJbnN0YW5jZSxcbiAgICAgIGNvbW1pdEh5ZHJhdGVkQ29udGFpbmVyID0gJCQkY29uZmlnLmNvbW1pdEh5ZHJhdGVkQ29udGFpbmVyLFxuICAgICAgY29tbWl0SHlkcmF0ZWRTdXNwZW5zZUluc3RhbmNlID0gJCQkY29uZmlnLmNvbW1pdEh5ZHJhdGVkU3VzcGVuc2VJbnN0YW5jZSxcbiAgICAgIGNsZWFyU3VzcGVuc2VCb3VuZGFyeSA9ICQkJGNvbmZpZy5jbGVhclN1c3BlbnNlQm91bmRhcnksXG4gICAgICBjbGVhclN1c3BlbnNlQm91bmRhcnlGcm9tQ29udGFpbmVyID1cbiAgICAgICAgJCQkY29uZmlnLmNsZWFyU3VzcGVuc2VCb3VuZGFyeUZyb21Db250YWluZXIsXG4gICAgICBzaG91bGREZWxldGVVbmh5ZHJhdGVkVGFpbEluc3RhbmNlcyA9XG4gICAgICAgICQkJGNvbmZpZy5zaG91bGREZWxldGVVbmh5ZHJhdGVkVGFpbEluc3RhbmNlcyxcbiAgICAgIGRpZmZIeWRyYXRlZFByb3BzRm9yRGV2V2FybmluZ3MgPVxuICAgICAgICAkJCRjb25maWcuZGlmZkh5ZHJhdGVkUHJvcHNGb3JEZXZXYXJuaW5ncyxcbiAgICAgIGRpZmZIeWRyYXRlZFRleHRGb3JEZXZXYXJuaW5ncyA9ICQkJGNvbmZpZy5kaWZmSHlkcmF0ZWRUZXh0Rm9yRGV2V2FybmluZ3MsXG4gICAgICBkZXNjcmliZUh5ZHJhdGFibGVJbnN0YW5jZUZvckRldldhcm5pbmdzID1cbiAgICAgICAgJCQkY29uZmlnLmRlc2NyaWJlSHlkcmF0YWJsZUluc3RhbmNlRm9yRGV2V2FybmluZ3MsXG4gICAgICB2YWxpZGF0ZUh5ZHJhdGFibGVJbnN0YW5jZSA9ICQkJGNvbmZpZy52YWxpZGF0ZUh5ZHJhdGFibGVJbnN0YW5jZSxcbiAgICAgIHZhbGlkYXRlSHlkcmF0YWJsZVRleHRJbnN0YW5jZSA9ICQkJGNvbmZpZy52YWxpZGF0ZUh5ZHJhdGFibGVUZXh0SW5zdGFuY2UsXG4gICAgICBzdXBwb3J0c1Jlc291cmNlcyA9ICQkJGNvbmZpZy5zdXBwb3J0c1Jlc291cmNlcyxcbiAgICAgIGlzSG9zdEhvaXN0YWJsZVR5cGUgPSAkJCRjb25maWcuaXNIb3N0SG9pc3RhYmxlVHlwZSxcbiAgICAgIGdldEhvaXN0YWJsZVJvb3QgPSAkJCRjb25maWcuZ2V0SG9pc3RhYmxlUm9vdCxcbiAgICAgIGdldFJlc291cmNlID0gJCQkY29uZmlnLmdldFJlc291cmNlLFxuICAgICAgYWNxdWlyZVJlc291cmNlID0gJCQkY29uZmlnLmFjcXVpcmVSZXNvdXJjZSxcbiAgICAgIHJlbGVhc2VSZXNvdXJjZSA9ICQkJGNvbmZpZy5yZWxlYXNlUmVzb3VyY2UsXG4gICAgICBoeWRyYXRlSG9pc3RhYmxlID0gJCQkY29uZmlnLmh5ZHJhdGVIb2lzdGFibGUsXG4gICAgICBtb3VudEhvaXN0YWJsZSA9ICQkJGNvbmZpZy5tb3VudEhvaXN0YWJsZSxcbiAgICAgIHVubW91bnRIb2lzdGFibGUgPSAkJCRjb25maWcudW5tb3VudEhvaXN0YWJsZSxcbiAgICAgIGNyZWF0ZUhvaXN0YWJsZUluc3RhbmNlID0gJCQkY29uZmlnLmNyZWF0ZUhvaXN0YWJsZUluc3RhbmNlLFxuICAgICAgcHJlcGFyZVRvQ29tbWl0SG9pc3RhYmxlcyA9ICQkJGNvbmZpZy5wcmVwYXJlVG9Db21taXRIb2lzdGFibGVzLFxuICAgICAgbWF5UmVzb3VyY2VTdXNwZW5kQ29tbWl0ID0gJCQkY29uZmlnLm1heVJlc291cmNlU3VzcGVuZENvbW1pdCxcbiAgICAgIHByZWxvYWRSZXNvdXJjZSA9ICQkJGNvbmZpZy5wcmVsb2FkUmVzb3VyY2UsXG4gICAgICBzdXNwZW5kUmVzb3VyY2UgPSAkJCRjb25maWcuc3VzcGVuZFJlc291cmNlLFxuICAgICAgc3VwcG9ydHNTaW5nbGV0b25zID0gJCQkY29uZmlnLnN1cHBvcnRzU2luZ2xldG9ucyxcbiAgICAgIHJlc29sdmVTaW5nbGV0b25JbnN0YW5jZSA9ICQkJGNvbmZpZy5yZXNvbHZlU2luZ2xldG9uSW5zdGFuY2UsXG4gICAgICBjbGVhclNpbmdsZXRvbiA9ICQkJGNvbmZpZy5jbGVhclNpbmdsZXRvbixcbiAgICAgIGFjcXVpcmVTaW5nbGV0b25JbnN0YW5jZSA9ICQkJGNvbmZpZy5hY3F1aXJlU2luZ2xldG9uSW5zdGFuY2UsXG4gICAgICByZWxlYXNlU2luZ2xldG9uSW5zdGFuY2UgPSAkJCRjb25maWcucmVsZWFzZVNpbmdsZXRvbkluc3RhbmNlLFxuICAgICAgaXNIb3N0U2luZ2xldG9uVHlwZSA9ICQkJGNvbmZpZy5pc0hvc3RTaW5nbGV0b25UeXBlLFxuICAgICAgdmFsdWVTdGFjayA9IFtdO1xuICAgIHZhciBmaWJlclN0YWNrID0gW107XG4gICAgdmFyIGluZGV4JGpzY29tcCQwID0gLTEsXG4gICAgICBlbXB0eUNvbnRleHRPYmplY3QgPSB7fTtcbiAgICBPYmplY3QuZnJlZXplKGVtcHR5Q29udGV4dE9iamVjdCk7XG4gICAgdmFyIGNsejMyID0gTWF0aC5jbHozMiA/IE1hdGguY2x6MzIgOiBjbHozMkZhbGxiYWNrLFxuICAgICAgbG9nJDEgPSBNYXRoLmxvZyxcbiAgICAgIExOMiA9IE1hdGguTE4yLFxuICAgICAgbmV4dFRyYW5zaXRpb25MYW5lID0gMTI4LFxuICAgICAgbmV4dFJldHJ5TGFuZSA9IDQxOTQzMDQsXG4gICAgICBzY2hlZHVsZUNhbGxiYWNrJDMgPSBTY2hlZHVsZXIudW5zdGFibGVfc2NoZWR1bGVDYWxsYmFjayxcbiAgICAgIGNhbmNlbENhbGxiYWNrJDEgPSBTY2hlZHVsZXIudW5zdGFibGVfY2FuY2VsQ2FsbGJhY2ssXG4gICAgICBzaG91bGRZaWVsZCA9IFNjaGVkdWxlci51bnN0YWJsZV9zaG91bGRZaWVsZCxcbiAgICAgIHJlcXVlc3RQYWludCA9IFNjaGVkdWxlci51bnN0YWJsZV9yZXF1ZXN0UGFpbnQsXG4gICAgICBub3ckMSA9IFNjaGVkdWxlci51bnN0YWJsZV9ub3csXG4gICAgICBJbW1lZGlhdGVQcmlvcml0eSA9IFNjaGVkdWxlci51bnN0YWJsZV9JbW1lZGlhdGVQcmlvcml0eSxcbiAgICAgIFVzZXJCbG9ja2luZ1ByaW9yaXR5ID0gU2NoZWR1bGVyLnVuc3RhYmxlX1VzZXJCbG9ja2luZ1ByaW9yaXR5LFxuICAgICAgTm9ybWFsUHJpb3JpdHkkMSA9IFNjaGVkdWxlci51bnN0YWJsZV9Ob3JtYWxQcmlvcml0eSxcbiAgICAgIElkbGVQcmlvcml0eSA9IFNjaGVkdWxlci51bnN0YWJsZV9JZGxlUHJpb3JpdHksXG4gICAgICBsb2cgPSBTY2hlZHVsZXIubG9nLFxuICAgICAgdW5zdGFibGVfc2V0RGlzYWJsZVlpZWxkVmFsdWUgPSBTY2hlZHVsZXIudW5zdGFibGVfc2V0RGlzYWJsZVlpZWxkVmFsdWUsXG4gICAgICByZW5kZXJlcklEID0gbnVsbCxcbiAgICAgIGluamVjdGVkSG9vayA9IG51bGwsXG4gICAgICBpbmplY3RlZFByb2ZpbGluZ0hvb2tzID0gbnVsbCxcbiAgICAgIGhhc0xvZ2dlZEVycm9yID0gITEsXG4gICAgICBpc0RldlRvb2xzUHJlc2VudCA9IFwidW5kZWZpbmVkXCIgIT09IHR5cGVvZiBfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX18sXG4gICAgICBvYmplY3RJcyA9IFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIE9iamVjdC5pcyA/IE9iamVjdC5pcyA6IGlzLFxuICAgICAgQ2FwdHVyZWRTdGFja3MgPSBuZXcgV2Vha01hcCgpLFxuICAgICAgZm9ya1N0YWNrID0gW10sXG4gICAgICBmb3JrU3RhY2tJbmRleCA9IDAsXG4gICAgICB0cmVlRm9ya1Byb3ZpZGVyID0gbnVsbCxcbiAgICAgIHRyZWVGb3JrQ291bnQgPSAwLFxuICAgICAgaWRTdGFjayA9IFtdLFxuICAgICAgaWRTdGFja0luZGV4ID0gMCxcbiAgICAgIHRyZWVDb250ZXh0UHJvdmlkZXIgPSBudWxsLFxuICAgICAgdHJlZUNvbnRleHRJZCA9IDEsXG4gICAgICB0cmVlQ29udGV4dE92ZXJmbG93ID0gXCJcIixcbiAgICAgIGNvbnRleHRTdGFja0N1cnNvciA9IGNyZWF0ZUN1cnNvcihudWxsKSxcbiAgICAgIGNvbnRleHRGaWJlclN0YWNrQ3Vyc29yID0gY3JlYXRlQ3Vyc29yKG51bGwpLFxuICAgICAgcm9vdEluc3RhbmNlU3RhY2tDdXJzb3IgPSBjcmVhdGVDdXJzb3IobnVsbCksXG4gICAgICBob3N0VHJhbnNpdGlvblByb3ZpZGVyQ3Vyc29yID0gY3JlYXRlQ3Vyc29yKG51bGwpLFxuICAgICAgbmVlZHNFc2NhcGluZyA9IC9bXCInJjw+XFxuXFx0XXxeXFxzfFxccyQvLFxuICAgICAgaHlkcmF0aW9uUGFyZW50RmliZXIgPSBudWxsLFxuICAgICAgbmV4dEh5ZHJhdGFibGVJbnN0YW5jZSA9IG51bGwsXG4gICAgICBpc0h5ZHJhdGluZyA9ICExLFxuICAgICAgZGlkU3VzcGVuZE9yRXJyb3JERVYgPSAhMSxcbiAgICAgIGh5ZHJhdGlvbkRpZmZSb290REVWID0gbnVsbCxcbiAgICAgIGh5ZHJhdGlvbkVycm9ycyA9IG51bGwsXG4gICAgICByb290T3JTaW5nbGV0b25Db250ZXh0ID0gITEsXG4gICAgICBIeWRyYXRpb25NaXNtYXRjaEV4Y2VwdGlvbiA9IEVycm9yKFxuICAgICAgICBcIkh5ZHJhdGlvbiBNaXNtYXRjaCBFeGNlcHRpb246IFRoaXMgaXMgbm90IGEgcmVhbCBlcnJvciwgYW5kIHNob3VsZCBub3QgbGVhayBpbnRvIHVzZXJzcGFjZS4gSWYgeW91J3JlIHNlZWluZyB0aGlzLCBpdCdzIGxpa2VseSBhIGJ1ZyBpbiBSZWFjdC5cIlxuICAgICAgKSxcbiAgICAgIE5vTW9kZSA9IDAsXG4gICAgICBjb25jdXJyZW50UXVldWVzID0gW10sXG4gICAgICBjb25jdXJyZW50UXVldWVzSW5kZXggPSAwLFxuICAgICAgY29uY3VycmVudGx5VXBkYXRlZExhbmVzID0gMCxcbiAgICAgIG5vdyA9IFNjaGVkdWxlci51bnN0YWJsZV9ub3csXG4gICAgICBjb21taXRTdGFydFRpbWUgPSAtMCxcbiAgICAgIHByb2ZpbGVyU3RhcnRUaW1lID0gLTEuMSxcbiAgICAgIHByb2ZpbGVyRWZmZWN0RHVyYXRpb24gPSAtMCxcbiAgICAgIGN1cnJlbnRVcGRhdGVJc05lc3RlZCA9ICExLFxuICAgICAgbmVzdGVkVXBkYXRlU2NoZWR1bGVkID0gITEsXG4gICAgICBmaXJzdFNjaGVkdWxlZFJvb3QgPSBudWxsLFxuICAgICAgbGFzdFNjaGVkdWxlZFJvb3QgPSBudWxsLFxuICAgICAgZGlkU2NoZWR1bGVNaWNyb3Rhc2sgPSAhMSxcbiAgICAgIGRpZFNjaGVkdWxlTWljcm90YXNrX2FjdCA9ICExLFxuICAgICAgbWlnaHRIYXZlUGVuZGluZ1N5bmNXb3JrID0gITEsXG4gICAgICBpc0ZsdXNoaW5nV29yayA9ICExLFxuICAgICAgY3VycmVudEV2ZW50VHJhbnNpdGlvbkxhbmUgPSAwLFxuICAgICAgZmFrZUFjdENhbGxiYWNrTm9kZSQxID0ge30sXG4gICAgICBjdXJyZW50RW50YW5nbGVkTGlzdGVuZXJzID0gbnVsbCxcbiAgICAgIGN1cnJlbnRFbnRhbmdsZWRQZW5kaW5nQ291bnQgPSAwLFxuICAgICAgY3VycmVudEVudGFuZ2xlZExhbmUgPSAwLFxuICAgICAgY3VycmVudEVudGFuZ2xlZEFjdGlvblRoZW5hYmxlID0gbnVsbCxcbiAgICAgIFVwZGF0ZVN0YXRlID0gMCxcbiAgICAgIFJlcGxhY2VTdGF0ZSA9IDEsXG4gICAgICBGb3JjZVVwZGF0ZSA9IDIsXG4gICAgICBDYXB0dXJlVXBkYXRlID0gMyxcbiAgICAgIGhhc0ZvcmNlVXBkYXRlID0gITE7XG4gICAgdmFyIGRpZFdhcm5VcGRhdGVJbnNpZGVVcGRhdGUgPSAhMTtcbiAgICB2YXIgY3VycmVudGx5UHJvY2Vzc2luZ1F1ZXVlID0gbnVsbDtcbiAgICB2YXIgZGlkUmVhZEZyb21FbnRhbmdsZWRBc3luY0FjdGlvbiA9ICExLFxuICAgICAgaGFzT3duUHJvcGVydHkgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LFxuICAgICAgUmVhY3RTdHJpY3RNb2RlV2FybmluZ3MgPSB7XG4gICAgICAgIHJlY29yZFVuc2FmZUxpZmVjeWNsZVdhcm5pbmdzOiBmdW5jdGlvbiAoKSB7fSxcbiAgICAgICAgZmx1c2hQZW5kaW5nVW5zYWZlTGlmZWN5Y2xlV2FybmluZ3M6IGZ1bmN0aW9uICgpIHt9LFxuICAgICAgICByZWNvcmRMZWdhY3lDb250ZXh0V2FybmluZzogZnVuY3Rpb24gKCkge30sXG4gICAgICAgIGZsdXNoTGVnYWN5Q29udGV4dFdhcm5pbmc6IGZ1bmN0aW9uICgpIHt9LFxuICAgICAgICBkaXNjYXJkUGVuZGluZ1dhcm5pbmdzOiBmdW5jdGlvbiAoKSB7fVxuICAgICAgfSxcbiAgICAgIHBlbmRpbmdDb21wb25lbnRXaWxsTW91bnRXYXJuaW5ncyA9IFtdLFxuICAgICAgcGVuZGluZ1VOU0FGRV9Db21wb25lbnRXaWxsTW91bnRXYXJuaW5ncyA9IFtdLFxuICAgICAgcGVuZGluZ0NvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHNXYXJuaW5ncyA9IFtdLFxuICAgICAgcGVuZGluZ1VOU0FGRV9Db21wb25lbnRXaWxsUmVjZWl2ZVByb3BzV2FybmluZ3MgPSBbXSxcbiAgICAgIHBlbmRpbmdDb21wb25lbnRXaWxsVXBkYXRlV2FybmluZ3MgPSBbXSxcbiAgICAgIHBlbmRpbmdVTlNBRkVfQ29tcG9uZW50V2lsbFVwZGF0ZVdhcm5pbmdzID0gW10sXG4gICAgICBkaWRXYXJuQWJvdXRVbnNhZmVMaWZlY3ljbGVzID0gbmV3IFNldCgpO1xuICAgIFJlYWN0U3RyaWN0TW9kZVdhcm5pbmdzLnJlY29yZFVuc2FmZUxpZmVjeWNsZVdhcm5pbmdzID0gZnVuY3Rpb24gKFxuICAgICAgZmliZXIsXG4gICAgICBpbnN0YW5jZVxuICAgICkge1xuICAgICAgZGlkV2FybkFib3V0VW5zYWZlTGlmZWN5Y2xlcy5oYXMoZmliZXIudHlwZSkgfHxcbiAgICAgICAgKFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIGluc3RhbmNlLmNvbXBvbmVudFdpbGxNb3VudCAmJlxuICAgICAgICAgICEwICE9PSBpbnN0YW5jZS5jb21wb25lbnRXaWxsTW91bnQuX19zdXBwcmVzc0RlcHJlY2F0aW9uV2FybmluZyAmJlxuICAgICAgICAgIHBlbmRpbmdDb21wb25lbnRXaWxsTW91bnRXYXJuaW5ncy5wdXNoKGZpYmVyKSxcbiAgICAgICAgZmliZXIubW9kZSAmIDggJiZcbiAgICAgICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBpbnN0YW5jZS5VTlNBRkVfY29tcG9uZW50V2lsbE1vdW50ICYmXG4gICAgICAgICAgcGVuZGluZ1VOU0FGRV9Db21wb25lbnRXaWxsTW91bnRXYXJuaW5ncy5wdXNoKGZpYmVyKSxcbiAgICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyAmJlxuICAgICAgICAgICEwICE9PVxuICAgICAgICAgICAgaW5zdGFuY2UuY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcy5fX3N1cHByZXNzRGVwcmVjYXRpb25XYXJuaW5nICYmXG4gICAgICAgICAgcGVuZGluZ0NvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHNXYXJuaW5ncy5wdXNoKGZpYmVyKSxcbiAgICAgICAgZmliZXIubW9kZSAmIDggJiZcbiAgICAgICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBpbnN0YW5jZS5VTlNBRkVfY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyAmJlxuICAgICAgICAgIHBlbmRpbmdVTlNBRkVfQ29tcG9uZW50V2lsbFJlY2VpdmVQcm9wc1dhcm5pbmdzLnB1c2goZmliZXIpLFxuICAgICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBpbnN0YW5jZS5jb21wb25lbnRXaWxsVXBkYXRlICYmXG4gICAgICAgICAgITAgIT09IGluc3RhbmNlLmNvbXBvbmVudFdpbGxVcGRhdGUuX19zdXBwcmVzc0RlcHJlY2F0aW9uV2FybmluZyAmJlxuICAgICAgICAgIHBlbmRpbmdDb21wb25lbnRXaWxsVXBkYXRlV2FybmluZ3MucHVzaChmaWJlciksXG4gICAgICAgIGZpYmVyLm1vZGUgJiA4ICYmXG4gICAgICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgaW5zdGFuY2UuVU5TQUZFX2NvbXBvbmVudFdpbGxVcGRhdGUgJiZcbiAgICAgICAgICBwZW5kaW5nVU5TQUZFX0NvbXBvbmVudFdpbGxVcGRhdGVXYXJuaW5ncy5wdXNoKGZpYmVyKSk7XG4gICAgfTtcbiAgICBSZWFjdFN0cmljdE1vZGVXYXJuaW5ncy5mbHVzaFBlbmRpbmdVbnNhZmVMaWZlY3ljbGVXYXJuaW5ncyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBjb21wb25lbnRXaWxsTW91bnRVbmlxdWVOYW1lcyA9IG5ldyBTZXQoKTtcbiAgICAgIDAgPCBwZW5kaW5nQ29tcG9uZW50V2lsbE1vdW50V2FybmluZ3MubGVuZ3RoICYmXG4gICAgICAgIChwZW5kaW5nQ29tcG9uZW50V2lsbE1vdW50V2FybmluZ3MuZm9yRWFjaChmdW5jdGlvbiAoZmliZXIpIHtcbiAgICAgICAgICBjb21wb25lbnRXaWxsTW91bnRVbmlxdWVOYW1lcy5hZGQoXG4gICAgICAgICAgICBnZXRDb21wb25lbnROYW1lRnJvbUZpYmVyKGZpYmVyKSB8fCBcIkNvbXBvbmVudFwiXG4gICAgICAgICAgKTtcbiAgICAgICAgICBkaWRXYXJuQWJvdXRVbnNhZmVMaWZlY3ljbGVzLmFkZChmaWJlci50eXBlKTtcbiAgICAgICAgfSksXG4gICAgICAgIChwZW5kaW5nQ29tcG9uZW50V2lsbE1vdW50V2FybmluZ3MgPSBbXSkpO1xuICAgICAgdmFyIFVOU0FGRV9jb21wb25lbnRXaWxsTW91bnRVbmlxdWVOYW1lcyA9IG5ldyBTZXQoKTtcbiAgICAgIDAgPCBwZW5kaW5nVU5TQUZFX0NvbXBvbmVudFdpbGxNb3VudFdhcm5pbmdzLmxlbmd0aCAmJlxuICAgICAgICAocGVuZGluZ1VOU0FGRV9Db21wb25lbnRXaWxsTW91bnRXYXJuaW5ncy5mb3JFYWNoKGZ1bmN0aW9uIChmaWJlcikge1xuICAgICAgICAgIFVOU0FGRV9jb21wb25lbnRXaWxsTW91bnRVbmlxdWVOYW1lcy5hZGQoXG4gICAgICAgICAgICBnZXRDb21wb25lbnROYW1lRnJvbUZpYmVyKGZpYmVyKSB8fCBcIkNvbXBvbmVudFwiXG4gICAgICAgICAgKTtcbiAgICAgICAgICBkaWRXYXJuQWJvdXRVbnNhZmVMaWZlY3ljbGVzLmFkZChmaWJlci50eXBlKTtcbiAgICAgICAgfSksXG4gICAgICAgIChwZW5kaW5nVU5TQUZFX0NvbXBvbmVudFdpbGxNb3VudFdhcm5pbmdzID0gW10pKTtcbiAgICAgIHZhciBjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzVW5pcXVlTmFtZXMgPSBuZXcgU2V0KCk7XG4gICAgICAwIDwgcGVuZGluZ0NvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHNXYXJuaW5ncy5sZW5ndGggJiZcbiAgICAgICAgKHBlbmRpbmdDb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzV2FybmluZ3MuZm9yRWFjaChmdW5jdGlvbiAoZmliZXIpIHtcbiAgICAgICAgICBjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzVW5pcXVlTmFtZXMuYWRkKFxuICAgICAgICAgICAgZ2V0Q29tcG9uZW50TmFtZUZyb21GaWJlcihmaWJlcikgfHwgXCJDb21wb25lbnRcIlxuICAgICAgICAgICk7XG4gICAgICAgICAgZGlkV2FybkFib3V0VW5zYWZlTGlmZWN5Y2xlcy5hZGQoZmliZXIudHlwZSk7XG4gICAgICAgIH0pLFxuICAgICAgICAocGVuZGluZ0NvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHNXYXJuaW5ncyA9IFtdKSk7XG4gICAgICB2YXIgVU5TQUZFX2NvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHNVbmlxdWVOYW1lcyA9IG5ldyBTZXQoKTtcbiAgICAgIDAgPCBwZW5kaW5nVU5TQUZFX0NvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHNXYXJuaW5ncy5sZW5ndGggJiZcbiAgICAgICAgKHBlbmRpbmdVTlNBRkVfQ29tcG9uZW50V2lsbFJlY2VpdmVQcm9wc1dhcm5pbmdzLmZvckVhY2goXG4gICAgICAgICAgZnVuY3Rpb24gKGZpYmVyKSB7XG4gICAgICAgICAgICBVTlNBRkVfY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wc1VuaXF1ZU5hbWVzLmFkZChcbiAgICAgICAgICAgICAgZ2V0Q29tcG9uZW50TmFtZUZyb21GaWJlcihmaWJlcikgfHwgXCJDb21wb25lbnRcIlxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGRpZFdhcm5BYm91dFVuc2FmZUxpZmVjeWNsZXMuYWRkKGZpYmVyLnR5cGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgKSxcbiAgICAgICAgKHBlbmRpbmdVTlNBRkVfQ29tcG9uZW50V2lsbFJlY2VpdmVQcm9wc1dhcm5pbmdzID0gW10pKTtcbiAgICAgIHZhciBjb21wb25lbnRXaWxsVXBkYXRlVW5pcXVlTmFtZXMgPSBuZXcgU2V0KCk7XG4gICAgICAwIDwgcGVuZGluZ0NvbXBvbmVudFdpbGxVcGRhdGVXYXJuaW5ncy5sZW5ndGggJiZcbiAgICAgICAgKHBlbmRpbmdDb21wb25lbnRXaWxsVXBkYXRlV2FybmluZ3MuZm9yRWFjaChmdW5jdGlvbiAoZmliZXIpIHtcbiAgICAgICAgICBjb21wb25lbnRXaWxsVXBkYXRlVW5pcXVlTmFtZXMuYWRkKFxuICAgICAgICAgICAgZ2V0Q29tcG9uZW50TmFtZUZyb21GaWJlcihmaWJlcikgfHwgXCJDb21wb25lbnRcIlxuICAgICAgICAgICk7XG4gICAgICAgICAgZGlkV2FybkFib3V0VW5zYWZlTGlmZWN5Y2xlcy5hZGQoZmliZXIudHlwZSk7XG4gICAgICAgIH0pLFxuICAgICAgICAocGVuZGluZ0NvbXBvbmVudFdpbGxVcGRhdGVXYXJuaW5ncyA9IFtdKSk7XG4gICAgICB2YXIgVU5TQUZFX2NvbXBvbmVudFdpbGxVcGRhdGVVbmlxdWVOYW1lcyA9IG5ldyBTZXQoKTtcbiAgICAgIDAgPCBwZW5kaW5nVU5TQUZFX0NvbXBvbmVudFdpbGxVcGRhdGVXYXJuaW5ncy5sZW5ndGggJiZcbiAgICAgICAgKHBlbmRpbmdVTlNBRkVfQ29tcG9uZW50V2lsbFVwZGF0ZVdhcm5pbmdzLmZvckVhY2goZnVuY3Rpb24gKGZpYmVyKSB7XG4gICAgICAgICAgVU5TQUZFX2NvbXBvbmVudFdpbGxVcGRhdGVVbmlxdWVOYW1lcy5hZGQoXG4gICAgICAgICAgICBnZXRDb21wb25lbnROYW1lRnJvbUZpYmVyKGZpYmVyKSB8fCBcIkNvbXBvbmVudFwiXG4gICAgICAgICAgKTtcbiAgICAgICAgICBkaWRXYXJuQWJvdXRVbnNhZmVMaWZlY3ljbGVzLmFkZChmaWJlci50eXBlKTtcbiAgICAgICAgfSksXG4gICAgICAgIChwZW5kaW5nVU5TQUZFX0NvbXBvbmVudFdpbGxVcGRhdGVXYXJuaW5ncyA9IFtdKSk7XG4gICAgICBpZiAoMCA8IFVOU0FGRV9jb21wb25lbnRXaWxsTW91bnRVbmlxdWVOYW1lcy5zaXplKSB7XG4gICAgICAgIHZhciBzb3J0ZWROYW1lcyA9IHNldFRvU29ydGVkU3RyaW5nKFxuICAgICAgICAgIFVOU0FGRV9jb21wb25lbnRXaWxsTW91bnRVbmlxdWVOYW1lc1xuICAgICAgICApO1xuICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgIFwiVXNpbmcgVU5TQUZFX2NvbXBvbmVudFdpbGxNb3VudCBpbiBzdHJpY3QgbW9kZSBpcyBub3QgcmVjb21tZW5kZWQgYW5kIG1heSBpbmRpY2F0ZSBidWdzIGluIHlvdXIgY29kZS4gU2VlIGh0dHBzOi8vcmVhY3QuZGV2L2xpbmsvdW5zYWZlLWNvbXBvbmVudC1saWZlY3ljbGVzIGZvciBkZXRhaWxzLlxcblxcbiogTW92ZSBjb2RlIHdpdGggc2lkZSBlZmZlY3RzIHRvIGNvbXBvbmVudERpZE1vdW50LCBhbmQgc2V0IGluaXRpYWwgc3RhdGUgaW4gdGhlIGNvbnN0cnVjdG9yLlxcblxcblBsZWFzZSB1cGRhdGUgdGhlIGZvbGxvd2luZyBjb21wb25lbnRzOiAlc1wiLFxuICAgICAgICAgIHNvcnRlZE5hbWVzXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICAwIDwgVU5TQUZFX2NvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHNVbmlxdWVOYW1lcy5zaXplICYmXG4gICAgICAgICgoc29ydGVkTmFtZXMgPSBzZXRUb1NvcnRlZFN0cmluZyhcbiAgICAgICAgICBVTlNBRkVfY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wc1VuaXF1ZU5hbWVzXG4gICAgICAgICkpLFxuICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgIFwiVXNpbmcgVU5TQUZFX2NvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMgaW4gc3RyaWN0IG1vZGUgaXMgbm90IHJlY29tbWVuZGVkIGFuZCBtYXkgaW5kaWNhdGUgYnVncyBpbiB5b3VyIGNvZGUuIFNlZSBodHRwczovL3JlYWN0LmRldi9saW5rL3Vuc2FmZS1jb21wb25lbnQtbGlmZWN5Y2xlcyBmb3IgZGV0YWlscy5cXG5cXG4qIE1vdmUgZGF0YSBmZXRjaGluZyBjb2RlIG9yIHNpZGUgZWZmZWN0cyB0byBjb21wb25lbnREaWRVcGRhdGUuXFxuKiBJZiB5b3UncmUgdXBkYXRpbmcgc3RhdGUgd2hlbmV2ZXIgcHJvcHMgY2hhbmdlLCByZWZhY3RvciB5b3VyIGNvZGUgdG8gdXNlIG1lbW9pemF0aW9uIHRlY2huaXF1ZXMgb3IgbW92ZSBpdCB0byBzdGF0aWMgZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzLiBMZWFybiBtb3JlIGF0OiBodHRwczovL3JlYWN0LmRldi9saW5rL2Rlcml2ZWQtc3RhdGVcXG5cXG5QbGVhc2UgdXBkYXRlIHRoZSBmb2xsb3dpbmcgY29tcG9uZW50czogJXNcIixcbiAgICAgICAgICBzb3J0ZWROYW1lc1xuICAgICAgICApKTtcbiAgICAgIDAgPCBVTlNBRkVfY29tcG9uZW50V2lsbFVwZGF0ZVVuaXF1ZU5hbWVzLnNpemUgJiZcbiAgICAgICAgKChzb3J0ZWROYW1lcyA9IHNldFRvU29ydGVkU3RyaW5nKFxuICAgICAgICAgIFVOU0FGRV9jb21wb25lbnRXaWxsVXBkYXRlVW5pcXVlTmFtZXNcbiAgICAgICAgKSksXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgXCJVc2luZyBVTlNBRkVfY29tcG9uZW50V2lsbFVwZGF0ZSBpbiBzdHJpY3QgbW9kZSBpcyBub3QgcmVjb21tZW5kZWQgYW5kIG1heSBpbmRpY2F0ZSBidWdzIGluIHlvdXIgY29kZS4gU2VlIGh0dHBzOi8vcmVhY3QuZGV2L2xpbmsvdW5zYWZlLWNvbXBvbmVudC1saWZlY3ljbGVzIGZvciBkZXRhaWxzLlxcblxcbiogTW92ZSBkYXRhIGZldGNoaW5nIGNvZGUgb3Igc2lkZSBlZmZlY3RzIHRvIGNvbXBvbmVudERpZFVwZGF0ZS5cXG5cXG5QbGVhc2UgdXBkYXRlIHRoZSBmb2xsb3dpbmcgY29tcG9uZW50czogJXNcIixcbiAgICAgICAgICBzb3J0ZWROYW1lc1xuICAgICAgICApKTtcbiAgICAgIDAgPCBjb21wb25lbnRXaWxsTW91bnRVbmlxdWVOYW1lcy5zaXplICYmXG4gICAgICAgICgoc29ydGVkTmFtZXMgPSBzZXRUb1NvcnRlZFN0cmluZyhjb21wb25lbnRXaWxsTW91bnRVbmlxdWVOYW1lcykpLFxuICAgICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgICAgXCJjb21wb25lbnRXaWxsTW91bnQgaGFzIGJlZW4gcmVuYW1lZCwgYW5kIGlzIG5vdCByZWNvbW1lbmRlZCBmb3IgdXNlLiBTZWUgaHR0cHM6Ly9yZWFjdC5kZXYvbGluay91bnNhZmUtY29tcG9uZW50LWxpZmVjeWNsZXMgZm9yIGRldGFpbHMuXFxuXFxuKiBNb3ZlIGNvZGUgd2l0aCBzaWRlIGVmZmVjdHMgdG8gY29tcG9uZW50RGlkTW91bnQsIGFuZCBzZXQgaW5pdGlhbCBzdGF0ZSBpbiB0aGUgY29uc3RydWN0b3IuXFxuKiBSZW5hbWUgY29tcG9uZW50V2lsbE1vdW50IHRvIFVOU0FGRV9jb21wb25lbnRXaWxsTW91bnQgdG8gc3VwcHJlc3MgdGhpcyB3YXJuaW5nIGluIG5vbi1zdHJpY3QgbW9kZS4gSW4gUmVhY3QgMTgueCwgb25seSB0aGUgVU5TQUZFXyBuYW1lIHdpbGwgd29yay4gVG8gcmVuYW1lIGFsbCBkZXByZWNhdGVkIGxpZmVjeWNsZXMgdG8gdGhlaXIgbmV3IG5hbWVzLCB5b3UgY2FuIHJ1biBgbnB4IHJlYWN0LWNvZGVtb2QgcmVuYW1lLXVuc2FmZS1saWZlY3ljbGVzYCBpbiB5b3VyIHByb2plY3Qgc291cmNlIGZvbGRlci5cXG5cXG5QbGVhc2UgdXBkYXRlIHRoZSBmb2xsb3dpbmcgY29tcG9uZW50czogJXNcIixcbiAgICAgICAgICBzb3J0ZWROYW1lc1xuICAgICAgICApKTtcbiAgICAgIDAgPCBjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzVW5pcXVlTmFtZXMuc2l6ZSAmJlxuICAgICAgICAoKHNvcnRlZE5hbWVzID0gc2V0VG9Tb3J0ZWRTdHJpbmcoXG4gICAgICAgICAgY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wc1VuaXF1ZU5hbWVzXG4gICAgICAgICkpLFxuICAgICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgICAgXCJjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzIGhhcyBiZWVuIHJlbmFtZWQsIGFuZCBpcyBub3QgcmVjb21tZW5kZWQgZm9yIHVzZS4gU2VlIGh0dHBzOi8vcmVhY3QuZGV2L2xpbmsvdW5zYWZlLWNvbXBvbmVudC1saWZlY3ljbGVzIGZvciBkZXRhaWxzLlxcblxcbiogTW92ZSBkYXRhIGZldGNoaW5nIGNvZGUgb3Igc2lkZSBlZmZlY3RzIHRvIGNvbXBvbmVudERpZFVwZGF0ZS5cXG4qIElmIHlvdSdyZSB1cGRhdGluZyBzdGF0ZSB3aGVuZXZlciBwcm9wcyBjaGFuZ2UsIHJlZmFjdG9yIHlvdXIgY29kZSB0byB1c2UgbWVtb2l6YXRpb24gdGVjaG5pcXVlcyBvciBtb3ZlIGl0IHRvIHN0YXRpYyBnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMuIExlYXJuIG1vcmUgYXQ6IGh0dHBzOi8vcmVhY3QuZGV2L2xpbmsvZGVyaXZlZC1zdGF0ZVxcbiogUmVuYW1lIGNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMgdG8gVU5TQUZFX2NvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMgdG8gc3VwcHJlc3MgdGhpcyB3YXJuaW5nIGluIG5vbi1zdHJpY3QgbW9kZS4gSW4gUmVhY3QgMTgueCwgb25seSB0aGUgVU5TQUZFXyBuYW1lIHdpbGwgd29yay4gVG8gcmVuYW1lIGFsbCBkZXByZWNhdGVkIGxpZmVjeWNsZXMgdG8gdGhlaXIgbmV3IG5hbWVzLCB5b3UgY2FuIHJ1biBgbnB4IHJlYWN0LWNvZGVtb2QgcmVuYW1lLXVuc2FmZS1saWZlY3ljbGVzYCBpbiB5b3VyIHByb2plY3Qgc291cmNlIGZvbGRlci5cXG5cXG5QbGVhc2UgdXBkYXRlIHRoZSBmb2xsb3dpbmcgY29tcG9uZW50czogJXNcIixcbiAgICAgICAgICBzb3J0ZWROYW1lc1xuICAgICAgICApKTtcbiAgICAgIDAgPCBjb21wb25lbnRXaWxsVXBkYXRlVW5pcXVlTmFtZXMuc2l6ZSAmJlxuICAgICAgICAoKHNvcnRlZE5hbWVzID0gc2V0VG9Tb3J0ZWRTdHJpbmcoY29tcG9uZW50V2lsbFVwZGF0ZVVuaXF1ZU5hbWVzKSksXG4gICAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgICBcImNvbXBvbmVudFdpbGxVcGRhdGUgaGFzIGJlZW4gcmVuYW1lZCwgYW5kIGlzIG5vdCByZWNvbW1lbmRlZCBmb3IgdXNlLiBTZWUgaHR0cHM6Ly9yZWFjdC5kZXYvbGluay91bnNhZmUtY29tcG9uZW50LWxpZmVjeWNsZXMgZm9yIGRldGFpbHMuXFxuXFxuKiBNb3ZlIGRhdGEgZmV0Y2hpbmcgY29kZSBvciBzaWRlIGVmZmVjdHMgdG8gY29tcG9uZW50RGlkVXBkYXRlLlxcbiogUmVuYW1lIGNvbXBvbmVudFdpbGxVcGRhdGUgdG8gVU5TQUZFX2NvbXBvbmVudFdpbGxVcGRhdGUgdG8gc3VwcHJlc3MgdGhpcyB3YXJuaW5nIGluIG5vbi1zdHJpY3QgbW9kZS4gSW4gUmVhY3QgMTgueCwgb25seSB0aGUgVU5TQUZFXyBuYW1lIHdpbGwgd29yay4gVG8gcmVuYW1lIGFsbCBkZXByZWNhdGVkIGxpZmVjeWNsZXMgdG8gdGhlaXIgbmV3IG5hbWVzLCB5b3UgY2FuIHJ1biBgbnB4IHJlYWN0LWNvZGVtb2QgcmVuYW1lLXVuc2FmZS1saWZlY3ljbGVzYCBpbiB5b3VyIHByb2plY3Qgc291cmNlIGZvbGRlci5cXG5cXG5QbGVhc2UgdXBkYXRlIHRoZSBmb2xsb3dpbmcgY29tcG9uZW50czogJXNcIixcbiAgICAgICAgICBzb3J0ZWROYW1lc1xuICAgICAgICApKTtcbiAgICB9O1xuICAgIHZhciBwZW5kaW5nTGVnYWN5Q29udGV4dFdhcm5pbmcgPSBuZXcgTWFwKCksXG4gICAgICBkaWRXYXJuQWJvdXRMZWdhY3lDb250ZXh0ID0gbmV3IFNldCgpO1xuICAgIFJlYWN0U3RyaWN0TW9kZVdhcm5pbmdzLnJlY29yZExlZ2FjeUNvbnRleHRXYXJuaW5nID0gZnVuY3Rpb24gKFxuICAgICAgZmliZXIsXG4gICAgICBpbnN0YW5jZVxuICAgICkge1xuICAgICAgdmFyIHN0cmljdFJvb3QgPSBudWxsO1xuICAgICAgZm9yICh2YXIgbm9kZSA9IGZpYmVyOyBudWxsICE9PSBub2RlOyApXG4gICAgICAgIG5vZGUubW9kZSAmIDggJiYgKHN0cmljdFJvb3QgPSBub2RlKSwgKG5vZGUgPSBub2RlLnJldHVybik7XG4gICAgICBudWxsID09PSBzdHJpY3RSb290XG4gICAgICAgID8gY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgIFwiRXhwZWN0ZWQgdG8gZmluZCBhIFN0cmljdE1vZGUgY29tcG9uZW50IGluIGEgc3RyaWN0IG1vZGUgdHJlZS4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS5cIlxuICAgICAgICAgIClcbiAgICAgICAgOiAhZGlkV2FybkFib3V0TGVnYWN5Q29udGV4dC5oYXMoZmliZXIudHlwZSkgJiZcbiAgICAgICAgICAoKG5vZGUgPSBwZW5kaW5nTGVnYWN5Q29udGV4dFdhcm5pbmcuZ2V0KHN0cmljdFJvb3QpKSxcbiAgICAgICAgICBudWxsICE9IGZpYmVyLnR5cGUuY29udGV4dFR5cGVzIHx8XG4gICAgICAgICAgICBudWxsICE9IGZpYmVyLnR5cGUuY2hpbGRDb250ZXh0VHlwZXMgfHxcbiAgICAgICAgICAgIChudWxsICE9PSBpbnN0YW5jZSAmJlxuICAgICAgICAgICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBpbnN0YW5jZS5nZXRDaGlsZENvbnRleHQpKSAmJlxuICAgICAgICAgICh2b2lkIDAgPT09IG5vZGUgJiZcbiAgICAgICAgICAgICgobm9kZSA9IFtdKSwgcGVuZGluZ0xlZ2FjeUNvbnRleHRXYXJuaW5nLnNldChzdHJpY3RSb290LCBub2RlKSksXG4gICAgICAgICAgbm9kZS5wdXNoKGZpYmVyKSk7XG4gICAgfTtcbiAgICBSZWFjdFN0cmljdE1vZGVXYXJuaW5ncy5mbHVzaExlZ2FjeUNvbnRleHRXYXJuaW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgcGVuZGluZ0xlZ2FjeUNvbnRleHRXYXJuaW5nLmZvckVhY2goZnVuY3Rpb24gKGZpYmVyQXJyYXkpIHtcbiAgICAgICAgaWYgKDAgIT09IGZpYmVyQXJyYXkubGVuZ3RoKSB7XG4gICAgICAgICAgdmFyIGZpcnN0RmliZXIgPSBmaWJlckFycmF5WzBdLFxuICAgICAgICAgICAgdW5pcXVlTmFtZXMgPSBuZXcgU2V0KCk7XG4gICAgICAgICAgZmliZXJBcnJheS5mb3JFYWNoKGZ1bmN0aW9uIChmaWJlcikge1xuICAgICAgICAgICAgdW5pcXVlTmFtZXMuYWRkKGdldENvbXBvbmVudE5hbWVGcm9tRmliZXIoZmliZXIpIHx8IFwiQ29tcG9uZW50XCIpO1xuICAgICAgICAgICAgZGlkV2FybkFib3V0TGVnYWN5Q29udGV4dC5hZGQoZmliZXIudHlwZSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgdmFyIHNvcnRlZE5hbWVzID0gc2V0VG9Tb3J0ZWRTdHJpbmcodW5pcXVlTmFtZXMpO1xuICAgICAgICAgIHJ1bldpdGhGaWJlckluREVWKGZpcnN0RmliZXIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgIFwiTGVnYWN5IGNvbnRleHQgQVBJIGhhcyBiZWVuIGRldGVjdGVkIHdpdGhpbiBhIHN0cmljdC1tb2RlIHRyZWUuXFxuXFxuVGhlIG9sZCBBUEkgd2lsbCBiZSBzdXBwb3J0ZWQgaW4gYWxsIDE2LnggcmVsZWFzZXMsIGJ1dCBhcHBsaWNhdGlvbnMgdXNpbmcgaXQgc2hvdWxkIG1pZ3JhdGUgdG8gdGhlIG5ldyB2ZXJzaW9uLlxcblxcblBsZWFzZSB1cGRhdGUgdGhlIGZvbGxvd2luZyBjb21wb25lbnRzOiAlc1xcblxcbkxlYXJuIG1vcmUgYWJvdXQgdGhpcyB3YXJuaW5nIGhlcmU6IGh0dHBzOi8vcmVhY3QuZGV2L2xpbmsvbGVnYWN5LWNvbnRleHRcIixcbiAgICAgICAgICAgICAgc29ydGVkTmFtZXNcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH07XG4gICAgUmVhY3RTdHJpY3RNb2RlV2FybmluZ3MuZGlzY2FyZFBlbmRpbmdXYXJuaW5ncyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHBlbmRpbmdDb21wb25lbnRXaWxsTW91bnRXYXJuaW5ncyA9IFtdO1xuICAgICAgcGVuZGluZ1VOU0FGRV9Db21wb25lbnRXaWxsTW91bnRXYXJuaW5ncyA9IFtdO1xuICAgICAgcGVuZGluZ0NvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHNXYXJuaW5ncyA9IFtdO1xuICAgICAgcGVuZGluZ1VOU0FGRV9Db21wb25lbnRXaWxsUmVjZWl2ZVByb3BzV2FybmluZ3MgPSBbXTtcbiAgICAgIHBlbmRpbmdDb21wb25lbnRXaWxsVXBkYXRlV2FybmluZ3MgPSBbXTtcbiAgICAgIHBlbmRpbmdVTlNBRkVfQ29tcG9uZW50V2lsbFVwZGF0ZVdhcm5pbmdzID0gW107XG4gICAgICBwZW5kaW5nTGVnYWN5Q29udGV4dFdhcm5pbmcgPSBuZXcgTWFwKCk7XG4gICAgfTtcbiAgICB2YXIgU3VzcGVuc2VFeGNlcHRpb24gPSBFcnJvcihcbiAgICAgICAgXCJTdXNwZW5zZSBFeGNlcHRpb246IFRoaXMgaXMgbm90IGEgcmVhbCBlcnJvciEgSXQncyBhbiBpbXBsZW1lbnRhdGlvbiBkZXRhaWwgb2YgYHVzZWAgdG8gaW50ZXJydXB0IHRoZSBjdXJyZW50IHJlbmRlci4gWW91IG11c3QgZWl0aGVyIHJldGhyb3cgaXQgaW1tZWRpYXRlbHksIG9yIG1vdmUgdGhlIGB1c2VgIGNhbGwgb3V0c2lkZSBvZiB0aGUgYHRyeS9jYXRjaGAgYmxvY2suIENhcHR1cmluZyB3aXRob3V0IHJldGhyb3dpbmcgd2lsbCBsZWFkIHRvIHVuZXhwZWN0ZWQgYmVoYXZpb3IuXFxuXFxuVG8gaGFuZGxlIGFzeW5jIGVycm9ycywgd3JhcCB5b3VyIGNvbXBvbmVudCBpbiBhbiBlcnJvciBib3VuZGFyeSwgb3IgY2FsbCB0aGUgcHJvbWlzZSdzIGAuY2F0Y2hgIG1ldGhvZCBhbmQgcGFzcyB0aGUgcmVzdWx0IHRvIGB1c2VgXCJcbiAgICAgICksXG4gICAgICBTdXNwZW5zZXlDb21taXRFeGNlcHRpb24gPSBFcnJvcihcbiAgICAgICAgXCJTdXNwZW5zZSBFeGNlcHRpb246IFRoaXMgaXMgbm90IGEgcmVhbCBlcnJvciwgYW5kIHNob3VsZCBub3QgbGVhayBpbnRvIHVzZXJzcGFjZS4gSWYgeW91J3JlIHNlZWluZyB0aGlzLCBpdCdzIGxpa2VseSBhIGJ1ZyBpbiBSZWFjdC5cIlxuICAgICAgKSxcbiAgICAgIG5vb3BTdXNwZW5zZXlDb21taXRUaGVuYWJsZSA9IHtcbiAgICAgICAgdGhlbjogZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAnSW50ZXJuYWwgUmVhY3QgZXJyb3I6IEEgbGlzdGVuZXIgd2FzIHVuZXhwZWN0ZWRseSBhdHRhY2hlZCB0byBhIFwibm9vcFwiIHRoZW5hYmxlLiBUaGlzIGlzIGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHN1c3BlbmRlZFRoZW5hYmxlID0gbnVsbCxcbiAgICAgIG5lZWRzVG9SZXNldFN1c3BlbmRlZFRoZW5hYmxlREVWID0gITEsXG4gICAgICBjYWxsQ29tcG9uZW50ID0ge1xuICAgICAgICBcInJlYWN0LXN0YWNrLWJvdHRvbS1mcmFtZVwiOiBmdW5jdGlvbiAoQ29tcG9uZW50LCBwcm9wcywgc2Vjb25kQXJnKSB7XG4gICAgICAgICAgdmFyIHdhc1JlbmRlcmluZyA9IGlzUmVuZGVyaW5nO1xuICAgICAgICAgIGlzUmVuZGVyaW5nID0gITA7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBDb21wb25lbnQocHJvcHMsIHNlY29uZEFyZyk7XG4gICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIGlzUmVuZGVyaW5nID0gd2FzUmVuZGVyaW5nO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGNhbGxDb21wb25lbnRJbkRFViA9XG4gICAgICAgIGNhbGxDb21wb25lbnRbXCJyZWFjdC1zdGFjay1ib3R0b20tZnJhbWVcIl0uYmluZChjYWxsQ29tcG9uZW50KSxcbiAgICAgIGNhbGxSZW5kZXIgPSB7XG4gICAgICAgIFwicmVhY3Qtc3RhY2stYm90dG9tLWZyYW1lXCI6IGZ1bmN0aW9uIChpbnN0YW5jZSkge1xuICAgICAgICAgIHZhciB3YXNSZW5kZXJpbmcgPSBpc1JlbmRlcmluZztcbiAgICAgICAgICBpc1JlbmRlcmluZyA9ICEwO1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gaW5zdGFuY2UucmVuZGVyKCk7XG4gICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIGlzUmVuZGVyaW5nID0gd2FzUmVuZGVyaW5nO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGNhbGxSZW5kZXJJbkRFViA9IGNhbGxSZW5kZXJbXCJyZWFjdC1zdGFjay1ib3R0b20tZnJhbWVcIl0uYmluZChjYWxsUmVuZGVyKSxcbiAgICAgIGNhbGxDb21wb25lbnREaWRNb3VudCA9IHtcbiAgICAgICAgXCJyZWFjdC1zdGFjay1ib3R0b20tZnJhbWVcIjogZnVuY3Rpb24gKGZpbmlzaGVkV29yaywgaW5zdGFuY2UpIHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgaW5zdGFuY2UuY29tcG9uZW50RGlkTW91bnQoKTtcbiAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgY2FwdHVyZUNvbW1pdFBoYXNlRXJyb3IoZmluaXNoZWRXb3JrLCBmaW5pc2hlZFdvcmsucmV0dXJuLCBlcnJvcik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgY2FsbENvbXBvbmVudERpZE1vdW50SW5ERVYgPSBjYWxsQ29tcG9uZW50RGlkTW91bnRbXG4gICAgICAgIFwicmVhY3Qtc3RhY2stYm90dG9tLWZyYW1lXCJcbiAgICAgIF0uYmluZChjYWxsQ29tcG9uZW50RGlkTW91bnQpLFxuICAgICAgY2FsbENvbXBvbmVudERpZFVwZGF0ZSA9IHtcbiAgICAgICAgXCJyZWFjdC1zdGFjay1ib3R0b20tZnJhbWVcIjogZnVuY3Rpb24gKFxuICAgICAgICAgIGZpbmlzaGVkV29yayxcbiAgICAgICAgICBpbnN0YW5jZSxcbiAgICAgICAgICBwcmV2UHJvcHMsXG4gICAgICAgICAgcHJldlN0YXRlLFxuICAgICAgICAgIHNuYXBzaG90XG4gICAgICAgICkge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpbnN0YW5jZS5jb21wb25lbnREaWRVcGRhdGUocHJldlByb3BzLCBwcmV2U3RhdGUsIHNuYXBzaG90KTtcbiAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgY2FwdHVyZUNvbW1pdFBoYXNlRXJyb3IoZmluaXNoZWRXb3JrLCBmaW5pc2hlZFdvcmsucmV0dXJuLCBlcnJvcik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgY2FsbENvbXBvbmVudERpZFVwZGF0ZUluREVWID0gY2FsbENvbXBvbmVudERpZFVwZGF0ZVtcbiAgICAgICAgXCJyZWFjdC1zdGFjay1ib3R0b20tZnJhbWVcIlxuICAgICAgXS5iaW5kKGNhbGxDb21wb25lbnREaWRVcGRhdGUpLFxuICAgICAgY2FsbENvbXBvbmVudERpZENhdGNoID0ge1xuICAgICAgICBcInJlYWN0LXN0YWNrLWJvdHRvbS1mcmFtZVwiOiBmdW5jdGlvbiAoaW5zdGFuY2UsIGVycm9ySW5mbykge1xuICAgICAgICAgIHZhciBzdGFjayA9IGVycm9ySW5mby5zdGFjaztcbiAgICAgICAgICBpbnN0YW5jZS5jb21wb25lbnREaWRDYXRjaChlcnJvckluZm8udmFsdWUsIHtcbiAgICAgICAgICAgIGNvbXBvbmVudFN0YWNrOiBudWxsICE9PSBzdGFjayA/IHN0YWNrIDogXCJcIlxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgY2FsbENvbXBvbmVudERpZENhdGNoSW5ERVYgPSBjYWxsQ29tcG9uZW50RGlkQ2F0Y2hbXG4gICAgICAgIFwicmVhY3Qtc3RhY2stYm90dG9tLWZyYW1lXCJcbiAgICAgIF0uYmluZChjYWxsQ29tcG9uZW50RGlkQ2F0Y2gpLFxuICAgICAgY2FsbENvbXBvbmVudFdpbGxVbm1vdW50ID0ge1xuICAgICAgICBcInJlYWN0LXN0YWNrLWJvdHRvbS1mcmFtZVwiOiBmdW5jdGlvbiAoXG4gICAgICAgICAgY3VycmVudCxcbiAgICAgICAgICBuZWFyZXN0TW91bnRlZEFuY2VzdG9yLFxuICAgICAgICAgIGluc3RhbmNlXG4gICAgICAgICkge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpbnN0YW5jZS5jb21wb25lbnRXaWxsVW5tb3VudCgpO1xuICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBjYXB0dXJlQ29tbWl0UGhhc2VFcnJvcihjdXJyZW50LCBuZWFyZXN0TW91bnRlZEFuY2VzdG9yLCBlcnJvcik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgY2FsbENvbXBvbmVudFdpbGxVbm1vdW50SW5ERVYgPSBjYWxsQ29tcG9uZW50V2lsbFVubW91bnRbXG4gICAgICAgIFwicmVhY3Qtc3RhY2stYm90dG9tLWZyYW1lXCJcbiAgICAgIF0uYmluZChjYWxsQ29tcG9uZW50V2lsbFVubW91bnQpLFxuICAgICAgY2FsbENyZWF0ZSA9IHtcbiAgICAgICAgXCJyZWFjdC1zdGFjay1ib3R0b20tZnJhbWVcIjogZnVuY3Rpb24gKGVmZmVjdCkge1xuICAgICAgICAgIHZhciBjcmVhdGUgPSBlZmZlY3QuY3JlYXRlO1xuICAgICAgICAgIGVmZmVjdCA9IGVmZmVjdC5pbnN0O1xuICAgICAgICAgIGNyZWF0ZSA9IGNyZWF0ZSgpO1xuICAgICAgICAgIHJldHVybiAoZWZmZWN0LmRlc3Ryb3kgPSBjcmVhdGUpO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgY2FsbENyZWF0ZUluREVWID0gY2FsbENyZWF0ZVtcInJlYWN0LXN0YWNrLWJvdHRvbS1mcmFtZVwiXS5iaW5kKGNhbGxDcmVhdGUpLFxuICAgICAgY2FsbERlc3Ryb3kgPSB7XG4gICAgICAgIFwicmVhY3Qtc3RhY2stYm90dG9tLWZyYW1lXCI6IGZ1bmN0aW9uIChcbiAgICAgICAgICBjdXJyZW50LFxuICAgICAgICAgIG5lYXJlc3RNb3VudGVkQW5jZXN0b3IsXG4gICAgICAgICAgZGVzdHJveVxuICAgICAgICApIHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgZGVzdHJveSgpO1xuICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBjYXB0dXJlQ29tbWl0UGhhc2VFcnJvcihjdXJyZW50LCBuZWFyZXN0TW91bnRlZEFuY2VzdG9yLCBlcnJvcik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgY2FsbERlc3Ryb3lJbkRFViA9XG4gICAgICAgIGNhbGxEZXN0cm95W1wicmVhY3Qtc3RhY2stYm90dG9tLWZyYW1lXCJdLmJpbmQoY2FsbERlc3Ryb3kpLFxuICAgICAgY2FsbExhenlJbml0ID0ge1xuICAgICAgICBcInJlYWN0LXN0YWNrLWJvdHRvbS1mcmFtZVwiOiBmdW5jdGlvbiAobGF6eSkge1xuICAgICAgICAgIHZhciBpbml0ID0gbGF6eS5faW5pdDtcbiAgICAgICAgICByZXR1cm4gaW5pdChsYXp5Ll9wYXlsb2FkKTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGNhbGxMYXp5SW5pdEluREVWID1cbiAgICAgICAgY2FsbExhenlJbml0W1wicmVhY3Qtc3RhY2stYm90dG9tLWZyYW1lXCJdLmJpbmQoY2FsbExhenlJbml0KSxcbiAgICAgIHRoZW5hYmxlU3RhdGUkMSA9IG51bGwsXG4gICAgICB0aGVuYWJsZUluZGV4Q291bnRlciQxID0gMCxcbiAgICAgIGN1cnJlbnREZWJ1Z0luZm8gPSBudWxsLFxuICAgICAgZGlkV2FybkFib3V0TWFwcztcbiAgICB2YXIgZGlkV2FybkFib3V0R2VuZXJhdG9ycyA9IChkaWRXYXJuQWJvdXRNYXBzID0gITEpO1xuICAgIHZhciBvd25lckhhc0tleVVzZVdhcm5pbmcgPSB7fTtcbiAgICB2YXIgb3duZXJIYXNGdW5jdGlvblR5cGVXYXJuaW5nID0ge307XG4gICAgdmFyIG93bmVySGFzU3ltYm9sVHlwZVdhcm5pbmcgPSB7fTtcbiAgICB3YXJuRm9yTWlzc2luZ0tleSA9IGZ1bmN0aW9uIChyZXR1cm5GaWJlciwgd29ya0luUHJvZ3Jlc3MsIGNoaWxkKSB7XG4gICAgICBpZiAoXG4gICAgICAgIG51bGwgIT09IGNoaWxkICYmXG4gICAgICAgIFwib2JqZWN0XCIgPT09IHR5cGVvZiBjaGlsZCAmJlxuICAgICAgICBjaGlsZC5fc3RvcmUgJiZcbiAgICAgICAgKCghY2hpbGQuX3N0b3JlLnZhbGlkYXRlZCAmJiBudWxsID09IGNoaWxkLmtleSkgfHxcbiAgICAgICAgICAyID09PSBjaGlsZC5fc3RvcmUudmFsaWRhdGVkKVxuICAgICAgKSB7XG4gICAgICAgIGlmIChcIm9iamVjdFwiICE9PSB0eXBlb2YgY2hpbGQuX3N0b3JlKVxuICAgICAgICAgIHRocm93IEVycm9yKFxuICAgICAgICAgICAgXCJSZWFjdCBDb21wb25lbnQgaW4gd2FybkZvck1pc3NpbmdLZXkgc2hvdWxkIGhhdmUgYSBfc3RvcmUuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuXCJcbiAgICAgICAgICApO1xuICAgICAgICBjaGlsZC5fc3RvcmUudmFsaWRhdGVkID0gMTtcbiAgICAgICAgdmFyIGNvbXBvbmVudE5hbWUgPSBnZXRDb21wb25lbnROYW1lRnJvbUZpYmVyKHJldHVybkZpYmVyKSxcbiAgICAgICAgICBjb21wb25lbnRLZXkgPSBjb21wb25lbnROYW1lIHx8IFwibnVsbFwiO1xuICAgICAgICBpZiAoIW93bmVySGFzS2V5VXNlV2FybmluZ1tjb21wb25lbnRLZXldKSB7XG4gICAgICAgICAgb3duZXJIYXNLZXlVc2VXYXJuaW5nW2NvbXBvbmVudEtleV0gPSAhMDtcbiAgICAgICAgICBjaGlsZCA9IGNoaWxkLl9vd25lcjtcbiAgICAgICAgICByZXR1cm5GaWJlciA9IHJldHVybkZpYmVyLl9kZWJ1Z093bmVyO1xuICAgICAgICAgIHZhciBjdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvID0gXCJcIjtcbiAgICAgICAgICByZXR1cm5GaWJlciAmJlxuICAgICAgICAgICAgXCJudW1iZXJcIiA9PT0gdHlwZW9mIHJldHVybkZpYmVyLnRhZyAmJlxuICAgICAgICAgICAgKGNvbXBvbmVudEtleSA9IGdldENvbXBvbmVudE5hbWVGcm9tRmliZXIocmV0dXJuRmliZXIpKSAmJlxuICAgICAgICAgICAgKGN1cnJlbnRDb21wb25lbnRFcnJvckluZm8gPVxuICAgICAgICAgICAgICBcIlxcblxcbkNoZWNrIHRoZSByZW5kZXIgbWV0aG9kIG9mIGBcIiArIGNvbXBvbmVudEtleSArIFwiYC5cIik7XG4gICAgICAgICAgY3VycmVudENvbXBvbmVudEVycm9ySW5mbyB8fFxuICAgICAgICAgICAgKGNvbXBvbmVudE5hbWUgJiZcbiAgICAgICAgICAgICAgKGN1cnJlbnRDb21wb25lbnRFcnJvckluZm8gPVxuICAgICAgICAgICAgICAgIFwiXFxuXFxuQ2hlY2sgdGhlIHRvcC1sZXZlbCByZW5kZXIgY2FsbCB1c2luZyA8XCIgK1xuICAgICAgICAgICAgICAgIGNvbXBvbmVudE5hbWUgK1xuICAgICAgICAgICAgICAgIFwiPi5cIikpO1xuICAgICAgICAgIHZhciBjaGlsZE93bmVyQXBwZW5kaXggPSBcIlwiO1xuICAgICAgICAgIG51bGwgIT0gY2hpbGQgJiZcbiAgICAgICAgICAgIHJldHVybkZpYmVyICE9PSBjaGlsZCAmJlxuICAgICAgICAgICAgKChjb21wb25lbnROYW1lID0gbnVsbCksXG4gICAgICAgICAgICBcIm51bWJlclwiID09PSB0eXBlb2YgY2hpbGQudGFnXG4gICAgICAgICAgICAgID8gKGNvbXBvbmVudE5hbWUgPSBnZXRDb21wb25lbnROYW1lRnJvbUZpYmVyKGNoaWxkKSlcbiAgICAgICAgICAgICAgOiBcInN0cmluZ1wiID09PSB0eXBlb2YgY2hpbGQubmFtZSAmJiAoY29tcG9uZW50TmFtZSA9IGNoaWxkLm5hbWUpLFxuICAgICAgICAgICAgY29tcG9uZW50TmFtZSAmJlxuICAgICAgICAgICAgICAoY2hpbGRPd25lckFwcGVuZGl4ID1cbiAgICAgICAgICAgICAgICBcIiBJdCB3YXMgcGFzc2VkIGEgY2hpbGQgZnJvbSBcIiArIGNvbXBvbmVudE5hbWUgKyBcIi5cIikpO1xuICAgICAgICAgIHJ1bldpdGhGaWJlckluREVWKHdvcmtJblByb2dyZXNzLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICAnRWFjaCBjaGlsZCBpbiBhIGxpc3Qgc2hvdWxkIGhhdmUgYSB1bmlxdWUgXCJrZXlcIiBwcm9wLiVzJXMgU2VlIGh0dHBzOi8vcmVhY3QuZGV2L2xpbmsvd2FybmluZy1rZXlzIGZvciBtb3JlIGluZm9ybWF0aW9uLicsXG4gICAgICAgICAgICAgIGN1cnJlbnRDb21wb25lbnRFcnJvckluZm8sXG4gICAgICAgICAgICAgIGNoaWxkT3duZXJBcHBlbmRpeFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gICAgdmFyIHJlY29uY2lsZUNoaWxkRmliZXJzID0gY3JlYXRlQ2hpbGRSZWNvbmNpbGVyKCEwKSxcbiAgICAgIG1vdW50Q2hpbGRGaWJlcnMgPSBjcmVhdGVDaGlsZFJlY29uY2lsZXIoITEpLFxuICAgICAgY3VycmVudFRyZWVIaWRkZW5TdGFja0N1cnNvciA9IGNyZWF0ZUN1cnNvcihudWxsKSxcbiAgICAgIHByZXZFbnRhbmdsZWRSZW5kZXJMYW5lc0N1cnNvciA9IGNyZWF0ZUN1cnNvcigwKSxcbiAgICAgIHN1c3BlbnNlSGFuZGxlclN0YWNrQ3Vyc29yID0gY3JlYXRlQ3Vyc29yKG51bGwpLFxuICAgICAgc2hlbGxCb3VuZGFyeSA9IG51bGwsXG4gICAgICBTdWJ0cmVlU3VzcGVuc2VDb250ZXh0TWFzayA9IDEsXG4gICAgICBGb3JjZVN1c3BlbnNlRmFsbGJhY2sgPSAyLFxuICAgICAgc3VzcGVuc2VTdGFja0N1cnNvciA9IGNyZWF0ZUN1cnNvcigwKSxcbiAgICAgIE5vRmxhZ3MgPSAwLFxuICAgICAgSGFzRWZmZWN0ID0gMSxcbiAgICAgIEluc2VydGlvbiA9IDIsXG4gICAgICBMYXlvdXQgPSA0LFxuICAgICAgUGFzc2l2ZSA9IDgsXG4gICAgICBkaWRXYXJuVW5jYWNoZWRHZXRTbmFwc2hvdDtcbiAgICB2YXIgZGlkV2FybkFib3V0TWlzbWF0Y2hlZEhvb2tzRm9yQ29tcG9uZW50ID0gbmV3IFNldCgpO1xuICAgIHZhciBkaWRXYXJuQWJvdXRVc2VXcmFwcGVkSW5UcnlDYXRjaCA9IG5ldyBTZXQoKTtcbiAgICB2YXIgZGlkV2FybkFib3V0QXN5bmNDbGllbnRDb21wb25lbnQgPSBuZXcgU2V0KCk7XG4gICAgdmFyIGRpZFdhcm5BYm91dFVzZUZvcm1TdGF0ZSA9IG5ldyBTZXQoKTtcbiAgICB2YXIgcmVuZGVyTGFuZXMgPSAwLFxuICAgICAgY3VycmVudGx5UmVuZGVyaW5nRmliZXIkMSA9IG51bGwsXG4gICAgICBjdXJyZW50SG9vayA9IG51bGwsXG4gICAgICB3b3JrSW5Qcm9ncmVzc0hvb2sgPSBudWxsLFxuICAgICAgZGlkU2NoZWR1bGVSZW5kZXJQaGFzZVVwZGF0ZSA9ICExLFxuICAgICAgZGlkU2NoZWR1bGVSZW5kZXJQaGFzZVVwZGF0ZUR1cmluZ1RoaXNQYXNzID0gITEsXG4gICAgICBzaG91bGREb3VibGVJbnZva2VVc2VyRm5zSW5Ib29rc0RFViA9ICExLFxuICAgICAgbG9jYWxJZENvdW50ZXIgPSAwLFxuICAgICAgdGhlbmFibGVJbmRleENvdW50ZXIgPSAwLFxuICAgICAgdGhlbmFibGVTdGF0ZSA9IG51bGwsXG4gICAgICBnbG9iYWxDbGllbnRJZENvdW50ZXIgPSAwLFxuICAgICAgUkVfUkVOREVSX0xJTUlUID0gMjUsXG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9IG51bGwsXG4gICAgICBob29rVHlwZXNEZXYgPSBudWxsLFxuICAgICAgaG9va1R5cGVzVXBkYXRlSW5kZXhEZXYgPSAtMSxcbiAgICAgIGlnbm9yZVByZXZpb3VzRGVwZW5kZW5jaWVzID0gITE7XG4gICAgdmFyIGNyZWF0ZUZ1bmN0aW9uQ29tcG9uZW50VXBkYXRlUXVldWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4geyBsYXN0RWZmZWN0OiBudWxsLCBldmVudHM6IG51bGwsIHN0b3JlczogbnVsbCwgbWVtb0NhY2hlOiBudWxsIH07XG4gICAgfTtcbiAgICB2YXIgQ29udGV4dE9ubHlEaXNwYXRjaGVyID0ge1xuICAgICAgcmVhZENvbnRleHQ6IHJlYWRDb250ZXh0LFxuICAgICAgdXNlOiB1c2UsXG4gICAgICB1c2VDYWxsYmFjazogdGhyb3dJbnZhbGlkSG9va0Vycm9yLFxuICAgICAgdXNlQ29udGV4dDogdGhyb3dJbnZhbGlkSG9va0Vycm9yLFxuICAgICAgdXNlRWZmZWN0OiB0aHJvd0ludmFsaWRIb29rRXJyb3IsXG4gICAgICB1c2VJbXBlcmF0aXZlSGFuZGxlOiB0aHJvd0ludmFsaWRIb29rRXJyb3IsXG4gICAgICB1c2VMYXlvdXRFZmZlY3Q6IHRocm93SW52YWxpZEhvb2tFcnJvcixcbiAgICAgIHVzZUluc2VydGlvbkVmZmVjdDogdGhyb3dJbnZhbGlkSG9va0Vycm9yLFxuICAgICAgdXNlTWVtbzogdGhyb3dJbnZhbGlkSG9va0Vycm9yLFxuICAgICAgdXNlUmVkdWNlcjogdGhyb3dJbnZhbGlkSG9va0Vycm9yLFxuICAgICAgdXNlUmVmOiB0aHJvd0ludmFsaWRIb29rRXJyb3IsXG4gICAgICB1c2VTdGF0ZTogdGhyb3dJbnZhbGlkSG9va0Vycm9yLFxuICAgICAgdXNlRGVidWdWYWx1ZTogdGhyb3dJbnZhbGlkSG9va0Vycm9yLFxuICAgICAgdXNlRGVmZXJyZWRWYWx1ZTogdGhyb3dJbnZhbGlkSG9va0Vycm9yLFxuICAgICAgdXNlVHJhbnNpdGlvbjogdGhyb3dJbnZhbGlkSG9va0Vycm9yLFxuICAgICAgdXNlU3luY0V4dGVybmFsU3RvcmU6IHRocm93SW52YWxpZEhvb2tFcnJvcixcbiAgICAgIHVzZUlkOiB0aHJvd0ludmFsaWRIb29rRXJyb3JcbiAgICB9O1xuICAgIENvbnRleHRPbmx5RGlzcGF0Y2hlci51c2VDYWNoZVJlZnJlc2ggPSB0aHJvd0ludmFsaWRIb29rRXJyb3I7XG4gICAgQ29udGV4dE9ubHlEaXNwYXRjaGVyLnVzZU1lbW9DYWNoZSA9IHRocm93SW52YWxpZEhvb2tFcnJvcjtcbiAgICBDb250ZXh0T25seURpc3BhdGNoZXIudXNlSG9zdFRyYW5zaXRpb25TdGF0dXMgPSB0aHJvd0ludmFsaWRIb29rRXJyb3I7XG4gICAgQ29udGV4dE9ubHlEaXNwYXRjaGVyLnVzZUZvcm1TdGF0ZSA9IHRocm93SW52YWxpZEhvb2tFcnJvcjtcbiAgICBDb250ZXh0T25seURpc3BhdGNoZXIudXNlQWN0aW9uU3RhdGUgPSB0aHJvd0ludmFsaWRIb29rRXJyb3I7XG4gICAgQ29udGV4dE9ubHlEaXNwYXRjaGVyLnVzZU9wdGltaXN0aWMgPSB0aHJvd0ludmFsaWRIb29rRXJyb3I7XG4gICAgdmFyIEhvb2tzRGlzcGF0Y2hlck9uTW91bnRJbkRFViA9IG51bGwsXG4gICAgICBIb29rc0Rpc3BhdGNoZXJPbk1vdW50V2l0aEhvb2tUeXBlc0luREVWID0gbnVsbCxcbiAgICAgIEhvb2tzRGlzcGF0Y2hlck9uVXBkYXRlSW5ERVYgPSBudWxsLFxuICAgICAgSG9va3NEaXNwYXRjaGVyT25SZXJlbmRlckluREVWID0gbnVsbCxcbiAgICAgIEludmFsaWROZXN0ZWRIb29rc0Rpc3BhdGNoZXJPbk1vdW50SW5ERVYgPSBudWxsLFxuICAgICAgSW52YWxpZE5lc3RlZEhvb2tzRGlzcGF0Y2hlck9uVXBkYXRlSW5ERVYgPSBudWxsLFxuICAgICAgSW52YWxpZE5lc3RlZEhvb2tzRGlzcGF0Y2hlck9uUmVyZW5kZXJJbkRFViA9IG51bGw7XG4gICAgSG9va3NEaXNwYXRjaGVyT25Nb3VudEluREVWID0ge1xuICAgICAgcmVhZENvbnRleHQ6IGZ1bmN0aW9uIChjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiByZWFkQ29udGV4dChjb250ZXh0KTtcbiAgICAgIH0sXG4gICAgICB1c2U6IHVzZSxcbiAgICAgIHVzZUNhbGxiYWNrOiBmdW5jdGlvbiAoY2FsbGJhY2ssIGRlcHMpIHtcbiAgICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSBcInVzZUNhbGxiYWNrXCI7XG4gICAgICAgIG1vdW50SG9va1R5cGVzRGV2KCk7XG4gICAgICAgIGNoZWNrRGVwc0FyZUFycmF5RGV2KGRlcHMpO1xuICAgICAgICByZXR1cm4gbW91bnRDYWxsYmFjayhjYWxsYmFjaywgZGVwcyk7XG4gICAgICB9LFxuICAgICAgdXNlQ29udGV4dDogZnVuY3Rpb24gKGNvbnRleHQpIHtcbiAgICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSBcInVzZUNvbnRleHRcIjtcbiAgICAgICAgbW91bnRIb29rVHlwZXNEZXYoKTtcbiAgICAgICAgcmV0dXJuIHJlYWRDb250ZXh0KGNvbnRleHQpO1xuICAgICAgfSxcbiAgICAgIHVzZUVmZmVjdDogZnVuY3Rpb24gKGNyZWF0ZSwgZGVwcykge1xuICAgICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9IFwidXNlRWZmZWN0XCI7XG4gICAgICAgIG1vdW50SG9va1R5cGVzRGV2KCk7XG4gICAgICAgIGNoZWNrRGVwc0FyZUFycmF5RGV2KGRlcHMpO1xuICAgICAgICByZXR1cm4gbW91bnRFZmZlY3QoY3JlYXRlLCBkZXBzKTtcbiAgICAgIH0sXG4gICAgICB1c2VJbXBlcmF0aXZlSGFuZGxlOiBmdW5jdGlvbiAocmVmLCBjcmVhdGUsIGRlcHMpIHtcbiAgICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSBcInVzZUltcGVyYXRpdmVIYW5kbGVcIjtcbiAgICAgICAgbW91bnRIb29rVHlwZXNEZXYoKTtcbiAgICAgICAgY2hlY2tEZXBzQXJlQXJyYXlEZXYoZGVwcyk7XG4gICAgICAgIHJldHVybiBtb3VudEltcGVyYXRpdmVIYW5kbGUocmVmLCBjcmVhdGUsIGRlcHMpO1xuICAgICAgfSxcbiAgICAgIHVzZUluc2VydGlvbkVmZmVjdDogZnVuY3Rpb24gKGNyZWF0ZSwgZGVwcykge1xuICAgICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9IFwidXNlSW5zZXJ0aW9uRWZmZWN0XCI7XG4gICAgICAgIG1vdW50SG9va1R5cGVzRGV2KCk7XG4gICAgICAgIGNoZWNrRGVwc0FyZUFycmF5RGV2KGRlcHMpO1xuICAgICAgICBtb3VudEVmZmVjdEltcGwoNCwgSW5zZXJ0aW9uLCBjcmVhdGUsIGRlcHMpO1xuICAgICAgfSxcbiAgICAgIHVzZUxheW91dEVmZmVjdDogZnVuY3Rpb24gKGNyZWF0ZSwgZGVwcykge1xuICAgICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9IFwidXNlTGF5b3V0RWZmZWN0XCI7XG4gICAgICAgIG1vdW50SG9va1R5cGVzRGV2KCk7XG4gICAgICAgIGNoZWNrRGVwc0FyZUFycmF5RGV2KGRlcHMpO1xuICAgICAgICByZXR1cm4gbW91bnRMYXlvdXRFZmZlY3QoY3JlYXRlLCBkZXBzKTtcbiAgICAgIH0sXG4gICAgICB1c2VNZW1vOiBmdW5jdGlvbiAoY3JlYXRlLCBkZXBzKSB7XG4gICAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gXCJ1c2VNZW1vXCI7XG4gICAgICAgIG1vdW50SG9va1R5cGVzRGV2KCk7XG4gICAgICAgIGNoZWNrRGVwc0FyZUFycmF5RGV2KGRlcHMpO1xuICAgICAgICB2YXIgcHJldkRpc3BhdGNoZXIgPSBSZWFjdFNoYXJlZEludGVybmFscy5IO1xuICAgICAgICBSZWFjdFNoYXJlZEludGVybmFscy5IID0gSW52YWxpZE5lc3RlZEhvb2tzRGlzcGF0Y2hlck9uTW91bnRJbkRFVjtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICByZXR1cm4gbW91bnRNZW1vKGNyZWF0ZSwgZGVwcyk7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgUmVhY3RTaGFyZWRJbnRlcm5hbHMuSCA9IHByZXZEaXNwYXRjaGVyO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgdXNlUmVkdWNlcjogZnVuY3Rpb24gKHJlZHVjZXIsIGluaXRpYWxBcmcsIGluaXQpIHtcbiAgICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSBcInVzZVJlZHVjZXJcIjtcbiAgICAgICAgbW91bnRIb29rVHlwZXNEZXYoKTtcbiAgICAgICAgdmFyIHByZXZEaXNwYXRjaGVyID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuSDtcbiAgICAgICAgUmVhY3RTaGFyZWRJbnRlcm5hbHMuSCA9IEludmFsaWROZXN0ZWRIb29rc0Rpc3BhdGNoZXJPbk1vdW50SW5ERVY7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgcmV0dXJuIG1vdW50UmVkdWNlcihyZWR1Y2VyLCBpbml0aWFsQXJnLCBpbml0KTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICBSZWFjdFNoYXJlZEludGVybmFscy5IID0gcHJldkRpc3BhdGNoZXI7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICB1c2VSZWY6IGZ1bmN0aW9uIChpbml0aWFsVmFsdWUpIHtcbiAgICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSBcInVzZVJlZlwiO1xuICAgICAgICBtb3VudEhvb2tUeXBlc0RldigpO1xuICAgICAgICByZXR1cm4gbW91bnRSZWYoaW5pdGlhbFZhbHVlKTtcbiAgICAgIH0sXG4gICAgICB1c2VTdGF0ZTogZnVuY3Rpb24gKGluaXRpYWxTdGF0ZSkge1xuICAgICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9IFwidXNlU3RhdGVcIjtcbiAgICAgICAgbW91bnRIb29rVHlwZXNEZXYoKTtcbiAgICAgICAgdmFyIHByZXZEaXNwYXRjaGVyID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuSDtcbiAgICAgICAgUmVhY3RTaGFyZWRJbnRlcm5hbHMuSCA9IEludmFsaWROZXN0ZWRIb29rc0Rpc3BhdGNoZXJPbk1vdW50SW5ERVY7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgcmV0dXJuIG1vdW50U3RhdGUoaW5pdGlhbFN0YXRlKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICBSZWFjdFNoYXJlZEludGVybmFscy5IID0gcHJldkRpc3BhdGNoZXI7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICB1c2VEZWJ1Z1ZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gXCJ1c2VEZWJ1Z1ZhbHVlXCI7XG4gICAgICAgIG1vdW50SG9va1R5cGVzRGV2KCk7XG4gICAgICB9LFxuICAgICAgdXNlRGVmZXJyZWRWYWx1ZTogZnVuY3Rpb24gKHZhbHVlLCBpbml0aWFsVmFsdWUpIHtcbiAgICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSBcInVzZURlZmVycmVkVmFsdWVcIjtcbiAgICAgICAgbW91bnRIb29rVHlwZXNEZXYoKTtcbiAgICAgICAgcmV0dXJuIG1vdW50RGVmZXJyZWRWYWx1ZSh2YWx1ZSwgaW5pdGlhbFZhbHVlKTtcbiAgICAgIH0sXG4gICAgICB1c2VUcmFuc2l0aW9uOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gXCJ1c2VUcmFuc2l0aW9uXCI7XG4gICAgICAgIG1vdW50SG9va1R5cGVzRGV2KCk7XG4gICAgICAgIHJldHVybiBtb3VudFRyYW5zaXRpb24oKTtcbiAgICAgIH0sXG4gICAgICB1c2VTeW5jRXh0ZXJuYWxTdG9yZTogZnVuY3Rpb24gKFxuICAgICAgICBzdWJzY3JpYmUsXG4gICAgICAgIGdldFNuYXBzaG90LFxuICAgICAgICBnZXRTZXJ2ZXJTbmFwc2hvdFxuICAgICAgKSB7XG4gICAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gXCJ1c2VTeW5jRXh0ZXJuYWxTdG9yZVwiO1xuICAgICAgICBtb3VudEhvb2tUeXBlc0RldigpO1xuICAgICAgICByZXR1cm4gbW91bnRTeW5jRXh0ZXJuYWxTdG9yZShcbiAgICAgICAgICBzdWJzY3JpYmUsXG4gICAgICAgICAgZ2V0U25hcHNob3QsXG4gICAgICAgICAgZ2V0U2VydmVyU25hcHNob3RcbiAgICAgICAgKTtcbiAgICAgIH0sXG4gICAgICB1c2VJZDogZnVuY3Rpb24gKCkge1xuICAgICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9IFwidXNlSWRcIjtcbiAgICAgICAgbW91bnRIb29rVHlwZXNEZXYoKTtcbiAgICAgICAgcmV0dXJuIG1vdW50SWQoKTtcbiAgICAgIH0sXG4gICAgICB1c2VDYWNoZVJlZnJlc2g6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSBcInVzZUNhY2hlUmVmcmVzaFwiO1xuICAgICAgICBtb3VudEhvb2tUeXBlc0RldigpO1xuICAgICAgICByZXR1cm4gbW91bnRSZWZyZXNoKCk7XG4gICAgICB9XG4gICAgfTtcbiAgICBIb29rc0Rpc3BhdGNoZXJPbk1vdW50SW5ERVYudXNlTWVtb0NhY2hlID0gdXNlTWVtb0NhY2hlO1xuICAgIEhvb2tzRGlzcGF0Y2hlck9uTW91bnRJbkRFVi51c2VIb3N0VHJhbnNpdGlvblN0YXR1cyA9XG4gICAgICB1c2VIb3N0VHJhbnNpdGlvblN0YXR1cztcbiAgICBIb29rc0Rpc3BhdGNoZXJPbk1vdW50SW5ERVYudXNlRm9ybVN0YXRlID0gZnVuY3Rpb24gKGFjdGlvbiwgaW5pdGlhbFN0YXRlKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9IFwidXNlRm9ybVN0YXRlXCI7XG4gICAgICBtb3VudEhvb2tUeXBlc0RldigpO1xuICAgICAgd2Fybk9uVXNlRm9ybVN0YXRlSW5EZXYoKTtcbiAgICAgIHJldHVybiBtb3VudEFjdGlvblN0YXRlKGFjdGlvbiwgaW5pdGlhbFN0YXRlKTtcbiAgICB9O1xuICAgIEhvb2tzRGlzcGF0Y2hlck9uTW91bnRJbkRFVi51c2VBY3Rpb25TdGF0ZSA9IGZ1bmN0aW9uIChcbiAgICAgIGFjdGlvbixcbiAgICAgIGluaXRpYWxTdGF0ZVxuICAgICkge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSBcInVzZUFjdGlvblN0YXRlXCI7XG4gICAgICBtb3VudEhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIG1vdW50QWN0aW9uU3RhdGUoYWN0aW9uLCBpbml0aWFsU3RhdGUpO1xuICAgIH07XG4gICAgSG9va3NEaXNwYXRjaGVyT25Nb3VudEluREVWLnVzZU9wdGltaXN0aWMgPSBmdW5jdGlvbiAocGFzc3Rocm91Z2gpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gXCJ1c2VPcHRpbWlzdGljXCI7XG4gICAgICBtb3VudEhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIG1vdW50T3B0aW1pc3RpYyhwYXNzdGhyb3VnaCk7XG4gICAgfTtcbiAgICBIb29rc0Rpc3BhdGNoZXJPbk1vdW50V2l0aEhvb2tUeXBlc0luREVWID0ge1xuICAgICAgcmVhZENvbnRleHQ6IGZ1bmN0aW9uIChjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiByZWFkQ29udGV4dChjb250ZXh0KTtcbiAgICAgIH0sXG4gICAgICB1c2U6IHVzZSxcbiAgICAgIHVzZUNhbGxiYWNrOiBmdW5jdGlvbiAoY2FsbGJhY2ssIGRlcHMpIHtcbiAgICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSBcInVzZUNhbGxiYWNrXCI7XG4gICAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgICByZXR1cm4gbW91bnRDYWxsYmFjayhjYWxsYmFjaywgZGVwcyk7XG4gICAgICB9LFxuICAgICAgdXNlQ29udGV4dDogZnVuY3Rpb24gKGNvbnRleHQpIHtcbiAgICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSBcInVzZUNvbnRleHRcIjtcbiAgICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICAgIHJldHVybiByZWFkQ29udGV4dChjb250ZXh0KTtcbiAgICAgIH0sXG4gICAgICB1c2VFZmZlY3Q6IGZ1bmN0aW9uIChjcmVhdGUsIGRlcHMpIHtcbiAgICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSBcInVzZUVmZmVjdFwiO1xuICAgICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgICAgcmV0dXJuIG1vdW50RWZmZWN0KGNyZWF0ZSwgZGVwcyk7XG4gICAgICB9LFxuICAgICAgdXNlSW1wZXJhdGl2ZUhhbmRsZTogZnVuY3Rpb24gKHJlZiwgY3JlYXRlLCBkZXBzKSB7XG4gICAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gXCJ1c2VJbXBlcmF0aXZlSGFuZGxlXCI7XG4gICAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgICByZXR1cm4gbW91bnRJbXBlcmF0aXZlSGFuZGxlKHJlZiwgY3JlYXRlLCBkZXBzKTtcbiAgICAgIH0sXG4gICAgICB1c2VJbnNlcnRpb25FZmZlY3Q6IGZ1bmN0aW9uIChjcmVhdGUsIGRlcHMpIHtcbiAgICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSBcInVzZUluc2VydGlvbkVmZmVjdFwiO1xuICAgICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgICAgbW91bnRFZmZlY3RJbXBsKDQsIEluc2VydGlvbiwgY3JlYXRlLCBkZXBzKTtcbiAgICAgIH0sXG4gICAgICB1c2VMYXlvdXRFZmZlY3Q6IGZ1bmN0aW9uIChjcmVhdGUsIGRlcHMpIHtcbiAgICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSBcInVzZUxheW91dEVmZmVjdFwiO1xuICAgICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgICAgcmV0dXJuIG1vdW50TGF5b3V0RWZmZWN0KGNyZWF0ZSwgZGVwcyk7XG4gICAgICB9LFxuICAgICAgdXNlTWVtbzogZnVuY3Rpb24gKGNyZWF0ZSwgZGVwcykge1xuICAgICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9IFwidXNlTWVtb1wiO1xuICAgICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgICAgdmFyIHByZXZEaXNwYXRjaGVyID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuSDtcbiAgICAgICAgUmVhY3RTaGFyZWRJbnRlcm5hbHMuSCA9IEludmFsaWROZXN0ZWRIb29rc0Rpc3BhdGNoZXJPbk1vdW50SW5ERVY7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgcmV0dXJuIG1vdW50TWVtbyhjcmVhdGUsIGRlcHMpO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIFJlYWN0U2hhcmVkSW50ZXJuYWxzLkggPSBwcmV2RGlzcGF0Y2hlcjtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHVzZVJlZHVjZXI6IGZ1bmN0aW9uIChyZWR1Y2VyLCBpbml0aWFsQXJnLCBpbml0KSB7XG4gICAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gXCJ1c2VSZWR1Y2VyXCI7XG4gICAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgICB2YXIgcHJldkRpc3BhdGNoZXIgPSBSZWFjdFNoYXJlZEludGVybmFscy5IO1xuICAgICAgICBSZWFjdFNoYXJlZEludGVybmFscy5IID0gSW52YWxpZE5lc3RlZEhvb2tzRGlzcGF0Y2hlck9uTW91bnRJbkRFVjtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICByZXR1cm4gbW91bnRSZWR1Y2VyKHJlZHVjZXIsIGluaXRpYWxBcmcsIGluaXQpO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIFJlYWN0U2hhcmVkSW50ZXJuYWxzLkggPSBwcmV2RGlzcGF0Y2hlcjtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHVzZVJlZjogZnVuY3Rpb24gKGluaXRpYWxWYWx1ZSkge1xuICAgICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9IFwidXNlUmVmXCI7XG4gICAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgICByZXR1cm4gbW91bnRSZWYoaW5pdGlhbFZhbHVlKTtcbiAgICAgIH0sXG4gICAgICB1c2VTdGF0ZTogZnVuY3Rpb24gKGluaXRpYWxTdGF0ZSkge1xuICAgICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9IFwidXNlU3RhdGVcIjtcbiAgICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICAgIHZhciBwcmV2RGlzcGF0Y2hlciA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLkg7XG4gICAgICAgIFJlYWN0U2hhcmVkSW50ZXJuYWxzLkggPSBJbnZhbGlkTmVzdGVkSG9va3NEaXNwYXRjaGVyT25Nb3VudEluREVWO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHJldHVybiBtb3VudFN0YXRlKGluaXRpYWxTdGF0ZSk7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgUmVhY3RTaGFyZWRJbnRlcm5hbHMuSCA9IHByZXZEaXNwYXRjaGVyO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgdXNlRGVidWdWYWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9IFwidXNlRGVidWdWYWx1ZVwiO1xuICAgICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIH0sXG4gICAgICB1c2VEZWZlcnJlZFZhbHVlOiBmdW5jdGlvbiAodmFsdWUsIGluaXRpYWxWYWx1ZSkge1xuICAgICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9IFwidXNlRGVmZXJyZWRWYWx1ZVwiO1xuICAgICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgICAgcmV0dXJuIG1vdW50RGVmZXJyZWRWYWx1ZSh2YWx1ZSwgaW5pdGlhbFZhbHVlKTtcbiAgICAgIH0sXG4gICAgICB1c2VUcmFuc2l0aW9uOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gXCJ1c2VUcmFuc2l0aW9uXCI7XG4gICAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgICByZXR1cm4gbW91bnRUcmFuc2l0aW9uKCk7XG4gICAgICB9LFxuICAgICAgdXNlU3luY0V4dGVybmFsU3RvcmU6IGZ1bmN0aW9uIChcbiAgICAgICAgc3Vic2NyaWJlLFxuICAgICAgICBnZXRTbmFwc2hvdCxcbiAgICAgICAgZ2V0U2VydmVyU25hcHNob3RcbiAgICAgICkge1xuICAgICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9IFwidXNlU3luY0V4dGVybmFsU3RvcmVcIjtcbiAgICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICAgIHJldHVybiBtb3VudFN5bmNFeHRlcm5hbFN0b3JlKFxuICAgICAgICAgIHN1YnNjcmliZSxcbiAgICAgICAgICBnZXRTbmFwc2hvdCxcbiAgICAgICAgICBnZXRTZXJ2ZXJTbmFwc2hvdFxuICAgICAgICApO1xuICAgICAgfSxcbiAgICAgIHVzZUlkOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gXCJ1c2VJZFwiO1xuICAgICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgICAgcmV0dXJuIG1vdW50SWQoKTtcbiAgICAgIH0sXG4gICAgICB1c2VDYWNoZVJlZnJlc2g6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSBcInVzZUNhY2hlUmVmcmVzaFwiO1xuICAgICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgICAgcmV0dXJuIG1vdW50UmVmcmVzaCgpO1xuICAgICAgfVxuICAgIH07XG4gICAgSG9va3NEaXNwYXRjaGVyT25Nb3VudFdpdGhIb29rVHlwZXNJbkRFVi51c2VNZW1vQ2FjaGUgPSB1c2VNZW1vQ2FjaGU7XG4gICAgSG9va3NEaXNwYXRjaGVyT25Nb3VudFdpdGhIb29rVHlwZXNJbkRFVi51c2VIb3N0VHJhbnNpdGlvblN0YXR1cyA9XG4gICAgICB1c2VIb3N0VHJhbnNpdGlvblN0YXR1cztcbiAgICBIb29rc0Rpc3BhdGNoZXJPbk1vdW50V2l0aEhvb2tUeXBlc0luREVWLnVzZUZvcm1TdGF0ZSA9IGZ1bmN0aW9uIChcbiAgICAgIGFjdGlvbixcbiAgICAgIGluaXRpYWxTdGF0ZVxuICAgICkge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSBcInVzZUZvcm1TdGF0ZVwiO1xuICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICB3YXJuT25Vc2VGb3JtU3RhdGVJbkRldigpO1xuICAgICAgcmV0dXJuIG1vdW50QWN0aW9uU3RhdGUoYWN0aW9uLCBpbml0aWFsU3RhdGUpO1xuICAgIH07XG4gICAgSG9va3NEaXNwYXRjaGVyT25Nb3VudFdpdGhIb29rVHlwZXNJbkRFVi51c2VBY3Rpb25TdGF0ZSA9IGZ1bmN0aW9uIChcbiAgICAgIGFjdGlvbixcbiAgICAgIGluaXRpYWxTdGF0ZVxuICAgICkge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSBcInVzZUFjdGlvblN0YXRlXCI7XG4gICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiBtb3VudEFjdGlvblN0YXRlKGFjdGlvbiwgaW5pdGlhbFN0YXRlKTtcbiAgICB9O1xuICAgIEhvb2tzRGlzcGF0Y2hlck9uTW91bnRXaXRoSG9va1R5cGVzSW5ERVYudXNlT3B0aW1pc3RpYyA9IGZ1bmN0aW9uIChcbiAgICAgIHBhc3N0aHJvdWdoXG4gICAgKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9IFwidXNlT3B0aW1pc3RpY1wiO1xuICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICByZXR1cm4gbW91bnRPcHRpbWlzdGljKHBhc3N0aHJvdWdoKTtcbiAgICB9O1xuICAgIEhvb2tzRGlzcGF0Y2hlck9uVXBkYXRlSW5ERVYgPSB7XG4gICAgICByZWFkQ29udGV4dDogZnVuY3Rpb24gKGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIHJlYWRDb250ZXh0KGNvbnRleHQpO1xuICAgICAgfSxcbiAgICAgIHVzZTogdXNlLFxuICAgICAgdXNlQ2FsbGJhY2s6IGZ1bmN0aW9uIChjYWxsYmFjaywgZGVwcykge1xuICAgICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9IFwidXNlQ2FsbGJhY2tcIjtcbiAgICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICAgIHJldHVybiB1cGRhdGVDYWxsYmFjayhjYWxsYmFjaywgZGVwcyk7XG4gICAgICB9LFxuICAgICAgdXNlQ29udGV4dDogZnVuY3Rpb24gKGNvbnRleHQpIHtcbiAgICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSBcInVzZUNvbnRleHRcIjtcbiAgICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICAgIHJldHVybiByZWFkQ29udGV4dChjb250ZXh0KTtcbiAgICAgIH0sXG4gICAgICB1c2VFZmZlY3Q6IGZ1bmN0aW9uIChjcmVhdGUsIGRlcHMpIHtcbiAgICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSBcInVzZUVmZmVjdFwiO1xuICAgICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgICAgdXBkYXRlRWZmZWN0SW1wbCgyMDQ4LCBQYXNzaXZlLCBjcmVhdGUsIGRlcHMpO1xuICAgICAgfSxcbiAgICAgIHVzZUltcGVyYXRpdmVIYW5kbGU6IGZ1bmN0aW9uIChyZWYsIGNyZWF0ZSwgZGVwcykge1xuICAgICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9IFwidXNlSW1wZXJhdGl2ZUhhbmRsZVwiO1xuICAgICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgICAgcmV0dXJuIHVwZGF0ZUltcGVyYXRpdmVIYW5kbGUocmVmLCBjcmVhdGUsIGRlcHMpO1xuICAgICAgfSxcbiAgICAgIHVzZUluc2VydGlvbkVmZmVjdDogZnVuY3Rpb24gKGNyZWF0ZSwgZGVwcykge1xuICAgICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9IFwidXNlSW5zZXJ0aW9uRWZmZWN0XCI7XG4gICAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgICByZXR1cm4gdXBkYXRlRWZmZWN0SW1wbCg0LCBJbnNlcnRpb24sIGNyZWF0ZSwgZGVwcyk7XG4gICAgICB9LFxuICAgICAgdXNlTGF5b3V0RWZmZWN0OiBmdW5jdGlvbiAoY3JlYXRlLCBkZXBzKSB7XG4gICAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gXCJ1c2VMYXlvdXRFZmZlY3RcIjtcbiAgICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICAgIHJldHVybiB1cGRhdGVFZmZlY3RJbXBsKDQsIExheW91dCwgY3JlYXRlLCBkZXBzKTtcbiAgICAgIH0sXG4gICAgICB1c2VNZW1vOiBmdW5jdGlvbiAoY3JlYXRlLCBkZXBzKSB7XG4gICAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gXCJ1c2VNZW1vXCI7XG4gICAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgICB2YXIgcHJldkRpc3BhdGNoZXIgPSBSZWFjdFNoYXJlZEludGVybmFscy5IO1xuICAgICAgICBSZWFjdFNoYXJlZEludGVybmFscy5IID0gSW52YWxpZE5lc3RlZEhvb2tzRGlzcGF0Y2hlck9uVXBkYXRlSW5ERVY7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgcmV0dXJuIHVwZGF0ZU1lbW8oY3JlYXRlLCBkZXBzKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICBSZWFjdFNoYXJlZEludGVybmFscy5IID0gcHJldkRpc3BhdGNoZXI7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICB1c2VSZWR1Y2VyOiBmdW5jdGlvbiAocmVkdWNlciwgaW5pdGlhbEFyZywgaW5pdCkge1xuICAgICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9IFwidXNlUmVkdWNlclwiO1xuICAgICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgICAgdmFyIHByZXZEaXNwYXRjaGVyID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuSDtcbiAgICAgICAgUmVhY3RTaGFyZWRJbnRlcm5hbHMuSCA9IEludmFsaWROZXN0ZWRIb29rc0Rpc3BhdGNoZXJPblVwZGF0ZUluREVWO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHJldHVybiB1cGRhdGVSZWR1Y2VyKHJlZHVjZXIsIGluaXRpYWxBcmcsIGluaXQpO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIFJlYWN0U2hhcmVkSW50ZXJuYWxzLkggPSBwcmV2RGlzcGF0Y2hlcjtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHVzZVJlZjogZnVuY3Rpb24gKCkge1xuICAgICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9IFwidXNlUmVmXCI7XG4gICAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgICByZXR1cm4gdXBkYXRlV29ya0luUHJvZ3Jlc3NIb29rKCkubWVtb2l6ZWRTdGF0ZTtcbiAgICAgIH0sXG4gICAgICB1c2VTdGF0ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9IFwidXNlU3RhdGVcIjtcbiAgICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICAgIHZhciBwcmV2RGlzcGF0Y2hlciA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLkg7XG4gICAgICAgIFJlYWN0U2hhcmVkSW50ZXJuYWxzLkggPSBJbnZhbGlkTmVzdGVkSG9va3NEaXNwYXRjaGVyT25VcGRhdGVJbkRFVjtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICByZXR1cm4gdXBkYXRlUmVkdWNlcihiYXNpY1N0YXRlUmVkdWNlcik7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgUmVhY3RTaGFyZWRJbnRlcm5hbHMuSCA9IHByZXZEaXNwYXRjaGVyO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgdXNlRGVidWdWYWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9IFwidXNlRGVidWdWYWx1ZVwiO1xuICAgICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIH0sXG4gICAgICB1c2VEZWZlcnJlZFZhbHVlOiBmdW5jdGlvbiAodmFsdWUsIGluaXRpYWxWYWx1ZSkge1xuICAgICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9IFwidXNlRGVmZXJyZWRWYWx1ZVwiO1xuICAgICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgICAgcmV0dXJuIHVwZGF0ZURlZmVycmVkVmFsdWUodmFsdWUsIGluaXRpYWxWYWx1ZSk7XG4gICAgICB9LFxuICAgICAgdXNlVHJhbnNpdGlvbjogZnVuY3Rpb24gKCkge1xuICAgICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9IFwidXNlVHJhbnNpdGlvblwiO1xuICAgICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgICAgcmV0dXJuIHVwZGF0ZVRyYW5zaXRpb24oKTtcbiAgICAgIH0sXG4gICAgICB1c2VTeW5jRXh0ZXJuYWxTdG9yZTogZnVuY3Rpb24gKFxuICAgICAgICBzdWJzY3JpYmUsXG4gICAgICAgIGdldFNuYXBzaG90LFxuICAgICAgICBnZXRTZXJ2ZXJTbmFwc2hvdFxuICAgICAgKSB7XG4gICAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gXCJ1c2VTeW5jRXh0ZXJuYWxTdG9yZVwiO1xuICAgICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgICAgcmV0dXJuIHVwZGF0ZVN5bmNFeHRlcm5hbFN0b3JlKFxuICAgICAgICAgIHN1YnNjcmliZSxcbiAgICAgICAgICBnZXRTbmFwc2hvdCxcbiAgICAgICAgICBnZXRTZXJ2ZXJTbmFwc2hvdFxuICAgICAgICApO1xuICAgICAgfSxcbiAgICAgIHVzZUlkOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gXCJ1c2VJZFwiO1xuICAgICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgICAgcmV0dXJuIHVwZGF0ZVdvcmtJblByb2dyZXNzSG9vaygpLm1lbW9pemVkU3RhdGU7XG4gICAgICB9LFxuICAgICAgdXNlQ2FjaGVSZWZyZXNoOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gXCJ1c2VDYWNoZVJlZnJlc2hcIjtcbiAgICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICAgIHJldHVybiB1cGRhdGVXb3JrSW5Qcm9ncmVzc0hvb2soKS5tZW1vaXplZFN0YXRlO1xuICAgICAgfVxuICAgIH07XG4gICAgSG9va3NEaXNwYXRjaGVyT25VcGRhdGVJbkRFVi51c2VNZW1vQ2FjaGUgPSB1c2VNZW1vQ2FjaGU7XG4gICAgSG9va3NEaXNwYXRjaGVyT25VcGRhdGVJbkRFVi51c2VIb3N0VHJhbnNpdGlvblN0YXR1cyA9XG4gICAgICB1c2VIb3N0VHJhbnNpdGlvblN0YXR1cztcbiAgICBIb29rc0Rpc3BhdGNoZXJPblVwZGF0ZUluREVWLnVzZUZvcm1TdGF0ZSA9IGZ1bmN0aW9uIChhY3Rpb24pIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gXCJ1c2VGb3JtU3RhdGVcIjtcbiAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgd2Fybk9uVXNlRm9ybVN0YXRlSW5EZXYoKTtcbiAgICAgIHJldHVybiB1cGRhdGVBY3Rpb25TdGF0ZShhY3Rpb24pO1xuICAgIH07XG4gICAgSG9va3NEaXNwYXRjaGVyT25VcGRhdGVJbkRFVi51c2VBY3Rpb25TdGF0ZSA9IGZ1bmN0aW9uIChhY3Rpb24pIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gXCJ1c2VBY3Rpb25TdGF0ZVwiO1xuICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICByZXR1cm4gdXBkYXRlQWN0aW9uU3RhdGUoYWN0aW9uKTtcbiAgICB9O1xuICAgIEhvb2tzRGlzcGF0Y2hlck9uVXBkYXRlSW5ERVYudXNlT3B0aW1pc3RpYyA9IGZ1bmN0aW9uIChcbiAgICAgIHBhc3N0aHJvdWdoLFxuICAgICAgcmVkdWNlclxuICAgICkge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSBcInVzZU9wdGltaXN0aWNcIjtcbiAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIHVwZGF0ZU9wdGltaXN0aWMocGFzc3Rocm91Z2gsIHJlZHVjZXIpO1xuICAgIH07XG4gICAgSG9va3NEaXNwYXRjaGVyT25SZXJlbmRlckluREVWID0ge1xuICAgICAgcmVhZENvbnRleHQ6IGZ1bmN0aW9uIChjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiByZWFkQ29udGV4dChjb250ZXh0KTtcbiAgICAgIH0sXG4gICAgICB1c2U6IHVzZSxcbiAgICAgIHVzZUNhbGxiYWNrOiBmdW5jdGlvbiAoY2FsbGJhY2ssIGRlcHMpIHtcbiAgICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSBcInVzZUNhbGxiYWNrXCI7XG4gICAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgICByZXR1cm4gdXBkYXRlQ2FsbGJhY2soY2FsbGJhY2ssIGRlcHMpO1xuICAgICAgfSxcbiAgICAgIHVzZUNvbnRleHQ6IGZ1bmN0aW9uIChjb250ZXh0KSB7XG4gICAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gXCJ1c2VDb250ZXh0XCI7XG4gICAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgICByZXR1cm4gcmVhZENvbnRleHQoY29udGV4dCk7XG4gICAgICB9LFxuICAgICAgdXNlRWZmZWN0OiBmdW5jdGlvbiAoY3JlYXRlLCBkZXBzKSB7XG4gICAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gXCJ1c2VFZmZlY3RcIjtcbiAgICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICAgIHVwZGF0ZUVmZmVjdEltcGwoMjA0OCwgUGFzc2l2ZSwgY3JlYXRlLCBkZXBzKTtcbiAgICAgIH0sXG4gICAgICB1c2VJbXBlcmF0aXZlSGFuZGxlOiBmdW5jdGlvbiAocmVmLCBjcmVhdGUsIGRlcHMpIHtcbiAgICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSBcInVzZUltcGVyYXRpdmVIYW5kbGVcIjtcbiAgICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICAgIHJldHVybiB1cGRhdGVJbXBlcmF0aXZlSGFuZGxlKHJlZiwgY3JlYXRlLCBkZXBzKTtcbiAgICAgIH0sXG4gICAgICB1c2VJbnNlcnRpb25FZmZlY3Q6IGZ1bmN0aW9uIChjcmVhdGUsIGRlcHMpIHtcbiAgICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSBcInVzZUluc2VydGlvbkVmZmVjdFwiO1xuICAgICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgICAgcmV0dXJuIHVwZGF0ZUVmZmVjdEltcGwoNCwgSW5zZXJ0aW9uLCBjcmVhdGUsIGRlcHMpO1xuICAgICAgfSxcbiAgICAgIHVzZUxheW91dEVmZmVjdDogZnVuY3Rpb24gKGNyZWF0ZSwgZGVwcykge1xuICAgICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9IFwidXNlTGF5b3V0RWZmZWN0XCI7XG4gICAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgICByZXR1cm4gdXBkYXRlRWZmZWN0SW1wbCg0LCBMYXlvdXQsIGNyZWF0ZSwgZGVwcyk7XG4gICAgICB9LFxuICAgICAgdXNlTWVtbzogZnVuY3Rpb24gKGNyZWF0ZSwgZGVwcykge1xuICAgICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9IFwidXNlTWVtb1wiO1xuICAgICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgICAgdmFyIHByZXZEaXNwYXRjaGVyID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuSDtcbiAgICAgICAgUmVhY3RTaGFyZWRJbnRlcm5hbHMuSCA9IEludmFsaWROZXN0ZWRIb29rc0Rpc3BhdGNoZXJPblJlcmVuZGVySW5ERVY7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgcmV0dXJuIHVwZGF0ZU1lbW8oY3JlYXRlLCBkZXBzKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICBSZWFjdFNoYXJlZEludGVybmFscy5IID0gcHJldkRpc3BhdGNoZXI7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICB1c2VSZWR1Y2VyOiBmdW5jdGlvbiAocmVkdWNlciwgaW5pdGlhbEFyZywgaW5pdCkge1xuICAgICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9IFwidXNlUmVkdWNlclwiO1xuICAgICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgICAgdmFyIHByZXZEaXNwYXRjaGVyID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuSDtcbiAgICAgICAgUmVhY3RTaGFyZWRJbnRlcm5hbHMuSCA9IEludmFsaWROZXN0ZWRIb29rc0Rpc3BhdGNoZXJPblJlcmVuZGVySW5ERVY7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgcmV0dXJuIHJlcmVuZGVyUmVkdWNlcihyZWR1Y2VyLCBpbml0aWFsQXJnLCBpbml0KTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICBSZWFjdFNoYXJlZEludGVybmFscy5IID0gcHJldkRpc3BhdGNoZXI7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICB1c2VSZWY6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSBcInVzZVJlZlwiO1xuICAgICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgICAgcmV0dXJuIHVwZGF0ZVdvcmtJblByb2dyZXNzSG9vaygpLm1lbW9pemVkU3RhdGU7XG4gICAgICB9LFxuICAgICAgdXNlU3RhdGU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSBcInVzZVN0YXRlXCI7XG4gICAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgICB2YXIgcHJldkRpc3BhdGNoZXIgPSBSZWFjdFNoYXJlZEludGVybmFscy5IO1xuICAgICAgICBSZWFjdFNoYXJlZEludGVybmFscy5IID0gSW52YWxpZE5lc3RlZEhvb2tzRGlzcGF0Y2hlck9uUmVyZW5kZXJJbkRFVjtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICByZXR1cm4gcmVyZW5kZXJSZWR1Y2VyKGJhc2ljU3RhdGVSZWR1Y2VyKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICBSZWFjdFNoYXJlZEludGVybmFscy5IID0gcHJldkRpc3BhdGNoZXI7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICB1c2VEZWJ1Z1ZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gXCJ1c2VEZWJ1Z1ZhbHVlXCI7XG4gICAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgfSxcbiAgICAgIHVzZURlZmVycmVkVmFsdWU6IGZ1bmN0aW9uICh2YWx1ZSwgaW5pdGlhbFZhbHVlKSB7XG4gICAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gXCJ1c2VEZWZlcnJlZFZhbHVlXCI7XG4gICAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgICByZXR1cm4gcmVyZW5kZXJEZWZlcnJlZFZhbHVlKHZhbHVlLCBpbml0aWFsVmFsdWUpO1xuICAgICAgfSxcbiAgICAgIHVzZVRyYW5zaXRpb246IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSBcInVzZVRyYW5zaXRpb25cIjtcbiAgICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICAgIHJldHVybiByZXJlbmRlclRyYW5zaXRpb24oKTtcbiAgICAgIH0sXG4gICAgICB1c2VTeW5jRXh0ZXJuYWxTdG9yZTogZnVuY3Rpb24gKFxuICAgICAgICBzdWJzY3JpYmUsXG4gICAgICAgIGdldFNuYXBzaG90LFxuICAgICAgICBnZXRTZXJ2ZXJTbmFwc2hvdFxuICAgICAgKSB7XG4gICAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gXCJ1c2VTeW5jRXh0ZXJuYWxTdG9yZVwiO1xuICAgICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgICAgcmV0dXJuIHVwZGF0ZVN5bmNFeHRlcm5hbFN0b3JlKFxuICAgICAgICAgIHN1YnNjcmliZSxcbiAgICAgICAgICBnZXRTbmFwc2hvdCxcbiAgICAgICAgICBnZXRTZXJ2ZXJTbmFwc2hvdFxuICAgICAgICApO1xuICAgICAgfSxcbiAgICAgIHVzZUlkOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gXCJ1c2VJZFwiO1xuICAgICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgICAgcmV0dXJuIHVwZGF0ZVdvcmtJblByb2dyZXNzSG9vaygpLm1lbW9pemVkU3RhdGU7XG4gICAgICB9LFxuICAgICAgdXNlQ2FjaGVSZWZyZXNoOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gXCJ1c2VDYWNoZVJlZnJlc2hcIjtcbiAgICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICAgIHJldHVybiB1cGRhdGVXb3JrSW5Qcm9ncmVzc0hvb2soKS5tZW1vaXplZFN0YXRlO1xuICAgICAgfVxuICAgIH07XG4gICAgSG9va3NEaXNwYXRjaGVyT25SZXJlbmRlckluREVWLnVzZU1lbW9DYWNoZSA9IHVzZU1lbW9DYWNoZTtcbiAgICBIb29rc0Rpc3BhdGNoZXJPblJlcmVuZGVySW5ERVYudXNlSG9zdFRyYW5zaXRpb25TdGF0dXMgPVxuICAgICAgdXNlSG9zdFRyYW5zaXRpb25TdGF0dXM7XG4gICAgSG9va3NEaXNwYXRjaGVyT25SZXJlbmRlckluREVWLnVzZUZvcm1TdGF0ZSA9IGZ1bmN0aW9uIChhY3Rpb24pIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gXCJ1c2VGb3JtU3RhdGVcIjtcbiAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgd2Fybk9uVXNlRm9ybVN0YXRlSW5EZXYoKTtcbiAgICAgIHJldHVybiByZXJlbmRlckFjdGlvblN0YXRlKGFjdGlvbik7XG4gICAgfTtcbiAgICBIb29rc0Rpc3BhdGNoZXJPblJlcmVuZGVySW5ERVYudXNlQWN0aW9uU3RhdGUgPSBmdW5jdGlvbiAoYWN0aW9uKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9IFwidXNlQWN0aW9uU3RhdGVcIjtcbiAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIHJlcmVuZGVyQWN0aW9uU3RhdGUoYWN0aW9uKTtcbiAgICB9O1xuICAgIEhvb2tzRGlzcGF0Y2hlck9uUmVyZW5kZXJJbkRFVi51c2VPcHRpbWlzdGljID0gZnVuY3Rpb24gKFxuICAgICAgcGFzc3Rocm91Z2gsXG4gICAgICByZWR1Y2VyXG4gICAgKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9IFwidXNlT3B0aW1pc3RpY1wiO1xuICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICByZXR1cm4gcmVyZW5kZXJPcHRpbWlzdGljKHBhc3N0aHJvdWdoLCByZWR1Y2VyKTtcbiAgICB9O1xuICAgIEludmFsaWROZXN0ZWRIb29rc0Rpc3BhdGNoZXJPbk1vdW50SW5ERVYgPSB7XG4gICAgICByZWFkQ29udGV4dDogZnVuY3Rpb24gKGNvbnRleHQpIHtcbiAgICAgICAgd2FybkludmFsaWRDb250ZXh0QWNjZXNzKCk7XG4gICAgICAgIHJldHVybiByZWFkQ29udGV4dChjb250ZXh0KTtcbiAgICAgIH0sXG4gICAgICB1c2U6IGZ1bmN0aW9uICh1c2FibGUpIHtcbiAgICAgICAgd2FybkludmFsaWRIb29rQWNjZXNzKCk7XG4gICAgICAgIHJldHVybiB1c2UodXNhYmxlKTtcbiAgICAgIH0sXG4gICAgICB1c2VDYWxsYmFjazogZnVuY3Rpb24gKGNhbGxiYWNrLCBkZXBzKSB7XG4gICAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gXCJ1c2VDYWxsYmFja1wiO1xuICAgICAgICB3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTtcbiAgICAgICAgbW91bnRIb29rVHlwZXNEZXYoKTtcbiAgICAgICAgcmV0dXJuIG1vdW50Q2FsbGJhY2soY2FsbGJhY2ssIGRlcHMpO1xuICAgICAgfSxcbiAgICAgIHVzZUNvbnRleHQ6IGZ1bmN0aW9uIChjb250ZXh0KSB7XG4gICAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gXCJ1c2VDb250ZXh0XCI7XG4gICAgICAgIHdhcm5JbnZhbGlkSG9va0FjY2VzcygpO1xuICAgICAgICBtb3VudEhvb2tUeXBlc0RldigpO1xuICAgICAgICByZXR1cm4gcmVhZENvbnRleHQoY29udGV4dCk7XG4gICAgICB9LFxuICAgICAgdXNlRWZmZWN0OiBmdW5jdGlvbiAoY3JlYXRlLCBkZXBzKSB7XG4gICAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gXCJ1c2VFZmZlY3RcIjtcbiAgICAgICAgd2FybkludmFsaWRIb29rQWNjZXNzKCk7XG4gICAgICAgIG1vdW50SG9va1R5cGVzRGV2KCk7XG4gICAgICAgIHJldHVybiBtb3VudEVmZmVjdChjcmVhdGUsIGRlcHMpO1xuICAgICAgfSxcbiAgICAgIHVzZUltcGVyYXRpdmVIYW5kbGU6IGZ1bmN0aW9uIChyZWYsIGNyZWF0ZSwgZGVwcykge1xuICAgICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9IFwidXNlSW1wZXJhdGl2ZUhhbmRsZVwiO1xuICAgICAgICB3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTtcbiAgICAgICAgbW91bnRIb29rVHlwZXNEZXYoKTtcbiAgICAgICAgcmV0dXJuIG1vdW50SW1wZXJhdGl2ZUhhbmRsZShyZWYsIGNyZWF0ZSwgZGVwcyk7XG4gICAgICB9LFxuICAgICAgdXNlSW5zZXJ0aW9uRWZmZWN0OiBmdW5jdGlvbiAoY3JlYXRlLCBkZXBzKSB7XG4gICAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gXCJ1c2VJbnNlcnRpb25FZmZlY3RcIjtcbiAgICAgICAgd2FybkludmFsaWRIb29rQWNjZXNzKCk7XG4gICAgICAgIG1vdW50SG9va1R5cGVzRGV2KCk7XG4gICAgICAgIG1vdW50RWZmZWN0SW1wbCg0LCBJbnNlcnRpb24sIGNyZWF0ZSwgZGVwcyk7XG4gICAgICB9LFxuICAgICAgdXNlTGF5b3V0RWZmZWN0OiBmdW5jdGlvbiAoY3JlYXRlLCBkZXBzKSB7XG4gICAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gXCJ1c2VMYXlvdXRFZmZlY3RcIjtcbiAgICAgICAgd2FybkludmFsaWRIb29rQWNjZXNzKCk7XG4gICAgICAgIG1vdW50SG9va1R5cGVzRGV2KCk7XG4gICAgICAgIHJldHVybiBtb3VudExheW91dEVmZmVjdChjcmVhdGUsIGRlcHMpO1xuICAgICAgfSxcbiAgICAgIHVzZU1lbW86IGZ1bmN0aW9uIChjcmVhdGUsIGRlcHMpIHtcbiAgICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSBcInVzZU1lbW9cIjtcbiAgICAgICAgd2FybkludmFsaWRIb29rQWNjZXNzKCk7XG4gICAgICAgIG1vdW50SG9va1R5cGVzRGV2KCk7XG4gICAgICAgIHZhciBwcmV2RGlzcGF0Y2hlciA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLkg7XG4gICAgICAgIFJlYWN0U2hhcmVkSW50ZXJuYWxzLkggPSBJbnZhbGlkTmVzdGVkSG9va3NEaXNwYXRjaGVyT25Nb3VudEluREVWO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHJldHVybiBtb3VudE1lbW8oY3JlYXRlLCBkZXBzKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICBSZWFjdFNoYXJlZEludGVybmFscy5IID0gcHJldkRpc3BhdGNoZXI7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICB1c2VSZWR1Y2VyOiBmdW5jdGlvbiAocmVkdWNlciwgaW5pdGlhbEFyZywgaW5pdCkge1xuICAgICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9IFwidXNlUmVkdWNlclwiO1xuICAgICAgICB3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTtcbiAgICAgICAgbW91bnRIb29rVHlwZXNEZXYoKTtcbiAgICAgICAgdmFyIHByZXZEaXNwYXRjaGVyID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuSDtcbiAgICAgICAgUmVhY3RTaGFyZWRJbnRlcm5hbHMuSCA9IEludmFsaWROZXN0ZWRIb29rc0Rpc3BhdGNoZXJPbk1vdW50SW5ERVY7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgcmV0dXJuIG1vdW50UmVkdWNlcihyZWR1Y2VyLCBpbml0aWFsQXJnLCBpbml0KTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICBSZWFjdFNoYXJlZEludGVybmFscy5IID0gcHJldkRpc3BhdGNoZXI7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICB1c2VSZWY6IGZ1bmN0aW9uIChpbml0aWFsVmFsdWUpIHtcbiAgICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSBcInVzZVJlZlwiO1xuICAgICAgICB3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTtcbiAgICAgICAgbW91bnRIb29rVHlwZXNEZXYoKTtcbiAgICAgICAgcmV0dXJuIG1vdW50UmVmKGluaXRpYWxWYWx1ZSk7XG4gICAgICB9LFxuICAgICAgdXNlU3RhdGU6IGZ1bmN0aW9uIChpbml0aWFsU3RhdGUpIHtcbiAgICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSBcInVzZVN0YXRlXCI7XG4gICAgICAgIHdhcm5JbnZhbGlkSG9va0FjY2VzcygpO1xuICAgICAgICBtb3VudEhvb2tUeXBlc0RldigpO1xuICAgICAgICB2YXIgcHJldkRpc3BhdGNoZXIgPSBSZWFjdFNoYXJlZEludGVybmFscy5IO1xuICAgICAgICBSZWFjdFNoYXJlZEludGVybmFscy5IID0gSW52YWxpZE5lc3RlZEhvb2tzRGlzcGF0Y2hlck9uTW91bnRJbkRFVjtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICByZXR1cm4gbW91bnRTdGF0ZShpbml0aWFsU3RhdGUpO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIFJlYWN0U2hhcmVkSW50ZXJuYWxzLkggPSBwcmV2RGlzcGF0Y2hlcjtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHVzZURlYnVnVmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSBcInVzZURlYnVnVmFsdWVcIjtcbiAgICAgICAgd2FybkludmFsaWRIb29rQWNjZXNzKCk7XG4gICAgICAgIG1vdW50SG9va1R5cGVzRGV2KCk7XG4gICAgICB9LFxuICAgICAgdXNlRGVmZXJyZWRWYWx1ZTogZnVuY3Rpb24gKHZhbHVlLCBpbml0aWFsVmFsdWUpIHtcbiAgICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSBcInVzZURlZmVycmVkVmFsdWVcIjtcbiAgICAgICAgd2FybkludmFsaWRIb29rQWNjZXNzKCk7XG4gICAgICAgIG1vdW50SG9va1R5cGVzRGV2KCk7XG4gICAgICAgIHJldHVybiBtb3VudERlZmVycmVkVmFsdWUodmFsdWUsIGluaXRpYWxWYWx1ZSk7XG4gICAgICB9LFxuICAgICAgdXNlVHJhbnNpdGlvbjogZnVuY3Rpb24gKCkge1xuICAgICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9IFwidXNlVHJhbnNpdGlvblwiO1xuICAgICAgICB3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTtcbiAgICAgICAgbW91bnRIb29rVHlwZXNEZXYoKTtcbiAgICAgICAgcmV0dXJuIG1vdW50VHJhbnNpdGlvbigpO1xuICAgICAgfSxcbiAgICAgIHVzZVN5bmNFeHRlcm5hbFN0b3JlOiBmdW5jdGlvbiAoXG4gICAgICAgIHN1YnNjcmliZSxcbiAgICAgICAgZ2V0U25hcHNob3QsXG4gICAgICAgIGdldFNlcnZlclNuYXBzaG90XG4gICAgICApIHtcbiAgICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSBcInVzZVN5bmNFeHRlcm5hbFN0b3JlXCI7XG4gICAgICAgIHdhcm5JbnZhbGlkSG9va0FjY2VzcygpO1xuICAgICAgICBtb3VudEhvb2tUeXBlc0RldigpO1xuICAgICAgICByZXR1cm4gbW91bnRTeW5jRXh0ZXJuYWxTdG9yZShcbiAgICAgICAgICBzdWJzY3JpYmUsXG4gICAgICAgICAgZ2V0U25hcHNob3QsXG4gICAgICAgICAgZ2V0U2VydmVyU25hcHNob3RcbiAgICAgICAgKTtcbiAgICAgIH0sXG4gICAgICB1c2VJZDogZnVuY3Rpb24gKCkge1xuICAgICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9IFwidXNlSWRcIjtcbiAgICAgICAgd2FybkludmFsaWRIb29rQWNjZXNzKCk7XG4gICAgICAgIG1vdW50SG9va1R5cGVzRGV2KCk7XG4gICAgICAgIHJldHVybiBtb3VudElkKCk7XG4gICAgICB9LFxuICAgICAgdXNlQ2FjaGVSZWZyZXNoOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gXCJ1c2VDYWNoZVJlZnJlc2hcIjtcbiAgICAgICAgbW91bnRIb29rVHlwZXNEZXYoKTtcbiAgICAgICAgcmV0dXJuIG1vdW50UmVmcmVzaCgpO1xuICAgICAgfSxcbiAgICAgIHVzZU1lbW9DYWNoZTogZnVuY3Rpb24gKHNpemUpIHtcbiAgICAgICAgd2FybkludmFsaWRIb29rQWNjZXNzKCk7XG4gICAgICAgIHJldHVybiB1c2VNZW1vQ2FjaGUoc2l6ZSk7XG4gICAgICB9XG4gICAgfTtcbiAgICBJbnZhbGlkTmVzdGVkSG9va3NEaXNwYXRjaGVyT25Nb3VudEluREVWLnVzZUhvc3RUcmFuc2l0aW9uU3RhdHVzID1cbiAgICAgIHVzZUhvc3RUcmFuc2l0aW9uU3RhdHVzO1xuICAgIEludmFsaWROZXN0ZWRIb29rc0Rpc3BhdGNoZXJPbk1vdW50SW5ERVYudXNlRm9ybVN0YXRlID0gZnVuY3Rpb24gKFxuICAgICAgYWN0aW9uLFxuICAgICAgaW5pdGlhbFN0YXRlXG4gICAgKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9IFwidXNlRm9ybVN0YXRlXCI7XG4gICAgICB3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTtcbiAgICAgIG1vdW50SG9va1R5cGVzRGV2KCk7XG4gICAgICByZXR1cm4gbW91bnRBY3Rpb25TdGF0ZShhY3Rpb24sIGluaXRpYWxTdGF0ZSk7XG4gICAgfTtcbiAgICBJbnZhbGlkTmVzdGVkSG9va3NEaXNwYXRjaGVyT25Nb3VudEluREVWLnVzZUFjdGlvblN0YXRlID0gZnVuY3Rpb24gKFxuICAgICAgYWN0aW9uLFxuICAgICAgaW5pdGlhbFN0YXRlXG4gICAgKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9IFwidXNlQWN0aW9uU3RhdGVcIjtcbiAgICAgIHdhcm5JbnZhbGlkSG9va0FjY2VzcygpO1xuICAgICAgbW91bnRIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiBtb3VudEFjdGlvblN0YXRlKGFjdGlvbiwgaW5pdGlhbFN0YXRlKTtcbiAgICB9O1xuICAgIEludmFsaWROZXN0ZWRIb29rc0Rpc3BhdGNoZXJPbk1vdW50SW5ERVYudXNlT3B0aW1pc3RpYyA9IGZ1bmN0aW9uIChcbiAgICAgIHBhc3N0aHJvdWdoXG4gICAgKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9IFwidXNlT3B0aW1pc3RpY1wiO1xuICAgICAgd2FybkludmFsaWRIb29rQWNjZXNzKCk7XG4gICAgICBtb3VudEhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIG1vdW50T3B0aW1pc3RpYyhwYXNzdGhyb3VnaCk7XG4gICAgfTtcbiAgICBJbnZhbGlkTmVzdGVkSG9va3NEaXNwYXRjaGVyT25VcGRhdGVJbkRFViA9IHtcbiAgICAgIHJlYWRDb250ZXh0OiBmdW5jdGlvbiAoY29udGV4dCkge1xuICAgICAgICB3YXJuSW52YWxpZENvbnRleHRBY2Nlc3MoKTtcbiAgICAgICAgcmV0dXJuIHJlYWRDb250ZXh0KGNvbnRleHQpO1xuICAgICAgfSxcbiAgICAgIHVzZTogZnVuY3Rpb24gKHVzYWJsZSkge1xuICAgICAgICB3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTtcbiAgICAgICAgcmV0dXJuIHVzZSh1c2FibGUpO1xuICAgICAgfSxcbiAgICAgIHVzZUNhbGxiYWNrOiBmdW5jdGlvbiAoY2FsbGJhY2ssIGRlcHMpIHtcbiAgICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSBcInVzZUNhbGxiYWNrXCI7XG4gICAgICAgIHdhcm5JbnZhbGlkSG9va0FjY2VzcygpO1xuICAgICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgICAgcmV0dXJuIHVwZGF0ZUNhbGxiYWNrKGNhbGxiYWNrLCBkZXBzKTtcbiAgICAgIH0sXG4gICAgICB1c2VDb250ZXh0OiBmdW5jdGlvbiAoY29udGV4dCkge1xuICAgICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9IFwidXNlQ29udGV4dFwiO1xuICAgICAgICB3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTtcbiAgICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICAgIHJldHVybiByZWFkQ29udGV4dChjb250ZXh0KTtcbiAgICAgIH0sXG4gICAgICB1c2VFZmZlY3Q6IGZ1bmN0aW9uIChjcmVhdGUsIGRlcHMpIHtcbiAgICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSBcInVzZUVmZmVjdFwiO1xuICAgICAgICB3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTtcbiAgICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICAgIHVwZGF0ZUVmZmVjdEltcGwoMjA0OCwgUGFzc2l2ZSwgY3JlYXRlLCBkZXBzKTtcbiAgICAgIH0sXG4gICAgICB1c2VJbXBlcmF0aXZlSGFuZGxlOiBmdW5jdGlvbiAocmVmLCBjcmVhdGUsIGRlcHMpIHtcbiAgICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSBcInVzZUltcGVyYXRpdmVIYW5kbGVcIjtcbiAgICAgICAgd2FybkludmFsaWRIb29rQWNjZXNzKCk7XG4gICAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgICByZXR1cm4gdXBkYXRlSW1wZXJhdGl2ZUhhbmRsZShyZWYsIGNyZWF0ZSwgZGVwcyk7XG4gICAgICB9LFxuICAgICAgdXNlSW5zZXJ0aW9uRWZmZWN0OiBmdW5jdGlvbiAoY3JlYXRlLCBkZXBzKSB7XG4gICAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gXCJ1c2VJbnNlcnRpb25FZmZlY3RcIjtcbiAgICAgICAgd2FybkludmFsaWRIb29rQWNjZXNzKCk7XG4gICAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgICByZXR1cm4gdXBkYXRlRWZmZWN0SW1wbCg0LCBJbnNlcnRpb24sIGNyZWF0ZSwgZGVwcyk7XG4gICAgICB9LFxuICAgICAgdXNlTGF5b3V0RWZmZWN0OiBmdW5jdGlvbiAoY3JlYXRlLCBkZXBzKSB7XG4gICAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gXCJ1c2VMYXlvdXRFZmZlY3RcIjtcbiAgICAgICAgd2FybkludmFsaWRIb29rQWNjZXNzKCk7XG4gICAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgICByZXR1cm4gdXBkYXRlRWZmZWN0SW1wbCg0LCBMYXlvdXQsIGNyZWF0ZSwgZGVwcyk7XG4gICAgICB9LFxuICAgICAgdXNlTWVtbzogZnVuY3Rpb24gKGNyZWF0ZSwgZGVwcykge1xuICAgICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9IFwidXNlTWVtb1wiO1xuICAgICAgICB3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTtcbiAgICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICAgIHZhciBwcmV2RGlzcGF0Y2hlciA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLkg7XG4gICAgICAgIFJlYWN0U2hhcmVkSW50ZXJuYWxzLkggPSBJbnZhbGlkTmVzdGVkSG9va3NEaXNwYXRjaGVyT25VcGRhdGVJbkRFVjtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICByZXR1cm4gdXBkYXRlTWVtbyhjcmVhdGUsIGRlcHMpO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIFJlYWN0U2hhcmVkSW50ZXJuYWxzLkggPSBwcmV2RGlzcGF0Y2hlcjtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHVzZVJlZHVjZXI6IGZ1bmN0aW9uIChyZWR1Y2VyLCBpbml0aWFsQXJnLCBpbml0KSB7XG4gICAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gXCJ1c2VSZWR1Y2VyXCI7XG4gICAgICAgIHdhcm5JbnZhbGlkSG9va0FjY2VzcygpO1xuICAgICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgICAgdmFyIHByZXZEaXNwYXRjaGVyID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuSDtcbiAgICAgICAgUmVhY3RTaGFyZWRJbnRlcm5hbHMuSCA9IEludmFsaWROZXN0ZWRIb29rc0Rpc3BhdGNoZXJPblVwZGF0ZUluREVWO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHJldHVybiB1cGRhdGVSZWR1Y2VyKHJlZHVjZXIsIGluaXRpYWxBcmcsIGluaXQpO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIFJlYWN0U2hhcmVkSW50ZXJuYWxzLkggPSBwcmV2RGlzcGF0Y2hlcjtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHVzZVJlZjogZnVuY3Rpb24gKCkge1xuICAgICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9IFwidXNlUmVmXCI7XG4gICAgICAgIHdhcm5JbnZhbGlkSG9va0FjY2VzcygpO1xuICAgICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgICAgcmV0dXJuIHVwZGF0ZVdvcmtJblByb2dyZXNzSG9vaygpLm1lbW9pemVkU3RhdGU7XG4gICAgICB9LFxuICAgICAgdXNlU3RhdGU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSBcInVzZVN0YXRlXCI7XG4gICAgICAgIHdhcm5JbnZhbGlkSG9va0FjY2VzcygpO1xuICAgICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgICAgdmFyIHByZXZEaXNwYXRjaGVyID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuSDtcbiAgICAgICAgUmVhY3RTaGFyZWRJbnRlcm5hbHMuSCA9IEludmFsaWROZXN0ZWRIb29rc0Rpc3BhdGNoZXJPblVwZGF0ZUluREVWO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHJldHVybiB1cGRhdGVSZWR1Y2VyKGJhc2ljU3RhdGVSZWR1Y2VyKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICBSZWFjdFNoYXJlZEludGVybmFscy5IID0gcHJldkRpc3BhdGNoZXI7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICB1c2VEZWJ1Z1ZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gXCJ1c2VEZWJ1Z1ZhbHVlXCI7XG4gICAgICAgIHdhcm5JbnZhbGlkSG9va0FjY2VzcygpO1xuICAgICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIH0sXG4gICAgICB1c2VEZWZlcnJlZFZhbHVlOiBmdW5jdGlvbiAodmFsdWUsIGluaXRpYWxWYWx1ZSkge1xuICAgICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9IFwidXNlRGVmZXJyZWRWYWx1ZVwiO1xuICAgICAgICB3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTtcbiAgICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICAgIHJldHVybiB1cGRhdGVEZWZlcnJlZFZhbHVlKHZhbHVlLCBpbml0aWFsVmFsdWUpO1xuICAgICAgfSxcbiAgICAgIHVzZVRyYW5zaXRpb246IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSBcInVzZVRyYW5zaXRpb25cIjtcbiAgICAgICAgd2FybkludmFsaWRIb29rQWNjZXNzKCk7XG4gICAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgICByZXR1cm4gdXBkYXRlVHJhbnNpdGlvbigpO1xuICAgICAgfSxcbiAgICAgIHVzZVN5bmNFeHRlcm5hbFN0b3JlOiBmdW5jdGlvbiAoXG4gICAgICAgIHN1YnNjcmliZSxcbiAgICAgICAgZ2V0U25hcHNob3QsXG4gICAgICAgIGdldFNlcnZlclNuYXBzaG90XG4gICAgICApIHtcbiAgICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSBcInVzZVN5bmNFeHRlcm5hbFN0b3JlXCI7XG4gICAgICAgIHdhcm5JbnZhbGlkSG9va0FjY2VzcygpO1xuICAgICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgICAgcmV0dXJuIHVwZGF0ZVN5bmNFeHRlcm5hbFN0b3JlKFxuICAgICAgICAgIHN1YnNjcmliZSxcbiAgICAgICAgICBnZXRTbmFwc2hvdCxcbiAgICAgICAgICBnZXRTZXJ2ZXJTbmFwc2hvdFxuICAgICAgICApO1xuICAgICAgfSxcbiAgICAgIHVzZUlkOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gXCJ1c2VJZFwiO1xuICAgICAgICB3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTtcbiAgICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICAgIHJldHVybiB1cGRhdGVXb3JrSW5Qcm9ncmVzc0hvb2soKS5tZW1vaXplZFN0YXRlO1xuICAgICAgfSxcbiAgICAgIHVzZUNhY2hlUmVmcmVzaDogZnVuY3Rpb24gKCkge1xuICAgICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9IFwidXNlQ2FjaGVSZWZyZXNoXCI7XG4gICAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgICByZXR1cm4gdXBkYXRlV29ya0luUHJvZ3Jlc3NIb29rKCkubWVtb2l6ZWRTdGF0ZTtcbiAgICAgIH0sXG4gICAgICB1c2VNZW1vQ2FjaGU6IGZ1bmN0aW9uIChzaXplKSB7XG4gICAgICAgIHdhcm5JbnZhbGlkSG9va0FjY2VzcygpO1xuICAgICAgICByZXR1cm4gdXNlTWVtb0NhY2hlKHNpemUpO1xuICAgICAgfVxuICAgIH07XG4gICAgSW52YWxpZE5lc3RlZEhvb2tzRGlzcGF0Y2hlck9uVXBkYXRlSW5ERVYudXNlSG9zdFRyYW5zaXRpb25TdGF0dXMgPVxuICAgICAgdXNlSG9zdFRyYW5zaXRpb25TdGF0dXM7XG4gICAgSW52YWxpZE5lc3RlZEhvb2tzRGlzcGF0Y2hlck9uVXBkYXRlSW5ERVYudXNlRm9ybVN0YXRlID0gZnVuY3Rpb24gKGFjdGlvbikge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSBcInVzZUZvcm1TdGF0ZVwiO1xuICAgICAgd2FybkludmFsaWRIb29rQWNjZXNzKCk7XG4gICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiB1cGRhdGVBY3Rpb25TdGF0ZShhY3Rpb24pO1xuICAgIH07XG4gICAgSW52YWxpZE5lc3RlZEhvb2tzRGlzcGF0Y2hlck9uVXBkYXRlSW5ERVYudXNlQWN0aW9uU3RhdGUgPSBmdW5jdGlvbiAoXG4gICAgICBhY3Rpb25cbiAgICApIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gXCJ1c2VBY3Rpb25TdGF0ZVwiO1xuICAgICAgd2FybkludmFsaWRIb29rQWNjZXNzKCk7XG4gICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiB1cGRhdGVBY3Rpb25TdGF0ZShhY3Rpb24pO1xuICAgIH07XG4gICAgSW52YWxpZE5lc3RlZEhvb2tzRGlzcGF0Y2hlck9uVXBkYXRlSW5ERVYudXNlT3B0aW1pc3RpYyA9IGZ1bmN0aW9uIChcbiAgICAgIHBhc3N0aHJvdWdoLFxuICAgICAgcmVkdWNlclxuICAgICkge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSBcInVzZU9wdGltaXN0aWNcIjtcbiAgICAgIHdhcm5JbnZhbGlkSG9va0FjY2VzcygpO1xuICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICByZXR1cm4gdXBkYXRlT3B0aW1pc3RpYyhwYXNzdGhyb3VnaCwgcmVkdWNlcik7XG4gICAgfTtcbiAgICBJbnZhbGlkTmVzdGVkSG9va3NEaXNwYXRjaGVyT25SZXJlbmRlckluREVWID0ge1xuICAgICAgcmVhZENvbnRleHQ6IGZ1bmN0aW9uIChjb250ZXh0KSB7XG4gICAgICAgIHdhcm5JbnZhbGlkQ29udGV4dEFjY2VzcygpO1xuICAgICAgICByZXR1cm4gcmVhZENvbnRleHQoY29udGV4dCk7XG4gICAgICB9LFxuICAgICAgdXNlOiBmdW5jdGlvbiAodXNhYmxlKSB7XG4gICAgICAgIHdhcm5JbnZhbGlkSG9va0FjY2VzcygpO1xuICAgICAgICByZXR1cm4gdXNlKHVzYWJsZSk7XG4gICAgICB9LFxuICAgICAgdXNlQ2FsbGJhY2s6IGZ1bmN0aW9uIChjYWxsYmFjaywgZGVwcykge1xuICAgICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9IFwidXNlQ2FsbGJhY2tcIjtcbiAgICAgICAgd2FybkludmFsaWRIb29rQWNjZXNzKCk7XG4gICAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgICByZXR1cm4gdXBkYXRlQ2FsbGJhY2soY2FsbGJhY2ssIGRlcHMpO1xuICAgICAgfSxcbiAgICAgIHVzZUNvbnRleHQ6IGZ1bmN0aW9uIChjb250ZXh0KSB7XG4gICAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gXCJ1c2VDb250ZXh0XCI7XG4gICAgICAgIHdhcm5JbnZhbGlkSG9va0FjY2VzcygpO1xuICAgICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgICAgcmV0dXJuIHJlYWRDb250ZXh0KGNvbnRleHQpO1xuICAgICAgfSxcbiAgICAgIHVzZUVmZmVjdDogZnVuY3Rpb24gKGNyZWF0ZSwgZGVwcykge1xuICAgICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9IFwidXNlRWZmZWN0XCI7XG4gICAgICAgIHdhcm5JbnZhbGlkSG9va0FjY2VzcygpO1xuICAgICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgICAgdXBkYXRlRWZmZWN0SW1wbCgyMDQ4LCBQYXNzaXZlLCBjcmVhdGUsIGRlcHMpO1xuICAgICAgfSxcbiAgICAgIHVzZUltcGVyYXRpdmVIYW5kbGU6IGZ1bmN0aW9uIChyZWYsIGNyZWF0ZSwgZGVwcykge1xuICAgICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9IFwidXNlSW1wZXJhdGl2ZUhhbmRsZVwiO1xuICAgICAgICB3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTtcbiAgICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICAgIHJldHVybiB1cGRhdGVJbXBlcmF0aXZlSGFuZGxlKHJlZiwgY3JlYXRlLCBkZXBzKTtcbiAgICAgIH0sXG4gICAgICB1c2VJbnNlcnRpb25FZmZlY3Q6IGZ1bmN0aW9uIChjcmVhdGUsIGRlcHMpIHtcbiAgICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSBcInVzZUluc2VydGlvbkVmZmVjdFwiO1xuICAgICAgICB3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTtcbiAgICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICAgIHJldHVybiB1cGRhdGVFZmZlY3RJbXBsKDQsIEluc2VydGlvbiwgY3JlYXRlLCBkZXBzKTtcbiAgICAgIH0sXG4gICAgICB1c2VMYXlvdXRFZmZlY3Q6IGZ1bmN0aW9uIChjcmVhdGUsIGRlcHMpIHtcbiAgICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSBcInVzZUxheW91dEVmZmVjdFwiO1xuICAgICAgICB3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTtcbiAgICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICAgIHJldHVybiB1cGRhdGVFZmZlY3RJbXBsKDQsIExheW91dCwgY3JlYXRlLCBkZXBzKTtcbiAgICAgIH0sXG4gICAgICB1c2VNZW1vOiBmdW5jdGlvbiAoY3JlYXRlLCBkZXBzKSB7XG4gICAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gXCJ1c2VNZW1vXCI7XG4gICAgICAgIHdhcm5JbnZhbGlkSG9va0FjY2VzcygpO1xuICAgICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgICAgdmFyIHByZXZEaXNwYXRjaGVyID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuSDtcbiAgICAgICAgUmVhY3RTaGFyZWRJbnRlcm5hbHMuSCA9IEludmFsaWROZXN0ZWRIb29rc0Rpc3BhdGNoZXJPblVwZGF0ZUluREVWO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHJldHVybiB1cGRhdGVNZW1vKGNyZWF0ZSwgZGVwcyk7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgUmVhY3RTaGFyZWRJbnRlcm5hbHMuSCA9IHByZXZEaXNwYXRjaGVyO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgdXNlUmVkdWNlcjogZnVuY3Rpb24gKHJlZHVjZXIsIGluaXRpYWxBcmcsIGluaXQpIHtcbiAgICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSBcInVzZVJlZHVjZXJcIjtcbiAgICAgICAgd2FybkludmFsaWRIb29rQWNjZXNzKCk7XG4gICAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgICB2YXIgcHJldkRpc3BhdGNoZXIgPSBSZWFjdFNoYXJlZEludGVybmFscy5IO1xuICAgICAgICBSZWFjdFNoYXJlZEludGVybmFscy5IID0gSW52YWxpZE5lc3RlZEhvb2tzRGlzcGF0Y2hlck9uVXBkYXRlSW5ERVY7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgcmV0dXJuIHJlcmVuZGVyUmVkdWNlcihyZWR1Y2VyLCBpbml0aWFsQXJnLCBpbml0KTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICBSZWFjdFNoYXJlZEludGVybmFscy5IID0gcHJldkRpc3BhdGNoZXI7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICB1c2VSZWY6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSBcInVzZVJlZlwiO1xuICAgICAgICB3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTtcbiAgICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICAgIHJldHVybiB1cGRhdGVXb3JrSW5Qcm9ncmVzc0hvb2soKS5tZW1vaXplZFN0YXRlO1xuICAgICAgfSxcbiAgICAgIHVzZVN0YXRlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gXCJ1c2VTdGF0ZVwiO1xuICAgICAgICB3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTtcbiAgICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICAgIHZhciBwcmV2RGlzcGF0Y2hlciA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLkg7XG4gICAgICAgIFJlYWN0U2hhcmVkSW50ZXJuYWxzLkggPSBJbnZhbGlkTmVzdGVkSG9va3NEaXNwYXRjaGVyT25VcGRhdGVJbkRFVjtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICByZXR1cm4gcmVyZW5kZXJSZWR1Y2VyKGJhc2ljU3RhdGVSZWR1Y2VyKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICBSZWFjdFNoYXJlZEludGVybmFscy5IID0gcHJldkRpc3BhdGNoZXI7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICB1c2VEZWJ1Z1ZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gXCJ1c2VEZWJ1Z1ZhbHVlXCI7XG4gICAgICAgIHdhcm5JbnZhbGlkSG9va0FjY2VzcygpO1xuICAgICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIH0sXG4gICAgICB1c2VEZWZlcnJlZFZhbHVlOiBmdW5jdGlvbiAodmFsdWUsIGluaXRpYWxWYWx1ZSkge1xuICAgICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9IFwidXNlRGVmZXJyZWRWYWx1ZVwiO1xuICAgICAgICB3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTtcbiAgICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICAgIHJldHVybiByZXJlbmRlckRlZmVycmVkVmFsdWUodmFsdWUsIGluaXRpYWxWYWx1ZSk7XG4gICAgICB9LFxuICAgICAgdXNlVHJhbnNpdGlvbjogZnVuY3Rpb24gKCkge1xuICAgICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9IFwidXNlVHJhbnNpdGlvblwiO1xuICAgICAgICB3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTtcbiAgICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICAgIHJldHVybiByZXJlbmRlclRyYW5zaXRpb24oKTtcbiAgICAgIH0sXG4gICAgICB1c2VTeW5jRXh0ZXJuYWxTdG9yZTogZnVuY3Rpb24gKFxuICAgICAgICBzdWJzY3JpYmUsXG4gICAgICAgIGdldFNuYXBzaG90LFxuICAgICAgICBnZXRTZXJ2ZXJTbmFwc2hvdFxuICAgICAgKSB7XG4gICAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gXCJ1c2VTeW5jRXh0ZXJuYWxTdG9yZVwiO1xuICAgICAgICB3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTtcbiAgICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICAgIHJldHVybiB1cGRhdGVTeW5jRXh0ZXJuYWxTdG9yZShcbiAgICAgICAgICBzdWJzY3JpYmUsXG4gICAgICAgICAgZ2V0U25hcHNob3QsXG4gICAgICAgICAgZ2V0U2VydmVyU25hcHNob3RcbiAgICAgICAgKTtcbiAgICAgIH0sXG4gICAgICB1c2VJZDogZnVuY3Rpb24gKCkge1xuICAgICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9IFwidXNlSWRcIjtcbiAgICAgICAgd2FybkludmFsaWRIb29rQWNjZXNzKCk7XG4gICAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgICByZXR1cm4gdXBkYXRlV29ya0luUHJvZ3Jlc3NIb29rKCkubWVtb2l6ZWRTdGF0ZTtcbiAgICAgIH0sXG4gICAgICB1c2VDYWNoZVJlZnJlc2g6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSBcInVzZUNhY2hlUmVmcmVzaFwiO1xuICAgICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgICAgcmV0dXJuIHVwZGF0ZVdvcmtJblByb2dyZXNzSG9vaygpLm1lbW9pemVkU3RhdGU7XG4gICAgICB9LFxuICAgICAgdXNlTWVtb0NhY2hlOiBmdW5jdGlvbiAoc2l6ZSkge1xuICAgICAgICB3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTtcbiAgICAgICAgcmV0dXJuIHVzZU1lbW9DYWNoZShzaXplKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIEludmFsaWROZXN0ZWRIb29rc0Rpc3BhdGNoZXJPblJlcmVuZGVySW5ERVYudXNlSG9zdFRyYW5zaXRpb25TdGF0dXMgPVxuICAgICAgdXNlSG9zdFRyYW5zaXRpb25TdGF0dXM7XG4gICAgSW52YWxpZE5lc3RlZEhvb2tzRGlzcGF0Y2hlck9uUmVyZW5kZXJJbkRFVi51c2VGb3JtU3RhdGUgPSBmdW5jdGlvbiAoXG4gICAgICBhY3Rpb25cbiAgICApIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gXCJ1c2VGb3JtU3RhdGVcIjtcbiAgICAgIHdhcm5JbnZhbGlkSG9va0FjY2VzcygpO1xuICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICByZXR1cm4gcmVyZW5kZXJBY3Rpb25TdGF0ZShhY3Rpb24pO1xuICAgIH07XG4gICAgSW52YWxpZE5lc3RlZEhvb2tzRGlzcGF0Y2hlck9uUmVyZW5kZXJJbkRFVi51c2VBY3Rpb25TdGF0ZSA9IGZ1bmN0aW9uIChcbiAgICAgIGFjdGlvblxuICAgICkge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSBcInVzZUFjdGlvblN0YXRlXCI7XG4gICAgICB3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTtcbiAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIHJlcmVuZGVyQWN0aW9uU3RhdGUoYWN0aW9uKTtcbiAgICB9O1xuICAgIEludmFsaWROZXN0ZWRIb29rc0Rpc3BhdGNoZXJPblJlcmVuZGVySW5ERVYudXNlT3B0aW1pc3RpYyA9IGZ1bmN0aW9uIChcbiAgICAgIHBhc3N0aHJvdWdoLFxuICAgICAgcmVkdWNlclxuICAgICkge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSBcInVzZU9wdGltaXN0aWNcIjtcbiAgICAgIHdhcm5JbnZhbGlkSG9va0FjY2VzcygpO1xuICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICByZXR1cm4gcmVyZW5kZXJPcHRpbWlzdGljKHBhc3N0aHJvdWdoLCByZWR1Y2VyKTtcbiAgICB9O1xuICAgIHZhciBmYWtlSW50ZXJuYWxJbnN0YW5jZSA9IHt9O1xuICAgIHZhciBkaWRXYXJuQWJvdXRTdGF0ZUFzc2lnbm1lbnRGb3JDb21wb25lbnQgPSBuZXcgU2V0KCk7XG4gICAgdmFyIGRpZFdhcm5BYm91dFVuaW5pdGlhbGl6ZWRTdGF0ZSA9IG5ldyBTZXQoKTtcbiAgICB2YXIgZGlkV2FybkFib3V0R2V0U25hcHNob3RCZWZvcmVVcGRhdGVXaXRob3V0RGlkVXBkYXRlID0gbmV3IFNldCgpO1xuICAgIHZhciBkaWRXYXJuQWJvdXRMZWdhY3lMaWZlY3ljbGVzQW5kRGVyaXZlZFN0YXRlID0gbmV3IFNldCgpO1xuICAgIHZhciBkaWRXYXJuQWJvdXREaXJlY3RseUFzc2lnbmluZ1Byb3BzVG9TdGF0ZSA9IG5ldyBTZXQoKTtcbiAgICB2YXIgZGlkV2FybkFib3V0VW5kZWZpbmVkRGVyaXZlZFN0YXRlID0gbmV3IFNldCgpO1xuICAgIHZhciBkaWRXYXJuQWJvdXRDb250ZXh0VHlwZXMkMSA9IG5ldyBTZXQoKTtcbiAgICB2YXIgZGlkV2FybkFib3V0Q2hpbGRDb250ZXh0VHlwZXMgPSBuZXcgU2V0KCk7XG4gICAgdmFyIGRpZFdhcm5BYm91dEludmFsaWRhdGVDb250ZXh0VHlwZSA9IG5ldyBTZXQoKTtcbiAgICB2YXIgZGlkV2Fybk9uSW52YWxpZENhbGxiYWNrID0gbmV3IFNldCgpO1xuICAgIE9iamVjdC5mcmVlemUoZmFrZUludGVybmFsSW5zdGFuY2UpO1xuICAgIHZhciBjbGFzc0NvbXBvbmVudFVwZGF0ZXIgPSB7XG4gICAgICAgIGlzTW91bnRlZDogZnVuY3Rpb24gKGNvbXBvbmVudCkge1xuICAgICAgICAgIHZhciBvd25lciA9IGN1cnJlbnQ7XG4gICAgICAgICAgaWYgKG51bGwgIT09IG93bmVyICYmIGlzUmVuZGVyaW5nICYmIDEgPT09IG93bmVyLnRhZykge1xuICAgICAgICAgICAgdmFyIGluc3RhbmNlID0gb3duZXIuc3RhdGVOb2RlO1xuICAgICAgICAgICAgaW5zdGFuY2UuX3dhcm5lZEFib3V0UmVmc0luUmVuZGVyIHx8XG4gICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgICAgXCIlcyBpcyBhY2Nlc3NpbmcgaXNNb3VudGVkIGluc2lkZSBpdHMgcmVuZGVyKCkgZnVuY3Rpb24uIHJlbmRlcigpIHNob3VsZCBiZSBhIHB1cmUgZnVuY3Rpb24gb2YgcHJvcHMgYW5kIHN0YXRlLiBJdCBzaG91bGQgbmV2ZXIgYWNjZXNzIHNvbWV0aGluZyB0aGF0IHJlcXVpcmVzIHN0YWxlIGRhdGEgZnJvbSB0aGUgcHJldmlvdXMgcmVuZGVyLCBzdWNoIGFzIHJlZnMuIE1vdmUgdGhpcyBsb2dpYyB0byBjb21wb25lbnREaWRNb3VudCBhbmQgY29tcG9uZW50RGlkVXBkYXRlIGluc3RlYWQuXCIsXG4gICAgICAgICAgICAgICAgZ2V0Q29tcG9uZW50TmFtZUZyb21GaWJlcihvd25lcikgfHwgXCJBIGNvbXBvbmVudFwiXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICBpbnN0YW5jZS5fd2FybmVkQWJvdXRSZWZzSW5SZW5kZXIgPSAhMDtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIChjb21wb25lbnQgPSBjb21wb25lbnQuX3JlYWN0SW50ZXJuYWxzKVxuICAgICAgICAgICAgPyBnZXROZWFyZXN0TW91bnRlZEZpYmVyKGNvbXBvbmVudCkgPT09IGNvbXBvbmVudFxuICAgICAgICAgICAgOiAhMTtcbiAgICAgICAgfSxcbiAgICAgICAgZW5xdWV1ZVNldFN0YXRlOiBmdW5jdGlvbiAoaW5zdCwgcGF5bG9hZCwgY2FsbGJhY2spIHtcbiAgICAgICAgICBpbnN0ID0gaW5zdC5fcmVhY3RJbnRlcm5hbHM7XG4gICAgICAgICAgdmFyIGxhbmUgPSByZXF1ZXN0VXBkYXRlTGFuZShpbnN0KSxcbiAgICAgICAgICAgIHVwZGF0ZSA9IGNyZWF0ZVVwZGF0ZShsYW5lKTtcbiAgICAgICAgICB1cGRhdGUucGF5bG9hZCA9IHBheWxvYWQ7XG4gICAgICAgICAgdm9pZCAwICE9PSBjYWxsYmFjayAmJlxuICAgICAgICAgICAgbnVsbCAhPT0gY2FsbGJhY2sgJiZcbiAgICAgICAgICAgICh3YXJuT25JbnZhbGlkQ2FsbGJhY2soY2FsbGJhY2spLCAodXBkYXRlLmNhbGxiYWNrID0gY2FsbGJhY2spKTtcbiAgICAgICAgICBwYXlsb2FkID0gZW5xdWV1ZVVwZGF0ZShpbnN0LCB1cGRhdGUsIGxhbmUpO1xuICAgICAgICAgIG51bGwgIT09IHBheWxvYWQgJiZcbiAgICAgICAgICAgIChzY2hlZHVsZVVwZGF0ZU9uRmliZXIocGF5bG9hZCwgaW5zdCwgbGFuZSksXG4gICAgICAgICAgICBlbnRhbmdsZVRyYW5zaXRpb25zKHBheWxvYWQsIGluc3QsIGxhbmUpKTtcbiAgICAgICAgICBtYXJrU3RhdGVVcGRhdGVTY2hlZHVsZWQoaW5zdCwgbGFuZSk7XG4gICAgICAgIH0sXG4gICAgICAgIGVucXVldWVSZXBsYWNlU3RhdGU6IGZ1bmN0aW9uIChpbnN0LCBwYXlsb2FkLCBjYWxsYmFjaykge1xuICAgICAgICAgIGluc3QgPSBpbnN0Ll9yZWFjdEludGVybmFscztcbiAgICAgICAgICB2YXIgbGFuZSA9IHJlcXVlc3RVcGRhdGVMYW5lKGluc3QpLFxuICAgICAgICAgICAgdXBkYXRlID0gY3JlYXRlVXBkYXRlKGxhbmUpO1xuICAgICAgICAgIHVwZGF0ZS50YWcgPSBSZXBsYWNlU3RhdGU7XG4gICAgICAgICAgdXBkYXRlLnBheWxvYWQgPSBwYXlsb2FkO1xuICAgICAgICAgIHZvaWQgMCAhPT0gY2FsbGJhY2sgJiZcbiAgICAgICAgICAgIG51bGwgIT09IGNhbGxiYWNrICYmXG4gICAgICAgICAgICAod2Fybk9uSW52YWxpZENhbGxiYWNrKGNhbGxiYWNrKSwgKHVwZGF0ZS5jYWxsYmFjayA9IGNhbGxiYWNrKSk7XG4gICAgICAgICAgcGF5bG9hZCA9IGVucXVldWVVcGRhdGUoaW5zdCwgdXBkYXRlLCBsYW5lKTtcbiAgICAgICAgICBudWxsICE9PSBwYXlsb2FkICYmXG4gICAgICAgICAgICAoc2NoZWR1bGVVcGRhdGVPbkZpYmVyKHBheWxvYWQsIGluc3QsIGxhbmUpLFxuICAgICAgICAgICAgZW50YW5nbGVUcmFuc2l0aW9ucyhwYXlsb2FkLCBpbnN0LCBsYW5lKSk7XG4gICAgICAgICAgbWFya1N0YXRlVXBkYXRlU2NoZWR1bGVkKGluc3QsIGxhbmUpO1xuICAgICAgICB9LFxuICAgICAgICBlbnF1ZXVlRm9yY2VVcGRhdGU6IGZ1bmN0aW9uIChpbnN0LCBjYWxsYmFjaykge1xuICAgICAgICAgIGluc3QgPSBpbnN0Ll9yZWFjdEludGVybmFscztcbiAgICAgICAgICB2YXIgbGFuZSA9IHJlcXVlc3RVcGRhdGVMYW5lKGluc3QpLFxuICAgICAgICAgICAgdXBkYXRlID0gY3JlYXRlVXBkYXRlKGxhbmUpO1xuICAgICAgICAgIHVwZGF0ZS50YWcgPSBGb3JjZVVwZGF0ZTtcbiAgICAgICAgICB2b2lkIDAgIT09IGNhbGxiYWNrICYmXG4gICAgICAgICAgICBudWxsICE9PSBjYWxsYmFjayAmJlxuICAgICAgICAgICAgKHdhcm5PbkludmFsaWRDYWxsYmFjayhjYWxsYmFjayksICh1cGRhdGUuY2FsbGJhY2sgPSBjYWxsYmFjaykpO1xuICAgICAgICAgIGNhbGxiYWNrID0gZW5xdWV1ZVVwZGF0ZShpbnN0LCB1cGRhdGUsIGxhbmUpO1xuICAgICAgICAgIG51bGwgIT09IGNhbGxiYWNrICYmXG4gICAgICAgICAgICAoc2NoZWR1bGVVcGRhdGVPbkZpYmVyKGNhbGxiYWNrLCBpbnN0LCBsYW5lKSxcbiAgICAgICAgICAgIGVudGFuZ2xlVHJhbnNpdGlvbnMoY2FsbGJhY2ssIGluc3QsIGxhbmUpKTtcbiAgICAgICAgICBudWxsICE9PSBpbmplY3RlZFByb2ZpbGluZ0hvb2tzICYmXG4gICAgICAgICAgICBcImZ1bmN0aW9uXCIgPT09XG4gICAgICAgICAgICAgIHR5cGVvZiBpbmplY3RlZFByb2ZpbGluZ0hvb2tzLm1hcmtGb3JjZVVwZGF0ZVNjaGVkdWxlZCAmJlxuICAgICAgICAgICAgaW5qZWN0ZWRQcm9maWxpbmdIb29rcy5tYXJrRm9yY2VVcGRhdGVTY2hlZHVsZWQoaW5zdCwgbGFuZSk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICByZXBvcnRHbG9iYWxFcnJvciA9XG4gICAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIHJlcG9ydEVycm9yXG4gICAgICAgICAgPyByZXBvcnRFcnJvclxuICAgICAgICAgIDogZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICBcIm9iamVjdFwiID09PSB0eXBlb2Ygd2luZG93ICYmXG4gICAgICAgICAgICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2Ygd2luZG93LkVycm9yRXZlbnRcbiAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgdmFyIGV2ZW50ID0gbmV3IHdpbmRvdy5FcnJvckV2ZW50KFwiZXJyb3JcIiwge1xuICAgICAgICAgICAgICAgICAgYnViYmxlczogITAsXG4gICAgICAgICAgICAgICAgICBjYW5jZWxhYmxlOiAhMCxcbiAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6XG4gICAgICAgICAgICAgICAgICAgIFwib2JqZWN0XCIgPT09IHR5cGVvZiBlcnJvciAmJlxuICAgICAgICAgICAgICAgICAgICBudWxsICE9PSBlcnJvciAmJlxuICAgICAgICAgICAgICAgICAgICBcInN0cmluZ1wiID09PSB0eXBlb2YgZXJyb3IubWVzc2FnZVxuICAgICAgICAgICAgICAgICAgICAgID8gU3RyaW5nKGVycm9yLm1lc3NhZ2UpXG4gICAgICAgICAgICAgICAgICAgICAgOiBTdHJpbmcoZXJyb3IpLFxuICAgICAgICAgICAgICAgICAgZXJyb3I6IGVycm9yXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgaWYgKCF3aW5kb3cuZGlzcGF0Y2hFdmVudChldmVudCkpIHJldHVybjtcbiAgICAgICAgICAgICAgfSBlbHNlIGlmIChcbiAgICAgICAgICAgICAgICBcIm9iamVjdFwiID09PSB0eXBlb2YgcHJvY2VzcyAmJlxuICAgICAgICAgICAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIHByb2Nlc3MuZW1pdFxuICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICBwcm9jZXNzLmVtaXQoXCJ1bmNhdWdodEV4Y2VwdGlvblwiLCBlcnJvcik7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoZXJyb3IpO1xuICAgICAgICAgICAgfSxcbiAgICAgIGNvbXBvbmVudE5hbWUgPSBudWxsLFxuICAgICAgZXJyb3JCb3VuZGFyeU5hbWUgPSBudWxsLFxuICAgICAgU2VsZWN0aXZlSHlkcmF0aW9uRXhjZXB0aW9uID0gRXJyb3IoXG4gICAgICAgIFwiVGhpcyBpcyBub3QgYSByZWFsIGVycm9yLiBJdCdzIGFuIGltcGxlbWVudGF0aW9uIGRldGFpbCBvZiBSZWFjdCdzIHNlbGVjdGl2ZSBoeWRyYXRpb24gZmVhdHVyZS4gSWYgdGhpcyBsZWFrcyBpbnRvIHVzZXJzcGFjZSwgaXQncyBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuXCJcbiAgICAgICksXG4gICAgICBkaWRSZWNlaXZlVXBkYXRlID0gITE7XG4gICAgdmFyIGRpZFdhcm5BYm91dEJhZENsYXNzID0ge307XG4gICAgdmFyIGRpZFdhcm5BYm91dENvbnRleHRUeXBlT25GdW5jdGlvbkNvbXBvbmVudCA9IHt9O1xuICAgIHZhciBkaWRXYXJuQWJvdXRDb250ZXh0VHlwZXMgPSB7fTtcbiAgICB2YXIgZGlkV2FybkFib3V0R2V0RGVyaXZlZFN0YXRlT25GdW5jdGlvbkNvbXBvbmVudCA9IHt9O1xuICAgIHZhciBkaWRXYXJuQWJvdXRSZWFzc2lnbmluZ1Byb3BzID0gITE7XG4gICAgdmFyIGRpZFdhcm5BYm91dFJldmVhbE9yZGVyID0ge307XG4gICAgdmFyIGRpZFdhcm5BYm91dFRhaWxPcHRpb25zID0ge307XG4gICAgdmFyIFNVU1BFTkRFRF9NQVJLRVIgPSB7XG4gICAgICAgIGRlaHlkcmF0ZWQ6IG51bGwsXG4gICAgICAgIHRyZWVDb250ZXh0OiBudWxsLFxuICAgICAgICByZXRyeUxhbmU6IDBcbiAgICAgIH0sXG4gICAgICBoYXNXYXJuZWRBYm91dFVzaW5nTm9WYWx1ZVByb3BPbkNvbnRleHRQcm92aWRlciA9ICExLFxuICAgICAgdmFsdWVDdXJzb3IgPSBjcmVhdGVDdXJzb3IobnVsbCk7XG4gICAgdmFyIHJlbmRlcmVyQ3Vyc29yREVWID0gY3JlYXRlQ3Vyc29yKG51bGwpO1xuICAgIHZhciByZW5kZXJlcjJDdXJzb3JERVYgPSBjcmVhdGVDdXJzb3IobnVsbCk7XG4gICAgdmFyIHJlbmRlcmVyU2lnaWwgPSB7fTtcbiAgICB2YXIgY3VycmVudGx5UmVuZGVyaW5nRmliZXIgPSBudWxsLFxuICAgICAgbGFzdENvbnRleHREZXBlbmRlbmN5ID0gbnVsbCxcbiAgICAgIGlzRGlzYWxsb3dlZENvbnRleHRSZWFkSW5ERVYgPSAhMSxcbiAgICAgIEFib3J0Q29udHJvbGxlckxvY2FsID1cbiAgICAgICAgXCJ1bmRlZmluZWRcIiAhPT0gdHlwZW9mIEFib3J0Q29udHJvbGxlclxuICAgICAgICAgID8gQWJvcnRDb250cm9sbGVyXG4gICAgICAgICAgOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIHZhciBsaXN0ZW5lcnMgPSBbXSxcbiAgICAgICAgICAgICAgICBzaWduYWwgPSAodGhpcy5zaWduYWwgPSB7XG4gICAgICAgICAgICAgICAgICBhYm9ydGVkOiAhMSxcbiAgICAgICAgICAgICAgICAgIGFkZEV2ZW50TGlzdGVuZXI6IGZ1bmN0aW9uICh0eXBlLCBsaXN0ZW5lcikge1xuICAgICAgICAgICAgICAgICAgICBsaXN0ZW5lcnMucHVzaChsaXN0ZW5lcik7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIHRoaXMuYWJvcnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgc2lnbmFsLmFib3J0ZWQgPSAhMDtcbiAgICAgICAgICAgICAgICBsaXN0ZW5lcnMuZm9yRWFjaChmdW5jdGlvbiAobGlzdGVuZXIpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBsaXN0ZW5lcigpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSxcbiAgICAgIHNjaGVkdWxlQ2FsbGJhY2skMSA9IFNjaGVkdWxlci51bnN0YWJsZV9zY2hlZHVsZUNhbGxiYWNrLFxuICAgICAgTm9ybWFsUHJpb3JpdHkgPSBTY2hlZHVsZXIudW5zdGFibGVfTm9ybWFsUHJpb3JpdHksXG4gICAgICBDYWNoZUNvbnRleHQgPSB7XG4gICAgICAgICQkdHlwZW9mOiBSRUFDVF9DT05URVhUX1RZUEUsXG4gICAgICAgIENvbnN1bWVyOiBudWxsLFxuICAgICAgICBQcm92aWRlcjogbnVsbCxcbiAgICAgICAgX2N1cnJlbnRWYWx1ZTogbnVsbCxcbiAgICAgICAgX2N1cnJlbnRWYWx1ZTI6IG51bGwsXG4gICAgICAgIF90aHJlYWRDb3VudDogMCxcbiAgICAgICAgX2N1cnJlbnRSZW5kZXJlcjogbnVsbCxcbiAgICAgICAgX2N1cnJlbnRSZW5kZXJlcjI6IG51bGxcbiAgICAgIH0sXG4gICAgICBwcmV2T25TdGFydFRyYW5zaXRpb25GaW5pc2ggPSBSZWFjdFNoYXJlZEludGVybmFscy5TO1xuICAgIFJlYWN0U2hhcmVkSW50ZXJuYWxzLlMgPSBmdW5jdGlvbiAodHJhbnNpdGlvbiwgcmV0dXJuVmFsdWUpIHtcbiAgICAgIFwib2JqZWN0XCIgPT09IHR5cGVvZiByZXR1cm5WYWx1ZSAmJlxuICAgICAgICBudWxsICE9PSByZXR1cm5WYWx1ZSAmJlxuICAgICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiByZXR1cm5WYWx1ZS50aGVuICYmXG4gICAgICAgIGVudGFuZ2xlQXN5bmNBY3Rpb24odHJhbnNpdGlvbiwgcmV0dXJuVmFsdWUpO1xuICAgICAgbnVsbCAhPT0gcHJldk9uU3RhcnRUcmFuc2l0aW9uRmluaXNoICYmXG4gICAgICAgIHByZXZPblN0YXJ0VHJhbnNpdGlvbkZpbmlzaCh0cmFuc2l0aW9uLCByZXR1cm5WYWx1ZSk7XG4gICAgfTtcbiAgICB2YXIgcmVzdW1lZENhY2hlID0gY3JlYXRlQ3Vyc29yKG51bGwpLFxuICAgICAgZGlkV2FybkFib3V0VW5kZWZpbmVkU25hcHNob3RCZWZvcmVVcGRhdGUgPSBudWxsO1xuICAgIGRpZFdhcm5BYm91dFVuZGVmaW5lZFNuYXBzaG90QmVmb3JlVXBkYXRlID0gbmV3IFNldCgpO1xuICAgIHZhciBvZmZzY3JlZW5TdWJ0cmVlSXNIaWRkZW4gPSAhMSxcbiAgICAgIG9mZnNjcmVlblN1YnRyZWVXYXNIaWRkZW4gPSAhMSxcbiAgICAgIG5lZWRzRm9ybVJlc2V0ID0gITEsXG4gICAgICBQb3NzaWJseVdlYWtTZXQgPSBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBXZWFrU2V0ID8gV2Vha1NldCA6IFNldCxcbiAgICAgIG5leHRFZmZlY3QgPSBudWxsLFxuICAgICAgaW5Qcm9ncmVzc0xhbmVzID0gbnVsbCxcbiAgICAgIGluUHJvZ3Jlc3NSb290ID0gbnVsbCxcbiAgICAgIHNob3VsZEZpcmVBZnRlckFjdGl2ZUluc3RhbmNlQmx1ciA9ICExLFxuICAgICAgaG9zdFBhcmVudCA9IG51bGwsXG4gICAgICBob3N0UGFyZW50SXNDb250YWluZXIgPSAhMSxcbiAgICAgIGN1cnJlbnRIb2lzdGFibGVSb290ID0gbnVsbCxcbiAgICAgIHN1c3BlbnNleUNvbW1pdEZsYWcgPSA4MTkyLFxuICAgICAgRGVmYXVsdEFzeW5jRGlzcGF0Y2hlciA9IHtcbiAgICAgICAgZ2V0Q2FjaGVGb3JUeXBlOiBmdW5jdGlvbiAocmVzb3VyY2VUeXBlKSB7XG4gICAgICAgICAgdmFyIGNhY2hlID0gcmVhZENvbnRleHQoQ2FjaGVDb250ZXh0KSxcbiAgICAgICAgICAgIGNhY2hlRm9yVHlwZSA9IGNhY2hlLmRhdGEuZ2V0KHJlc291cmNlVHlwZSk7XG4gICAgICAgICAgdm9pZCAwID09PSBjYWNoZUZvclR5cGUgJiZcbiAgICAgICAgICAgICgoY2FjaGVGb3JUeXBlID0gcmVzb3VyY2VUeXBlKCkpLFxuICAgICAgICAgICAgY2FjaGUuZGF0YS5zZXQocmVzb3VyY2VUeXBlLCBjYWNoZUZvclR5cGUpKTtcbiAgICAgICAgICByZXR1cm4gY2FjaGVGb3JUeXBlO1xuICAgICAgICB9LFxuICAgICAgICBnZXRPd25lcjogZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiBjdXJyZW50O1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgQ09NUE9ORU5UX1RZUEUgPSAwLFxuICAgICAgSEFTX1BTRVVET19DTEFTU19UWVBFID0gMSxcbiAgICAgIFJPTEVfVFlQRSA9IDIsXG4gICAgICBURVNUX05BTUVfVFlQRSA9IDMsXG4gICAgICBURVhUX1RZUEUgPSA0O1xuICAgIGlmIChcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBTeW1ib2wgJiYgU3ltYm9sLmZvcikge1xuICAgICAgdmFyIHN5bWJvbEZvciA9IFN5bWJvbC5mb3I7XG4gICAgICBDT01QT05FTlRfVFlQRSA9IHN5bWJvbEZvcihcInNlbGVjdG9yLmNvbXBvbmVudFwiKTtcbiAgICAgIEhBU19QU0VVRE9fQ0xBU1NfVFlQRSA9IHN5bWJvbEZvcihcInNlbGVjdG9yLmhhc19wc2V1ZG9fY2xhc3NcIik7XG4gICAgICBST0xFX1RZUEUgPSBzeW1ib2xGb3IoXCJzZWxlY3Rvci5yb2xlXCIpO1xuICAgICAgVEVTVF9OQU1FX1RZUEUgPSBzeW1ib2xGb3IoXCJzZWxlY3Rvci50ZXN0X2lkXCIpO1xuICAgICAgVEVYVF9UWVBFID0gc3ltYm9sRm9yKFwic2VsZWN0b3IudGV4dFwiKTtcbiAgICB9XG4gICAgdmFyIGNvbW1pdEhvb2tzID0gW10sXG4gICAgICBQb3NzaWJseVdlYWtNYXAgPSBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBXZWFrTWFwID8gV2Vha01hcCA6IE1hcCxcbiAgICAgIE5vQ29udGV4dCA9IDAsXG4gICAgICBSZW5kZXJDb250ZXh0ID0gMixcbiAgICAgIENvbW1pdENvbnRleHQgPSA0LFxuICAgICAgUm9vdEluUHJvZ3Jlc3MgPSAwLFxuICAgICAgUm9vdEZhdGFsRXJyb3JlZCA9IDEsXG4gICAgICBSb290RXJyb3JlZCA9IDIsXG4gICAgICBSb290U3VzcGVuZGVkID0gMyxcbiAgICAgIFJvb3RTdXNwZW5kZWRXaXRoRGVsYXkgPSA0LFxuICAgICAgUm9vdENvbXBsZXRlZCA9IDUsXG4gICAgICBSb290RGlkTm90Q29tcGxldGUgPSA2LFxuICAgICAgZXhlY3V0aW9uQ29udGV4dCA9IE5vQ29udGV4dCxcbiAgICAgIHdvcmtJblByb2dyZXNzUm9vdCA9IG51bGwsXG4gICAgICB3b3JrSW5Qcm9ncmVzcyA9IG51bGwsXG4gICAgICB3b3JrSW5Qcm9ncmVzc1Jvb3RSZW5kZXJMYW5lcyA9IDAsXG4gICAgICBOb3RTdXNwZW5kZWQgPSAwLFxuICAgICAgU3VzcGVuZGVkT25FcnJvciA9IDEsXG4gICAgICBTdXNwZW5kZWRPbkRhdGEgPSAyLFxuICAgICAgU3VzcGVuZGVkT25JbW1lZGlhdGUgPSAzLFxuICAgICAgU3VzcGVuZGVkT25JbnN0YW5jZSA9IDQsXG4gICAgICBTdXNwZW5kZWRPbkluc3RhbmNlQW5kUmVhZHlUb0NvbnRpbnVlID0gNSxcbiAgICAgIFN1c3BlbmRlZE9uRGVwcmVjYXRlZFRocm93UHJvbWlzZSA9IDYsXG4gICAgICBTdXNwZW5kZWRBbmRSZWFkeVRvQ29udGludWUgPSA3LFxuICAgICAgU3VzcGVuZGVkT25IeWRyYXRpb24gPSA4LFxuICAgICAgd29ya0luUHJvZ3Jlc3NTdXNwZW5kZWRSZWFzb24gPSBOb3RTdXNwZW5kZWQsXG4gICAgICB3b3JrSW5Qcm9ncmVzc1Rocm93blZhbHVlID0gbnVsbCxcbiAgICAgIHdvcmtJblByb2dyZXNzUm9vdERpZFNraXBTdXNwZW5kZWRTaWJsaW5ncyA9ICExLFxuICAgICAgd29ya0luUHJvZ3Jlc3NSb290SXNQcmVyZW5kZXJpbmcgPSAhMSxcbiAgICAgIHdvcmtJblByb2dyZXNzUm9vdERpZEF0dGFjaFBpbmdMaXN0ZW5lciA9ICExLFxuICAgICAgZW50YW5nbGVkUmVuZGVyTGFuZXMgPSAwLFxuICAgICAgd29ya0luUHJvZ3Jlc3NSb290RXhpdFN0YXR1cyA9IFJvb3RJblByb2dyZXNzLFxuICAgICAgd29ya0luUHJvZ3Jlc3NSb290U2tpcHBlZExhbmVzID0gMCxcbiAgICAgIHdvcmtJblByb2dyZXNzUm9vdEludGVybGVhdmVkVXBkYXRlZExhbmVzID0gMCxcbiAgICAgIHdvcmtJblByb2dyZXNzUm9vdFBpbmdlZExhbmVzID0gMCxcbiAgICAgIHdvcmtJblByb2dyZXNzRGVmZXJyZWRMYW5lID0gMCxcbiAgICAgIHdvcmtJblByb2dyZXNzU3VzcGVuZGVkUmV0cnlMYW5lcyA9IDAsXG4gICAgICB3b3JrSW5Qcm9ncmVzc1Jvb3RDb25jdXJyZW50RXJyb3JzID0gbnVsbCxcbiAgICAgIHdvcmtJblByb2dyZXNzUm9vdFJlY292ZXJhYmxlRXJyb3JzID0gbnVsbCxcbiAgICAgIHdvcmtJblByb2dyZXNzUm9vdERpZEluY2x1ZGVSZWN1cnNpdmVSZW5kZXJVcGRhdGUgPSAhMSxcbiAgICAgIGdsb2JhbE1vc3RSZWNlbnRGYWxsYmFja1RpbWUgPSAwLFxuICAgICAgRkFMTEJBQ0tfVEhST1RUTEVfTVMgPSAzMDAsXG4gICAgICB3b3JrSW5Qcm9ncmVzc1Jvb3RSZW5kZXJUYXJnZXRUaW1lID0gSW5maW5pdHksXG4gICAgICBSRU5ERVJfVElNRU9VVF9NUyA9IDUwMCxcbiAgICAgIHdvcmtJblByb2dyZXNzVHJhbnNpdGlvbnMgPSBudWxsLFxuICAgICAgbGVnYWN5RXJyb3JCb3VuZGFyaWVzVGhhdEFscmVhZHlGYWlsZWQgPSBudWxsLFxuICAgICAgcm9vdERvZXNIYXZlUGFzc2l2ZUVmZmVjdHMgPSAhMSxcbiAgICAgIHJvb3RXaXRoUGVuZGluZ1Bhc3NpdmVFZmZlY3RzID0gbnVsbCxcbiAgICAgIHBlbmRpbmdQYXNzaXZlRWZmZWN0c0xhbmVzID0gMCxcbiAgICAgIHBlbmRpbmdQYXNzaXZlRWZmZWN0c1JlbWFpbmluZ0xhbmVzID0gMCxcbiAgICAgIHBlbmRpbmdQYXNzaXZlVHJhbnNpdGlvbnMgPSBudWxsLFxuICAgICAgTkVTVEVEX1VQREFURV9MSU1JVCA9IDUwLFxuICAgICAgbmVzdGVkVXBkYXRlQ291bnQgPSAwLFxuICAgICAgcm9vdFdpdGhOZXN0ZWRVcGRhdGVzID0gbnVsbCxcbiAgICAgIGlzRmx1c2hpbmdQYXNzaXZlRWZmZWN0cyA9ICExLFxuICAgICAgZGlkU2NoZWR1bGVVcGRhdGVEdXJpbmdQYXNzaXZlRWZmZWN0cyA9ICExLFxuICAgICAgTkVTVEVEX1BBU1NJVkVfVVBEQVRFX0xJTUlUID0gNTAsXG4gICAgICBuZXN0ZWRQYXNzaXZlVXBkYXRlQ291bnQgPSAwLFxuICAgICAgcm9vdFdpdGhQYXNzaXZlTmVzdGVkVXBkYXRlcyA9IG51bGwsXG4gICAgICBpc1J1bm5pbmdJbnNlcnRpb25FZmZlY3QgPSAhMSxcbiAgICAgIElNTUVESUFURV9DT01NSVQgPSAwLFxuICAgICAgU1VTUEVOREVEX0NPTU1JVCA9IDEsXG4gICAgICBUSFJPVFRMRURfQ09NTUlUID0gMixcbiAgICAgIGRpZFdhcm5TdGF0ZVVwZGF0ZUZvck5vdFlldE1vdW50ZWRDb21wb25lbnQgPSBudWxsLFxuICAgICAgZGlkV2FybkFib3V0VXBkYXRlSW5SZW5kZXIgPSAhMTtcbiAgICB2YXIgZGlkV2FybkFib3V0VXBkYXRlSW5SZW5kZXJGb3JBbm90aGVyQ29tcG9uZW50ID0gbmV3IFNldCgpO1xuICAgIHZhciBmYWtlQWN0Q2FsbGJhY2tOb2RlID0ge30sXG4gICAgICByZXNvbHZlRmFtaWx5ID0gbnVsbCxcbiAgICAgIGZhaWxlZEJvdW5kYXJpZXMgPSBudWxsO1xuICAgIHZhciBoYXNCYWRNYXBQb2x5ZmlsbCA9ICExO1xuICAgIHRyeSB7XG4gICAgICB2YXIgbm9uRXh0ZW5zaWJsZU9iamVjdCA9IE9iamVjdC5wcmV2ZW50RXh0ZW5zaW9ucyh7fSk7XG4gICAgICBuZXcgTWFwKFtbbm9uRXh0ZW5zaWJsZU9iamVjdCwgbnVsbF1dKTtcbiAgICAgIG5ldyBTZXQoW25vbkV4dGVuc2libGVPYmplY3RdKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBoYXNCYWRNYXBQb2x5ZmlsbCA9ICEwO1xuICAgIH1cbiAgICB2YXIgZGlkV2FybkFib3V0TmVzdGVkVXBkYXRlcyA9ICExO1xuICAgIHZhciBkaWRXYXJuQWJvdXRGaW5kTm9kZUluU3RyaWN0TW9kZSA9IHt9O1xuICAgIHZhciBvdmVycmlkZUhvb2tTdGF0ZSA9IG51bGwsXG4gICAgICBvdmVycmlkZUhvb2tTdGF0ZURlbGV0ZVBhdGggPSBudWxsLFxuICAgICAgb3ZlcnJpZGVIb29rU3RhdGVSZW5hbWVQYXRoID0gbnVsbCxcbiAgICAgIG92ZXJyaWRlUHJvcHMgPSBudWxsLFxuICAgICAgb3ZlcnJpZGVQcm9wc0RlbGV0ZVBhdGggPSBudWxsLFxuICAgICAgb3ZlcnJpZGVQcm9wc1JlbmFtZVBhdGggPSBudWxsLFxuICAgICAgc2NoZWR1bGVVcGRhdGUgPSBudWxsLFxuICAgICAgc2V0RXJyb3JIYW5kbGVyID0gbnVsbCxcbiAgICAgIHNldFN1c3BlbnNlSGFuZGxlciA9IG51bGw7XG4gICAgb3ZlcnJpZGVIb29rU3RhdGUgPSBmdW5jdGlvbiAoZmliZXIsIGlkLCBwYXRoLCB2YWx1ZSkge1xuICAgICAgaWQgPSBmaW5kSG9vayhmaWJlciwgaWQpO1xuICAgICAgbnVsbCAhPT0gaWQgJiZcbiAgICAgICAgKChwYXRoID0gY29weVdpdGhTZXRJbXBsKGlkLm1lbW9pemVkU3RhdGUsIHBhdGgsIDAsIHZhbHVlKSksXG4gICAgICAgIChpZC5tZW1vaXplZFN0YXRlID0gcGF0aCksXG4gICAgICAgIChpZC5iYXNlU3RhdGUgPSBwYXRoKSxcbiAgICAgICAgKGZpYmVyLm1lbW9pemVkUHJvcHMgPSBhc3NpZ24oe30sIGZpYmVyLm1lbW9pemVkUHJvcHMpKSxcbiAgICAgICAgKHBhdGggPSBlbnF1ZXVlQ29uY3VycmVudFJlbmRlckZvckxhbmUoZmliZXIsIDIpKSxcbiAgICAgICAgbnVsbCAhPT0gcGF0aCAmJiBzY2hlZHVsZVVwZGF0ZU9uRmliZXIocGF0aCwgZmliZXIsIDIpKTtcbiAgICB9O1xuICAgIG92ZXJyaWRlSG9va1N0YXRlRGVsZXRlUGF0aCA9IGZ1bmN0aW9uIChmaWJlciwgaWQsIHBhdGgpIHtcbiAgICAgIGlkID0gZmluZEhvb2soZmliZXIsIGlkKTtcbiAgICAgIG51bGwgIT09IGlkICYmXG4gICAgICAgICgocGF0aCA9IGNvcHlXaXRoRGVsZXRlSW1wbChpZC5tZW1vaXplZFN0YXRlLCBwYXRoLCAwKSksXG4gICAgICAgIChpZC5tZW1vaXplZFN0YXRlID0gcGF0aCksXG4gICAgICAgIChpZC5iYXNlU3RhdGUgPSBwYXRoKSxcbiAgICAgICAgKGZpYmVyLm1lbW9pemVkUHJvcHMgPSBhc3NpZ24oe30sIGZpYmVyLm1lbW9pemVkUHJvcHMpKSxcbiAgICAgICAgKHBhdGggPSBlbnF1ZXVlQ29uY3VycmVudFJlbmRlckZvckxhbmUoZmliZXIsIDIpKSxcbiAgICAgICAgbnVsbCAhPT0gcGF0aCAmJiBzY2hlZHVsZVVwZGF0ZU9uRmliZXIocGF0aCwgZmliZXIsIDIpKTtcbiAgICB9O1xuICAgIG92ZXJyaWRlSG9va1N0YXRlUmVuYW1lUGF0aCA9IGZ1bmN0aW9uIChmaWJlciwgaWQsIG9sZFBhdGgsIG5ld1BhdGgpIHtcbiAgICAgIGlkID0gZmluZEhvb2soZmliZXIsIGlkKTtcbiAgICAgIG51bGwgIT09IGlkICYmXG4gICAgICAgICgob2xkUGF0aCA9IGNvcHlXaXRoUmVuYW1lKGlkLm1lbW9pemVkU3RhdGUsIG9sZFBhdGgsIG5ld1BhdGgpKSxcbiAgICAgICAgKGlkLm1lbW9pemVkU3RhdGUgPSBvbGRQYXRoKSxcbiAgICAgICAgKGlkLmJhc2VTdGF0ZSA9IG9sZFBhdGgpLFxuICAgICAgICAoZmliZXIubWVtb2l6ZWRQcm9wcyA9IGFzc2lnbih7fSwgZmliZXIubWVtb2l6ZWRQcm9wcykpLFxuICAgICAgICAob2xkUGF0aCA9IGVucXVldWVDb25jdXJyZW50UmVuZGVyRm9yTGFuZShmaWJlciwgMikpLFxuICAgICAgICBudWxsICE9PSBvbGRQYXRoICYmIHNjaGVkdWxlVXBkYXRlT25GaWJlcihvbGRQYXRoLCBmaWJlciwgMikpO1xuICAgIH07XG4gICAgb3ZlcnJpZGVQcm9wcyA9IGZ1bmN0aW9uIChmaWJlciwgcGF0aCwgdmFsdWUpIHtcbiAgICAgIGZpYmVyLnBlbmRpbmdQcm9wcyA9IGNvcHlXaXRoU2V0SW1wbChmaWJlci5tZW1vaXplZFByb3BzLCBwYXRoLCAwLCB2YWx1ZSk7XG4gICAgICBmaWJlci5hbHRlcm5hdGUgJiYgKGZpYmVyLmFsdGVybmF0ZS5wZW5kaW5nUHJvcHMgPSBmaWJlci5wZW5kaW5nUHJvcHMpO1xuICAgICAgcGF0aCA9IGVucXVldWVDb25jdXJyZW50UmVuZGVyRm9yTGFuZShmaWJlciwgMik7XG4gICAgICBudWxsICE9PSBwYXRoICYmIHNjaGVkdWxlVXBkYXRlT25GaWJlcihwYXRoLCBmaWJlciwgMik7XG4gICAgfTtcbiAgICBvdmVycmlkZVByb3BzRGVsZXRlUGF0aCA9IGZ1bmN0aW9uIChmaWJlciwgcGF0aCkge1xuICAgICAgZmliZXIucGVuZGluZ1Byb3BzID0gY29weVdpdGhEZWxldGVJbXBsKGZpYmVyLm1lbW9pemVkUHJvcHMsIHBhdGgsIDApO1xuICAgICAgZmliZXIuYWx0ZXJuYXRlICYmIChmaWJlci5hbHRlcm5hdGUucGVuZGluZ1Byb3BzID0gZmliZXIucGVuZGluZ1Byb3BzKTtcbiAgICAgIHBhdGggPSBlbnF1ZXVlQ29uY3VycmVudFJlbmRlckZvckxhbmUoZmliZXIsIDIpO1xuICAgICAgbnVsbCAhPT0gcGF0aCAmJiBzY2hlZHVsZVVwZGF0ZU9uRmliZXIocGF0aCwgZmliZXIsIDIpO1xuICAgIH07XG4gICAgb3ZlcnJpZGVQcm9wc1JlbmFtZVBhdGggPSBmdW5jdGlvbiAoZmliZXIsIG9sZFBhdGgsIG5ld1BhdGgpIHtcbiAgICAgIGZpYmVyLnBlbmRpbmdQcm9wcyA9IGNvcHlXaXRoUmVuYW1lKFxuICAgICAgICBmaWJlci5tZW1vaXplZFByb3BzLFxuICAgICAgICBvbGRQYXRoLFxuICAgICAgICBuZXdQYXRoXG4gICAgICApO1xuICAgICAgZmliZXIuYWx0ZXJuYXRlICYmIChmaWJlci5hbHRlcm5hdGUucGVuZGluZ1Byb3BzID0gZmliZXIucGVuZGluZ1Byb3BzKTtcbiAgICAgIG9sZFBhdGggPSBlbnF1ZXVlQ29uY3VycmVudFJlbmRlckZvckxhbmUoZmliZXIsIDIpO1xuICAgICAgbnVsbCAhPT0gb2xkUGF0aCAmJiBzY2hlZHVsZVVwZGF0ZU9uRmliZXIob2xkUGF0aCwgZmliZXIsIDIpO1xuICAgIH07XG4gICAgc2NoZWR1bGVVcGRhdGUgPSBmdW5jdGlvbiAoZmliZXIpIHtcbiAgICAgIHZhciByb290ID0gZW5xdWV1ZUNvbmN1cnJlbnRSZW5kZXJGb3JMYW5lKGZpYmVyLCAyKTtcbiAgICAgIG51bGwgIT09IHJvb3QgJiYgc2NoZWR1bGVVcGRhdGVPbkZpYmVyKHJvb3QsIGZpYmVyLCAyKTtcbiAgICB9O1xuICAgIHNldEVycm9ySGFuZGxlciA9IGZ1bmN0aW9uIChuZXdTaG91bGRFcnJvckltcGwpIHtcbiAgICAgIHNob3VsZEVycm9ySW1wbCA9IG5ld1Nob3VsZEVycm9ySW1wbDtcbiAgICB9O1xuICAgIHNldFN1c3BlbnNlSGFuZGxlciA9IGZ1bmN0aW9uIChuZXdTaG91bGRTdXNwZW5kSW1wbCkge1xuICAgICAgc2hvdWxkU3VzcGVuZEltcGwgPSBuZXdTaG91bGRTdXNwZW5kSW1wbDtcbiAgICB9O1xuICAgIGV4cG9ydHMuYXR0ZW1wdENvbnRpbnVvdXNIeWRyYXRpb24gPSBmdW5jdGlvbiAoZmliZXIpIHtcbiAgICAgIGlmICgxMyA9PT0gZmliZXIudGFnKSB7XG4gICAgICAgIHZhciByb290ID0gZW5xdWV1ZUNvbmN1cnJlbnRSZW5kZXJGb3JMYW5lKGZpYmVyLCA2NzEwODg2NCk7XG4gICAgICAgIG51bGwgIT09IHJvb3QgJiYgc2NoZWR1bGVVcGRhdGVPbkZpYmVyKHJvb3QsIGZpYmVyLCA2NzEwODg2NCk7XG4gICAgICAgIG1hcmtSZXRyeUxhbmVJZk5vdEh5ZHJhdGVkKGZpYmVyLCA2NzEwODg2NCk7XG4gICAgICB9XG4gICAgfTtcbiAgICBleHBvcnRzLmF0dGVtcHRIeWRyYXRpb25BdEN1cnJlbnRQcmlvcml0eSA9IGZ1bmN0aW9uIChmaWJlcikge1xuICAgICAgaWYgKDEzID09PSBmaWJlci50YWcpIHtcbiAgICAgICAgdmFyIGxhbmUgPSByZXF1ZXN0VXBkYXRlTGFuZShmaWJlciksXG4gICAgICAgICAgcm9vdCA9IGVucXVldWVDb25jdXJyZW50UmVuZGVyRm9yTGFuZShmaWJlciwgbGFuZSk7XG4gICAgICAgIG51bGwgIT09IHJvb3QgJiYgc2NoZWR1bGVVcGRhdGVPbkZpYmVyKHJvb3QsIGZpYmVyLCBsYW5lKTtcbiAgICAgICAgbWFya1JldHJ5TGFuZUlmTm90SHlkcmF0ZWQoZmliZXIsIGxhbmUpO1xuICAgICAgfVxuICAgIH07XG4gICAgZXhwb3J0cy5hdHRlbXB0U3luY2hyb25vdXNIeWRyYXRpb24gPSBmdW5jdGlvbiAoZmliZXIpIHtcbiAgICAgIHN3aXRjaCAoZmliZXIudGFnKSB7XG4gICAgICAgIGNhc2UgMzpcbiAgICAgICAgICBmaWJlciA9IGZpYmVyLnN0YXRlTm9kZTtcbiAgICAgICAgICBpZiAoZmliZXIuY3VycmVudC5tZW1vaXplZFN0YXRlLmlzRGVoeWRyYXRlZCkge1xuICAgICAgICAgICAgdmFyIGxhbmVzID0gZ2V0SGlnaGVzdFByaW9yaXR5TGFuZXMoZmliZXIucGVuZGluZ0xhbmVzKTtcbiAgICAgICAgICAgIGlmICgwICE9PSBsYW5lcykge1xuICAgICAgICAgICAgICBmaWJlci5wZW5kaW5nTGFuZXMgfD0gMjtcbiAgICAgICAgICAgICAgZm9yIChmaWJlci5lbnRhbmdsZWRMYW5lcyB8PSAyOyBsYW5lczsgKSB7XG4gICAgICAgICAgICAgICAgdmFyIGxhbmUgPSAxIDw8ICgzMSAtIGNsejMyKGxhbmVzKSk7XG4gICAgICAgICAgICAgICAgZmliZXIuZW50YW5nbGVtZW50c1sxXSB8PSBsYW5lO1xuICAgICAgICAgICAgICAgIGxhbmVzICY9IH5sYW5lO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGVuc3VyZVJvb3RJc1NjaGVkdWxlZChmaWJlcik7XG4gICAgICAgICAgICAgIChleGVjdXRpb25Db250ZXh0ICYgKFJlbmRlckNvbnRleHQgfCBDb21taXRDb250ZXh0KSkgPT09XG4gICAgICAgICAgICAgICAgTm9Db250ZXh0ICYmXG4gICAgICAgICAgICAgICAgKCh3b3JrSW5Qcm9ncmVzc1Jvb3RSZW5kZXJUYXJnZXRUaW1lID1cbiAgICAgICAgICAgICAgICAgIG5vdyQxKCkgKyBSRU5ERVJfVElNRU9VVF9NUyksXG4gICAgICAgICAgICAgICAgZmx1c2hTeW5jV29ya0Fjcm9zc1Jvb3RzX2ltcGwoMCwgITEpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMTM6XG4gICAgICAgICAgKGxhbmVzID0gZW5xdWV1ZUNvbmN1cnJlbnRSZW5kZXJGb3JMYW5lKGZpYmVyLCAyKSksXG4gICAgICAgICAgICBudWxsICE9PSBsYW5lcyAmJiBzY2hlZHVsZVVwZGF0ZU9uRmliZXIobGFuZXMsIGZpYmVyLCAyKSxcbiAgICAgICAgICAgIGZsdXNoU3luY1dvcmsoKSxcbiAgICAgICAgICAgIG1hcmtSZXRyeUxhbmVJZk5vdEh5ZHJhdGVkKGZpYmVyLCAyKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGV4cG9ydHMuYmF0Y2hlZFVwZGF0ZXMgPSBmdW5jdGlvbiAoZm4sIGEpIHtcbiAgICAgIHJldHVybiBmbihhKTtcbiAgICB9O1xuICAgIGV4cG9ydHMuY3JlYXRlQ29tcG9uZW50U2VsZWN0b3IgPSBmdW5jdGlvbiAoY29tcG9uZW50KSB7XG4gICAgICByZXR1cm4geyAkJHR5cGVvZjogQ09NUE9ORU5UX1RZUEUsIHZhbHVlOiBjb21wb25lbnQgfTtcbiAgICB9O1xuICAgIGV4cG9ydHMuY3JlYXRlQ29udGFpbmVyID0gZnVuY3Rpb24gKFxuICAgICAgY29udGFpbmVySW5mbyxcbiAgICAgIHRhZyxcbiAgICAgIGh5ZHJhdGlvbkNhbGxiYWNrcyxcbiAgICAgIGlzU3RyaWN0TW9kZSxcbiAgICAgIGNvbmN1cnJlbnRVcGRhdGVzQnlEZWZhdWx0T3ZlcnJpZGUsXG4gICAgICBpZGVudGlmaWVyUHJlZml4LFxuICAgICAgb25VbmNhdWdodEVycm9yLFxuICAgICAgb25DYXVnaHRFcnJvcixcbiAgICAgIG9uUmVjb3ZlcmFibGVFcnJvcixcbiAgICAgIHRyYW5zaXRpb25DYWxsYmFja3NcbiAgICApIHtcbiAgICAgIHJldHVybiBjcmVhdGVGaWJlclJvb3QoXG4gICAgICAgIGNvbnRhaW5lckluZm8sXG4gICAgICAgIHRhZyxcbiAgICAgICAgITEsXG4gICAgICAgIG51bGwsXG4gICAgICAgIGh5ZHJhdGlvbkNhbGxiYWNrcyxcbiAgICAgICAgaXNTdHJpY3RNb2RlLFxuICAgICAgICBpZGVudGlmaWVyUHJlZml4LFxuICAgICAgICBvblVuY2F1Z2h0RXJyb3IsXG4gICAgICAgIG9uQ2F1Z2h0RXJyb3IsXG4gICAgICAgIG9uUmVjb3ZlcmFibGVFcnJvcixcbiAgICAgICAgdHJhbnNpdGlvbkNhbGxiYWNrcyxcbiAgICAgICAgbnVsbFxuICAgICAgKTtcbiAgICB9O1xuICAgIGV4cG9ydHMuY3JlYXRlSGFzUHNldWRvQ2xhc3NTZWxlY3RvciA9IGZ1bmN0aW9uIChzZWxlY3RvcnMpIHtcbiAgICAgIHJldHVybiB7ICQkdHlwZW9mOiBIQVNfUFNFVURPX0NMQVNTX1RZUEUsIHZhbHVlOiBzZWxlY3RvcnMgfTtcbiAgICB9O1xuICAgIGV4cG9ydHMuY3JlYXRlSHlkcmF0aW9uQ29udGFpbmVyID0gZnVuY3Rpb24gKFxuICAgICAgaW5pdGlhbENoaWxkcmVuLFxuICAgICAgY2FsbGJhY2ssXG4gICAgICBjb250YWluZXJJbmZvLFxuICAgICAgdGFnLFxuICAgICAgaHlkcmF0aW9uQ2FsbGJhY2tzLFxuICAgICAgaXNTdHJpY3RNb2RlLFxuICAgICAgY29uY3VycmVudFVwZGF0ZXNCeURlZmF1bHRPdmVycmlkZSxcbiAgICAgIGlkZW50aWZpZXJQcmVmaXgsXG4gICAgICBvblVuY2F1Z2h0RXJyb3IsXG4gICAgICBvbkNhdWdodEVycm9yLFxuICAgICAgb25SZWNvdmVyYWJsZUVycm9yLFxuICAgICAgdHJhbnNpdGlvbkNhbGxiYWNrcyxcbiAgICAgIGZvcm1TdGF0ZVxuICAgICkge1xuICAgICAgaW5pdGlhbENoaWxkcmVuID0gY3JlYXRlRmliZXJSb290KFxuICAgICAgICBjb250YWluZXJJbmZvLFxuICAgICAgICB0YWcsXG4gICAgICAgICEwLFxuICAgICAgICBpbml0aWFsQ2hpbGRyZW4sXG4gICAgICAgIGh5ZHJhdGlvbkNhbGxiYWNrcyxcbiAgICAgICAgaXNTdHJpY3RNb2RlLFxuICAgICAgICBpZGVudGlmaWVyUHJlZml4LFxuICAgICAgICBvblVuY2F1Z2h0RXJyb3IsXG4gICAgICAgIG9uQ2F1Z2h0RXJyb3IsXG4gICAgICAgIG9uUmVjb3ZlcmFibGVFcnJvcixcbiAgICAgICAgdHJhbnNpdGlvbkNhbGxiYWNrcyxcbiAgICAgICAgZm9ybVN0YXRlXG4gICAgICApO1xuICAgICAgaW5pdGlhbENoaWxkcmVuLmNvbnRleHQgPSBnZXRDb250ZXh0Rm9yU3VidHJlZShudWxsKTtcbiAgICAgIGNvbnRhaW5lckluZm8gPSBpbml0aWFsQ2hpbGRyZW4uY3VycmVudDtcbiAgICAgIHRhZyA9IHJlcXVlc3RVcGRhdGVMYW5lKGNvbnRhaW5lckluZm8pO1xuICAgICAgaHlkcmF0aW9uQ2FsbGJhY2tzID0gY3JlYXRlVXBkYXRlKHRhZyk7XG4gICAgICBoeWRyYXRpb25DYWxsYmFja3MuY2FsbGJhY2sgPVxuICAgICAgICB2b2lkIDAgIT09IGNhbGxiYWNrICYmIG51bGwgIT09IGNhbGxiYWNrID8gY2FsbGJhY2sgOiBudWxsO1xuICAgICAgZW5xdWV1ZVVwZGF0ZShjb250YWluZXJJbmZvLCBoeWRyYXRpb25DYWxsYmFja3MsIHRhZyk7XG4gICAgICBpbml0aWFsQ2hpbGRyZW4uY3VycmVudC5sYW5lcyA9IHRhZztcbiAgICAgIG1hcmtSb290VXBkYXRlZCQxKGluaXRpYWxDaGlsZHJlbiwgdGFnKTtcbiAgICAgIGVuc3VyZVJvb3RJc1NjaGVkdWxlZChpbml0aWFsQ2hpbGRyZW4pO1xuICAgICAgcmV0dXJuIGluaXRpYWxDaGlsZHJlbjtcbiAgICB9O1xuICAgIGV4cG9ydHMuY3JlYXRlUG9ydGFsID0gZnVuY3Rpb24gKGNoaWxkcmVuLCBjb250YWluZXJJbmZvLCBpbXBsZW1lbnRhdGlvbikge1xuICAgICAgdmFyIGtleSA9XG4gICAgICAgIDMgPCBhcmd1bWVudHMubGVuZ3RoICYmIHZvaWQgMCAhPT0gYXJndW1lbnRzWzNdID8gYXJndW1lbnRzWzNdIDogbnVsbDtcbiAgICAgIHRyeSB7XG4gICAgICAgIHRlc3RTdHJpbmdDb2VyY2lvbihrZXkpO1xuICAgICAgICB2YXIgSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0ID0gITE7XG4gICAgICB9IGNhdGNoIChlJDYpIHtcbiAgICAgICAgSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0ID0gITA7XG4gICAgICB9XG4gICAgICBKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQgJiZcbiAgICAgICAgKGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgXCJUaGUgcHJvdmlkZWQga2V5IGlzIGFuIHVuc3VwcG9ydGVkIHR5cGUgJXMuIFRoaXMgdmFsdWUgbXVzdCBiZSBjb2VyY2VkIHRvIGEgc3RyaW5nIGJlZm9yZSB1c2luZyBpdCBoZXJlLlwiLFxuICAgICAgICAgIChcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBTeW1ib2wgJiZcbiAgICAgICAgICAgIFN5bWJvbC50b1N0cmluZ1RhZyAmJlxuICAgICAgICAgICAga2V5W1N5bWJvbC50b1N0cmluZ1RhZ10pIHx8XG4gICAgICAgICAgICBrZXkuY29uc3RydWN0b3IubmFtZSB8fFxuICAgICAgICAgICAgXCJPYmplY3RcIlxuICAgICAgICApLFxuICAgICAgICB0ZXN0U3RyaW5nQ29lcmNpb24oa2V5KSk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICAkJHR5cGVvZjogUkVBQ1RfUE9SVEFMX1RZUEUsXG4gICAgICAgIGtleTogbnVsbCA9PSBrZXkgPyBudWxsIDogXCJcIiArIGtleSxcbiAgICAgICAgY2hpbGRyZW46IGNoaWxkcmVuLFxuICAgICAgICBjb250YWluZXJJbmZvOiBjb250YWluZXJJbmZvLFxuICAgICAgICBpbXBsZW1lbnRhdGlvbjogaW1wbGVtZW50YXRpb25cbiAgICAgIH07XG4gICAgfTtcbiAgICBleHBvcnRzLmNyZWF0ZVJvbGVTZWxlY3RvciA9IGZ1bmN0aW9uIChyb2xlKSB7XG4gICAgICByZXR1cm4geyAkJHR5cGVvZjogUk9MRV9UWVBFLCB2YWx1ZTogcm9sZSB9O1xuICAgIH07XG4gICAgZXhwb3J0cy5jcmVhdGVUZXN0TmFtZVNlbGVjdG9yID0gZnVuY3Rpb24gKGlkKSB7XG4gICAgICByZXR1cm4geyAkJHR5cGVvZjogVEVTVF9OQU1FX1RZUEUsIHZhbHVlOiBpZCB9O1xuICAgIH07XG4gICAgZXhwb3J0cy5jcmVhdGVUZXh0U2VsZWN0b3IgPSBmdW5jdGlvbiAodGV4dCkge1xuICAgICAgcmV0dXJuIHsgJCR0eXBlb2Y6IFRFWFRfVFlQRSwgdmFsdWU6IHRleHQgfTtcbiAgICB9O1xuICAgIGV4cG9ydHMuZGVmYXVsdE9uQ2F1Z2h0RXJyb3IgPSBmdW5jdGlvbiAoZXJyb3IsIGVycm9ySW5mbykge1xuICAgICAgdmFyIGNvbXBvbmVudE5hbWVNZXNzYWdlID0gY29tcG9uZW50TmFtZVxuICAgICAgICAgID8gXCJUaGUgYWJvdmUgZXJyb3Igb2NjdXJyZWQgaW4gdGhlIDxcIiArIGNvbXBvbmVudE5hbWUgKyBcIj4gY29tcG9uZW50LlwiXG4gICAgICAgICAgOiBcIlRoZSBhYm92ZSBlcnJvciBvY2N1cnJlZCBpbiBvbmUgb2YgeW91ciBSZWFjdCBjb21wb25lbnRzLlwiLFxuICAgICAgICByZWNyZWF0ZU1lc3NhZ2UgPVxuICAgICAgICAgIFwiUmVhY3Qgd2lsbCB0cnkgdG8gcmVjcmVhdGUgdGhpcyBjb21wb25lbnQgdHJlZSBmcm9tIHNjcmF0Y2ggdXNpbmcgdGhlIGVycm9yIGJvdW5kYXJ5IHlvdSBwcm92aWRlZCwgXCIgK1xuICAgICAgICAgICgoZXJyb3JCb3VuZGFyeU5hbWUgfHwgXCJBbm9ueW1vdXNcIikgKyBcIi5cIiksXG4gICAgICAgIHByZXZHZXRDdXJyZW50U3RhY2sgPSBSZWFjdFNoYXJlZEludGVybmFscy5nZXRDdXJyZW50U3RhY2ssXG4gICAgICAgIGNvbXBvbmVudFN0YWNrID1cbiAgICAgICAgICBudWxsICE9IGVycm9ySW5mby5jb21wb25lbnRTdGFjayA/IGVycm9ySW5mby5jb21wb25lbnRTdGFjayA6IFwiXCI7XG4gICAgICBSZWFjdFNoYXJlZEludGVybmFscy5nZXRDdXJyZW50U3RhY2sgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBjb21wb25lbnRTdGFjaztcbiAgICAgIH07XG4gICAgICB0cnkge1xuICAgICAgICBcIm9iamVjdFwiID09PSB0eXBlb2YgZXJyb3IgJiZcbiAgICAgICAgbnVsbCAhPT0gZXJyb3IgJiZcbiAgICAgICAgXCJzdHJpbmdcIiA9PT0gdHlwZW9mIGVycm9yLmVudmlyb25tZW50TmFtZVxuICAgICAgICAgID8gYmluZFRvQ29uc29sZShcbiAgICAgICAgICAgICAgXCJlcnJvclwiLFxuICAgICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgXCIlb1xcblxcbiVzXFxuXFxuJXNcXG5cIixcbiAgICAgICAgICAgICAgICBlcnJvcixcbiAgICAgICAgICAgICAgICBjb21wb25lbnROYW1lTWVzc2FnZSxcbiAgICAgICAgICAgICAgICByZWNyZWF0ZU1lc3NhZ2VcbiAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgZXJyb3IuZW52aXJvbm1lbnROYW1lXG4gICAgICAgICAgICApKClcbiAgICAgICAgICA6IGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgIFwiJW9cXG5cXG4lc1xcblxcbiVzXFxuXCIsXG4gICAgICAgICAgICAgIGVycm9yLFxuICAgICAgICAgICAgICBjb21wb25lbnROYW1lTWVzc2FnZSxcbiAgICAgICAgICAgICAgcmVjcmVhdGVNZXNzYWdlXG4gICAgICAgICAgICApO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgUmVhY3RTaGFyZWRJbnRlcm5hbHMuZ2V0Q3VycmVudFN0YWNrID0gcHJldkdldEN1cnJlbnRTdGFjaztcbiAgICAgIH1cbiAgICB9O1xuICAgIGV4cG9ydHMuZGVmYXVsdE9uUmVjb3ZlcmFibGVFcnJvciA9IGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgcmVwb3J0R2xvYmFsRXJyb3IoZXJyb3IpO1xuICAgIH07XG4gICAgZXhwb3J0cy5kZWZhdWx0T25VbmNhdWdodEVycm9yID0gZnVuY3Rpb24gKGVycm9yLCBlcnJvckluZm8pIHtcbiAgICAgIHJlcG9ydEdsb2JhbEVycm9yKGVycm9yKTtcbiAgICAgIGVycm9yID0gY29tcG9uZW50TmFtZVxuICAgICAgICA/IFwiQW4gZXJyb3Igb2NjdXJyZWQgaW4gdGhlIDxcIiArIGNvbXBvbmVudE5hbWUgKyBcIj4gY29tcG9uZW50LlwiXG4gICAgICAgIDogXCJBbiBlcnJvciBvY2N1cnJlZCBpbiBvbmUgb2YgeW91ciBSZWFjdCBjb21wb25lbnRzLlwiO1xuICAgICAgdmFyIHByZXZHZXRDdXJyZW50U3RhY2sgPSBSZWFjdFNoYXJlZEludGVybmFscy5nZXRDdXJyZW50U3RhY2ssXG4gICAgICAgIGNvbXBvbmVudFN0YWNrID1cbiAgICAgICAgICBudWxsICE9IGVycm9ySW5mby5jb21wb25lbnRTdGFjayA/IGVycm9ySW5mby5jb21wb25lbnRTdGFjayA6IFwiXCI7XG4gICAgICBSZWFjdFNoYXJlZEludGVybmFscy5nZXRDdXJyZW50U3RhY2sgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBjb21wb25lbnRTdGFjaztcbiAgICAgIH07XG4gICAgICB0cnkge1xuICAgICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgICAgXCIlc1xcblxcbiVzXFxuXCIsXG4gICAgICAgICAgZXJyb3IsXG4gICAgICAgICAgXCJDb25zaWRlciBhZGRpbmcgYW4gZXJyb3IgYm91bmRhcnkgdG8geW91ciB0cmVlIHRvIGN1c3RvbWl6ZSBlcnJvciBoYW5kbGluZyBiZWhhdmlvci5cXG5WaXNpdCBodHRwczovL3JlYWN0LmRldi9saW5rL2Vycm9yLWJvdW5kYXJpZXMgdG8gbGVhcm4gbW9yZSBhYm91dCBlcnJvciBib3VuZGFyaWVzLlwiXG4gICAgICAgICk7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBSZWFjdFNoYXJlZEludGVybmFscy5nZXRDdXJyZW50U3RhY2sgPSBwcmV2R2V0Q3VycmVudFN0YWNrO1xuICAgICAgfVxuICAgIH07XG4gICAgZXhwb3J0cy5kZWZlcnJlZFVwZGF0ZXMgPSBmdW5jdGlvbiAoZm4pIHtcbiAgICAgIHZhciBwcmV2VHJhbnNpdGlvbiA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlQsXG4gICAgICAgIHByZXZpb3VzUHJpb3JpdHkgPSBnZXRDdXJyZW50VXBkYXRlUHJpb3JpdHkoKTtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgc2V0Q3VycmVudFVwZGF0ZVByaW9yaXR5KDMyKSwgKFJlYWN0U2hhcmVkSW50ZXJuYWxzLlQgPSBudWxsKSwgZm4oKVxuICAgICAgICApO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgc2V0Q3VycmVudFVwZGF0ZVByaW9yaXR5KHByZXZpb3VzUHJpb3JpdHkpLFxuICAgICAgICAgIChSZWFjdFNoYXJlZEludGVybmFscy5UID0gcHJldlRyYW5zaXRpb24pO1xuICAgICAgfVxuICAgIH07XG4gICAgZXhwb3J0cy5kaXNjcmV0ZVVwZGF0ZXMgPSBmdW5jdGlvbiAoZm4sIGEsIGIsIGMsIGQpIHtcbiAgICAgIHZhciBwcmV2VHJhbnNpdGlvbiA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlQsXG4gICAgICAgIHByZXZpb3VzUHJpb3JpdHkgPSBnZXRDdXJyZW50VXBkYXRlUHJpb3JpdHkoKTtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgc2V0Q3VycmVudFVwZGF0ZVByaW9yaXR5KDIpLFxuICAgICAgICAgIChSZWFjdFNoYXJlZEludGVybmFscy5UID0gbnVsbCksXG4gICAgICAgICAgZm4oYSwgYiwgYywgZClcbiAgICAgICAgKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIHNldEN1cnJlbnRVcGRhdGVQcmlvcml0eShwcmV2aW91c1ByaW9yaXR5KSxcbiAgICAgICAgICAoUmVhY3RTaGFyZWRJbnRlcm5hbHMuVCA9IHByZXZUcmFuc2l0aW9uKSxcbiAgICAgICAgICBleGVjdXRpb25Db250ZXh0ID09PSBOb0NvbnRleHQgJiZcbiAgICAgICAgICAgICh3b3JrSW5Qcm9ncmVzc1Jvb3RSZW5kZXJUYXJnZXRUaW1lID0gbm93JDEoKSArIFJFTkRFUl9USU1FT1VUX01TKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGV4cG9ydHMuZmluZEFsbE5vZGVzID0gZmluZEFsbE5vZGVzO1xuICAgIGV4cG9ydHMuZmluZEJvdW5kaW5nUmVjdHMgPSBmdW5jdGlvbiAoaG9zdFJvb3QsIHNlbGVjdG9ycykge1xuICAgICAgaWYgKCFzdXBwb3J0c1Rlc3RTZWxlY3RvcnMpXG4gICAgICAgIHRocm93IEVycm9yKFwiVGVzdCBzZWxlY3RvciBBUEkgaXMgbm90IHN1cHBvcnRlZCBieSB0aGlzIHJlbmRlcmVyLlwiKTtcbiAgICAgIHNlbGVjdG9ycyA9IGZpbmRBbGxOb2Rlcyhob3N0Um9vdCwgc2VsZWN0b3JzKTtcbiAgICAgIGhvc3RSb290ID0gW107XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNlbGVjdG9ycy5sZW5ndGg7IGkrKylcbiAgICAgICAgaG9zdFJvb3QucHVzaChnZXRCb3VuZGluZ1JlY3Qoc2VsZWN0b3JzW2ldKSk7XG4gICAgICBmb3IgKHNlbGVjdG9ycyA9IGhvc3RSb290Lmxlbmd0aCAtIDE7IDAgPCBzZWxlY3RvcnM7IHNlbGVjdG9ycy0tKSB7XG4gICAgICAgIGkgPSBob3N0Um9vdFtzZWxlY3RvcnNdO1xuICAgICAgICBmb3IgKFxuICAgICAgICAgIHZhciB0YXJnZXRMZWZ0ID0gaS54LFxuICAgICAgICAgICAgdGFyZ2V0UmlnaHQgPSB0YXJnZXRMZWZ0ICsgaS53aWR0aCxcbiAgICAgICAgICAgIHRhcmdldFRvcCA9IGkueSxcbiAgICAgICAgICAgIHRhcmdldEJvdHRvbSA9IHRhcmdldFRvcCArIGkuaGVpZ2h0LFxuICAgICAgICAgICAgaiA9IHNlbGVjdG9ycyAtIDE7XG4gICAgICAgICAgMCA8PSBqO1xuICAgICAgICAgIGotLVxuICAgICAgICApXG4gICAgICAgICAgaWYgKHNlbGVjdG9ycyAhPT0gaikge1xuICAgICAgICAgICAgdmFyIG90aGVyUmVjdCA9IGhvc3RSb290W2pdLFxuICAgICAgICAgICAgICBvdGhlckxlZnQgPSBvdGhlclJlY3QueCxcbiAgICAgICAgICAgICAgb3RoZXJSaWdodCA9IG90aGVyTGVmdCArIG90aGVyUmVjdC53aWR0aCxcbiAgICAgICAgICAgICAgb3RoZXJUb3AgPSBvdGhlclJlY3QueSxcbiAgICAgICAgICAgICAgb3RoZXJCb3R0b20gPSBvdGhlclRvcCArIG90aGVyUmVjdC5oZWlnaHQ7XG4gICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgIHRhcmdldExlZnQgPj0gb3RoZXJMZWZ0ICYmXG4gICAgICAgICAgICAgIHRhcmdldFRvcCA+PSBvdGhlclRvcCAmJlxuICAgICAgICAgICAgICB0YXJnZXRSaWdodCA8PSBvdGhlclJpZ2h0ICYmXG4gICAgICAgICAgICAgIHRhcmdldEJvdHRvbSA8PSBvdGhlckJvdHRvbVxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgIGhvc3RSb290LnNwbGljZShzZWxlY3RvcnMsIDEpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoXG4gICAgICAgICAgICAgICEoXG4gICAgICAgICAgICAgICAgdGFyZ2V0TGVmdCAhPT0gb3RoZXJMZWZ0IHx8XG4gICAgICAgICAgICAgICAgaS53aWR0aCAhPT0gb3RoZXJSZWN0LndpZHRoIHx8XG4gICAgICAgICAgICAgICAgb3RoZXJCb3R0b20gPCB0YXJnZXRUb3AgfHxcbiAgICAgICAgICAgICAgICBvdGhlclRvcCA+IHRhcmdldEJvdHRvbVxuICAgICAgICAgICAgICApXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgb3RoZXJUb3AgPiB0YXJnZXRUb3AgJiZcbiAgICAgICAgICAgICAgICAoKG90aGVyUmVjdC5oZWlnaHQgKz0gb3RoZXJUb3AgLSB0YXJnZXRUb3ApLFxuICAgICAgICAgICAgICAgIChvdGhlclJlY3QueSA9IHRhcmdldFRvcCkpO1xuICAgICAgICAgICAgICBvdGhlckJvdHRvbSA8IHRhcmdldEJvdHRvbSAmJlxuICAgICAgICAgICAgICAgIChvdGhlclJlY3QuaGVpZ2h0ID0gdGFyZ2V0Qm90dG9tIC0gb3RoZXJUb3ApO1xuICAgICAgICAgICAgICBob3N0Um9vdC5zcGxpY2Uoc2VsZWN0b3JzLCAxKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKFxuICAgICAgICAgICAgICAhKFxuICAgICAgICAgICAgICAgIHRhcmdldFRvcCAhPT0gb3RoZXJUb3AgfHxcbiAgICAgICAgICAgICAgICBpLmhlaWdodCAhPT0gb3RoZXJSZWN0LmhlaWdodCB8fFxuICAgICAgICAgICAgICAgIG90aGVyUmlnaHQgPCB0YXJnZXRMZWZ0IHx8XG4gICAgICAgICAgICAgICAgb3RoZXJMZWZ0ID4gdGFyZ2V0UmlnaHRcbiAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgIG90aGVyTGVmdCA+IHRhcmdldExlZnQgJiZcbiAgICAgICAgICAgICAgICAoKG90aGVyUmVjdC53aWR0aCArPSBvdGhlckxlZnQgLSB0YXJnZXRMZWZ0KSxcbiAgICAgICAgICAgICAgICAob3RoZXJSZWN0LnggPSB0YXJnZXRMZWZ0KSk7XG4gICAgICAgICAgICAgIG90aGVyUmlnaHQgPCB0YXJnZXRSaWdodCAmJlxuICAgICAgICAgICAgICAgIChvdGhlclJlY3Qud2lkdGggPSB0YXJnZXRSaWdodCAtIG90aGVyTGVmdCk7XG4gICAgICAgICAgICAgIGhvc3RSb290LnNwbGljZShzZWxlY3RvcnMsIDEpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gaG9zdFJvb3Q7XG4gICAgfTtcbiAgICBleHBvcnRzLmZpbmRIb3N0SW5zdGFuY2UgPSBmdW5jdGlvbiAoY29tcG9uZW50KSB7XG4gICAgICB2YXIgZmliZXIgPSBjb21wb25lbnQuX3JlYWN0SW50ZXJuYWxzO1xuICAgICAgaWYgKHZvaWQgMCA9PT0gZmliZXIpIHtcbiAgICAgICAgaWYgKFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIGNvbXBvbmVudC5yZW5kZXIpXG4gICAgICAgICAgdGhyb3cgRXJyb3IoXCJVbmFibGUgdG8gZmluZCBub2RlIG9uIGFuIHVubW91bnRlZCBjb21wb25lbnQuXCIpO1xuICAgICAgICBjb21wb25lbnQgPSBPYmplY3Qua2V5cyhjb21wb25lbnQpLmpvaW4oXCIsXCIpO1xuICAgICAgICB0aHJvdyBFcnJvcihcbiAgICAgICAgICBcIkFyZ3VtZW50IGFwcGVhcnMgdG8gbm90IGJlIGEgUmVhY3RDb21wb25lbnQuIEtleXM6IFwiICsgY29tcG9uZW50XG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBjb21wb25lbnQgPSBmaW5kQ3VycmVudEhvc3RGaWJlcihmaWJlcik7XG4gICAgICByZXR1cm4gbnVsbCA9PT0gY29tcG9uZW50ID8gbnVsbCA6IGdldFB1YmxpY0luc3RhbmNlKGNvbXBvbmVudC5zdGF0ZU5vZGUpO1xuICAgIH07XG4gICAgZXhwb3J0cy5maW5kSG9zdEluc3RhbmNlV2l0aE5vUG9ydGFscyA9IGZ1bmN0aW9uIChmaWJlcikge1xuICAgICAgZmliZXIgPSBmaW5kQ3VycmVudEZpYmVyVXNpbmdTbG93UGF0aChmaWJlcik7XG4gICAgICBmaWJlciA9XG4gICAgICAgIG51bGwgIT09IGZpYmVyID8gZmluZEN1cnJlbnRIb3N0RmliZXJXaXRoTm9Qb3J0YWxzSW1wbChmaWJlcikgOiBudWxsO1xuICAgICAgcmV0dXJuIG51bGwgPT09IGZpYmVyID8gbnVsbCA6IGdldFB1YmxpY0luc3RhbmNlKGZpYmVyLnN0YXRlTm9kZSk7XG4gICAgfTtcbiAgICBleHBvcnRzLmZpbmRIb3N0SW5zdGFuY2VXaXRoV2FybmluZyA9IGZ1bmN0aW9uIChjb21wb25lbnQsIG1ldGhvZE5hbWUpIHtcbiAgICAgIHZhciBmaWJlciA9IGNvbXBvbmVudC5fcmVhY3RJbnRlcm5hbHM7XG4gICAgICBpZiAodm9pZCAwID09PSBmaWJlcikge1xuICAgICAgICBpZiAoXCJmdW5jdGlvblwiID09PSB0eXBlb2YgY29tcG9uZW50LnJlbmRlcilcbiAgICAgICAgICB0aHJvdyBFcnJvcihcIlVuYWJsZSB0byBmaW5kIG5vZGUgb24gYW4gdW5tb3VudGVkIGNvbXBvbmVudC5cIik7XG4gICAgICAgIGNvbXBvbmVudCA9IE9iamVjdC5rZXlzKGNvbXBvbmVudCkuam9pbihcIixcIik7XG4gICAgICAgIHRocm93IEVycm9yKFxuICAgICAgICAgIFwiQXJndW1lbnQgYXBwZWFycyB0byBub3QgYmUgYSBSZWFjdENvbXBvbmVudC4gS2V5czogXCIgKyBjb21wb25lbnRcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGNvbXBvbmVudCA9IGZpbmRDdXJyZW50SG9zdEZpYmVyKGZpYmVyKTtcbiAgICAgIGlmIChudWxsID09PSBjb21wb25lbnQpIHJldHVybiBudWxsO1xuICAgICAgaWYgKGNvbXBvbmVudC5tb2RlICYgOCkge1xuICAgICAgICB2YXIgY29tcG9uZW50TmFtZSA9IGdldENvbXBvbmVudE5hbWVGcm9tRmliZXIoZmliZXIpIHx8IFwiQ29tcG9uZW50XCI7XG4gICAgICAgIGRpZFdhcm5BYm91dEZpbmROb2RlSW5TdHJpY3RNb2RlW2NvbXBvbmVudE5hbWVdIHx8XG4gICAgICAgICAgKChkaWRXYXJuQWJvdXRGaW5kTm9kZUluU3RyaWN0TW9kZVtjb21wb25lbnROYW1lXSA9ICEwKSxcbiAgICAgICAgICBydW5XaXRoRmliZXJJbkRFVihjb21wb25lbnQsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGZpYmVyLm1vZGUgJiA4XG4gICAgICAgICAgICAgID8gY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgICAgIFwiJXMgaXMgZGVwcmVjYXRlZCBpbiBTdHJpY3RNb2RlLiAlcyB3YXMgcGFzc2VkIGFuIGluc3RhbmNlIG9mICVzIHdoaWNoIGlzIGluc2lkZSBTdHJpY3RNb2RlLiBJbnN0ZWFkLCBhZGQgYSByZWYgZGlyZWN0bHkgdG8gdGhlIGVsZW1lbnQgeW91IHdhbnQgdG8gcmVmZXJlbmNlLiBMZWFybiBtb3JlIGFib3V0IHVzaW5nIHJlZnMgc2FmZWx5IGhlcmU6IGh0dHBzOi8vcmVhY3QuZGV2L2xpbmsvc3RyaWN0LW1vZGUtZmluZC1ub2RlXCIsXG4gICAgICAgICAgICAgICAgICBtZXRob2ROYW1lLFxuICAgICAgICAgICAgICAgICAgbWV0aG9kTmFtZSxcbiAgICAgICAgICAgICAgICAgIGNvbXBvbmVudE5hbWVcbiAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgIDogY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgICAgIFwiJXMgaXMgZGVwcmVjYXRlZCBpbiBTdHJpY3RNb2RlLiAlcyB3YXMgcGFzc2VkIGFuIGluc3RhbmNlIG9mICVzIHdoaWNoIHJlbmRlcnMgU3RyaWN0TW9kZSBjaGlsZHJlbi4gSW5zdGVhZCwgYWRkIGEgcmVmIGRpcmVjdGx5IHRvIHRoZSBlbGVtZW50IHlvdSB3YW50IHRvIHJlZmVyZW5jZS4gTGVhcm4gbW9yZSBhYm91dCB1c2luZyByZWZzIHNhZmVseSBoZXJlOiBodHRwczovL3JlYWN0LmRldi9saW5rL3N0cmljdC1tb2RlLWZpbmQtbm9kZVwiLFxuICAgICAgICAgICAgICAgICAgbWV0aG9kTmFtZSxcbiAgICAgICAgICAgICAgICAgIG1ldGhvZE5hbWUsXG4gICAgICAgICAgICAgICAgICBjb21wb25lbnROYW1lXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICB9KSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZ2V0UHVibGljSW5zdGFuY2UoY29tcG9uZW50LnN0YXRlTm9kZSk7XG4gICAgfTtcbiAgICBleHBvcnRzLmZsdXNoUGFzc2l2ZUVmZmVjdHMgPSBmbHVzaFBhc3NpdmVFZmZlY3RzO1xuICAgIGV4cG9ydHMuZmx1c2hTeW5jRnJvbVJlY29uY2lsZXIgPSBmdW5jdGlvbiAoZm4pIHtcbiAgICAgIHZhciBwcmV2RXhlY3V0aW9uQ29udGV4dCA9IGV4ZWN1dGlvbkNvbnRleHQ7XG4gICAgICBleGVjdXRpb25Db250ZXh0IHw9IDE7XG4gICAgICB2YXIgcHJldlRyYW5zaXRpb24gPSBSZWFjdFNoYXJlZEludGVybmFscy5ULFxuICAgICAgICBwcmV2aW91c1ByaW9yaXR5ID0gZ2V0Q3VycmVudFVwZGF0ZVByaW9yaXR5KCk7XG4gICAgICB0cnkge1xuICAgICAgICBpZiAoKHNldEN1cnJlbnRVcGRhdGVQcmlvcml0eSgyKSwgKFJlYWN0U2hhcmVkSW50ZXJuYWxzLlQgPSBudWxsKSwgZm4pKVxuICAgICAgICAgIHJldHVybiBmbigpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgc2V0Q3VycmVudFVwZGF0ZVByaW9yaXR5KHByZXZpb3VzUHJpb3JpdHkpLFxuICAgICAgICAgIChSZWFjdFNoYXJlZEludGVybmFscy5UID0gcHJldlRyYW5zaXRpb24pLFxuICAgICAgICAgIChleGVjdXRpb25Db250ZXh0ID0gcHJldkV4ZWN1dGlvbkNvbnRleHQpLFxuICAgICAgICAgIChleGVjdXRpb25Db250ZXh0ICYgKFJlbmRlckNvbnRleHQgfCBDb21taXRDb250ZXh0KSkgPT09IE5vQ29udGV4dCAmJlxuICAgICAgICAgICAgZmx1c2hTeW5jV29ya0Fjcm9zc1Jvb3RzX2ltcGwoMCwgITEpO1xuICAgICAgfVxuICAgIH07XG4gICAgZXhwb3J0cy5mbHVzaFN5bmNXb3JrID0gZmx1c2hTeW5jV29yaztcbiAgICBleHBvcnRzLmZvY3VzV2l0aGluID0gZnVuY3Rpb24gKGhvc3RSb290LCBzZWxlY3RvcnMpIHtcbiAgICAgIGlmICghc3VwcG9ydHNUZXN0U2VsZWN0b3JzKVxuICAgICAgICB0aHJvdyBFcnJvcihcIlRlc3Qgc2VsZWN0b3IgQVBJIGlzIG5vdCBzdXBwb3J0ZWQgYnkgdGhpcyByZW5kZXJlci5cIik7XG4gICAgICBob3N0Um9vdCA9IGZpbmRGaWJlclJvb3RGb3JIb3N0Um9vdChob3N0Um9vdCk7XG4gICAgICBzZWxlY3RvcnMgPSBmaW5kUGF0aHMoaG9zdFJvb3QsIHNlbGVjdG9ycyk7XG4gICAgICBzZWxlY3RvcnMgPSBBcnJheS5mcm9tKHNlbGVjdG9ycyk7XG4gICAgICBmb3IgKGhvc3RSb290ID0gMDsgaG9zdFJvb3QgPCBzZWxlY3RvcnMubGVuZ3RoOyApIHtcbiAgICAgICAgdmFyIGZpYmVyID0gc2VsZWN0b3JzW2hvc3RSb290KytdLFxuICAgICAgICAgIHRhZyA9IGZpYmVyLnRhZztcbiAgICAgICAgaWYgKCFpc0hpZGRlblN1YnRyZWUoZmliZXIpKSB7XG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgKDUgPT09IHRhZyB8fCAyNiA9PT0gdGFnIHx8IDI3ID09PSB0YWcpICYmXG4gICAgICAgICAgICBzZXRGb2N1c0lmRm9jdXNhYmxlKGZpYmVyLnN0YXRlTm9kZSlcbiAgICAgICAgICApXG4gICAgICAgICAgICByZXR1cm4gITA7XG4gICAgICAgICAgZm9yIChmaWJlciA9IGZpYmVyLmNoaWxkOyBudWxsICE9PSBmaWJlcjsgKVxuICAgICAgICAgICAgc2VsZWN0b3JzLnB1c2goZmliZXIpLCAoZmliZXIgPSBmaWJlci5zaWJsaW5nKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuICExO1xuICAgIH07XG4gICAgZXhwb3J0cy5nZXRGaW5kQWxsTm9kZXNGYWlsdXJlRGVzY3JpcHRpb24gPSBmdW5jdGlvbiAoaG9zdFJvb3QsIHNlbGVjdG9ycykge1xuICAgICAgaWYgKCFzdXBwb3J0c1Rlc3RTZWxlY3RvcnMpXG4gICAgICAgIHRocm93IEVycm9yKFwiVGVzdCBzZWxlY3RvciBBUEkgaXMgbm90IHN1cHBvcnRlZCBieSB0aGlzIHJlbmRlcmVyLlwiKTtcbiAgICAgIHZhciBtYXhTZWxlY3RvckluZGV4ID0gMCxcbiAgICAgICAgbWF0Y2hlZE5hbWVzID0gW107XG4gICAgICBob3N0Um9vdCA9IFtmaW5kRmliZXJSb290Rm9ySG9zdFJvb3QoaG9zdFJvb3QpLCAwXTtcbiAgICAgIGZvciAodmFyIGluZGV4ID0gMDsgaW5kZXggPCBob3N0Um9vdC5sZW5ndGg7ICkge1xuICAgICAgICB2YXIgZmliZXIgPSBob3N0Um9vdFtpbmRleCsrXSxcbiAgICAgICAgICB0YWcgPSBmaWJlci50YWcsXG4gICAgICAgICAgc2VsZWN0b3JJbmRleCA9IGhvc3RSb290W2luZGV4KytdLFxuICAgICAgICAgIHNlbGVjdG9yID0gc2VsZWN0b3JzW3NlbGVjdG9ySW5kZXhdO1xuICAgICAgICBpZiAoKDUgIT09IHRhZyAmJiAyNiAhPT0gdGFnICYmIDI3ICE9PSB0YWcpIHx8ICFpc0hpZGRlblN1YnRyZWUoZmliZXIpKVxuICAgICAgICAgIGlmIChcbiAgICAgICAgICAgIChtYXRjaFNlbGVjdG9yKGZpYmVyLCBzZWxlY3RvcikgJiZcbiAgICAgICAgICAgICAgKG1hdGNoZWROYW1lcy5wdXNoKHNlbGVjdG9yVG9TdHJpbmcoc2VsZWN0b3IpKSxcbiAgICAgICAgICAgICAgc2VsZWN0b3JJbmRleCsrLFxuICAgICAgICAgICAgICBzZWxlY3RvckluZGV4ID4gbWF4U2VsZWN0b3JJbmRleCAmJlxuICAgICAgICAgICAgICAgIChtYXhTZWxlY3RvckluZGV4ID0gc2VsZWN0b3JJbmRleCkpLFxuICAgICAgICAgICAgc2VsZWN0b3JJbmRleCA8IHNlbGVjdG9ycy5sZW5ndGgpXG4gICAgICAgICAgKVxuICAgICAgICAgICAgZm9yIChmaWJlciA9IGZpYmVyLmNoaWxkOyBudWxsICE9PSBmaWJlcjsgKVxuICAgICAgICAgICAgICBob3N0Um9vdC5wdXNoKGZpYmVyLCBzZWxlY3RvckluZGV4KSwgKGZpYmVyID0gZmliZXIuc2libGluZyk7XG4gICAgICB9XG4gICAgICBpZiAobWF4U2VsZWN0b3JJbmRleCA8IHNlbGVjdG9ycy5sZW5ndGgpIHtcbiAgICAgICAgZm9yIChcbiAgICAgICAgICBob3N0Um9vdCA9IFtdO1xuICAgICAgICAgIG1heFNlbGVjdG9ySW5kZXggPCBzZWxlY3RvcnMubGVuZ3RoO1xuICAgICAgICAgIG1heFNlbGVjdG9ySW5kZXgrK1xuICAgICAgICApXG4gICAgICAgICAgaG9zdFJvb3QucHVzaChzZWxlY3RvclRvU3RyaW5nKHNlbGVjdG9yc1ttYXhTZWxlY3RvckluZGV4XSkpO1xuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgIFwiZmluZEFsbE5vZGVzIHdhcyBhYmxlIHRvIG1hdGNoIHBhcnQgb2YgdGhlIHNlbGVjdG9yOlxcbiAgXCIgK1xuICAgICAgICAgIChtYXRjaGVkTmFtZXMuam9pbihcIiA+IFwiKSArXG4gICAgICAgICAgICBcIlxcblxcbk5vIG1hdGNoaW5nIGNvbXBvbmVudCB3YXMgZm91bmQgZm9yOlxcbiAgXCIpICtcbiAgICAgICAgICBob3N0Um9vdC5qb2luKFwiID4gXCIpXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuICAgIGV4cG9ydHMuZ2V0UHVibGljUm9vdEluc3RhbmNlID0gZnVuY3Rpb24gKGNvbnRhaW5lcikge1xuICAgICAgY29udGFpbmVyID0gY29udGFpbmVyLmN1cnJlbnQ7XG4gICAgICBpZiAoIWNvbnRhaW5lci5jaGlsZCkgcmV0dXJuIG51bGw7XG4gICAgICBzd2l0Y2ggKGNvbnRhaW5lci5jaGlsZC50YWcpIHtcbiAgICAgICAgY2FzZSAyNzpcbiAgICAgICAgY2FzZSA1OlxuICAgICAgICAgIHJldHVybiBnZXRQdWJsaWNJbnN0YW5jZShjb250YWluZXIuY2hpbGQuc3RhdGVOb2RlKTtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICByZXR1cm4gY29udGFpbmVyLmNoaWxkLnN0YXRlTm9kZTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGV4cG9ydHMuaW5qZWN0SW50b0RldlRvb2xzID0gZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIGludGVybmFscyA9IHtcbiAgICAgICAgYnVuZGxlVHlwZTogMSxcbiAgICAgICAgdmVyc2lvbjogcmVuZGVyZXJWZXJzaW9uLFxuICAgICAgICByZW5kZXJlclBhY2thZ2VOYW1lOiByZW5kZXJlclBhY2thZ2VOYW1lLFxuICAgICAgICBjdXJyZW50RGlzcGF0Y2hlclJlZjogUmVhY3RTaGFyZWRJbnRlcm5hbHMsXG4gICAgICAgIGZpbmRGaWJlckJ5SG9zdEluc3RhbmNlOiBnZXRJbnN0YW5jZUZyb21Ob2RlLFxuICAgICAgICByZWNvbmNpbGVyVmVyc2lvbjogXCIxOS4wLjBcIlxuICAgICAgfTtcbiAgICAgIG51bGwgIT09IGV4dHJhRGV2VG9vbHNDb25maWcgJiZcbiAgICAgICAgKGludGVybmFscy5yZW5kZXJlckNvbmZpZyA9IGV4dHJhRGV2VG9vbHNDb25maWcpO1xuICAgICAgaW50ZXJuYWxzLm92ZXJyaWRlSG9va1N0YXRlID0gb3ZlcnJpZGVIb29rU3RhdGU7XG4gICAgICBpbnRlcm5hbHMub3ZlcnJpZGVIb29rU3RhdGVEZWxldGVQYXRoID0gb3ZlcnJpZGVIb29rU3RhdGVEZWxldGVQYXRoO1xuICAgICAgaW50ZXJuYWxzLm92ZXJyaWRlSG9va1N0YXRlUmVuYW1lUGF0aCA9IG92ZXJyaWRlSG9va1N0YXRlUmVuYW1lUGF0aDtcbiAgICAgIGludGVybmFscy5vdmVycmlkZVByb3BzID0gb3ZlcnJpZGVQcm9wcztcbiAgICAgIGludGVybmFscy5vdmVycmlkZVByb3BzRGVsZXRlUGF0aCA9IG92ZXJyaWRlUHJvcHNEZWxldGVQYXRoO1xuICAgICAgaW50ZXJuYWxzLm92ZXJyaWRlUHJvcHNSZW5hbWVQYXRoID0gb3ZlcnJpZGVQcm9wc1JlbmFtZVBhdGg7XG4gICAgICBpbnRlcm5hbHMuc2NoZWR1bGVVcGRhdGUgPSBzY2hlZHVsZVVwZGF0ZTtcbiAgICAgIGludGVybmFscy5zZXRFcnJvckhhbmRsZXIgPSBzZXRFcnJvckhhbmRsZXI7XG4gICAgICBpbnRlcm5hbHMuc2V0U3VzcGVuc2VIYW5kbGVyID0gc2V0U3VzcGVuc2VIYW5kbGVyO1xuICAgICAgaW50ZXJuYWxzLnNjaGVkdWxlUmVmcmVzaCA9IHNjaGVkdWxlUmVmcmVzaDtcbiAgICAgIGludGVybmFscy5zY2hlZHVsZVJvb3QgPSBzY2hlZHVsZVJvb3Q7XG4gICAgICBpbnRlcm5hbHMuc2V0UmVmcmVzaEhhbmRsZXIgPSBzZXRSZWZyZXNoSGFuZGxlcjtcbiAgICAgIGludGVybmFscy5nZXRDdXJyZW50RmliZXIgPSBnZXRDdXJyZW50RmliZXJGb3JEZXZUb29scztcbiAgICAgIGludGVybmFscy5nZXRMYW5lTGFiZWxNYXAgPSBnZXRMYW5lTGFiZWxNYXA7XG4gICAgICBpbnRlcm5hbHMuaW5qZWN0UHJvZmlsaW5nSG9va3MgPSBpbmplY3RQcm9maWxpbmdIb29rcztcbiAgICAgIHJldHVybiBpbmplY3RJbnRlcm5hbHMoaW50ZXJuYWxzKTtcbiAgICB9O1xuICAgIGV4cG9ydHMuaXNBbHJlYWR5UmVuZGVyaW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIChleGVjdXRpb25Db250ZXh0ICYgKFJlbmRlckNvbnRleHQgfCBDb21taXRDb250ZXh0KSkgIT09IE5vQ29udGV4dDtcbiAgICB9O1xuICAgIGV4cG9ydHMub2JzZXJ2ZVZpc2libGVSZWN0cyA9IGZ1bmN0aW9uIChcbiAgICAgIGhvc3RSb290LFxuICAgICAgc2VsZWN0b3JzLFxuICAgICAgY2FsbGJhY2ssXG4gICAgICBvcHRpb25zXG4gICAgKSB7XG4gICAgICBmdW5jdGlvbiBjb21taXRIb29rKCkge1xuICAgICAgICB2YXIgbmV4dEluc3RhbmNlUm9vdHMgPSBmaW5kQWxsTm9kZXMoaG9zdFJvb3QsIHNlbGVjdG9ycyk7XG4gICAgICAgIGluc3RhbmNlUm9vdHMuZm9yRWFjaChmdW5jdGlvbiAodGFyZ2V0KSB7XG4gICAgICAgICAgMCA+IG5leHRJbnN0YW5jZVJvb3RzLmluZGV4T2YodGFyZ2V0KSAmJiB1bm9ic2VydmUodGFyZ2V0KTtcbiAgICAgICAgfSk7XG4gICAgICAgIG5leHRJbnN0YW5jZVJvb3RzLmZvckVhY2goZnVuY3Rpb24gKHRhcmdldCkge1xuICAgICAgICAgIDAgPiBpbnN0YW5jZVJvb3RzLmluZGV4T2YodGFyZ2V0KSAmJiBvYnNlcnZlKHRhcmdldCk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgaWYgKCFzdXBwb3J0c1Rlc3RTZWxlY3RvcnMpXG4gICAgICAgIHRocm93IEVycm9yKFwiVGVzdCBzZWxlY3RvciBBUEkgaXMgbm90IHN1cHBvcnRlZCBieSB0aGlzIHJlbmRlcmVyLlwiKTtcbiAgICAgIHZhciBpbnN0YW5jZVJvb3RzID0gZmluZEFsbE5vZGVzKGhvc3RSb290LCBzZWxlY3RvcnMpO1xuICAgICAgY2FsbGJhY2sgPSBzZXR1cEludGVyc2VjdGlvbk9ic2VydmVyKGluc3RhbmNlUm9vdHMsIGNhbGxiYWNrLCBvcHRpb25zKTtcbiAgICAgIHZhciBkaXNjb25uZWN0ID0gY2FsbGJhY2suZGlzY29ubmVjdCxcbiAgICAgICAgb2JzZXJ2ZSA9IGNhbGxiYWNrLm9ic2VydmUsXG4gICAgICAgIHVub2JzZXJ2ZSA9IGNhbGxiYWNrLnVub2JzZXJ2ZTtcbiAgICAgIGNvbW1pdEhvb2tzLnB1c2goY29tbWl0SG9vayk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBkaXNjb25uZWN0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdmFyIGluZGV4ID0gY29tbWl0SG9va3MuaW5kZXhPZihjb21taXRIb29rKTtcbiAgICAgICAgICAwIDw9IGluZGV4ICYmIGNvbW1pdEhvb2tzLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgICAgZGlzY29ubmVjdCgpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH07XG4gICAgZXhwb3J0cy5zaG91bGRFcnJvciA9IGZ1bmN0aW9uIChmaWJlcikge1xuICAgICAgcmV0dXJuIHNob3VsZEVycm9ySW1wbChmaWJlcik7XG4gICAgfTtcbiAgICBleHBvcnRzLnNob3VsZFN1c3BlbmQgPSBmdW5jdGlvbiAoZmliZXIpIHtcbiAgICAgIHJldHVybiBzaG91bGRTdXNwZW5kSW1wbChmaWJlcik7XG4gICAgfTtcbiAgICBleHBvcnRzLnN0YXJ0SG9zdFRyYW5zaXRpb24gPSBmdW5jdGlvbiAoXG4gICAgICBmb3JtRmliZXIsXG4gICAgICBwZW5kaW5nU3RhdGUsXG4gICAgICBhY3Rpb24sXG4gICAgICBmb3JtRGF0YVxuICAgICkge1xuICAgICAgaWYgKDUgIT09IGZvcm1GaWJlci50YWcpXG4gICAgICAgIHRocm93IEVycm9yKFxuICAgICAgICAgIFwiRXhwZWN0ZWQgdGhlIGZvcm0gaW5zdGFuY2UgdG8gYmUgYSBIb3N0Q29tcG9uZW50LiBUaGlzIGlzIGEgYnVnIGluIFJlYWN0LlwiXG4gICAgICAgICk7XG4gICAgICB2YXIgcXVldWUgPSBlbnN1cmVGb3JtQ29tcG9uZW50SXNTdGF0ZWZ1bChmb3JtRmliZXIpLnF1ZXVlO1xuICAgICAgc3RhcnRUcmFuc2l0aW9uKFxuICAgICAgICBmb3JtRmliZXIsXG4gICAgICAgIHF1ZXVlLFxuICAgICAgICBwZW5kaW5nU3RhdGUsXG4gICAgICAgIE5vdFBlbmRpbmdUcmFuc2l0aW9uLFxuICAgICAgICBudWxsID09PSBhY3Rpb25cbiAgICAgICAgICA/IG5vb3BcbiAgICAgICAgICA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgbnVsbCA9PT0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuVCAmJlxuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgICAgICBcInJlcXVlc3RGb3JtUmVzZXQgd2FzIGNhbGxlZCBvdXRzaWRlIGEgdHJhbnNpdGlvbiBvciBhY3Rpb24uIFRvIGZpeCwgbW92ZSB0byBhbiBhY3Rpb24sIG9yIHdyYXAgd2l0aCBzdGFydFRyYW5zaXRpb24uXCJcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICB2YXIgcmVzZXRTdGF0ZVF1ZXVlID1cbiAgICAgICAgICAgICAgICBlbnN1cmVGb3JtQ29tcG9uZW50SXNTdGF0ZWZ1bChmb3JtRmliZXIpLm5leHQucXVldWU7XG4gICAgICAgICAgICAgIGRpc3BhdGNoU2V0U3RhdGVJbnRlcm5hbChcbiAgICAgICAgICAgICAgICBmb3JtRmliZXIsXG4gICAgICAgICAgICAgICAgcmVzZXRTdGF0ZVF1ZXVlLFxuICAgICAgICAgICAgICAgIHt9LFxuICAgICAgICAgICAgICAgIHJlcXVlc3RVcGRhdGVMYW5lKGZvcm1GaWJlcilcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgcmV0dXJuIGFjdGlvbihmb3JtRGF0YSk7XG4gICAgICAgICAgICB9XG4gICAgICApO1xuICAgIH07XG4gICAgZXhwb3J0cy51cGRhdGVDb250YWluZXIgPSBmdW5jdGlvbiAoXG4gICAgICBlbGVtZW50LFxuICAgICAgY29udGFpbmVyLFxuICAgICAgcGFyZW50Q29tcG9uZW50LFxuICAgICAgY2FsbGJhY2tcbiAgICApIHtcbiAgICAgIHZhciBjdXJyZW50ID0gY29udGFpbmVyLmN1cnJlbnQsXG4gICAgICAgIGxhbmUgPSByZXF1ZXN0VXBkYXRlTGFuZShjdXJyZW50KTtcbiAgICAgIHVwZGF0ZUNvbnRhaW5lckltcGwoXG4gICAgICAgIGN1cnJlbnQsXG4gICAgICAgIGxhbmUsXG4gICAgICAgIGVsZW1lbnQsXG4gICAgICAgIGNvbnRhaW5lcixcbiAgICAgICAgcGFyZW50Q29tcG9uZW50LFxuICAgICAgICBjYWxsYmFja1xuICAgICAgKTtcbiAgICAgIHJldHVybiBsYW5lO1xuICAgIH07XG4gICAgZXhwb3J0cy51cGRhdGVDb250YWluZXJTeW5jID0gdXBkYXRlQ29udGFpbmVyU3luYztcbiAgICByZXR1cm4gZXhwb3J0cztcbiAgfSksXG4gIChtb2R1bGUuZXhwb3J0cy5kZWZhdWx0ID0gbW9kdWxlLmV4cG9ydHMpLFxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkobW9kdWxlLmV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiAhMCB9KSk7XG4iXSwibmFtZXMiOlsibW9kdWxlIiwiZXhwb3J0cyIsIiQkJGNvbmZpZyIsImZpbmRIb29rIiwiZmliZXIiLCJpZCIsIm1lbW9pemVkU3RhdGUiLCJuZXh0IiwiY29weVdpdGhTZXRJbXBsIiwib2JqIiwicGF0aCIsImluZGV4IiwidmFsdWUiLCJsZW5ndGgiLCJrZXkiLCJ1cGRhdGVkIiwiaXNBcnJheUltcGwiLCJzbGljZSIsImFzc2lnbiIsImNvcHlXaXRoUmVuYW1lIiwib2xkUGF0aCIsIm5ld1BhdGgiLCJjb25zb2xlIiwid2FybiIsImkiLCJjb3B5V2l0aFJlbmFtZUltcGwiLCJvbGRLZXkiLCJzcGxpY2UiLCJjb3B5V2l0aERlbGV0ZUltcGwiLCJzaG91bGRTdXNwZW5kSW1wbCIsInNob3VsZEVycm9ySW1wbCIsImNyZWF0ZUZpYmVyIiwidGFnIiwicGVuZGluZ1Byb3BzIiwibW9kZSIsIkZpYmVyTm9kZSIsInNjaGVkdWxlUm9vdCIsInJvb3QiLCJlbGVtZW50IiwiY29udGV4dCIsImVtcHR5Q29udGV4dE9iamVjdCIsInVwZGF0ZUNvbnRhaW5lclN5bmMiLCJmbHVzaFN5bmNXb3JrIiwic2NoZWR1bGVSZWZyZXNoIiwidXBkYXRlIiwicmVzb2x2ZUZhbWlseSIsInN0YWxlRmFtaWxpZXMiLCJ1cGRhdGVkRmFtaWxpZXMiLCJmbHVzaFBhc3NpdmVFZmZlY3RzIiwic2NoZWR1bGVGaWJlcnNXaXRoRmFtaWxpZXNSZWN1cnNpdmVseSIsImN1cnJlbnQiLCJzZXRSZWZyZXNoSGFuZGxlciIsImhhbmRsZXIiLCJ3YXJuSW52YWxpZEhvb2tBY2Nlc3MiLCJlcnJvciIsIndhcm5JbnZhbGlkQ29udGV4dEFjY2VzcyIsIm5vb3AiLCJ3YXJuRm9yTWlzc2luZ0tleSIsInNldFRvU29ydGVkU3RyaW5nIiwic2V0IiwiYXJyYXkiLCJmb3JFYWNoIiwicHVzaCIsInNvcnQiLCJqb2luIiwiZ2V0SXRlcmF0b3JGbiIsIm1heWJlSXRlcmFibGUiLCJNQVlCRV9JVEVSQVRPUl9TWU1CT0wiLCJnZXRDb21wb25lbnROYW1lRnJvbVR5cGUiLCJ0eXBlIiwiJCR0eXBlb2YiLCJSRUFDVF9DTElFTlRfUkVGRVJFTkNFIiwiZGlzcGxheU5hbWUiLCJuYW1lIiwiUkVBQ1RfRlJBR01FTlRfVFlQRSIsIlJFQUNUX1BPUlRBTF9UWVBFIiwiUkVBQ1RfUFJPRklMRVJfVFlQRSIsIlJFQUNUX1NUUklDVF9NT0RFX1RZUEUiLCJSRUFDVF9TVVNQRU5TRV9UWVBFIiwiUkVBQ1RfU1VTUEVOU0VfTElTVF9UWVBFIiwiUkVBQ1RfQ09OVEVYVF9UWVBFIiwiUkVBQ1RfQ09OU1VNRVJfVFlQRSIsIl9jb250ZXh0IiwiUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRSIsImlubmVyVHlwZSIsInJlbmRlciIsIlJFQUNUX01FTU9fVFlQRSIsIlJFQUNUX0xBWllfVFlQRSIsIl9wYXlsb2FkIiwiX2luaXQiLCJ4IiwiZ2V0Q29tcG9uZW50TmFtZUZyb21GaWJlciIsIl9kZWJ1Z0luZm8iLCJyZXR1cm4iLCJkaXNhYmxlZExvZyIsImRpc2FibGVMb2dzIiwiZGlzYWJsZWREZXB0aCIsInByZXZMb2ciLCJsb2ciLCJwcmV2SW5mbyIsImluZm8iLCJwcmV2V2FybiIsInByZXZFcnJvciIsInByZXZHcm91cCIsImdyb3VwIiwicHJldkdyb3VwQ29sbGFwc2VkIiwiZ3JvdXBDb2xsYXBzZWQiLCJwcmV2R3JvdXBFbmQiLCJncm91cEVuZCIsInByb3BzIiwiY29uZmlndXJhYmxlIiwiZW51bWVyYWJsZSIsIndyaXRhYmxlIiwiT2JqZWN0IiwiZGVmaW5lUHJvcGVydGllcyIsInJlZW5hYmxlTG9ncyIsImRlc2NyaWJlQnVpbHRJbkNvbXBvbmVudEZyYW1lIiwicHJlZml4IiwiRXJyb3IiLCJtYXRjaCIsInN0YWNrIiwidHJpbSIsInN1ZmZpeCIsImluZGV4T2YiLCJkZXNjcmliZU5hdGl2ZUNvbXBvbmVudEZyYW1lIiwiZm4iLCJjb25zdHJ1Y3QiLCJyZWVudHJ5IiwiZnJhbWUiLCJjb21wb25lbnRGcmFtZUNhY2hlIiwiZ2V0IiwicHJlcGFyZVN0YWNrVHJhY2UiLCJwcmV2aW91c0Rpc3BhdGNoZXIiLCJSZWFjdFNoYXJlZEludGVybmFscyIsIkgiLCJSdW5JblJvb3RGcmFtZSIsIkRldGVybWluZUNvbXBvbmVudEZyYW1lUm9vdCIsIkZha2UiLCJkZWZpbmVQcm9wZXJ0eSIsInByb3RvdHlwZSIsIlJlZmxlY3QiLCJjb250cm9sIiwiY2FsbCIsIngkMCIsIngkMSIsImNhdGNoIiwic2FtcGxlIiwibmFtZVByb3BEZXNjcmlwdG9yIiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yIiwiX1J1bkluUm9vdEZyYW1lJERldGVyIiwic2FtcGxlU3RhY2siLCJjb250cm9sU3RhY2siLCJzYW1wbGVMaW5lcyIsInNwbGl0IiwiY29udHJvbExpbmVzIiwiaW5jbHVkZXMiLCJfZnJhbWUiLCJyZXBsYWNlIiwiZGVzY3JpYmVGaWJlciIsImdldFN0YWNrQnlGaWJlckluRGV2QW5kUHJvZCIsIndvcmtJblByb2dyZXNzIiwiZGVidWdJbmZvIiwiZW50cnkiLCJKU0NvbXBpbGVyX3RlbXBfY29uc3QiLCJlbnYiLCJKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQiLCJtZXNzYWdlIiwiZ2V0Q3VycmVudEZpYmVyU3RhY2tJbkRldiIsInJ1bldpdGhGaWJlckluREVWIiwiY2FsbGJhY2siLCJhcmcwIiwiYXJnMSIsImFyZzIiLCJhcmczIiwiYXJnNCIsInByZXZpb3VzRmliZXIiLCJnZXRDdXJyZW50U3RhY2siLCJpc1JlbmRlcmluZyIsImdldE5lYXJlc3RNb3VudGVkRmliZXIiLCJub2RlIiwibmVhcmVzdE1vdW50ZWQiLCJhbHRlcm5hdGUiLCJmbGFncyIsImFzc2VydElzTW91bnRlZCIsImZpbmRDdXJyZW50RmliZXJVc2luZ1Nsb3dQYXRoIiwiYSIsImIiLCJwYXJlbnRBIiwicGFyZW50QiIsImNoaWxkIiwic2libGluZyIsImRpZEZpbmRDaGlsZCIsIl9jaGlsZCIsInN0YXRlTm9kZSIsImZpbmRDdXJyZW50SG9zdEZpYmVyIiwicGFyZW50IiwiZmluZEN1cnJlbnRIb3N0RmliZXJJbXBsIiwiZmluZEN1cnJlbnRIb3N0RmliZXJXaXRoTm9Qb3J0YWxzSW1wbCIsImNyZWF0ZUN1cnNvciIsImRlZmF1bHRWYWx1ZSIsInBvcCIsImN1cnNvciIsImluZGV4JGpzY29tcCQwIiwiZmliZXJTdGFjayIsInZhbHVlU3RhY2siLCJjbHozMkZhbGxiYWNrIiwibG9nJDEiLCJMTjIiLCJnZXRMYWJlbEZvckxhbmUiLCJsYW5lIiwiZ2V0SGlnaGVzdFByaW9yaXR5TGFuZXMiLCJsYW5lcyIsInBlbmRpbmdTeW5jTGFuZXMiLCJnZXROZXh0TGFuZXMiLCJ3aXBMYW5lcyIsInBlbmRpbmdMYW5lcyIsIm5leHRMYW5lcyIsInN1c3BlbmRlZExhbmVzIiwicGluZ2VkTGFuZXMiLCJ3YXJtTGFuZXMiLCJmaW5pc2hlZExhbmVzIiwibm9uSWRsZVBlbmRpbmdMYW5lcyIsImNoZWNrSWZSb290SXNQcmVyZW5kZXJpbmciLCJyZW5kZXJMYW5lcyIsImNvbXB1dGVFeHBpcmF0aW9uVGltZSIsImN1cnJlbnRUaW1lIiwiY2xhaW1OZXh0VHJhbnNpdGlvbkxhbmUiLCJuZXh0VHJhbnNpdGlvbkxhbmUiLCJjbGFpbU5leHRSZXRyeUxhbmUiLCJuZXh0UmV0cnlMYW5lIiwiY3JlYXRlTGFuZU1hcCIsImluaXRpYWwiLCJsYW5lTWFwIiwibWFya1Jvb3RVcGRhdGVkJDEiLCJ1cGRhdGVMYW5lIiwibWFya1Jvb3RGaW5pc2hlZCIsInJlbWFpbmluZ0xhbmVzIiwic3Bhd25lZExhbmUiLCJ1cGRhdGVkTGFuZXMiLCJzdXNwZW5kZWRSZXRyeUxhbmVzIiwicHJldmlvdXNseVBlbmRpbmdMYW5lcyIsImV4cGlyZWRMYW5lcyIsImVudGFuZ2xlZExhbmVzIiwiZXJyb3JSZWNvdmVyeURpc2FibGVkTGFuZXMiLCJzaGVsbFN1c3BlbmRDb3VudGVyIiwiZW50YW5nbGVtZW50cyIsImV4cGlyYXRpb25UaW1lcyIsImhpZGRlblVwZGF0ZXMiLCJjbHozMiIsImhpZGRlblVwZGF0ZXNGb3JMYW5lIiwibWFya1NwYXduZWREZWZlcnJlZExhbmUiLCJzcGF3bmVkTGFuZUluZGV4IiwibWFya1Jvb3RFbnRhbmdsZWQiLCJyb290RW50YW5nbGVkTGFuZXMiLCJhZGRGaWJlclRvTGFuZXNNYXAiLCJpc0RldlRvb2xzUHJlc2VudCIsInBlbmRpbmdVcGRhdGVyc0xhbmVNYXAiLCJhZGQiLCJtb3ZlUGVuZGluZ0ZpYmVyc1RvTWVtb2l6ZWQiLCJtZW1vaXplZFVwZGF0ZXJzIiwic2l6ZSIsImhhcyIsImNsZWFyIiwibGFuZXNUb0V2ZW50UHJpb3JpdHkiLCJpbmplY3RJbnRlcm5hbHMiLCJpbnRlcm5hbHMiLCJfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX18iLCJob29rIiwiaXNEaXNhYmxlZCIsInN1cHBvcnRzRmliZXIiLCJyZW5kZXJlcklEIiwiaW5qZWN0IiwiaW5qZWN0ZWRIb29rIiwiZXJyIiwiY2hlY2tEQ0UiLCJvbkNvbW1pdFJvb3QkMSIsImV2ZW50UHJpb3JpdHkiLCJvbkNvbW1pdEZpYmVyUm9vdCIsImRpZEVycm9yIiwic2NoZWR1bGVyUHJpb3JpdHkiLCJJbW1lZGlhdGVQcmlvcml0eSIsIlVzZXJCbG9ja2luZ1ByaW9yaXR5IiwiTm9ybWFsUHJpb3JpdHkkMSIsIklkbGVQcmlvcml0eSIsImhhc0xvZ2dlZEVycm9yIiwic2V0SXNTdHJpY3RNb2RlRm9yRGV2dG9vbHMiLCJuZXdJc1N0cmljdE1vZGUiLCJ1bnN0YWJsZV9zZXREaXNhYmxlWWllbGRWYWx1ZSIsInNldFN0cmljdE1vZGUiLCJpbmplY3RQcm9maWxpbmdIb29rcyIsInByb2ZpbGluZ0hvb2tzIiwiaW5qZWN0ZWRQcm9maWxpbmdIb29rcyIsIm1hcmtDb21taXRTdG9wcGVkIiwibWFya0NvbXBvbmVudFJlbmRlclN0YXJ0ZWQiLCJtYXJrQ29tcG9uZW50UmVuZGVyU3RvcHBlZCIsIm1hcmtSZW5kZXJTdGFydGVkIiwibWFya1JlbmRlclN0b3BwZWQiLCJtYXJrU3RhdGVVcGRhdGVTY2hlZHVsZWQiLCJpcyIsInkiLCJjcmVhdGVDYXB0dXJlZFZhbHVlQXRGaWJlciIsInNvdXJjZSIsImV4aXN0aW5nIiwiQ2FwdHVyZWRTdGFja3MiLCJwdXNoVHJlZUZvcmsiLCJ0b3RhbENoaWxkcmVuIiwid2FybklmTm90SHlkcmF0aW5nIiwiZm9ya1N0YWNrIiwiZm9ya1N0YWNrSW5kZXgiLCJ0cmVlRm9ya0NvdW50IiwidHJlZUZvcmtQcm92aWRlciIsInB1c2hUcmVlSWQiLCJpZFN0YWNrIiwiaWRTdGFja0luZGV4IiwidHJlZUNvbnRleHRJZCIsInRyZWVDb250ZXh0T3ZlcmZsb3ciLCJ0cmVlQ29udGV4dFByb3ZpZGVyIiwiYmFzZUlkV2l0aExlYWRpbmdCaXQiLCJiYXNlTGVuZ3RoIiwibnVtYmVyT2ZPdmVyZmxvd0JpdHMiLCJ0b1N0cmluZyIsInB1c2hNYXRlcmlhbGl6ZWRUcmVlSWQiLCJwb3BUcmVlQ29udGV4dCIsImlzSHlkcmF0aW5nIiwicmVxdWlyZWRDb250ZXh0IiwiYyIsInB1c2hIb3N0Q29udGFpbmVyIiwibmV4dFJvb3RJbnN0YW5jZSIsInJvb3RJbnN0YW5jZVN0YWNrQ3Vyc29yIiwiY29udGV4dEZpYmVyU3RhY2tDdXJzb3IiLCJjb250ZXh0U3RhY2tDdXJzb3IiLCJnZXRSb290SG9zdENvbnRleHQiLCJwb3BIb3N0Q29udGFpbmVyIiwiZ2V0SG9zdENvbnRleHQiLCJwdXNoSG9zdENvbnRleHQiLCJob3N0VHJhbnNpdGlvblByb3ZpZGVyQ3Vyc29yIiwibmV4dENvbnRleHQiLCJnZXRDaGlsZEhvc3RDb250ZXh0IiwicG9wSG9zdENvbnRleHQiLCJpc1ByaW1hcnlSZW5kZXJlciIsIkhvc3RUcmFuc2l0aW9uQ29udGV4dCIsIl9jdXJyZW50VmFsdWUiLCJOb3RQZW5kaW5nVHJhbnNpdGlvbiIsIl9jdXJyZW50VmFsdWUyIiwiZmluZE5vdGFibGVOb2RlIiwiaW5kZW50Iiwic2VydmVyUHJvcHMiLCJzZXJ2ZXJUYWlsIiwiY2hpbGRyZW4iLCJkaXN0YW5jZUZyb21MZWFmIiwiaW5kZW50YXRpb24iLCJyZXBlYXQiLCJhZGRlZCIsInJlbW92ZWQiLCJkZXNjcmliZUZpYmVyVHlwZSIsImRlc2NyaWJlVGV4dE5vZGUiLCJjb250ZW50IiwibWF4TGVuZ3RoIiwibmVlZHNFc2NhcGluZyIsInRlc3QiLCJKU09OIiwic3RyaW5naWZ5IiwiZGVzY3JpYmVUZXh0RGlmZiIsImNsaWVudFRleHQiLCJmaXJzdERpZmYiLCJjaGFyQ29kZUF0Iiwib2JqZWN0TmFtZSIsIm9iamVjdCIsIm0iLCJwMCIsImRlc2NyaWJlVmFsdWUiLCJSRUFDVF9FTEVNRU5UX1RZUEUiLCJwcm9wTmFtZSIsImhhc093blByb3BlcnR5IiwianNvblByb3BOYW1lIiwiU3RyaW5nIiwiZGVzY3JpYmVQcm9wVmFsdWUiLCJkZXNjcmliZUV4cGFuZGVkRWxlbWVudCIsInJvd1ByZWZpeCIsInJlbWFpbmluZ1Jvd0xlbmd0aCIsInByb3BlcnRpZXMiLCJwcm9wVmFsdWUiLCJkZXNjcmliZVByb3BlcnRpZXNEaWZmIiwiY2xpZW50T2JqZWN0Iiwic2VydmVyT2JqZWN0IiwicmVtYWluaW5nU2VydmVyUHJvcGVydGllcyIsImNsaWVudFByb3BWYWx1ZSIsIl9wcm9wTmFtZSIsImRlc2NyaWJlRWxlbWVudERpZmYiLCJjbGllbnRQcm9wcyIsInNlcnZlclByb3BOYW1lcyIsIk1hcCIsInByb3BOYW1lJGpzY29tcCQwIiwidG9Mb3dlckNhc2UiLCJfcHJvcE5hbWUyIiwibWF4TGVuZ3RoJGpzY29tcCQwIiwic2VydmVyUHJvcE5hbWUiLCJkZWxldGUiLCJrZXlzIiwiZGVzY3JpYmVTaWJsaW5nRmliZXIiLCJkZXNjcmliZU5vZGUiLCJza2lwVG9Ob2RlIiwic2VydmVyQ29tcG9uZW50TmFtZSIsImRlc2NyaWJlRGlmZiIsInJvb3ROb2RlIiwiYnVpbGRIeWRyYXRpb25EaWZmTm9kZSIsImh5ZHJhdGlvbkRpZmZSb290REVWIiwic2libGluZ3MiLCJ3YXJuTm9uSHlkcmF0ZWRJbnN0YW5jZSIsInJlamVjdGVkQ2FuZGlkYXRlIiwiZGlkU3VzcGVuZE9yRXJyb3JERVYiLCJkZXNjcmliZUh5ZHJhdGFibGVJbnN0YW5jZUZvckRldldhcm5pbmdzIiwidGhyb3dPbkh5ZHJhdGlvbk1pc21hdGNoIiwiZGlmZiIsImRpZmZSb290IiwicXVldWVIeWRyYXRpb25FcnJvciIsIkh5ZHJhdGlvbk1pc21hdGNoRXhjZXB0aW9uIiwicHJlcGFyZVRvSHlkcmF0ZUhvc3RJbnN0YW5jZSIsImhvc3RDb250ZXh0Iiwic3VwcG9ydHNIeWRyYXRpb24iLCJoeWRyYXRlSW5zdGFuY2UiLCJtZW1vaXplZFByb3BzIiwicG9wVG9OZXh0SG9zdFBhcmVudCIsImh5ZHJhdGlvblBhcmVudEZpYmVyIiwicm9vdE9yU2luZ2xldG9uQ29udGV4dCIsInBvcEh5ZHJhdGlvblN0YXRlIiwic2hvdWxkQ2xlYXIiLCJzdXBwb3J0c1NpbmdsZXRvbnMiLCJzaG91bGREZWxldGVVbmh5ZHJhdGVkVGFpbEluc3RhbmNlcyIsInNob3VsZFNldFRleHRDb250ZW50IiwibmV4dEh5ZHJhdGFibGVJbnN0YW5jZSIsImRpZmZOb2RlIiwiZGVzY3JpcHRpb24iLCJnZXROZXh0SHlkcmF0YWJsZUluc3RhbmNlQWZ0ZXJTdXNwZW5zZUluc3RhbmNlIiwiZ2V0TmV4dEh5ZHJhdGFibGVTaWJsaW5nIiwiZGVoeWRyYXRlZCIsInJlc2V0SHlkcmF0aW9uU3RhdGUiLCJoeWRyYXRpb25FcnJvcnMiLCJlbWl0UGVuZGluZ0h5ZHJhdGlvbldhcm5pbmdzIiwiZmluaXNoUXVldWVpbmdDb25jdXJyZW50VXBkYXRlcyIsImVuZEluZGV4IiwiY29uY3VycmVudFF1ZXVlc0luZGV4IiwiY29uY3VycmVudGx5VXBkYXRlZExhbmVzIiwiY29uY3VycmVudFF1ZXVlcyIsInF1ZXVlIiwicGVuZGluZyIsIm1hcmtVcGRhdGVMYW5lRnJvbUZpYmVyVG9Sb290IiwiZW5xdWV1ZVVwZGF0ZSQxIiwiZW5xdWV1ZUNvbmN1cnJlbnRIb29rVXBkYXRlIiwiZ2V0Um9vdEZvclVwZGF0ZWRGaWJlciIsImVucXVldWVDb25jdXJyZW50UmVuZGVyRm9yTGFuZSIsInNvdXJjZUZpYmVyIiwiaXNIaWRkZW4iLCJjaGlsZExhbmVzIiwiX3Zpc2liaWxpdHkiLCJuZXN0ZWRVcGRhdGVDb3VudCIsIk5FU1RFRF9VUERBVEVfTElNSVQiLCJuZXN0ZWRQYXNzaXZlVXBkYXRlQ291bnQiLCJyb290V2l0aFBhc3NpdmVOZXN0ZWRVcGRhdGVzIiwicm9vdFdpdGhOZXN0ZWRVcGRhdGVzIiwiTkVTVEVEX1BBU1NJVkVfVVBEQVRFX0xJTUlUIiwid2FybkFib3V0VXBkYXRlT25Ob3RZZXRNb3VudGVkRmliZXJJbkRFViIsInB1c2hOZXN0ZWRFZmZlY3REdXJhdGlvbnMiLCJwcmV2RWZmZWN0RHVyYXRpb24iLCJwcm9maWxlckVmZmVjdER1cmF0aW9uIiwicG9wTmVzdGVkRWZmZWN0RHVyYXRpb25zIiwiZWxhcHNlZFRpbWUiLCJidWJibGVOZXN0ZWRFZmZlY3REdXJhdGlvbnMiLCJzdGFydFByb2ZpbGVyVGltZXIiLCJwcm9maWxlclN0YXJ0VGltZSIsIm5vdyIsImFjdHVhbFN0YXJ0VGltZSIsInN0b3BQcm9maWxlclRpbWVySWZSdW5uaW5nQW5kUmVjb3JkRHVyYXRpb24iLCJhY3R1YWxEdXJhdGlvbiIsInNlbGZCYXNlRHVyYXRpb24iLCJzdG9wUHJvZmlsZXJUaW1lcklmUnVubmluZ0FuZFJlY29yZEluY29tcGxldGVEdXJhdGlvbiIsInJlY29yZEVmZmVjdER1cmF0aW9uIiwic3RhcnRFZmZlY3RUaW1lciIsInRyYW5zZmVyQWN0dWFsRHVyYXRpb24iLCJlbnN1cmVSb290SXNTY2hlZHVsZWQiLCJsYXN0U2NoZWR1bGVkUm9vdCIsImZpcnN0U2NoZWR1bGVkUm9vdCIsIm1pZ2h0SGF2ZVBlbmRpbmdTeW5jV29yayIsImFjdFF1ZXVlIiwiZGlkU2NoZWR1bGVNaWNyb3Rhc2tfYWN0Iiwic2NoZWR1bGVJbW1lZGlhdGVUYXNrIiwicHJvY2Vzc1Jvb3RTY2hlZHVsZUluTWljcm90YXNrIiwiZGlkU2NoZWR1bGVNaWNyb3Rhc2siLCJmbHVzaFN5bmNXb3JrQWNyb3NzUm9vdHNfaW1wbCIsInN5bmNUcmFuc2l0aW9uTGFuZXMiLCJvbmx5TGVnYWN5IiwiaXNGbHVzaGluZ1dvcmsiLCJkaWRQZXJmb3JtU29tZVdvcmsiLCJwZXJmb3JtU3luY1dvcmtPblJvb3QiLCJ3b3JrSW5Qcm9ncmVzc1Jvb3RSZW5kZXJMYW5lcyIsIndvcmtJblByb2dyZXNzUm9vdCIsImN1cnJlbnRFdmVudFRyYW5zaXRpb25MYW5lIiwic2hvdWxkQXR0ZW1wdEVhZ2VyVHJhbnNpdGlvbiIsIm5vdyQxIiwicHJldiIsInNjaGVkdWxlVGFza0ZvclJvb3REdXJpbmdNaWNyb3Rhc2siLCJleHBpcmF0aW9uVGltZSIsImNhbGxiYWNrTm9kZSIsIndvcmtJblByb2dyZXNzU3VzcGVuZGVkUmVhc29uIiwiU3VzcGVuZGVkT25EYXRhIiwiY2FuY2VsUGVuZGluZ0NvbW1pdCIsImNhbmNlbENhbGxiYWNrIiwiY2FsbGJhY2tQcmlvcml0eSIsImZha2VBY3RDYWxsYmFja05vZGUkMSIsInBlcmZvcm1Xb3JrT25Sb290VmlhU2NoZWR1bGVyVGFzayIsImJpbmQiLCJzY2hlZHVsZUNhbGxiYWNrJDMiLCJkaWRUaW1lb3V0IiwibmVzdGVkVXBkYXRlU2NoZWR1bGVkIiwiY3VycmVudFVwZGF0ZUlzTmVzdGVkIiwib3JpZ2luYWxDYWxsYmFja05vZGUiLCJ3b3JrSW5Qcm9ncmVzc1Jvb3RSZW5kZXJMYW5lcyRqc2NvbXAkMCIsInBlcmZvcm1Xb3JrT25Sb290IiwiY2FuY2VsQ2FsbGJhY2skMSIsImNiIiwic3VwcG9ydHNNaWNyb3Rhc2tzIiwic2NoZWR1bGVNaWNyb3Rhc2siLCJleGVjdXRpb25Db250ZXh0IiwiUmVuZGVyQ29udGV4dCIsIkNvbW1pdENvbnRleHQiLCJOb0NvbnRleHQiLCJyZXF1ZXN0VHJhbnNpdGlvbkxhbmUiLCJlbnRhbmdsZUFzeW5jQWN0aW9uIiwidHJhbnNpdGlvbiIsInRoZW5hYmxlIiwiY3VycmVudEVudGFuZ2xlZExpc3RlbmVycyIsImVudGFuZ2xlZExpc3RlbmVycyIsImN1cnJlbnRFbnRhbmdsZWRQZW5kaW5nQ291bnQiLCJjdXJyZW50RW50YW5nbGVkTGFuZSIsImN1cnJlbnRFbnRhbmdsZWRBY3Rpb25UaGVuYWJsZSIsInN0YXR1cyIsInRoZW4iLCJyZXNvbHZlIiwicGluZ0VuZ3RhbmdsZWRBY3Rpb25TY29wZSIsImxpc3RlbmVycyIsImNoYWluVGhlbmFibGVWYWx1ZSIsInJlc3VsdCIsInRoZW5hYmxlV2l0aE92ZXJyaWRlIiwicmVhc29uIiwiaW5pdGlhbGl6ZVVwZGF0ZVF1ZXVlIiwidXBkYXRlUXVldWUiLCJiYXNlU3RhdGUiLCJmaXJzdEJhc2VVcGRhdGUiLCJsYXN0QmFzZVVwZGF0ZSIsInNoYXJlZCIsImhpZGRlbkNhbGxiYWNrcyIsImNhbGxiYWNrcyIsImNsb25lVXBkYXRlUXVldWUiLCJjcmVhdGVVcGRhdGUiLCJVcGRhdGVTdGF0ZSIsInBheWxvYWQiLCJlbnF1ZXVlVXBkYXRlIiwiY3VycmVudGx5UHJvY2Vzc2luZ1F1ZXVlIiwiZGlkV2FyblVwZGF0ZUluc2lkZVVwZGF0ZSIsImNvbXBvbmVudE5hbWUiLCJlbnRhbmdsZVRyYW5zaXRpb25zIiwicXVldWVMYW5lcyIsImVucXVldWVDYXB0dXJlZFVwZGF0ZSIsImNhcHR1cmVkVXBkYXRlIiwibmV3Rmlyc3QiLCJuZXdMYXN0IiwiY2xvbmUiLCJzdXNwZW5kSWZVcGRhdGVSZWFkRnJvbUVudGFuZ2xlZEFzeW5jQWN0aW9uIiwiZGlkUmVhZEZyb21FbnRhbmdsZWRBc3luY0FjdGlvbiIsImVudGFuZ2xlZEFjdGlvblRoZW5hYmxlIiwicHJvY2Vzc1VwZGF0ZVF1ZXVlIiwiaW5zdGFuY2UkanNjb21wJDAiLCJoYXNGb3JjZVVwZGF0ZSIsInBlbmRpbmdRdWV1ZSIsImxhc3RQZW5kaW5nVXBkYXRlIiwiZmlyc3RQZW5kaW5nVXBkYXRlIiwibmV3U3RhdGUiLCJpc0hpZGRlblVwZGF0ZSIsInBhcnRpYWxTdGF0ZSIsIm5leHRQcm9wcyIsImluc3RhbmNlIiwiUmVwbGFjZVN0YXRlIiwiaXNEaXNhbGxvd2VkQ29udGV4dFJlYWRJbkRFViIsIm5leHRTdGF0ZSIsIkNhcHR1cmVVcGRhdGUiLCJGb3JjZVVwZGF0ZSIsIndvcmtJblByb2dyZXNzUm9vdFNraXBwZWRMYW5lcyIsImNhbGxDYWxsYmFjayIsImNvbW1pdEhpZGRlbkNhbGxiYWNrcyIsImNvbW1pdENhbGxiYWNrcyIsInNoYWxsb3dFcXVhbCIsIm9iakEiLCJvYmpCIiwib2JqZWN0SXMiLCJrZXlzQSIsImtleXNCIiwiY3VycmVudEtleSIsImNyZWF0ZVRoZW5hYmxlU3RhdGUiLCJkaWRXYXJuQWJvdXRVbmNhY2hlZFByb21pc2UiLCJ0aGVuYWJsZXMiLCJpc1RoZW5hYmxlUmVzb2x2ZWQiLCJub29wJDEiLCJ0cmFja1VzZWRUaGVuYWJsZSIsInRoZW5hYmxlU3RhdGUiLCJkaWRVc2VQcm9taXNlIiwidHJhY2tlZFRoZW5hYmxlcyIsImNoZWNrSWZVc2VXcmFwcGVkSW5Bc3luY0NhdGNoIiwiZnVsZmlsbGVkVmFsdWUiLCJmdWxmaWxsZWRUaGVuYWJsZSIsInJlamVjdGVkVGhlbmFibGUiLCJzdXNwZW5kZWRUaGVuYWJsZSIsIm5lZWRzVG9SZXNldFN1c3BlbmRlZFRoZW5hYmxlREVWIiwiU3VzcGVuc2VFeGNlcHRpb24iLCJnZXRTdXNwZW5kZWRUaGVuYWJsZSIsInJlamVjdGVkUmVhc29uIiwicHVzaERlYnVnSW5mbyIsInByZXZpb3VzRGVidWdJbmZvIiwiY3VycmVudERlYnVnSW5mbyIsImNvbmNhdCIsInZhbGlkYXRlRnJhZ21lbnRQcm9wcyIsInJldHVybkZpYmVyIiwiY3JlYXRlRmliZXJGcm9tRWxlbWVudCIsImVycm9yZWRLZXkiLCJ1bndyYXBUaGVuYWJsZSIsInRoZW5hYmxlSW5kZXhDb3VudGVyJDEiLCJ0aGVuYWJsZVN0YXRlJDEiLCJjb2VyY2VSZWYiLCJyZWYiLCJ0aHJvd09uSW52YWxpZE9iamVjdFR5cGUiLCJuZXdDaGlsZCIsIlJFQUNUX0xFR0FDWV9FTEVNRU5UX1RZUEUiLCJ3YXJuT25GdW5jdGlvblR5cGUiLCJpbnZhbGlkQ2hpbGQiLCJwYXJlbnROYW1lIiwib3duZXJIYXNGdW5jdGlvblR5cGVXYXJuaW5nIiwid2Fybk9uU3ltYm9sVHlwZSIsIm93bmVySGFzU3ltYm9sVHlwZVdhcm5pbmciLCJjcmVhdGVDaGlsZFJlY29uY2lsZXIiLCJzaG91bGRUcmFja1NpZGVFZmZlY3RzIiwiZGVsZXRlQ2hpbGQiLCJjaGlsZFRvRGVsZXRlIiwiZGVsZXRpb25zIiwiZGVsZXRlUmVtYWluaW5nQ2hpbGRyZW4iLCJjdXJyZW50Rmlyc3RDaGlsZCIsIm1hcFJlbWFpbmluZ0NoaWxkcmVuIiwiZXhpc3RpbmdDaGlsZHJlbiIsInVzZUZpYmVyIiwiY3JlYXRlV29ya0luUHJvZ3Jlc3MiLCJwbGFjZUNoaWxkIiwibmV3RmliZXIiLCJsYXN0UGxhY2VkSW5kZXgiLCJuZXdJbmRleCIsInBsYWNlU2luZ2xlQ2hpbGQiLCJ1cGRhdGVUZXh0Tm9kZSIsInRleHRDb250ZW50IiwiY3JlYXRlRmliZXJGcm9tVGV4dCIsIl9kZWJ1Z093bmVyIiwidXBkYXRlRWxlbWVudCIsImVsZW1lbnRUeXBlIiwidXBkYXRlRnJhZ21lbnQiLCJpc0NvbXBhdGlibGVGYW1pbHlGb3JIb3RSZWxvYWRpbmciLCJjYWxsTGF6eUluaXRJbkRFViIsIl9vd25lciIsInVwZGF0ZVBvcnRhbCIsInBvcnRhbCIsImNvbnRhaW5lckluZm8iLCJpbXBsZW1lbnRhdGlvbiIsImNyZWF0ZUZpYmVyRnJvbVBvcnRhbCIsImZyYWdtZW50IiwiY3JlYXRlRmliZXJGcm9tRnJhZ21lbnQiLCJjcmVhdGVDaGlsZCIsIl9wcmV2RGVidWdJbmZvIiwicmVhZENvbnRleHREdXJpbmdSZWNvbmNpbGlhdGlvbiIsInVwZGF0ZVNsb3QiLCJvbGRGaWJlciIsInVwZGF0ZUZyb21NYXAiLCJuZXdJZHgiLCJfcHJldkRlYnVnSW5mbzciLCJ3YXJuT25JbnZhbGlkS2V5Iiwia25vd25LZXlzIiwiU2V0IiwicmVjb25jaWxlQ2hpbGRyZW5BcnJheSIsIm5ld0NoaWxkcmVuIiwicmVzdWx0aW5nRmlyc3RDaGlsZCIsInByZXZpb3VzTmV3RmliZXIiLCJuZXh0T2xkRmliZXIiLCJyZWNvbmNpbGVDaGlsZHJlbkl0ZXJhdG9yIiwic3RlcCIsImRvbmUiLCJyZWNvbmNpbGVDaGlsZEZpYmVyc0ltcGwiLCJwcmV2RGVidWdJbmZvIiwiZGlkV2FybkFib3V0R2VuZXJhdG9ycyIsImVudHJpZXMiLCJkaWRXYXJuQWJvdXRNYXBzIiwiZmlyc3RDaGlsZEZpYmVyIiwicHVzaEhpZGRlbkNvbnRleHQiLCJwcmV2RW50YW5nbGVkUmVuZGVyTGFuZXMiLCJlbnRhbmdsZWRSZW5kZXJMYW5lcyIsInByZXZFbnRhbmdsZWRSZW5kZXJMYW5lc0N1cnNvciIsImN1cnJlbnRUcmVlSGlkZGVuU3RhY2tDdXJzb3IiLCJiYXNlTGFuZXMiLCJyZXVzZUhpZGRlbkNvbnRleHRPblN0YWNrIiwicG9wSGlkZGVuQ29udGV4dCIsInB1c2hQcmltYXJ5VHJlZVN1c3BlbnNlSGFuZGxlciIsInN1c3BlbnNlU3RhY2tDdXJzb3IiLCJTdWJ0cmVlU3VzcGVuc2VDb250ZXh0TWFzayIsInN1c3BlbnNlSGFuZGxlclN0YWNrQ3Vyc29yIiwic2hlbGxCb3VuZGFyeSIsInB1c2hPZmZzY3JlZW5TdXNwZW5zZUhhbmRsZXIiLCJyZXVzZVN1c3BlbnNlSGFuZGxlck9uU3RhY2siLCJwb3BTdXNwZW5zZUhhbmRsZXIiLCJmaW5kRmlyc3RTdXNwZW5kZWQiLCJyb3ciLCJzdGF0ZSIsImlzU3VzcGVuc2VJbnN0YW5jZVBlbmRpbmciLCJpc1N1c3BlbnNlSW5zdGFuY2VGYWxsYmFjayIsInJldmVhbE9yZGVyIiwibW91bnRIb29rVHlwZXNEZXYiLCJob29rTmFtZSIsImN1cnJlbnRIb29rTmFtZUluRGV2IiwiaG9va1R5cGVzRGV2IiwidXBkYXRlSG9va1R5cGVzRGV2IiwiaG9va1R5cGVzVXBkYXRlSW5kZXhEZXYiLCJjdXJyZW50bHlSZW5kZXJpbmdGaWJlciQxIiwiZGlkV2FybkFib3V0TWlzbWF0Y2hlZEhvb2tzRm9yQ29tcG9uZW50IiwidGFibGUiLCJvbGRIb29rTmFtZSIsIm5ld0hvb2tOYW1lIiwiY2hlY2tEZXBzQXJlQXJyYXlEZXYiLCJkZXBzIiwid2Fybk9uVXNlRm9ybVN0YXRlSW5EZXYiLCJkaWRXYXJuQWJvdXRVc2VGb3JtU3RhdGUiLCJ0aHJvd0ludmFsaWRIb29rRXJyb3IiLCJhcmVIb29rSW5wdXRzRXF1YWwiLCJuZXh0RGVwcyIsInByZXZEZXBzIiwiaWdub3JlUHJldmlvdXNEZXBlbmRlbmNpZXMiLCJyZW5kZXJXaXRoSG9va3MiLCJDb21wb25lbnQiLCJzZWNvbmRBcmciLCJuZXh0UmVuZGVyTGFuZXMiLCJfZGVidWdIb29rVHlwZXMiLCJkaWRXYXJuQWJvdXRBc3luY0NsaWVudENvbXBvbmVudCIsIkhvb2tzRGlzcGF0Y2hlck9uVXBkYXRlSW5ERVYiLCJIb29rc0Rpc3BhdGNoZXJPbk1vdW50V2l0aEhvb2tUeXBlc0luREVWIiwiSG9va3NEaXNwYXRjaGVyT25Nb3VudEluREVWIiwic2hvdWxkRG91YmxlSW52b2tlVXNlckZuc0luSG9va3NERVYiLCJOb01vZGUiLCJjYWxsQ29tcG9uZW50SW5ERVYiLCJkaWRTY2hlZHVsZVJlbmRlclBoYXNlVXBkYXRlRHVyaW5nVGhpc1Bhc3MiLCJyZW5kZXJXaXRoSG9va3NBZ2FpbiIsImZpbmlzaFJlbmRlcmluZ0hvb2tzIiwiZGVwZW5kZW5jaWVzIiwiZmlyc3RDb250ZXh0IiwiX2RlYnVnVGhlbmFibGVTdGF0ZSIsIkNvbnRleHRPbmx5RGlzcGF0Y2hlciIsImRpZFJlbmRlclRvb0Zld0hvb2tzIiwiY3VycmVudEhvb2siLCJ3b3JrSW5Qcm9ncmVzc0hvb2siLCJkaWRTY2hlZHVsZVJlbmRlclBoYXNlVXBkYXRlIiwidGhlbmFibGVJbmRleENvdW50ZXIiLCJkaWRSZWNlaXZlVXBkYXRlIiwiY2hlY2tJZkNvbnRleHRDaGFuZ2VkIiwiZGlkV2FybkFib3V0VXNlV3JhcHBlZEluVHJ5Q2F0Y2giLCJudW1iZXJPZlJlUmVuZGVycyIsIlJFX1JFTkRFUl9MSU1JVCIsImxhc3RFZmZlY3QiLCJldmVudHMiLCJzdG9yZXMiLCJtZW1vQ2FjaGUiLCJIb29rc0Rpc3BhdGNoZXJPblJlcmVuZGVySW5ERVYiLCJUcmFuc2l0aW9uQXdhcmVIb3N0Q29tcG9uZW50IiwiZGlzcGF0Y2hlciIsIm1heWJlVGhlbmFibGUiLCJ1c2VTdGF0ZSIsInVzZVRoZW5hYmxlIiwiY2hlY2tEaWRSZW5kZXJJZEhvb2siLCJkaWRSZW5kZXJJZEhvb2siLCJsb2NhbElkQ291bnRlciIsImJhaWxvdXRIb29rcyIsInJlc2V0SG9va3NPblVud2luZCIsIm1vdW50V29ya0luUHJvZ3Jlc3NIb29rIiwiYmFzZVF1ZXVlIiwidXBkYXRlV29ya0luUHJvZ3Jlc3NIb29rIiwibmV4dEN1cnJlbnRIb29rIiwibmV4dFdvcmtJblByb2dyZXNzSG9vayIsInVzZSIsInVzYWJsZSIsInJlYWRDb250ZXh0IiwidXNlTWVtb0NhY2hlIiwiZGF0YSIsIm1hcCIsImNyZWF0ZUZ1bmN0aW9uQ29tcG9uZW50VXBkYXRlUXVldWUiLCJBcnJheSIsIlJFQUNUX01FTU9fQ0FDSEVfU0VOVElORUwiLCJiYXNpY1N0YXRlUmVkdWNlciIsImFjdGlvbiIsIm1vdW50UmVkdWNlciIsInJlZHVjZXIiLCJpbml0aWFsQXJnIiwiaW5pdCIsImluaXRpYWxTdGF0ZSIsImRpc3BhdGNoIiwibGFzdFJlbmRlcmVkUmVkdWNlciIsImxhc3RSZW5kZXJlZFN0YXRlIiwiZGlzcGF0Y2hSZWR1Y2VyQWN0aW9uIiwidXBkYXRlUmVkdWNlciIsInVwZGF0ZVJlZHVjZXJJbXBsIiwiYmFzZUZpcnN0IiwibmV3QmFzZVF1ZXVlRmlyc3QiLCJuZXdCYXNlUXVldWVMYXN0IiwicmV2ZXJ0TGFuZSIsImhhc0VhZ2VyU3RhdGUiLCJlYWdlclN0YXRlIiwicmVyZW5kZXJSZWR1Y2VyIiwibGFzdFJlbmRlclBoYXNlVXBkYXRlIiwibW91bnRTeW5jRXh0ZXJuYWxTdG9yZSIsInN1YnNjcmliZSIsImdldFNuYXBzaG90IiwiZ2V0U2VydmVyU25hcHNob3QiLCJuZXh0U25hcHNob3QiLCJkaWRXYXJuVW5jYWNoZWRHZXRTbmFwc2hvdCIsInB1c2hTdG9yZUNvbnNpc3RlbmN5Q2hlY2siLCJtb3VudEVmZmVjdCIsInN1YnNjcmliZVRvU3RvcmUiLCJwdXNoRWZmZWN0IiwiSGFzRWZmZWN0IiwiUGFzc2l2ZSIsInVwZGF0ZVN0b3JlSW5zdGFuY2UiLCJkZXN0cm95IiwidXBkYXRlU3luY0V4dGVybmFsU3RvcmUiLCJpc0h5ZHJhdGluZyRqc2NvbXAkMCIsImNhY2hlZFNuYXBzaG90IiwiY3JlYXRlIiwidXBkYXRlRWZmZWN0SW1wbCIsInJlbmRlcmVkU25hcHNob3QiLCJpbnN0IiwiY2hlY2tJZlNuYXBzaG90Q2hhbmdlZCIsImZvcmNlU3RvcmVSZXJlbmRlciIsImxhdGVzdEdldFNuYXBzaG90IiwibmV4dFZhbHVlIiwic2NoZWR1bGVVcGRhdGVPbkZpYmVyIiwibW91bnRTdGF0ZUltcGwiLCJpbml0aWFsU3RhdGVJbml0aWFsaXplciIsIm1vdW50U3RhdGUiLCJkaXNwYXRjaFNldFN0YXRlIiwibW91bnRPcHRpbWlzdGljIiwicGFzc3Rocm91Z2giLCJkaXNwYXRjaE9wdGltaXN0aWNTZXRTdGF0ZSIsInVwZGF0ZU9wdGltaXN0aWMiLCJ1cGRhdGVPcHRpbWlzdGljSW1wbCIsInJlcmVuZGVyT3B0aW1pc3RpYyIsImRpc3BhdGNoQWN0aW9uU3RhdGUiLCJhY3Rpb25RdWV1ZSIsInNldFBlbmRpbmdTdGF0ZSIsInNldFN0YXRlIiwiaXNSZW5kZXJQaGFzZVVwZGF0ZSIsImFjdGlvbk5vZGUiLCJpc1RyYW5zaXRpb24iLCJsaXN0ZW5lciIsIlQiLCJydW5BY3Rpb25TdGF0ZUFjdGlvbiIsInByZXZTdGF0ZSIsInByZXZUcmFuc2l0aW9uIiwiY3VycmVudFRyYW5zaXRpb24iLCJfdXBkYXRlZEZpYmVycyIsInJldHVyblZhbHVlIiwib25TdGFydFRyYW5zaXRpb25GaW5pc2giLCJTIiwiaGFuZGxlQWN0aW9uUmV0dXJuVmFsdWUiLCJvbkFjdGlvbkVycm9yIiwiZXJyb3IkMiIsIm9uQWN0aW9uU3VjY2VzcyIsIm5vdGlmeUFjdGlvbkxpc3RlbmVycyIsImxhc3QiLCJhY3Rpb25TdGF0ZVJlZHVjZXIiLCJvbGRTdGF0ZSIsIm1vdW50QWN0aW9uU3RhdGUiLCJpbml0aWFsU3RhdGVQcm9wIiwic3NyRm9ybVN0YXRlIiwiZm9ybVN0YXRlIiwiaXNNYXRjaGluZyIsIm1hcmtlckluc3RhbmNlIiwiY2FuSHlkcmF0ZUZvcm1TdGF0ZU1hcmtlciIsImlzRm9ybVN0YXRlTWFya2VyTWF0Y2hpbmciLCJ1cGRhdGVBY3Rpb25TdGF0ZSIsInN0YXRlSG9vayIsInVwZGF0ZUFjdGlvblN0YXRlSW1wbCIsImN1cnJlbnRTdGF0ZUhvb2siLCJhY3Rpb25RdWV1ZUhvb2siLCJhY3Rpb25TdGF0ZUFjdGlvbkVmZmVjdCIsInJlcmVuZGVyQWN0aW9uU3RhdGUiLCJtb3VudFJlZiIsImluaXRpYWxWYWx1ZSIsIm1vdW50RWZmZWN0SW1wbCIsImZpYmVyRmxhZ3MiLCJob29rRmxhZ3MiLCJtb3VudExheW91dEVmZmVjdCIsIkxheW91dCIsImltcGVyYXRpdmVIYW5kbGVFZmZlY3QiLCJyZWZDbGVhbnVwIiwibW91bnRJbXBlcmF0aXZlSGFuZGxlIiwidXBkYXRlSW1wZXJhdGl2ZUhhbmRsZSIsIm1vdW50Q2FsbGJhY2siLCJ1cGRhdGVDYWxsYmFjayIsIm1vdW50TWVtbyIsIm5leHRDcmVhdGUiLCJ1cGRhdGVNZW1vIiwibW91bnREZWZlcnJlZFZhbHVlIiwibW91bnREZWZlcnJlZFZhbHVlSW1wbCIsInVwZGF0ZURlZmVycmVkVmFsdWUiLCJ1cGRhdGVEZWZlcnJlZFZhbHVlSW1wbCIsInJlcmVuZGVyRGVmZXJyZWRWYWx1ZSIsInJlcXVlc3REZWZlcnJlZExhbmUiLCJwcmV2VmFsdWUiLCJzdGFydFRyYW5zaXRpb24iLCJwZW5kaW5nU3RhdGUiLCJmaW5pc2hlZFN0YXRlIiwicHJldmlvdXNQcmlvcml0eSIsImdldEN1cnJlbnRVcGRhdGVQcmlvcml0eSIsInNldEN1cnJlbnRVcGRhdGVQcmlvcml0eSIsInRoZW5hYmxlRm9yRmluaXNoZWRTdGF0ZSIsImRpc3BhdGNoU2V0U3RhdGVJbnRlcm5hbCIsInJlcXVlc3RVcGRhdGVMYW5lIiwiZW5zdXJlRm9ybUNvbXBvbmVudElzU3RhdGVmdWwiLCJmb3JtRmliZXIiLCJleGlzdGluZ1N0YXRlSG9vayIsImluaXRpYWxSZXNldFN0YXRlIiwibW91bnRUcmFuc2l0aW9uIiwidXBkYXRlVHJhbnNpdGlvbiIsImJvb2xlYW5PclRoZW5hYmxlIiwic3RhcnQiLCJyZXJlbmRlclRyYW5zaXRpb24iLCJ1c2VIb3N0VHJhbnNpdGlvblN0YXR1cyIsIm1vdW50SWQiLCJpZGVudGlmaWVyUHJlZml4IiwidHJlZUlkIiwiaWRXaXRoTGVhZGluZ0JpdCIsImdsb2JhbENsaWVudElkQ291bnRlciIsIm1vdW50UmVmcmVzaCIsInJlZnJlc2hDYWNoZSIsInNlZWRLZXkiLCJwcm92aWRlciIsImNyZWF0ZUNhY2hlIiwiY2FjaGUiLCJKU0NvbXBpbGVyX09wdGltaXplQXJndW1lbnRzQXJyYXlfcDAiLCJlbnF1ZXVlUmVuZGVyUGhhc2VVcGRhdGUiLCJlbnRhbmdsZVRyYW5zaXRpb25VcGRhdGUiLCJKU0NvbXBpbGVyX09wdGltaXplQXJndW1lbnRzQXJyYXlfcDEiLCJwcmV2RGlzcGF0Y2hlciIsIkludmFsaWROZXN0ZWRIb29rc0Rpc3BhdGNoZXJPblVwZGF0ZUluREVWIiwiY3VycmVudFN0YXRlIiwidGhyb3dJZkR1cmluZ1JlbmRlciIsIndhcm5PbkludmFsaWRDYWxsYmFjayIsImRpZFdhcm5PbkludmFsaWRDYWxsYmFjayIsImFwcGx5RGVyaXZlZFN0YXRlRnJvbVByb3BzIiwiY3RvciIsImdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyIsImRpZFdhcm5BYm91dFVuZGVmaW5lZERlcml2ZWRTdGF0ZSIsImNoZWNrU2hvdWxkQ29tcG9uZW50VXBkYXRlIiwib2xkUHJvcHMiLCJuZXdQcm9wcyIsInNob3VsZENvbXBvbmVudFVwZGF0ZSIsImlzUHVyZVJlYWN0Q29tcG9uZW50IiwiY2FsbENvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMiLCJjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzIiwiVU5TQUZFX2NvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMiLCJkaWRXYXJuQWJvdXRTdGF0ZUFzc2lnbm1lbnRGb3JDb21wb25lbnQiLCJjbGFzc0NvbXBvbmVudFVwZGF0ZXIiLCJlbnF1ZXVlUmVwbGFjZVN0YXRlIiwicmVzb2x2ZUNsYXNzQ29tcG9uZW50UHJvcHMiLCJiYXNlUHJvcHMiLCJkZWZhdWx0UHJvcHMiLCJsb2dVbmNhdWdodEVycm9yIiwiZXJyb3JJbmZvIiwiZXJyb3JCb3VuZGFyeU5hbWUiLCJ0aHJvd25FcnJvcnMiLCJvblVuY2F1Z2h0RXJyb3IiLCJjb21wb25lbnRTdGFjayIsImUiLCJzZXRUaW1lb3V0IiwibG9nQ2F1Z2h0RXJyb3IiLCJib3VuZGFyeSIsIm9uQ2F1Z2h0RXJyb3IiLCJlcnJvckJvdW5kYXJ5IiwiY3JlYXRlUm9vdEVycm9yVXBkYXRlIiwiY3JlYXRlQ2xhc3NFcnJvclVwZGF0ZSIsImluaXRpYWxpemVDbGFzc0Vycm9yVXBkYXRlIiwiZ2V0RGVyaXZlZFN0YXRlRnJvbUVycm9yIiwibWFya0ZhaWxlZEVycm9yQm91bmRhcnlGb3JIb3RSZWxvYWRpbmciLCJjb21wb25lbnREaWRDYXRjaCIsImxlZ2FjeUVycm9yQm91bmRhcmllc1RoYXRBbHJlYWR5RmFpbGVkIiwiY2FsbENvbXBvbmVudERpZENhdGNoSW5ERVYiLCJ0aHJvd0V4Y2VwdGlvbiIsInJvb3RSZW5kZXJMYW5lcyIsInJlc3RvcmVQZW5kaW5nVXBkYXRlcnMiLCJwcm9wYWdhdGVQYXJlbnRDb250ZXh0Q2hhbmdlcyIsInJlbmRlckRpZFN1c3BlbmREZWxheUlmUG9zc2libGUiLCJ3b3JrSW5Qcm9ncmVzc1Jvb3RFeGl0U3RhdHVzIiwiUm9vdEluUHJvZ3Jlc3MiLCJSb290U3VzcGVuZGVkIiwibm9vcFN1c3BlbnNleUNvbW1pdFRoZW5hYmxlIiwiYXR0YWNoUGluZ0xpc3RlbmVyIiwidHJhbnNpdGlvbnMiLCJtYXJrZXJJbnN0YW5jZXMiLCJyZXRyeVF1ZXVlIiwiY2F1c2UiLCJSb290U3VzcGVuZGVkV2l0aERlbGF5IiwiUm9vdEVycm9yZWQiLCJ3b3JrSW5Qcm9ncmVzc1Jvb3RDb25jdXJyZW50RXJyb3JzIiwicmVjb25jaWxlQ2hpbGRyZW4iLCJuZXh0Q2hpbGRyZW4iLCJtb3VudENoaWxkRmliZXJzIiwicmVjb25jaWxlQ2hpbGRGaWJlcnMiLCJ1cGRhdGVGb3J3YXJkUmVmIiwicHJvcHNXaXRob3V0UmVmIiwicHJlcGFyZVRvUmVhZENvbnRleHQiLCJiYWlsb3V0T25BbHJlYWR5RmluaXNoZWRXb3JrIiwidXBkYXRlTWVtb0NvbXBvbmVudCIsInNob3VsZENvbnN0cnVjdCIsImNvbXBhcmUiLCJyZXNvbHZlRnVuY3Rpb25Gb3JIb3RSZWxvYWRpbmciLCJ2YWxpZGF0ZUZ1bmN0aW9uQ29tcG9uZW50SW5EZXYiLCJ1cGRhdGVTaW1wbGVNZW1vQ29tcG9uZW50IiwiY3JlYXRlRmliZXJGcm9tVHlwZUFuZFByb3BzIiwiY2hlY2tTY2hlZHVsZWRVcGRhdGVPckNvbnRleHQiLCJwcmV2UHJvcHMiLCJ1cGRhdGVGdW5jdGlvbkNvbXBvbmVudCIsInVwZGF0ZU9mZnNjcmVlbkNvbXBvbmVudCIsIm5leHRJc0RldGFjaGVkIiwiX3BlbmRpbmdWaXNpYmlsaXR5IiwibWFya1JlZiIsImRlZmVySGlkZGVuT2Zmc2NyZWVuQ29tcG9uZW50IiwiY2FjaGVQb29sIiwicHVzaFRyYW5zaXRpb24iLCJuZXh0QmFzZUxhbmVzIiwicGVla0NhY2hlRnJvbVBvb2wiLCJDYWNoZUNvbnRleHQiLCJwb29sIiwiZGlkV2FybkFib3V0QmFkQ2xhc3MiLCJSZWFjdFN0cmljdE1vZGVXYXJuaW5ncyIsInJlY29yZExlZ2FjeUNvbnRleHRXYXJuaW5nIiwiY29udGV4dFR5cGVzIiwiZGlkV2FybkFib3V0Q29udGV4dFR5cGVzIiwicmVwbGF5RnVuY3Rpb25Db21wb25lbnQiLCJ1cGRhdGVDbGFzc0NvbXBvbmVudCIsImN1cnJlbnQkanNjb21wJDAiLCJfaW5zdGFuY2UiLCJ1cGRhdGVyIiwiZW5xdWV1ZVNldFN0YXRlIiwiY29udGV4dFR5cGUiLCJkaWRXYXJuQWJvdXRJbnZhbGlkYXRlQ29udGV4dFR5cGUiLCJfcmVhY3RJbnRlcm5hbHMiLCJfcmVhY3RJbnRlcm5hbEluc3RhbmNlIiwiZmFrZUludGVybmFsSW5zdGFuY2UiLCJkaWRXYXJuQWJvdXRVbmluaXRpYWxpemVkU3RhdGUiLCJnZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZSIsImZvdW5kV2lsbFVwZGF0ZU5hbWUiLCJjb21wb25lbnRXaWxsTW91bnQiLCJfX3N1cHByZXNzRGVwcmVjYXRpb25XYXJuaW5nIiwiVU5TQUZFX2NvbXBvbmVudFdpbGxNb3VudCIsImNvbXBvbmVudFdpbGxVcGRhdGUiLCJVTlNBRkVfY29tcG9uZW50V2lsbFVwZGF0ZSIsIm5ld0FwaU5hbWUiLCJkaWRXYXJuQWJvdXRMZWdhY3lMaWZlY3ljbGVzQW5kRGVyaXZlZFN0YXRlIiwiZ2V0SW5pdGlhbFN0YXRlIiwiaXNSZWFjdENsYXNzQXBwcm92ZWQiLCJnZXREZWZhdWx0UHJvcHMiLCJjaGlsZENvbnRleHRUeXBlcyIsImRpZFdhcm5BYm91dENoaWxkQ29udGV4dFR5cGVzIiwiZGlkV2FybkFib3V0Q29udGV4dFR5cGVzJDEiLCJjb21wb25lbnRTaG91bGRVcGRhdGUiLCJjb21wb25lbnREaWRVbm1vdW50IiwiY29tcG9uZW50RGlkUmVjZWl2ZVByb3BzIiwiY29tcG9uZW50V2lsbFJlY2lldmVQcm9wcyIsIlVOU0FGRV9jb21wb25lbnRXaWxsUmVjaWV2ZVByb3BzIiwiY29tcG9uZW50RGlkVXBkYXRlIiwiZGlkV2FybkFib3V0R2V0U25hcHNob3RCZWZvcmVVcGRhdGVXaXRob3V0RGlkVXBkYXRlIiwiZ2V0Q2hpbGRDb250ZXh0IiwicmVmcyIsImRpZFdhcm5BYm91dERpcmVjdGx5QXNzaWduaW5nUHJvcHNUb1N0YXRlIiwicmVjb3JkVW5zYWZlTGlmZWN5Y2xlV2FybmluZ3MiLCJjb21wb25lbnREaWRNb3VudCIsInVucmVzb2x2ZWRPbGRQcm9wcyIsIm9sZENvbnRleHQiLCJjYWxsUmVuZGVySW5ERVYiLCJkaWRXYXJuQWJvdXRSZWFzc2lnbmluZ1Byb3BzIiwibW91bnRIb3N0Um9vdFdpdGhvdXRIeWRyYXRpbmciLCJkaWRXYXJuQWJvdXRHZXREZXJpdmVkU3RhdGVPbkZ1bmN0aW9uQ29tcG9uZW50IiwiZGlkV2FybkFib3V0Q29udGV4dFR5cGVPbkZ1bmN0aW9uQ29tcG9uZW50IiwibW91bnRTdXNwZW5zZU9mZnNjcmVlblN0YXRlIiwiZ2V0U3VzcGVuZGVkQ2FjaGUiLCJnZXRSZW1haW5pbmdXb3JrSW5QcmltYXJ5VHJlZSIsInByaW1hcnlUcmVlRGlkRGVmZXIiLCJ3b3JrSW5Qcm9ncmVzc0RlZmVycmVkTGFuZSIsInVwZGF0ZVN1c3BlbnNlQ29tcG9uZW50Iiwic2hvd0ZhbGxiYWNrIiwiZGlkU3VzcGVuZCIsIkpTQ29tcGlsZXJfdGVtcCIsIkZvcmNlU3VzcGVuc2VGYWxsYmFjayIsIm5leHRJbnN0YW5jZSIsIkpTQ29tcGlsZXJfdGVtcCRqc2NvbXAkMCIsImNhbkh5ZHJhdGVTdXNwZW5zZUluc3RhbmNlIiwidHJlZUNvbnRleHQiLCJvdmVyZmxvdyIsInJldHJ5TGFuZSIsImZhbGxiYWNrIiwibW91bnRXb3JrSW5Qcm9ncmVzc09mZnNjcmVlbkZpYmVyIiwiU1VTUEVOREVEX01BUktFUiIsIm1vdW50U3VzcGVuc2VQcmltYXJ5Q2hpbGRyZW4iLCJyZXRyeVN1c3BlbnNlQ29tcG9uZW50V2l0aG91dEh5ZHJhdGluZyIsImdldFN1c3BlbnNlSW5zdGFuY2VGYWxsYmFja0Vycm9yRGV0YWlscyIsImRpZ2VzdCIsIlNlbGVjdGl2ZUh5ZHJhdGlvbkV4Y2VwdGlvbiIsInJldHJ5RGVoeWRyYXRlZFN1c3BlbnNlQm91bmRhcnkiLCJyZWdpc3RlclN1c3BlbnNlSW5zdGFuY2VSZXRyeSIsImdldEZpcnN0SHlkcmF0YWJsZUNoaWxkV2l0aGluU3VzcGVuc2VJbnN0YW5jZSIsInN1YnRyZWVGbGFncyIsInByaW1hcnlDaGlsZHJlbiIsIm9mZnNjcmVlblByb3BzIiwiY3JlYXRlRmliZXJGcm9tT2Zmc2NyZWVuIiwic2NoZWR1bGVTdXNwZW5zZVdvcmtPbkZpYmVyIiwicHJvcGFnYXRpb25Sb290Iiwic2NoZWR1bGVDb250ZXh0V29ya09uUGFyZW50UGF0aCIsInZhbGlkYXRlU3VzcGVuc2VMaXN0TmVzdGVkQ2hpbGQiLCJjaGlsZFNsb3QiLCJpc0FuQXJyYXkiLCJpbml0U3VzcGVuc2VMaXN0UmVuZGVyU3RhdGUiLCJpc0JhY2t3YXJkcyIsInRhaWwiLCJsYXN0Q29udGVudFJvdyIsInRhaWxNb2RlIiwicmVuZGVyU3RhdGUiLCJyZW5kZXJpbmciLCJyZW5kZXJpbmdTdGFydFRpbWUiLCJ1cGRhdGVTdXNwZW5zZUxpc3RDb21wb25lbnQiLCJkaWRXYXJuQWJvdXRSZXZlYWxPcmRlciIsImRpZFdhcm5BYm91dFRhaWxPcHRpb25zIiwiX2kiLCJhdHRlbXB0RWFybHlCYWlsb3V0SWZOb1NjaGVkdWxlZFVwZGF0ZSIsInB1c2hQcm92aWRlciIsImVmZmVjdER1cmF0aW9uIiwicGFzc2l2ZUVmZmVjdER1cmF0aW9uIiwiZGlkU3VzcGVuZEJlZm9yZSIsImJlZ2luV29yayIsIl9kZWJ1Z05lZWRzUmVtb3VudCIsInByZXZTaWJsaW5nIiwicmVzb2x2ZUZvcndhcmRSZWZGb3JIb3RSZWxvYWRpbmciLCJwcm9wYWdhdGVDb250ZXh0Q2hhbmdlcyIsImlzRGVoeWRyYXRlZCIsImdldEZpcnN0SHlkcmF0YWJsZUNoaWxkV2l0aGluQ29udGFpbmVyIiwic3VwcG9ydHNSZXNvdXJjZXMiLCJnZXRSZXNvdXJjZSIsImNyZWF0ZUhvaXN0YWJsZUluc3RhbmNlIiwicmVzb2x2ZVNpbmdsZXRvbkluc3RhbmNlIiwiZGlmZkh5ZHJhdGVkUHJvcHNGb3JEZXZXYXJuaW5ncyIsImdldEZpcnN0SHlkcmF0YWJsZUNoaWxkIiwidmFsaWRhdGVIeWRyYXRhYmxlSW5zdGFuY2UiLCJjYW5IeWRyYXRlSW5zdGFuY2UiLCJ2YWxpZGF0ZUh5ZHJhdGFibGVUZXh0SW5zdGFuY2UiLCJjYW5IeWRyYXRlVGV4dEluc3RhbmNlIiwiaGFzV2FybmVkQWJvdXRVc2luZ05vVmFsdWVQcm9wT25Db250ZXh0UHJvdmlkZXIiLCJwb29sZWRDYWNoZSIsInJldGFpbkNhY2hlIiwicG9vbGVkQ2FjaGVMYW5lcyIsInJlc2V0Q29udGV4dERlcGVuZGVuY2llcyIsImxhc3RDb250ZXh0RGVwZW5kZW5jeSIsImN1cnJlbnRseVJlbmRlcmluZ0ZpYmVyIiwicHJvdmlkZXJGaWJlciIsInZhbHVlQ3Vyc29yIiwicmVuZGVyZXJDdXJzb3JERVYiLCJfY3VycmVudFJlbmRlcmVyIiwicmVuZGVyZXJTaWdpbCIsInJlbmRlcmVyMkN1cnNvckRFViIsIl9jdXJyZW50UmVuZGVyZXIyIiwicG9wUHJvdmlkZXIiLCJjdXJyZW50VmFsdWUiLCJjb250ZXh0cyIsImZvcmNlUHJvcGFnYXRlRW50aXJlVHJlZSIsImxpc3QiLCJuZXh0RmliZXIiLCJkZXBlbmRlbmN5IiwiaXNJbnNpZGVQcm9wYWdhdGlvbkJhaWxvdXQiLCJjdXJyZW50UGFyZW50IiwiY3VycmVudERlcGVuZGVuY2llcyIsIm1lbW9pemVkVmFsdWUiLCJyZWFkQ29udGV4dEZvckNvbnN1bWVyIiwiY29uc3VtZXIiLCJjb250cm9sbGVyIiwiQWJvcnRDb250cm9sbGVyTG9jYWwiLCJyZWZDb3VudCIsInNpZ25hbCIsImFib3J0ZWQiLCJyZWxlYXNlQ2FjaGUiLCJzY2hlZHVsZUNhbGxiYWNrJDEiLCJOb3JtYWxQcmlvcml0eSIsImFib3J0IiwiY2FjaGVSZXN1bWVkRnJvbVByZXZpb3VzUmVuZGVyIiwicmVzdW1lZENhY2hlIiwib2Zmc2NyZWVuV29ya0luUHJvZ3Jlc3MiLCJwcmV2Q2FjaGVQb29sIiwiY2FjaGVGcm9tUG9vbCIsIm1hcmtVcGRhdGUiLCJkb2VzUmVxdWlyZUNsb25lIiwiY29tcGxldGVkV29yayIsImFwcGVuZEFsbENoaWxkcmVuIiwibmVlZHNWaXNpYmlsaXR5VG9nZ2xlIiwic3VwcG9ydHNNdXRhdGlvbiIsImFwcGVuZEluaXRpYWxDaGlsZCIsInN1cHBvcnRzUGVyc2lzdGVuY2UiLCJfbm9kZSIsImNsb25lSGlkZGVuSW5zdGFuY2UiLCJjbG9uZUhpZGRlblRleHRJbnN0YW5jZSIsImFwcGVuZEFsbENoaWxkcmVuVG9Db250YWluZXIiLCJjb250YWluZXJDaGlsZFNldCIsImFwcGVuZENoaWxkVG9Db250YWluZXJDaGlsZFNldCIsInVwZGF0ZUhvc3RDb250YWluZXIiLCJjb250YWluZXIiLCJuZXdDaGlsZFNldCIsImNyZWF0ZUNvbnRhaW5lckNoaWxkU2V0IiwicGVuZGluZ0NoaWxkcmVuIiwiZmluYWxpemVDb250YWluZXJDaGlsZHJlbiIsInVwZGF0ZUhvc3RDb21wb25lbnQiLCJjdXJyZW50SW5zdGFuY2UiLCJfb2xkUHJvcHMiLCJjdXJyZW50SG9zdENvbnRleHQiLCJjbG9uZUluc3RhbmNlIiwiZmluYWxpemVJbml0aWFsQ2hpbGRyZW4iLCJwcmVsb2FkSW5zdGFuY2VBbmRTdXNwZW5kSWZOZWVkZWQiLCJtYXlTdXNwZW5kQ29tbWl0IiwicHJlbG9hZEluc3RhbmNlIiwic2hvdWxkUmVtYWluT25QcmV2aW91c1NjcmVlbiIsIlN1c3BlbnNleUNvbW1pdEV4Y2VwdGlvbiIsInByZWxvYWRSZXNvdXJjZUFuZFN1c3BlbmRJZk5lZWRlZCIsInJlc291cmNlIiwibWF5UmVzb3VyY2VTdXNwZW5kQ29tbWl0IiwicHJlbG9hZFJlc291cmNlIiwic2NoZWR1bGVSZXRyeUVmZmVjdCIsIndvcmtJblByb2dyZXNzU3VzcGVuZGVkUmV0cnlMYW5lcyIsImN1dE9mZlRhaWxJZk5lZWRlZCIsImhhc1JlbmRlcmVkQVRhaWxGYWxsYmFjayIsImxhc3RUYWlsTm9kZSIsIl9sYXN0VGFpbE5vZGUiLCJidWJibGVQcm9wZXJ0aWVzIiwiZGlkQmFpbG91dCIsIm5ld0NoaWxkTGFuZXMiLCJfdHJlZUJhc2VEdXJhdGlvbiIsIl9jaGlsZDIiLCJ0cmVlQmFzZUR1cmF0aW9uIiwiY29tcGxldGVXb3JrIiwicGVuZGluZ0NvbnRleHQiLCJxdWV1ZVJlY292ZXJhYmxlRXJyb3JzIiwibmV4dFJlc291cmNlIiwiY3JlYXRlSW5zdGFuY2UiLCJjcmVhdGVUZXh0SW5zdGFuY2UiLCJkaWZmSHlkcmF0ZWRUZXh0Rm9yRGV2V2FybmluZ3MiLCJoeWRyYXRlVGV4dEluc3RhbmNlIiwiaHlkcmF0ZVN1c3BlbnNlSW5zdGFuY2UiLCJwcmVwYXJlUG9ydGFsTW91bnQiLCJyZXNldFdvcmtJblByb2dyZXNzIiwid29ya0luUHJvZ3Jlc3NSb290UmVuZGVyVGFyZ2V0VGltZSIsInVud2luZFdvcmsiLCJ1bndpbmRJbnRlcnJ1cHRlZFdvcmsiLCJpbnRlcnJ1cHRlZFdvcmsiLCJzaG91bGRQcm9maWxlIiwiY29tbWl0SG9va0xheW91dEVmZmVjdHMiLCJmaW5pc2hlZFdvcmsiLCJjb21taXRIb29rRWZmZWN0TGlzdE1vdW50IiwiY29tbWl0SG9va0xheW91dFVubW91bnRFZmZlY3RzIiwibmVhcmVzdE1vdW50ZWRBbmNlc3RvciIsImNvbW1pdEhvb2tFZmZlY3RMaXN0VW5tb3VudCIsImZpcnN0RWZmZWN0IiwiTm9GbGFncyIsIm1hcmtDb21wb25lbnRQYXNzaXZlRWZmZWN0TW91bnRTdGFydGVkIiwibWFya0NvbXBvbmVudExheW91dEVmZmVjdE1vdW50U3RhcnRlZCIsIkluc2VydGlvbiIsImlzUnVubmluZ0luc2VydGlvbkVmZmVjdCIsImNhbGxDcmVhdGVJbkRFViIsIm1hcmtDb21wb25lbnRQYXNzaXZlRWZmZWN0TW91bnRTdG9wcGVkIiwibWFya0NvbXBvbmVudExheW91dEVmZmVjdE1vdW50U3RvcHBlZCIsImFkZGVuZHVtIiwibiIsImNhcHR1cmVDb21taXRQaGFzZUVycm9yIiwibWFya0NvbXBvbmVudFBhc3NpdmVFZmZlY3RVbm1vdW50U3RhcnRlZCIsIm1hcmtDb21wb25lbnRMYXlvdXRFZmZlY3RVbm1vdW50U3RhcnRlZCIsImNhbGxEZXN0cm95SW5ERVYiLCJtYXJrQ29tcG9uZW50UGFzc2l2ZUVmZmVjdFVubW91bnRTdG9wcGVkIiwibWFya0NvbXBvbmVudExheW91dEVmZmVjdFVubW91bnRTdG9wcGVkIiwiY29tbWl0SG9va1Bhc3NpdmVNb3VudEVmZmVjdHMiLCJjb21taXRIb29rUGFzc2l2ZVVubW91bnRFZmZlY3RzIiwiY29tbWl0Q2xhc3NDYWxsYmFja3MiLCJjYWxsR2V0U25hcHNob3RCZWZvcmVVcGRhdGVzIiwiY29tbWl0Q2xhc3NTbmFwc2hvdCIsInJlc29sdmVkUHJldlByb3BzIiwic25hcHNob3QiLCJkaWRXYXJuQWJvdXRVbmRlZmluZWRTbmFwc2hvdEJlZm9yZVVwZGF0ZSIsIl9fcmVhY3RJbnRlcm5hbFNuYXBzaG90QmVmb3JlVXBkYXRlIiwic2FmZWx5Q2FsbENvbXBvbmVudFdpbGxVbm1vdW50IiwiY2FsbENvbXBvbmVudFdpbGxVbm1vdW50SW5ERVYiLCJjb21taXRBdHRhY2hSZWYiLCJnZXRQdWJsaWNJbnN0YW5jZSIsInNhZmVseUF0dGFjaFJlZiIsInNhZmVseURldGFjaFJlZiIsImVycm9yJDMiLCJjb21taXRQcm9maWxlciIsImNvbW1pdFN0YXJ0VGltZSIsIl9maW5pc2hlZFdvcmskbWVtb2l6ZSIsIm9uQ29tbWl0Iiwib25SZW5kZXIiLCJjb21taXRQcm9maWxlclBvc3RDb21taXRJbXBsIiwiX2ZpbmlzaGVkV29yayRtZW1vaXplMiIsIm9uUG9zdENvbW1pdCIsImNvbW1pdEhvc3RNb3VudCIsImNvbW1pdE1vdW50IiwiY29tbWl0SG9zdFVwZGF0ZSIsImNvbW1pdFVwZGF0ZSIsImlzSG9zdFBhcmVudCIsImdldEhvc3RTaWJsaW5nIiwiaW5zZXJ0T3JBcHBlbmRQbGFjZW1lbnROb2RlSW50b0NvbnRhaW5lciIsImJlZm9yZSIsImluc2VydEluQ29udGFpbmVyQmVmb3JlIiwiYXBwZW5kQ2hpbGRUb0NvbnRhaW5lciIsImluc2VydE9yQXBwZW5kUGxhY2VtZW50Tm9kZSIsImluc2VydEJlZm9yZSIsImFwcGVuZENoaWxkIiwiY29tbWl0UGxhY2VtZW50IiwicGFyZW50RmliZXIiLCJyZXNldFRleHRDb250ZW50IiwiY29tbWl0SG9zdFBvcnRhbENvbnRhaW5lckNoaWxkcmVuIiwicmVwbGFjZUNvbnRhaW5lckNoaWxkcmVuIiwiY29tbWl0QmVmb3JlTXV0YXRpb25FZmZlY3RzIiwiZmlyc3RDaGlsZCIsInByZXBhcmVGb3JDb21taXQiLCJuZXh0RWZmZWN0IiwiY2xlYXJDb250YWluZXIiLCJzaG91bGRGaXJlQWZ0ZXJBY3RpdmVJbnN0YW5jZUJsdXIiLCJjb21taXRMYXlvdXRFZmZlY3RPbkZpYmVyIiwiZmluaXNoZWRSb290IiwicmVjdXJzaXZlbHlUcmF2ZXJzZUxheW91dEVmZmVjdHMiLCJjYWxsQ29tcG9uZW50RGlkTW91bnRJbkRFViIsImNhbGxDb21wb25lbnREaWRVcGRhdGVJbkRFViIsImNvbW1pdFN1c3BlbnNlSHlkcmF0aW9uQ2FsbGJhY2tzIiwib2Zmc2NyZWVuU3VidHJlZUlzSGlkZGVuIiwib2Zmc2NyZWVuU3VidHJlZVdhc0hpZGRlbiIsInByZXZPZmZzY3JlZW5TdWJ0cmVlSXNIaWRkZW4iLCJwcmV2T2Zmc2NyZWVuU3VidHJlZVdhc0hpZGRlbiIsInJlY3Vyc2l2ZWx5VHJhdmVyc2VSZWFwcGVhckxheW91dEVmZmVjdHMiLCJkZXRhY2hGaWJlckFmdGVyRWZmZWN0cyIsImRldGFjaERlbGV0ZWRJbnN0YW5jZSIsInJlY3Vyc2l2ZWx5VHJhdmVyc2VEZWxldGlvbkVmZmVjdHMiLCJjb21taXREZWxldGlvbkVmZmVjdHNPbkZpYmVyIiwiZGVsZXRlZEZpYmVyIiwib25Db21taXRGaWJlclVubW91bnQiLCJyZWxlYXNlUmVzb3VyY2UiLCJ1bm1vdW50SG9pc3RhYmxlIiwicHJldkhvc3RQYXJlbnQiLCJob3N0UGFyZW50IiwicHJldkhvc3RQYXJlbnRJc0NvbnRhaW5lciIsImhvc3RQYXJlbnRJc0NvbnRhaW5lciIsInJlbGVhc2VTaW5nbGV0b25JbnN0YW5jZSIsInJlbW92ZUNoaWxkRnJvbUNvbnRhaW5lciIsInJlbW92ZUNoaWxkIiwiY2xlYXJTdXNwZW5zZUJvdW5kYXJ5RnJvbUNvbnRhaW5lciIsImNsZWFyU3VzcGVuc2VCb3VuZGFyeSIsImNvbXBvbmVudFdpbGxVbm1vdW50IiwiY29tbWl0SHlkcmF0ZWRTdXNwZW5zZUluc3RhbmNlIiwiZ2V0UmV0cnlDYWNoZSIsInJldHJ5Q2FjaGUiLCJQb3NzaWJseVdlYWtTZXQiLCJfcmV0cnlDYWNoZSIsImF0dGFjaFN1c3BlbnNlUmV0cnlMaXN0ZW5lcnMiLCJ3YWtlYWJsZXMiLCJ3YWtlYWJsZSIsInJldHJ5IiwicmVzb2x2ZVJldHJ5V2FrZWFibGUiLCJpblByb2dyZXNzTGFuZXMiLCJpblByb2dyZXNzUm9vdCIsImNvbW1pdE11dGF0aW9uRWZmZWN0cyIsImNvbW1pdHRlZExhbmVzIiwiY29tbWl0TXV0YXRpb25FZmZlY3RzT25GaWJlciIsInJlY3Vyc2l2ZWx5VHJhdmVyc2VNdXRhdGlvbkVmZmVjdHMiLCJyb290JGpzY29tcCQwIiwiY29tbWl0UmVjb25jaWxpYXRpb25FZmZlY3RzIiwiaG9pc3RhYmxlUm9vdCIsImN1cnJlbnRIb2lzdGFibGVSb290IiwiaHlkcmF0ZUhvaXN0YWJsZSIsIm1vdW50SG9pc3RhYmxlIiwiYWNxdWlyZVJlc291cmNlIiwiY2xlYXJTaW5nbGV0b24iLCJhY3F1aXJlU2luZ2xldG9uSW5zdGFuY2UiLCJuZWVkc0Zvcm1SZXNldCIsImNvbW1pdFRleHRVcGRhdGUiLCJwcmVwYXJlVG9Db21taXRIb2lzdGFibGVzIiwiZ2V0SG9pc3RhYmxlUm9vdCIsImNvbW1pdEh5ZHJhdGVkQ29udGFpbmVyIiwicmVjdXJzaXZlbHlSZXNldEZvcm1zIiwiZ2xvYmFsTW9zdFJlY2VudEZhbGxiYWNrVGltZSIsIndhc0hpZGRlbiIsIl9jdXJyZW50IiwicmVjdXJzaXZlbHlUcmF2ZXJzZURpc2FwcGVhckxheW91dEVmZmVjdHMiLCJoaWRlSW5zdGFuY2UiLCJ1bmhpZGVJbnN0YW5jZSIsImhpZGVUZXh0SW5zdGFuY2UiLCJ1bmhpZGVUZXh0SW5zdGFuY2UiLCJyZXNldEZvcm1JbnN0YW5jZSIsImNvbW1pdExheW91dEVmZmVjdHMiLCJkaXNhcHBlYXJMYXlvdXRFZmZlY3RzIiwicmVhcHBlYXJMYXlvdXRFZmZlY3RzIiwiaW5jbHVkZVdvcmtJblByb2dyZXNzRWZmZWN0cyIsImNvbW1pdE9mZnNjcmVlblBhc3NpdmVNb3VudEVmZmVjdHMiLCJwcmV2aW91c0NhY2hlIiwiY29tbWl0Q2FjaGVQYXNzaXZlTW91bnRFZmZlY3QiLCJyZWN1cnNpdmVseVRyYXZlcnNlUGFzc2l2ZU1vdW50RWZmZWN0cyIsImNvbW1pdHRlZFRyYW5zaXRpb25zIiwiY29tbWl0UGFzc2l2ZU1vdW50T25GaWJlciIsInJlY3Vyc2l2ZWx5VHJhdmVyc2VBdG9taWNQYXNzaXZlRWZmZWN0cyIsInJlY3Vyc2l2ZWx5VHJhdmVyc2VSZWNvbm5lY3RQYXNzaXZlRWZmZWN0cyIsInJlY29ubmVjdFBhc3NpdmVFZmZlY3RzIiwiX2luc3RhbmNlMiIsImZpbmlzaGVkUm9vdCRqc2NvbXAkMCIsInJlY3Vyc2l2ZWx5QWNjdW11bGF0ZVN1c3BlbnNleUNvbW1pdCIsInN1c3BlbnNleUNvbW1pdEZsYWciLCJhY2N1bXVsYXRlU3VzcGVuc2V5Q29tbWl0T25GaWJlciIsInN1c3BlbmRSZXNvdXJjZSIsInN1c3BlbmRJbnN0YW5jZSIsInByZXZpb3VzSG9pc3RhYmxlUm9vdCIsImRldGFjaEFsdGVybmF0ZVNpYmxpbmdzIiwicmVjdXJzaXZlbHlUcmF2ZXJzZVBhc3NpdmVVbm1vdW50RWZmZWN0cyIsImNvbW1pdFBhc3NpdmVVbm1vdW50RWZmZWN0c0luc2lkZU9mRGVsZXRlZFRyZWVfYmVnaW4iLCJjb21taXRQYXNzaXZlVW5tb3VudE9uRmliZXIiLCJyZWN1cnNpdmVseVRyYXZlcnNlRGlzY29ubmVjdFBhc3NpdmVFZmZlY3RzIiwiZGlzY29ubmVjdFBhc3NpdmVFZmZlY3QiLCJkZWxldGVkU3VidHJlZVJvb3QiLCJmaW5kRmliZXJSb290Rm9ySG9zdFJvb3QiLCJob3N0Um9vdCIsIm1heWJlRmliZXIiLCJnZXRJbnN0YW5jZUZyb21Ob2RlIiwiZmluZEZpYmVyUm9vdCIsIm1hdGNoU2VsZWN0b3IiLCJmaWJlciRqc2NvbXAkMCIsInNlbGVjdG9yIiwiQ09NUE9ORU5UX1RZUEUiLCJIQVNfUFNFVURPX0NMQVNTX1RZUEUiLCJ0YWckanNjb21wJDAiLCJzZWxlY3RvckluZGV4Iiwic2VsZWN0b3IkanNjb21wJDAiLCJpc0hpZGRlblN1YnRyZWUiLCJST0xFX1RZUEUiLCJtYXRjaEFjY2Vzc2liaWxpdHlSb2xlIiwiVEVYVF9UWVBFIiwiZ2V0VGV4dENvbnRlbnQiLCJURVNUX05BTUVfVFlQRSIsInNlbGVjdG9yVG9TdHJpbmciLCJmaW5kUGF0aHMiLCJzZWxlY3RvcnMiLCJtYXRjaGluZ0ZpYmVycyIsImZpbmRBbGxOb2RlcyIsInN1cHBvcnRzVGVzdFNlbGVjdG9ycyIsImZyb20iLCJvbkNvbW1pdFJvb3QiLCJjb21taXRIb29rcyIsImNvbW1pdEhvb2siLCJpc0NvbmN1cnJlbnRBY3RFbnZpcm9ubWVudCIsImlzUmVhY3RBY3RFbnZpcm9ubWVudEdsb2JhbCIsIklTX1JFQUNUX0FDVF9FTlZJUk9OTUVOVCIsInJlc29sdmVVcGRhdGVQcmlvcml0eSIsInN1c3BlbnNlSGFuZGxlciIsImlzRmx1c2hpbmdQYXNzaXZlRWZmZWN0cyIsImRpZFNjaGVkdWxlVXBkYXRlRHVyaW5nUGFzc2l2ZUVmZmVjdHMiLCJwcmVwYXJlRnJlc2hTdGFjayIsIm1hcmtSb290U3VzcGVuZGVkIiwiZGlkV2FybkFib3V0VXBkYXRlSW5SZW5kZXJGb3JBbm90aGVyQ29tcG9uZW50IiwiZGlkV2FybkFib3V0VXBkYXRlSW5SZW5kZXIiLCJ3YXJuSWZVcGRhdGVzTm90V3JhcHBlZFdpdGhBY3RERVYiLCJ3b3JrSW5Qcm9ncmVzc1Jvb3RJbnRlcmxlYXZlZFVwZGF0ZWRMYW5lcyIsImZvcmNlU3luYyIsInNob3VsZFRpbWVTbGljZSIsImV4aXRTdGF0dXMiLCJyZW5kZXJSb290Q29uY3VycmVudCIsInJlbmRlclJvb3RTeW5jIiwicmVuZGVyV2FzQ29uY3VycmVudCIsIndvcmtJblByb2dyZXNzUm9vdElzUHJlcmVuZGVyaW5nIiwiUm9vdERpZE5vdENvbXBsZXRlIiwid29ya0luUHJvZ3Jlc3NSb290RGlkU2tpcFN1c3BlbmRlZFNpYmxpbmdzIiwiaXNSZW5kZXJDb25zaXN0ZW50V2l0aEV4dGVybmFsU3RvcmVzIiwiZXJyb3JSZXRyeUxhbmVzIiwiZXJyb3JSZXRyeUxhbmVzJGpzY29tcCQwIiwid2FzUm9vdERlaHlkcmF0ZWQiLCJ3b3JrSW5Qcm9ncmVzc1Jvb3REaWRBdHRhY2hQaW5nTGlzdGVuZXIiLCJ3b3JrSW5Qcm9ncmVzc1Jvb3RSZWNvdmVyYWJsZUVycm9ycyIsIlJvb3RGYXRhbEVycm9yZWQiLCJSb290Q29tcGxldGVkIiwiY29tbWl0Um9vdCIsIndvcmtJblByb2dyZXNzVHJhbnNpdGlvbnMiLCJ3b3JrSW5Qcm9ncmVzc1Jvb3REaWRJbmNsdWRlUmVjdXJzaXZlUmVuZGVyVXBkYXRlIiwiSU1NRURJQVRFX0NPTU1JVCIsIkZBTExCQUNLX1RIUk9UVExFX01TIiwidGltZW91dEhhbmRsZSIsInNjaGVkdWxlVGltZW91dCIsImNvbW1pdFJvb3RXaGVuUmVhZHkiLCJUSFJPVFRMRURfQ09NTUlUIiwiZXJyb3JzIiwiYXBwbHkiLCJyZWNvdmVyYWJsZUVycm9ycyIsImRpZEluY2x1ZGVSZW5kZXJQaGFzZVVwZGF0ZSIsImRpZFNraXBTdXNwZW5kZWRTaWJsaW5ncyIsInN1c3BlbmRlZENvbW1pdFJlYXNvbiIsImNvbXBsZXRlZFJlbmRlclN0YXJ0VGltZSIsImNvbXBsZXRlZFJlbmRlckVuZFRpbWUiLCJzdGFydFN1c3BlbmRpbmdDb21taXQiLCJ3YWl0Rm9yQ29tbWl0VG9CZVJlYWR5IiwiU1VTUEVOREVEX0NPTU1JVCIsImNoZWNrIiwiZGlkQXR0ZW1wdEVudGlyZVRyZWUiLCJ3b3JrSW5Qcm9ncmVzc1Jvb3RQaW5nZWRMYW5lcyIsInJlc2V0V29ya0luUHJvZ3Jlc3NTdGFjayIsIk5vdFN1c3BlbmRlZCIsIm5vVGltZW91dCIsImNhbmNlbFRpbWVvdXQiLCJ3b3JrSW5Qcm9ncmVzc1Rocm93blZhbHVlIiwiYWxsRW50YW5nbGVkTGFuZXMiLCJkaXNjYXJkUGVuZGluZ1dhcm5pbmdzIiwiaGFuZGxlVGhyb3ciLCJ0aHJvd25WYWx1ZSIsIlN1c3BlbmRlZE9uSW1tZWRpYXRlIiwiU3VzcGVuZGVkT25JbnN0YW5jZSIsIlN1c3BlbmRlZE9uSHlkcmF0aW9uIiwiU3VzcGVuZGVkT25EZXByZWNhdGVkVGhyb3dQcm9taXNlIiwiU3VzcGVuZGVkT25FcnJvciIsImVycm9yZWRXb3JrIiwibWFya0NvbXBvbmVudEVycm9yZWQiLCJTdXNwZW5kZWRBbmRSZWFkeVRvQ29udGludWUiLCJtYXJrQ29tcG9uZW50U3VzcGVuZGVkIiwicHVzaERpc3BhdGNoZXIiLCJwdXNoQXN5bmNEaXNwYXRjaGVyIiwicHJldkFzeW5jRGlzcGF0Y2hlciIsIkEiLCJEZWZhdWx0QXN5bmNEaXNwYXRjaGVyIiwic2hvdWxkWWllbGRGb3JQcmVyZW5kZXJpbmciLCJwcmV2RXhlY3V0aW9uQ29udGV4dCIsInVuaXRPZldvcmsiLCJ0aHJvd0FuZFVud2luZFdvcmtMb29wIiwid29ya0xvb3BTeW5jIiwidGhyb3duVmFsdWUkNCIsInBlcmZvcm1Vbml0T2ZXb3JrIiwiUkVOREVSX1RJTUVPVVRfTVMiLCJyZXBsYXlTdXNwZW5kZWRVbml0T2ZXb3JrIiwiU3VzcGVuZGVkT25JbnN0YW5jZUFuZFJlYWR5VG9Db250aW51ZSIsImhvc3RGaWJlciIsImNvbXBsZXRlVW5pdE9mV29yayIsIndvcmtMb29wQ29uY3VycmVudCIsInRocm93blZhbHVlJDUiLCJtYXJrUmVuZGVyWWllbGRlZCIsInNob3VsZFlpZWxkIiwicmVwbGF5QmVnaW5Xb3JrIiwiaXNQcm9maWxpbmdNb2RlIiwic3VzcGVuZGVkUmVhc29uIiwidW53aW5kVW5pdE9mV29yayIsInNraXBTaWJsaW5ncyIsInByZXZpb3VzVXBkYXRlTGFuZVByaW9yaXR5IiwiY29tbWl0Um9vdEltcGwiLCJyZW5kZXJQcmlvcml0eUxldmVsIiwicm9vdFdpdGhQZW5kaW5nUGFzc2l2ZUVmZmVjdHMiLCJmbHVzaExlZ2FjeUNvbnRleHRXYXJuaW5nIiwiZmx1c2hQZW5kaW5nVW5zYWZlTGlmZWN5Y2xlV2FybmluZ3MiLCJtYXJrQ29tbWl0U3RhcnRlZCIsInJvb3REb2VzSGF2ZVBhc3NpdmVFZmZlY3RzIiwicGVuZGluZ1Bhc3NpdmVFZmZlY3RzUmVtYWluaW5nTGFuZXMiLCJwZW5kaW5nUGFzc2l2ZVRyYW5zaXRpb25zIiwic2NoZWR1bGVDYWxsYmFjayIsInJlc2V0QWZ0ZXJDb21taXQiLCJtYXJrTGF5b3V0RWZmZWN0c1N0YXJ0ZWQiLCJtYXJrTGF5b3V0RWZmZWN0c1N0b3BwZWQiLCJyZXF1ZXN0UGFpbnQiLCJwZW5kaW5nUGFzc2l2ZUVmZmVjdHNMYW5lcyIsInJlbGVhc2VSb290UG9vbGVkQ2FjaGUiLCJjb21taXREb3VibGVJbnZva2VFZmZlY3RzSW5ERVYiLCJvblJlY292ZXJhYmxlRXJyb3IiLCJtYWtlRXJyb3JJbmZvIiwicmVuZGVyUHJpb3JpdHkiLCJwcmlvcml0eSIsIm1hcmtQYXNzaXZlRWZmZWN0c1N0YXJ0ZWQiLCJtYXJrUGFzc2l2ZUVmZmVjdHNTdG9wcGVkIiwib25Qb3N0Q29tbWl0RmliZXJSb290IiwiY2FwdHVyZUNvbW1pdFBoYXNlRXJyb3JPblJvb3QiLCJyb290RmliZXIiLCJwaW5nQ2FjaGUiLCJQb3NzaWJseVdlYWtNYXAiLCJ0aHJlYWRJRHMiLCJwaW5nU3VzcGVuZGVkUm9vdCIsInJldHJ5VGltZWRPdXRCb3VuZGFyeSIsImJvdW5kYXJ5RmliZXIiLCJzdXNwZW5zZVN0YXRlIiwicmVjdXJzaXZlbHlUcmF2ZXJzZUFuZERvdWJsZUludm9rZUVmZmVjdHNJbkRFViIsImlzSW5TdHJpY3RNb2RlIiwiaXNTdHJpY3RNb2RlRmliZXIiLCJkb3VibGVJbnZva2VFZmZlY3RzT25GaWJlciIsInNob3VsZERvdWJsZUludm9rZVBhc3NpdmVFZmZlY3RzIiwiYXJndW1lbnRzIiwiZG91YmxlSW52b2tlRWZmZWN0cyIsImRpZFdhcm5TdGF0ZVVwZGF0ZUZvck5vdFlldE1vdW50ZWRDb21wb25lbnQiLCJzY2hlZHVsaW5nRmliZXIiLCJwcmlvcml0eUxldmVsIiwiZmFrZUFjdENhbGxiYWNrTm9kZSIsImZhbWlseSIsInByZXZUeXBlIiwibmVlZHNDb21wYXJlRmFtaWxpZXMiLCIkJHR5cGVvZk5leHRUeXBlIiwiV2Vha1NldCIsImZhaWxlZEJvdW5kYXJpZXMiLCJjYW5kaWRhdGVUeXBlIiwibmVlZHNSZW5kZXIiLCJoYXNCYWRNYXBQb2x5ZmlsbCIsInByZXZlbnRFeHRlbnNpb25zIiwiaXNSZWFjdENvbXBvbmVudCIsIm93bmVyIiwiZmliZXJUYWciLCJyZXNvbHZlZFR5cGUiLCJpc0hvc3RIb2lzdGFibGVUeXBlIiwiaXNIb3N0U2luZ2xldG9uVHlwZSIsIlJFQUNUX09GRlNDUkVFTl9UWVBFIiwiUkVBQ1RfUFJPVklERVJfVFlQRSIsImVsZW1lbnRzIiwicHJpbWFyeUNoaWxkSW5zdGFuY2UiLCJfcGVuZGluZ01hcmtlcnMiLCJfdHJhbnNpdGlvbnMiLCJkZXRhY2giLCJhdHRhY2giLCJGaWJlclJvb3ROb2RlIiwiaHlkcmF0ZSIsImluY29tcGxldGVUcmFuc2l0aW9ucyIsIl9kZWJ1Z1Jvb3RUeXBlIiwiY3JlYXRlRmliZXJSb290IiwiaW5pdGlhbENoaWxkcmVuIiwiaHlkcmF0aW9uQ2FsbGJhY2tzIiwiaXNTdHJpY3RNb2RlIiwidHJhbnNpdGlvbkNhbGxiYWNrcyIsInRlc3RTdHJpbmdDb2VyY2lvbiIsImdldENvbnRleHRGb3JTdWJ0cmVlIiwicGFyZW50Q29tcG9uZW50IiwidXBkYXRlQ29udGFpbmVySW1wbCIsIm9uU2NoZWR1bGVGaWJlclJvb3QiLCJtYXJrUmVuZGVyU2NoZWR1bGVkIiwiZGlkV2FybkFib3V0TmVzdGVkVXBkYXRlcyIsIm1hcmtSZXRyeUxhbmVJbXBsIiwibWFya1JldHJ5TGFuZUlmTm90SHlkcmF0ZWQiLCJnZXRDdXJyZW50RmliZXJGb3JEZXZUb29scyIsImdldExhbmVMYWJlbE1hcCIsImxhYmVsIiwiUmVhY3QiLCJyZXF1aXJlIiwiU2NoZWR1bGVyIiwiU3ltYm9sIiwiZm9yIiwiaXRlcmF0b3IiLCJfX0NMSUVOVF9JTlRFUk5BTFNfRE9fTk9UX1VTRV9PUl9XQVJOX1VTRVJTX1RIRVlfQ0FOTk9UX1VQR1JBREUiLCJfX3JlYWN0RGlzYWJsZWRMb2ciLCJXZWFrTWFwIiwiaXNBcnJheSIsInJlbmRlcmVyVmVyc2lvbiIsInJlbmRlcmVyUGFja2FnZU5hbWUiLCJleHRyYURldlRvb2xzQ29uZmlnIiwid2FybnNJZk5vdEFjdGluZyIsImJlZm9yZUFjdGl2ZUluc3RhbmNlQmx1ciIsImFmdGVyQWN0aXZlSW5zdGFuY2VCbHVyIiwicHJlcGFyZVNjb3BlVXBkYXRlIiwiZ2V0SW5zdGFuY2VGcm9tU2NvcGUiLCJyZXNvbHZlRXZlbnRUeXBlIiwicmVzb2x2ZUV2ZW50VGltZVN0YW1wIiwicmVxdWVzdFBvc3RQYWludENhbGxiYWNrIiwiYmluZFRvQ29uc29sZSIsImdldEJvdW5kaW5nUmVjdCIsInNldEZvY3VzSWZGb2N1c2FibGUiLCJzZXR1cEludGVyc2VjdGlvbk9ic2VydmVyIiwiZnJlZXplIiwiTWF0aCIsInVuc3RhYmxlX3NjaGVkdWxlQ2FsbGJhY2siLCJ1bnN0YWJsZV9jYW5jZWxDYWxsYmFjayIsInVuc3RhYmxlX3Nob3VsZFlpZWxkIiwidW5zdGFibGVfcmVxdWVzdFBhaW50IiwidW5zdGFibGVfbm93IiwidW5zdGFibGVfSW1tZWRpYXRlUHJpb3JpdHkiLCJ1bnN0YWJsZV9Vc2VyQmxvY2tpbmdQcmlvcml0eSIsInVuc3RhYmxlX05vcm1hbFByaW9yaXR5IiwidW5zdGFibGVfSWRsZVByaW9yaXR5IiwicGVuZGluZ0NvbXBvbmVudFdpbGxNb3VudFdhcm5pbmdzIiwicGVuZGluZ1VOU0FGRV9Db21wb25lbnRXaWxsTW91bnRXYXJuaW5ncyIsInBlbmRpbmdDb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzV2FybmluZ3MiLCJwZW5kaW5nVU5TQUZFX0NvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHNXYXJuaW5ncyIsInBlbmRpbmdDb21wb25lbnRXaWxsVXBkYXRlV2FybmluZ3MiLCJwZW5kaW5nVU5TQUZFX0NvbXBvbmVudFdpbGxVcGRhdGVXYXJuaW5ncyIsImRpZFdhcm5BYm91dFVuc2FmZUxpZmVjeWNsZXMiLCJjb21wb25lbnRXaWxsTW91bnRVbmlxdWVOYW1lcyIsIlVOU0FGRV9jb21wb25lbnRXaWxsTW91bnRVbmlxdWVOYW1lcyIsImNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHNVbmlxdWVOYW1lcyIsIlVOU0FGRV9jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzVW5pcXVlTmFtZXMiLCJjb21wb25lbnRXaWxsVXBkYXRlVW5pcXVlTmFtZXMiLCJVTlNBRkVfY29tcG9uZW50V2lsbFVwZGF0ZVVuaXF1ZU5hbWVzIiwic29ydGVkTmFtZXMiLCJwZW5kaW5nTGVnYWN5Q29udGV4dFdhcm5pbmciLCJkaWRXYXJuQWJvdXRMZWdhY3lDb250ZXh0Iiwic3RyaWN0Um9vdCIsImZpYmVyQXJyYXkiLCJmaXJzdEZpYmVyIiwidW5pcXVlTmFtZXMiLCJjYWxsQ29tcG9uZW50Iiwid2FzUmVuZGVyaW5nIiwiY2FsbFJlbmRlciIsImNhbGxDb21wb25lbnREaWRNb3VudCIsImNhbGxDb21wb25lbnREaWRVcGRhdGUiLCJjYWxsQ29tcG9uZW50RGlkQ2F0Y2giLCJjYWxsQ29tcG9uZW50V2lsbFVubW91bnQiLCJjYWxsQ3JlYXRlIiwiZWZmZWN0IiwiY2FsbERlc3Ryb3kiLCJjYWxsTGF6eUluaXQiLCJsYXp5Iiwib3duZXJIYXNLZXlVc2VXYXJuaW5nIiwiX3N0b3JlIiwidmFsaWRhdGVkIiwiY29tcG9uZW50S2V5IiwiY3VycmVudENvbXBvbmVudEVycm9ySW5mbyIsImNoaWxkT3duZXJBcHBlbmRpeCIsInVzZUNhbGxiYWNrIiwidXNlQ29udGV4dCIsInVzZUVmZmVjdCIsInVzZUltcGVyYXRpdmVIYW5kbGUiLCJ1c2VMYXlvdXRFZmZlY3QiLCJ1c2VJbnNlcnRpb25FZmZlY3QiLCJ1c2VNZW1vIiwidXNlUmVkdWNlciIsInVzZVJlZiIsInVzZURlYnVnVmFsdWUiLCJ1c2VEZWZlcnJlZFZhbHVlIiwidXNlVHJhbnNpdGlvbiIsInVzZVN5bmNFeHRlcm5hbFN0b3JlIiwidXNlSWQiLCJ1c2VDYWNoZVJlZnJlc2giLCJ1c2VGb3JtU3RhdGUiLCJ1c2VBY3Rpb25TdGF0ZSIsInVzZU9wdGltaXN0aWMiLCJJbnZhbGlkTmVzdGVkSG9va3NEaXNwYXRjaGVyT25Nb3VudEluREVWIiwiSW52YWxpZE5lc3RlZEhvb2tzRGlzcGF0Y2hlck9uUmVyZW5kZXJJbkRFViIsImlzTW91bnRlZCIsImNvbXBvbmVudCIsIl93YXJuZWRBYm91dFJlZnNJblJlbmRlciIsImVucXVldWVGb3JjZVVwZGF0ZSIsIm1hcmtGb3JjZVVwZGF0ZVNjaGVkdWxlZCIsInJlcG9ydEdsb2JhbEVycm9yIiwicmVwb3J0RXJyb3IiLCJ3aW5kb3ciLCJFcnJvckV2ZW50IiwiZXZlbnQiLCJidWJibGVzIiwiY2FuY2VsYWJsZSIsImRpc3BhdGNoRXZlbnQiLCJwcm9jZXNzIiwiZW1pdCIsIkFib3J0Q29udHJvbGxlciIsImFkZEV2ZW50TGlzdGVuZXIiLCJDb25zdW1lciIsIlByb3ZpZGVyIiwiX3RocmVhZENvdW50IiwicHJldk9uU3RhcnRUcmFuc2l0aW9uRmluaXNoIiwiZ2V0Q2FjaGVGb3JUeXBlIiwicmVzb3VyY2VUeXBlIiwiY2FjaGVGb3JUeXBlIiwiZ2V0T3duZXIiLCJzeW1ib2xGb3IiLCJJbmZpbml0eSIsIm5vbkV4dGVuc2libGVPYmplY3QiLCJkaWRXYXJuQWJvdXRGaW5kTm9kZUluU3RyaWN0TW9kZSIsIm92ZXJyaWRlSG9va1N0YXRlIiwib3ZlcnJpZGVIb29rU3RhdGVEZWxldGVQYXRoIiwib3ZlcnJpZGVIb29rU3RhdGVSZW5hbWVQYXRoIiwib3ZlcnJpZGVQcm9wcyIsIm92ZXJyaWRlUHJvcHNEZWxldGVQYXRoIiwib3ZlcnJpZGVQcm9wc1JlbmFtZVBhdGgiLCJzY2hlZHVsZVVwZGF0ZSIsInNldEVycm9ySGFuZGxlciIsInNldFN1c3BlbnNlSGFuZGxlciIsIm5ld1Nob3VsZEVycm9ySW1wbCIsIm5ld1Nob3VsZFN1c3BlbmRJbXBsIiwiYXR0ZW1wdENvbnRpbnVvdXNIeWRyYXRpb24iLCJhdHRlbXB0SHlkcmF0aW9uQXRDdXJyZW50UHJpb3JpdHkiLCJhdHRlbXB0U3luY2hyb25vdXNIeWRyYXRpb24iLCJiYXRjaGVkVXBkYXRlcyIsImNyZWF0ZUNvbXBvbmVudFNlbGVjdG9yIiwiY3JlYXRlQ29udGFpbmVyIiwiY29uY3VycmVudFVwZGF0ZXNCeURlZmF1bHRPdmVycmlkZSIsImNyZWF0ZUhhc1BzZXVkb0NsYXNzU2VsZWN0b3IiLCJjcmVhdGVIeWRyYXRpb25Db250YWluZXIiLCJjcmVhdGVQb3J0YWwiLCJlJDYiLCJ0b1N0cmluZ1RhZyIsImNvbnN0cnVjdG9yIiwiY3JlYXRlUm9sZVNlbGVjdG9yIiwicm9sZSIsImNyZWF0ZVRlc3ROYW1lU2VsZWN0b3IiLCJjcmVhdGVUZXh0U2VsZWN0b3IiLCJ0ZXh0IiwiZGVmYXVsdE9uQ2F1Z2h0RXJyb3IiLCJjb21wb25lbnROYW1lTWVzc2FnZSIsInJlY3JlYXRlTWVzc2FnZSIsInByZXZHZXRDdXJyZW50U3RhY2siLCJlbnZpcm9ubWVudE5hbWUiLCJkZWZhdWx0T25SZWNvdmVyYWJsZUVycm9yIiwiZGVmYXVsdE9uVW5jYXVnaHRFcnJvciIsImRlZmVycmVkVXBkYXRlcyIsImRpc2NyZXRlVXBkYXRlcyIsImQiLCJmaW5kQm91bmRpbmdSZWN0cyIsInRhcmdldExlZnQiLCJ0YXJnZXRSaWdodCIsIndpZHRoIiwidGFyZ2V0VG9wIiwidGFyZ2V0Qm90dG9tIiwiaGVpZ2h0IiwiaiIsIm90aGVyUmVjdCIsIm90aGVyTGVmdCIsIm90aGVyUmlnaHQiLCJvdGhlclRvcCIsIm90aGVyQm90dG9tIiwiZmluZEhvc3RJbnN0YW5jZSIsImZpbmRIb3N0SW5zdGFuY2VXaXRoTm9Qb3J0YWxzIiwiZmluZEhvc3RJbnN0YW5jZVdpdGhXYXJuaW5nIiwibWV0aG9kTmFtZSIsImZsdXNoU3luY0Zyb21SZWNvbmNpbGVyIiwiZm9jdXNXaXRoaW4iLCJnZXRGaW5kQWxsTm9kZXNGYWlsdXJlRGVzY3JpcHRpb24iLCJtYXhTZWxlY3RvckluZGV4IiwibWF0Y2hlZE5hbWVzIiwiZ2V0UHVibGljUm9vdEluc3RhbmNlIiwiaW5qZWN0SW50b0RldlRvb2xzIiwiYnVuZGxlVHlwZSIsInZlcnNpb24iLCJjdXJyZW50RGlzcGF0Y2hlclJlZiIsImZpbmRGaWJlckJ5SG9zdEluc3RhbmNlIiwicmVjb25jaWxlclZlcnNpb24iLCJyZW5kZXJlckNvbmZpZyIsImdldEN1cnJlbnRGaWJlciIsImlzQWxyZWFkeVJlbmRlcmluZyIsIm9ic2VydmVWaXNpYmxlUmVjdHMiLCJvcHRpb25zIiwibmV4dEluc3RhbmNlUm9vdHMiLCJpbnN0YW5jZVJvb3RzIiwidGFyZ2V0IiwidW5vYnNlcnZlIiwib2JzZXJ2ZSIsImRpc2Nvbm5lY3QiLCJzaG91bGRFcnJvciIsInNob3VsZFN1c3BlbmQiLCJzdGFydEhvc3RUcmFuc2l0aW9uIiwiZm9ybURhdGEiLCJyZXNldFN0YXRlUXVldWUiLCJ1cGRhdGVDb250YWluZXIiLCJkZWZhdWx0Il0sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/react-reconciler/cjs/react-reconciler.development.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/react-reconciler/constants.js":
/*!****************************************************!*\
  !*** ./node_modules/react-reconciler/constants.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nif (false) {} else {\n  module.exports = __webpack_require__(/*! ./cjs/react-reconciler-constants.development.js */ \"(ssr)/./node_modules/react-reconciler/cjs/react-reconciler-constants.development.js\");\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmVhY3QtcmVjb25jaWxlci9jb25zdGFudHMuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsSUFBSSxLQUFxQyxFQUFFLEVBRTFDLENBQUM7QUFDRixFQUFFLGtMQUEyRTtBQUM3RSIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxSYXZpc2ggU2luZ2hcXEVDT0ZcXGVjb1xcZWNvLWN5Y2xlXFxub2RlX21vZHVsZXNcXHJlYWN0LXJlY29uY2lsZXJcXGNvbnN0YW50cy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9janMvcmVhY3QtcmVjb25jaWxlci1jb25zdGFudHMucHJvZHVjdGlvbi5qcycpO1xufSBlbHNlIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2Nqcy9yZWFjdC1yZWNvbmNpbGVyLWNvbnN0YW50cy5kZXZlbG9wbWVudC5qcycpO1xufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/react-reconciler/constants.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/react-reconciler/index.js":
/*!************************************************!*\
  !*** ./node_modules/react-reconciler/index.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nif (false) {} else {\n  module.exports = __webpack_require__(/*! ./cjs/react-reconciler.development.js */ \"(ssr)/./node_modules/react-reconciler/cjs/react-reconciler.development.js\");\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmVhY3QtcmVjb25jaWxlci9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYixJQUFJLEtBQXFDLEVBQUUsRUFFMUMsQ0FBQztBQUNGLEVBQUUsOEpBQWlFO0FBQ25FIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXFJhdmlzaCBTaW5naFxcRUNPRlxcZWNvXFxlY28tY3ljbGVcXG5vZGVfbW9kdWxlc1xccmVhY3QtcmVjb25jaWxlclxcaW5kZXguanMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdwcm9kdWN0aW9uJykge1xuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vY2pzL3JlYWN0LXJlY29uY2lsZXIucHJvZHVjdGlvbi5qcycpO1xufSBlbHNlIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2Nqcy9yZWFjdC1yZWNvbmNpbGVyLmRldmVsb3BtZW50LmpzJyk7XG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/react-reconciler/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/react-reconciler/node_modules/scheduler/cjs/scheduler.development.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/react-reconciler/node_modules/scheduler/cjs/scheduler.development.js ***!
  \*******************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("/**\n * @license React\n * scheduler.development.js\n *\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\n true &&\n  (function () {\n    function performWorkUntilDeadline() {\n      if (isMessageLoopRunning) {\n        var currentTime = exports.unstable_now();\n        startTime = currentTime;\n        var hasMoreWork = !0;\n        try {\n          a: {\n            isHostCallbackScheduled = !1;\n            isHostTimeoutScheduled &&\n              ((isHostTimeoutScheduled = !1),\n              localClearTimeout(taskTimeoutID),\n              (taskTimeoutID = -1));\n            isPerformingWork = !0;\n            var previousPriorityLevel = currentPriorityLevel;\n            try {\n              b: {\n                advanceTimers(currentTime);\n                for (\n                  currentTask = peek(taskQueue);\n                  null !== currentTask &&\n                  !(\n                    currentTask.expirationTime > currentTime &&\n                    shouldYieldToHost()\n                  );\n\n                ) {\n                  var callback = currentTask.callback;\n                  if (\"function\" === typeof callback) {\n                    currentTask.callback = null;\n                    currentPriorityLevel = currentTask.priorityLevel;\n                    var continuationCallback = callback(\n                      currentTask.expirationTime <= currentTime\n                    );\n                    currentTime = exports.unstable_now();\n                    if (\"function\" === typeof continuationCallback) {\n                      currentTask.callback = continuationCallback;\n                      advanceTimers(currentTime);\n                      hasMoreWork = !0;\n                      break b;\n                    }\n                    currentTask === peek(taskQueue) && pop(taskQueue);\n                    advanceTimers(currentTime);\n                  } else pop(taskQueue);\n                  currentTask = peek(taskQueue);\n                }\n                if (null !== currentTask) hasMoreWork = !0;\n                else {\n                  var firstTimer = peek(timerQueue);\n                  null !== firstTimer &&\n                    requestHostTimeout(\n                      handleTimeout,\n                      firstTimer.startTime - currentTime\n                    );\n                  hasMoreWork = !1;\n                }\n              }\n              break a;\n            } finally {\n              (currentTask = null),\n                (currentPriorityLevel = previousPriorityLevel),\n                (isPerformingWork = !1);\n            }\n            hasMoreWork = void 0;\n          }\n        } finally {\n          hasMoreWork\n            ? schedulePerformWorkUntilDeadline()\n            : (isMessageLoopRunning = !1);\n        }\n      }\n    }\n    function push(heap, node) {\n      var index = heap.length;\n      heap.push(node);\n      a: for (; 0 < index; ) {\n        var parentIndex = (index - 1) >>> 1,\n          parent = heap[parentIndex];\n        if (0 < compare(parent, node))\n          (heap[parentIndex] = node),\n            (heap[index] = parent),\n            (index = parentIndex);\n        else break a;\n      }\n    }\n    function peek(heap) {\n      return 0 === heap.length ? null : heap[0];\n    }\n    function pop(heap) {\n      if (0 === heap.length) return null;\n      var first = heap[0],\n        last = heap.pop();\n      if (last !== first) {\n        heap[0] = last;\n        a: for (\n          var index = 0, length = heap.length, halfLength = length >>> 1;\n          index < halfLength;\n\n        ) {\n          var leftIndex = 2 * (index + 1) - 1,\n            left = heap[leftIndex],\n            rightIndex = leftIndex + 1,\n            right = heap[rightIndex];\n          if (0 > compare(left, last))\n            rightIndex < length && 0 > compare(right, left)\n              ? ((heap[index] = right),\n                (heap[rightIndex] = last),\n                (index = rightIndex))\n              : ((heap[index] = left),\n                (heap[leftIndex] = last),\n                (index = leftIndex));\n          else if (rightIndex < length && 0 > compare(right, last))\n            (heap[index] = right),\n              (heap[rightIndex] = last),\n              (index = rightIndex);\n          else break a;\n        }\n      }\n      return first;\n    }\n    function compare(a, b) {\n      var diff = a.sortIndex - b.sortIndex;\n      return 0 !== diff ? diff : a.id - b.id;\n    }\n    function advanceTimers(currentTime) {\n      for (var timer = peek(timerQueue); null !== timer; ) {\n        if (null === timer.callback) pop(timerQueue);\n        else if (timer.startTime <= currentTime)\n          pop(timerQueue),\n            (timer.sortIndex = timer.expirationTime),\n            push(taskQueue, timer);\n        else break;\n        timer = peek(timerQueue);\n      }\n    }\n    function handleTimeout(currentTime) {\n      isHostTimeoutScheduled = !1;\n      advanceTimers(currentTime);\n      if (!isHostCallbackScheduled)\n        if (null !== peek(taskQueue))\n          (isHostCallbackScheduled = !0), requestHostCallback();\n        else {\n          var firstTimer = peek(timerQueue);\n          null !== firstTimer &&\n            requestHostTimeout(\n              handleTimeout,\n              firstTimer.startTime - currentTime\n            );\n        }\n    }\n    function shouldYieldToHost() {\n      return exports.unstable_now() - startTime < frameInterval ? !1 : !0;\n    }\n    function requestHostCallback() {\n      isMessageLoopRunning ||\n        ((isMessageLoopRunning = !0), schedulePerformWorkUntilDeadline());\n    }\n    function requestHostTimeout(callback, ms) {\n      taskTimeoutID = localSetTimeout(function () {\n        callback(exports.unstable_now());\n      }, ms);\n    }\n    \"undefined\" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ &&\n      \"function\" ===\n        typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart &&\n      __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(Error());\n    exports.unstable_now = void 0;\n    if (\n      \"object\" === typeof performance &&\n      \"function\" === typeof performance.now\n    ) {\n      var localPerformance = performance;\n      exports.unstable_now = function () {\n        return localPerformance.now();\n      };\n    } else {\n      var localDate = Date,\n        initialTime = localDate.now();\n      exports.unstable_now = function () {\n        return localDate.now() - initialTime;\n      };\n    }\n    var taskQueue = [],\n      timerQueue = [],\n      taskIdCounter = 1,\n      currentTask = null,\n      currentPriorityLevel = 3,\n      isPerformingWork = !1,\n      isHostCallbackScheduled = !1,\n      isHostTimeoutScheduled = !1,\n      localSetTimeout = \"function\" === typeof setTimeout ? setTimeout : null,\n      localClearTimeout =\n        \"function\" === typeof clearTimeout ? clearTimeout : null,\n      localSetImmediate =\n        \"undefined\" !== typeof setImmediate ? setImmediate : null,\n      isMessageLoopRunning = !1,\n      taskTimeoutID = -1,\n      frameInterval = 5,\n      startTime = -1;\n    if (\"function\" === typeof localSetImmediate)\n      var schedulePerformWorkUntilDeadline = function () {\n        localSetImmediate(performWorkUntilDeadline);\n      };\n    else if (\"undefined\" !== typeof MessageChannel) {\n      var channel = new MessageChannel(),\n        port = channel.port2;\n      channel.port1.onmessage = performWorkUntilDeadline;\n      schedulePerformWorkUntilDeadline = function () {\n        port.postMessage(null);\n      };\n    } else\n      schedulePerformWorkUntilDeadline = function () {\n        localSetTimeout(performWorkUntilDeadline, 0);\n      };\n    exports.unstable_IdlePriority = 5;\n    exports.unstable_ImmediatePriority = 1;\n    exports.unstable_LowPriority = 4;\n    exports.unstable_NormalPriority = 3;\n    exports.unstable_Profiling = null;\n    exports.unstable_UserBlockingPriority = 2;\n    exports.unstable_cancelCallback = function (task) {\n      task.callback = null;\n    };\n    exports.unstable_continueExecution = function () {\n      isHostCallbackScheduled ||\n        isPerformingWork ||\n        ((isHostCallbackScheduled = !0), requestHostCallback());\n    };\n    exports.unstable_forceFrameRate = function (fps) {\n      0 > fps || 125 < fps\n        ? console.error(\n            \"forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported\"\n          )\n        : (frameInterval = 0 < fps ? Math.floor(1e3 / fps) : 5);\n    };\n    exports.unstable_getCurrentPriorityLevel = function () {\n      return currentPriorityLevel;\n    };\n    exports.unstable_getFirstCallbackNode = function () {\n      return peek(taskQueue);\n    };\n    exports.unstable_next = function (eventHandler) {\n      switch (currentPriorityLevel) {\n        case 1:\n        case 2:\n        case 3:\n          var priorityLevel = 3;\n          break;\n        default:\n          priorityLevel = currentPriorityLevel;\n      }\n      var previousPriorityLevel = currentPriorityLevel;\n      currentPriorityLevel = priorityLevel;\n      try {\n        return eventHandler();\n      } finally {\n        currentPriorityLevel = previousPriorityLevel;\n      }\n    };\n    exports.unstable_pauseExecution = function () {};\n    exports.unstable_requestPaint = function () {};\n    exports.unstable_runWithPriority = function (priorityLevel, eventHandler) {\n      switch (priorityLevel) {\n        case 1:\n        case 2:\n        case 3:\n        case 4:\n        case 5:\n          break;\n        default:\n          priorityLevel = 3;\n      }\n      var previousPriorityLevel = currentPriorityLevel;\n      currentPriorityLevel = priorityLevel;\n      try {\n        return eventHandler();\n      } finally {\n        currentPriorityLevel = previousPriorityLevel;\n      }\n    };\n    exports.unstable_scheduleCallback = function (\n      priorityLevel,\n      callback,\n      options\n    ) {\n      var currentTime = exports.unstable_now();\n      \"object\" === typeof options && null !== options\n        ? ((options = options.delay),\n          (options =\n            \"number\" === typeof options && 0 < options\n              ? currentTime + options\n              : currentTime))\n        : (options = currentTime);\n      switch (priorityLevel) {\n        case 1:\n          var timeout = -1;\n          break;\n        case 2:\n          timeout = 250;\n          break;\n        case 5:\n          timeout = 1073741823;\n          break;\n        case 4:\n          timeout = 1e4;\n          break;\n        default:\n          timeout = 5e3;\n      }\n      timeout = options + timeout;\n      priorityLevel = {\n        id: taskIdCounter++,\n        callback: callback,\n        priorityLevel: priorityLevel,\n        startTime: options,\n        expirationTime: timeout,\n        sortIndex: -1\n      };\n      options > currentTime\n        ? ((priorityLevel.sortIndex = options),\n          push(timerQueue, priorityLevel),\n          null === peek(taskQueue) &&\n            priorityLevel === peek(timerQueue) &&\n            (isHostTimeoutScheduled\n              ? (localClearTimeout(taskTimeoutID), (taskTimeoutID = -1))\n              : (isHostTimeoutScheduled = !0),\n            requestHostTimeout(handleTimeout, options - currentTime)))\n        : ((priorityLevel.sortIndex = timeout),\n          push(taskQueue, priorityLevel),\n          isHostCallbackScheduled ||\n            isPerformingWork ||\n            ((isHostCallbackScheduled = !0), requestHostCallback()));\n      return priorityLevel;\n    };\n    exports.unstable_shouldYield = shouldYieldToHost;\n    exports.unstable_wrapCallback = function (callback) {\n      var parentPriorityLevel = currentPriorityLevel;\n      return function () {\n        var previousPriorityLevel = currentPriorityLevel;\n        currentPriorityLevel = parentPriorityLevel;\n        try {\n          return callback.apply(this, arguments);\n        } finally {\n          currentPriorityLevel = previousPriorityLevel;\n        }\n      };\n    };\n    \"undefined\" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ &&\n      \"function\" ===\n        typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop &&\n      __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(Error());\n  })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmVhY3QtcmVjb25jaWxlci9ub2RlX21vZHVsZXMvc2NoZWR1bGVyL2Nqcy9zY2hlZHVsZXIuZGV2ZWxvcG1lbnQuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVhO0FBQ2IsS0FBcUM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsV0FBVztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLGdCQUFnQjtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSxvQkFBb0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sb0JBQW9CO0FBQzFCO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLE1BQU0sb0JBQW9CO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLElBQUksNkJBQTZCO0FBQ2pDLElBQUksa0NBQWtDO0FBQ3RDLElBQUksNEJBQTRCO0FBQ2hDLElBQUksK0JBQStCO0FBQ25DLElBQUksMEJBQTBCO0FBQzlCLElBQUkscUNBQXFDO0FBQ3pDLElBQUksK0JBQStCO0FBQ25DO0FBQ0E7QUFDQSxJQUFJLGtDQUFrQztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksK0JBQStCO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksd0NBQXdDO0FBQzVDO0FBQ0E7QUFDQSxJQUFJLHFDQUFxQztBQUN6QztBQUNBO0FBQ0EsSUFBSSxxQkFBcUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsSUFBSSwrQkFBK0I7QUFDbkMsSUFBSSw2QkFBNkI7QUFDakMsSUFBSSxnQ0FBZ0M7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxJQUFJLGlDQUFpQztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSw0QkFBNEI7QUFDaEMsSUFBSSw2QkFBNkI7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXFJhdmlzaCBTaW5naFxcRUNPRlxcZWNvXFxlY28tY3ljbGVcXG5vZGVfbW9kdWxlc1xccmVhY3QtcmVjb25jaWxlclxcbm9kZV9tb2R1bGVzXFxzY2hlZHVsZXJcXGNqc1xcc2NoZWR1bGVyLmRldmVsb3BtZW50LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGxpY2Vuc2UgUmVhY3RcbiAqIHNjaGVkdWxlci5kZXZlbG9wbWVudC5qc1xuICpcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxuXCJ1c2Ugc3RyaWN0XCI7XG5cInByb2R1Y3Rpb25cIiAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgJiZcbiAgKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBwZXJmb3JtV29ya1VudGlsRGVhZGxpbmUoKSB7XG4gICAgICBpZiAoaXNNZXNzYWdlTG9vcFJ1bm5pbmcpIHtcbiAgICAgICAgdmFyIGN1cnJlbnRUaW1lID0gZXhwb3J0cy51bnN0YWJsZV9ub3coKTtcbiAgICAgICAgc3RhcnRUaW1lID0gY3VycmVudFRpbWU7XG4gICAgICAgIHZhciBoYXNNb3JlV29yayA9ICEwO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGE6IHtcbiAgICAgICAgICAgIGlzSG9zdENhbGxiYWNrU2NoZWR1bGVkID0gITE7XG4gICAgICAgICAgICBpc0hvc3RUaW1lb3V0U2NoZWR1bGVkICYmXG4gICAgICAgICAgICAgICgoaXNIb3N0VGltZW91dFNjaGVkdWxlZCA9ICExKSxcbiAgICAgICAgICAgICAgbG9jYWxDbGVhclRpbWVvdXQodGFza1RpbWVvdXRJRCksXG4gICAgICAgICAgICAgICh0YXNrVGltZW91dElEID0gLTEpKTtcbiAgICAgICAgICAgIGlzUGVyZm9ybWluZ1dvcmsgPSAhMDtcbiAgICAgICAgICAgIHZhciBwcmV2aW91c1ByaW9yaXR5TGV2ZWwgPSBjdXJyZW50UHJpb3JpdHlMZXZlbDtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIGI6IHtcbiAgICAgICAgICAgICAgICBhZHZhbmNlVGltZXJzKGN1cnJlbnRUaW1lKTtcbiAgICAgICAgICAgICAgICBmb3IgKFxuICAgICAgICAgICAgICAgICAgY3VycmVudFRhc2sgPSBwZWVrKHRhc2tRdWV1ZSk7XG4gICAgICAgICAgICAgICAgICBudWxsICE9PSBjdXJyZW50VGFzayAmJlxuICAgICAgICAgICAgICAgICAgIShcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudFRhc2suZXhwaXJhdGlvblRpbWUgPiBjdXJyZW50VGltZSAmJlxuICAgICAgICAgICAgICAgICAgICBzaG91bGRZaWVsZFRvSG9zdCgpXG4gICAgICAgICAgICAgICAgICApO1xuXG4gICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICB2YXIgY2FsbGJhY2sgPSBjdXJyZW50VGFzay5jYWxsYmFjaztcbiAgICAgICAgICAgICAgICAgIGlmIChcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBjYWxsYmFjaykge1xuICAgICAgICAgICAgICAgICAgICBjdXJyZW50VGFzay5jYWxsYmFjayA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRQcmlvcml0eUxldmVsID0gY3VycmVudFRhc2sucHJpb3JpdHlMZXZlbDtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNvbnRpbnVhdGlvbkNhbGxiYWNrID0gY2FsbGJhY2soXG4gICAgICAgICAgICAgICAgICAgICAgY3VycmVudFRhc2suZXhwaXJhdGlvblRpbWUgPD0gY3VycmVudFRpbWVcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudFRpbWUgPSBleHBvcnRzLnVuc3RhYmxlX25vdygpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoXCJmdW5jdGlvblwiID09PSB0eXBlb2YgY29udGludWF0aW9uQ2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50VGFzay5jYWxsYmFjayA9IGNvbnRpbnVhdGlvbkNhbGxiYWNrO1xuICAgICAgICAgICAgICAgICAgICAgIGFkdmFuY2VUaW1lcnMoY3VycmVudFRpbWUpO1xuICAgICAgICAgICAgICAgICAgICAgIGhhc01vcmVXb3JrID0gITA7XG4gICAgICAgICAgICAgICAgICAgICAgYnJlYWsgYjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjdXJyZW50VGFzayA9PT0gcGVlayh0YXNrUXVldWUpICYmIHBvcCh0YXNrUXVldWUpO1xuICAgICAgICAgICAgICAgICAgICBhZHZhbmNlVGltZXJzKGN1cnJlbnRUaW1lKTtcbiAgICAgICAgICAgICAgICAgIH0gZWxzZSBwb3AodGFza1F1ZXVlKTtcbiAgICAgICAgICAgICAgICAgIGN1cnJlbnRUYXNrID0gcGVlayh0YXNrUXVldWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAobnVsbCAhPT0gY3VycmVudFRhc2spIGhhc01vcmVXb3JrID0gITA7XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICB2YXIgZmlyc3RUaW1lciA9IHBlZWsodGltZXJRdWV1ZSk7XG4gICAgICAgICAgICAgICAgICBudWxsICE9PSBmaXJzdFRpbWVyICYmXG4gICAgICAgICAgICAgICAgICAgIHJlcXVlc3RIb3N0VGltZW91dChcbiAgICAgICAgICAgICAgICAgICAgICBoYW5kbGVUaW1lb3V0LFxuICAgICAgICAgICAgICAgICAgICAgIGZpcnN0VGltZXIuc3RhcnRUaW1lIC0gY3VycmVudFRpbWVcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgIGhhc01vcmVXb3JrID0gITE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGJyZWFrIGE7XG4gICAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgICAoY3VycmVudFRhc2sgPSBudWxsKSxcbiAgICAgICAgICAgICAgICAoY3VycmVudFByaW9yaXR5TGV2ZWwgPSBwcmV2aW91c1ByaW9yaXR5TGV2ZWwpLFxuICAgICAgICAgICAgICAgIChpc1BlcmZvcm1pbmdXb3JrID0gITEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaGFzTW9yZVdvcmsgPSB2b2lkIDA7XG4gICAgICAgICAgfVxuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIGhhc01vcmVXb3JrXG4gICAgICAgICAgICA/IHNjaGVkdWxlUGVyZm9ybVdvcmtVbnRpbERlYWRsaW5lKClcbiAgICAgICAgICAgIDogKGlzTWVzc2FnZUxvb3BSdW5uaW5nID0gITEpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIHB1c2goaGVhcCwgbm9kZSkge1xuICAgICAgdmFyIGluZGV4ID0gaGVhcC5sZW5ndGg7XG4gICAgICBoZWFwLnB1c2gobm9kZSk7XG4gICAgICBhOiBmb3IgKDsgMCA8IGluZGV4OyApIHtcbiAgICAgICAgdmFyIHBhcmVudEluZGV4ID0gKGluZGV4IC0gMSkgPj4+IDEsXG4gICAgICAgICAgcGFyZW50ID0gaGVhcFtwYXJlbnRJbmRleF07XG4gICAgICAgIGlmICgwIDwgY29tcGFyZShwYXJlbnQsIG5vZGUpKVxuICAgICAgICAgIChoZWFwW3BhcmVudEluZGV4XSA9IG5vZGUpLFxuICAgICAgICAgICAgKGhlYXBbaW5kZXhdID0gcGFyZW50KSxcbiAgICAgICAgICAgIChpbmRleCA9IHBhcmVudEluZGV4KTtcbiAgICAgICAgZWxzZSBicmVhayBhO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBwZWVrKGhlYXApIHtcbiAgICAgIHJldHVybiAwID09PSBoZWFwLmxlbmd0aCA/IG51bGwgOiBoZWFwWzBdO1xuICAgIH1cbiAgICBmdW5jdGlvbiBwb3AoaGVhcCkge1xuICAgICAgaWYgKDAgPT09IGhlYXAubGVuZ3RoKSByZXR1cm4gbnVsbDtcbiAgICAgIHZhciBmaXJzdCA9IGhlYXBbMF0sXG4gICAgICAgIGxhc3QgPSBoZWFwLnBvcCgpO1xuICAgICAgaWYgKGxhc3QgIT09IGZpcnN0KSB7XG4gICAgICAgIGhlYXBbMF0gPSBsYXN0O1xuICAgICAgICBhOiBmb3IgKFxuICAgICAgICAgIHZhciBpbmRleCA9IDAsIGxlbmd0aCA9IGhlYXAubGVuZ3RoLCBoYWxmTGVuZ3RoID0gbGVuZ3RoID4+PiAxO1xuICAgICAgICAgIGluZGV4IDwgaGFsZkxlbmd0aDtcblxuICAgICAgICApIHtcbiAgICAgICAgICB2YXIgbGVmdEluZGV4ID0gMiAqIChpbmRleCArIDEpIC0gMSxcbiAgICAgICAgICAgIGxlZnQgPSBoZWFwW2xlZnRJbmRleF0sXG4gICAgICAgICAgICByaWdodEluZGV4ID0gbGVmdEluZGV4ICsgMSxcbiAgICAgICAgICAgIHJpZ2h0ID0gaGVhcFtyaWdodEluZGV4XTtcbiAgICAgICAgICBpZiAoMCA+IGNvbXBhcmUobGVmdCwgbGFzdCkpXG4gICAgICAgICAgICByaWdodEluZGV4IDwgbGVuZ3RoICYmIDAgPiBjb21wYXJlKHJpZ2h0LCBsZWZ0KVxuICAgICAgICAgICAgICA/ICgoaGVhcFtpbmRleF0gPSByaWdodCksXG4gICAgICAgICAgICAgICAgKGhlYXBbcmlnaHRJbmRleF0gPSBsYXN0KSxcbiAgICAgICAgICAgICAgICAoaW5kZXggPSByaWdodEluZGV4KSlcbiAgICAgICAgICAgICAgOiAoKGhlYXBbaW5kZXhdID0gbGVmdCksXG4gICAgICAgICAgICAgICAgKGhlYXBbbGVmdEluZGV4XSA9IGxhc3QpLFxuICAgICAgICAgICAgICAgIChpbmRleCA9IGxlZnRJbmRleCkpO1xuICAgICAgICAgIGVsc2UgaWYgKHJpZ2h0SW5kZXggPCBsZW5ndGggJiYgMCA+IGNvbXBhcmUocmlnaHQsIGxhc3QpKVxuICAgICAgICAgICAgKGhlYXBbaW5kZXhdID0gcmlnaHQpLFxuICAgICAgICAgICAgICAoaGVhcFtyaWdodEluZGV4XSA9IGxhc3QpLFxuICAgICAgICAgICAgICAoaW5kZXggPSByaWdodEluZGV4KTtcbiAgICAgICAgICBlbHNlIGJyZWFrIGE7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBmaXJzdDtcbiAgICB9XG4gICAgZnVuY3Rpb24gY29tcGFyZShhLCBiKSB7XG4gICAgICB2YXIgZGlmZiA9IGEuc29ydEluZGV4IC0gYi5zb3J0SW5kZXg7XG4gICAgICByZXR1cm4gMCAhPT0gZGlmZiA/IGRpZmYgOiBhLmlkIC0gYi5pZDtcbiAgICB9XG4gICAgZnVuY3Rpb24gYWR2YW5jZVRpbWVycyhjdXJyZW50VGltZSkge1xuICAgICAgZm9yICh2YXIgdGltZXIgPSBwZWVrKHRpbWVyUXVldWUpOyBudWxsICE9PSB0aW1lcjsgKSB7XG4gICAgICAgIGlmIChudWxsID09PSB0aW1lci5jYWxsYmFjaykgcG9wKHRpbWVyUXVldWUpO1xuICAgICAgICBlbHNlIGlmICh0aW1lci5zdGFydFRpbWUgPD0gY3VycmVudFRpbWUpXG4gICAgICAgICAgcG9wKHRpbWVyUXVldWUpLFxuICAgICAgICAgICAgKHRpbWVyLnNvcnRJbmRleCA9IHRpbWVyLmV4cGlyYXRpb25UaW1lKSxcbiAgICAgICAgICAgIHB1c2godGFza1F1ZXVlLCB0aW1lcik7XG4gICAgICAgIGVsc2UgYnJlYWs7XG4gICAgICAgIHRpbWVyID0gcGVlayh0aW1lclF1ZXVlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gaGFuZGxlVGltZW91dChjdXJyZW50VGltZSkge1xuICAgICAgaXNIb3N0VGltZW91dFNjaGVkdWxlZCA9ICExO1xuICAgICAgYWR2YW5jZVRpbWVycyhjdXJyZW50VGltZSk7XG4gICAgICBpZiAoIWlzSG9zdENhbGxiYWNrU2NoZWR1bGVkKVxuICAgICAgICBpZiAobnVsbCAhPT0gcGVlayh0YXNrUXVldWUpKVxuICAgICAgICAgIChpc0hvc3RDYWxsYmFja1NjaGVkdWxlZCA9ICEwKSwgcmVxdWVzdEhvc3RDYWxsYmFjaygpO1xuICAgICAgICBlbHNlIHtcbiAgICAgICAgICB2YXIgZmlyc3RUaW1lciA9IHBlZWsodGltZXJRdWV1ZSk7XG4gICAgICAgICAgbnVsbCAhPT0gZmlyc3RUaW1lciAmJlxuICAgICAgICAgICAgcmVxdWVzdEhvc3RUaW1lb3V0KFxuICAgICAgICAgICAgICBoYW5kbGVUaW1lb3V0LFxuICAgICAgICAgICAgICBmaXJzdFRpbWVyLnN0YXJ0VGltZSAtIGN1cnJlbnRUaW1lXG4gICAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIHNob3VsZFlpZWxkVG9Ib3N0KCkge1xuICAgICAgcmV0dXJuIGV4cG9ydHMudW5zdGFibGVfbm93KCkgLSBzdGFydFRpbWUgPCBmcmFtZUludGVydmFsID8gITEgOiAhMDtcbiAgICB9XG4gICAgZnVuY3Rpb24gcmVxdWVzdEhvc3RDYWxsYmFjaygpIHtcbiAgICAgIGlzTWVzc2FnZUxvb3BSdW5uaW5nIHx8XG4gICAgICAgICgoaXNNZXNzYWdlTG9vcFJ1bm5pbmcgPSAhMCksIHNjaGVkdWxlUGVyZm9ybVdvcmtVbnRpbERlYWRsaW5lKCkpO1xuICAgIH1cbiAgICBmdW5jdGlvbiByZXF1ZXN0SG9zdFRpbWVvdXQoY2FsbGJhY2ssIG1zKSB7XG4gICAgICB0YXNrVGltZW91dElEID0gbG9jYWxTZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY2FsbGJhY2soZXhwb3J0cy51bnN0YWJsZV9ub3coKSk7XG4gICAgICB9LCBtcyk7XG4gICAgfVxuICAgIFwidW5kZWZpbmVkXCIgIT09IHR5cGVvZiBfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX18gJiZcbiAgICAgIFwiZnVuY3Rpb25cIiA9PT1cbiAgICAgICAgdHlwZW9mIF9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXy5yZWdpc3RlckludGVybmFsTW9kdWxlU3RhcnQgJiZcbiAgICAgIF9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXy5yZWdpc3RlckludGVybmFsTW9kdWxlU3RhcnQoRXJyb3IoKSk7XG4gICAgZXhwb3J0cy51bnN0YWJsZV9ub3cgPSB2b2lkIDA7XG4gICAgaWYgKFxuICAgICAgXCJvYmplY3RcIiA9PT0gdHlwZW9mIHBlcmZvcm1hbmNlICYmXG4gICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBwZXJmb3JtYW5jZS5ub3dcbiAgICApIHtcbiAgICAgIHZhciBsb2NhbFBlcmZvcm1hbmNlID0gcGVyZm9ybWFuY2U7XG4gICAgICBleHBvcnRzLnVuc3RhYmxlX25vdyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGxvY2FsUGVyZm9ybWFuY2Uubm93KCk7XG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgbG9jYWxEYXRlID0gRGF0ZSxcbiAgICAgICAgaW5pdGlhbFRpbWUgPSBsb2NhbERhdGUubm93KCk7XG4gICAgICBleHBvcnRzLnVuc3RhYmxlX25vdyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGxvY2FsRGF0ZS5ub3coKSAtIGluaXRpYWxUaW1lO1xuICAgICAgfTtcbiAgICB9XG4gICAgdmFyIHRhc2tRdWV1ZSA9IFtdLFxuICAgICAgdGltZXJRdWV1ZSA9IFtdLFxuICAgICAgdGFza0lkQ291bnRlciA9IDEsXG4gICAgICBjdXJyZW50VGFzayA9IG51bGwsXG4gICAgICBjdXJyZW50UHJpb3JpdHlMZXZlbCA9IDMsXG4gICAgICBpc1BlcmZvcm1pbmdXb3JrID0gITEsXG4gICAgICBpc0hvc3RDYWxsYmFja1NjaGVkdWxlZCA9ICExLFxuICAgICAgaXNIb3N0VGltZW91dFNjaGVkdWxlZCA9ICExLFxuICAgICAgbG9jYWxTZXRUaW1lb3V0ID0gXCJmdW5jdGlvblwiID09PSB0eXBlb2Ygc2V0VGltZW91dCA/IHNldFRpbWVvdXQgOiBudWxsLFxuICAgICAgbG9jYWxDbGVhclRpbWVvdXQgPVxuICAgICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBjbGVhclRpbWVvdXQgPyBjbGVhclRpbWVvdXQgOiBudWxsLFxuICAgICAgbG9jYWxTZXRJbW1lZGlhdGUgPVxuICAgICAgICBcInVuZGVmaW5lZFwiICE9PSB0eXBlb2Ygc2V0SW1tZWRpYXRlID8gc2V0SW1tZWRpYXRlIDogbnVsbCxcbiAgICAgIGlzTWVzc2FnZUxvb3BSdW5uaW5nID0gITEsXG4gICAgICB0YXNrVGltZW91dElEID0gLTEsXG4gICAgICBmcmFtZUludGVydmFsID0gNSxcbiAgICAgIHN0YXJ0VGltZSA9IC0xO1xuICAgIGlmIChcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBsb2NhbFNldEltbWVkaWF0ZSlcbiAgICAgIHZhciBzY2hlZHVsZVBlcmZvcm1Xb3JrVW50aWxEZWFkbGluZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgbG9jYWxTZXRJbW1lZGlhdGUocGVyZm9ybVdvcmtVbnRpbERlYWRsaW5lKTtcbiAgICAgIH07XG4gICAgZWxzZSBpZiAoXCJ1bmRlZmluZWRcIiAhPT0gdHlwZW9mIE1lc3NhZ2VDaGFubmVsKSB7XG4gICAgICB2YXIgY2hhbm5lbCA9IG5ldyBNZXNzYWdlQ2hhbm5lbCgpLFxuICAgICAgICBwb3J0ID0gY2hhbm5lbC5wb3J0MjtcbiAgICAgIGNoYW5uZWwucG9ydDEub25tZXNzYWdlID0gcGVyZm9ybVdvcmtVbnRpbERlYWRsaW5lO1xuICAgICAgc2NoZWR1bGVQZXJmb3JtV29ya1VudGlsRGVhZGxpbmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHBvcnQucG9zdE1lc3NhZ2UobnVsbCk7XG4gICAgICB9O1xuICAgIH0gZWxzZVxuICAgICAgc2NoZWR1bGVQZXJmb3JtV29ya1VudGlsRGVhZGxpbmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGxvY2FsU2V0VGltZW91dChwZXJmb3JtV29ya1VudGlsRGVhZGxpbmUsIDApO1xuICAgICAgfTtcbiAgICBleHBvcnRzLnVuc3RhYmxlX0lkbGVQcmlvcml0eSA9IDU7XG4gICAgZXhwb3J0cy51bnN0YWJsZV9JbW1lZGlhdGVQcmlvcml0eSA9IDE7XG4gICAgZXhwb3J0cy51bnN0YWJsZV9Mb3dQcmlvcml0eSA9IDQ7XG4gICAgZXhwb3J0cy51bnN0YWJsZV9Ob3JtYWxQcmlvcml0eSA9IDM7XG4gICAgZXhwb3J0cy51bnN0YWJsZV9Qcm9maWxpbmcgPSBudWxsO1xuICAgIGV4cG9ydHMudW5zdGFibGVfVXNlckJsb2NraW5nUHJpb3JpdHkgPSAyO1xuICAgIGV4cG9ydHMudW5zdGFibGVfY2FuY2VsQ2FsbGJhY2sgPSBmdW5jdGlvbiAodGFzaykge1xuICAgICAgdGFzay5jYWxsYmFjayA9IG51bGw7XG4gICAgfTtcbiAgICBleHBvcnRzLnVuc3RhYmxlX2NvbnRpbnVlRXhlY3V0aW9uID0gZnVuY3Rpb24gKCkge1xuICAgICAgaXNIb3N0Q2FsbGJhY2tTY2hlZHVsZWQgfHxcbiAgICAgICAgaXNQZXJmb3JtaW5nV29yayB8fFxuICAgICAgICAoKGlzSG9zdENhbGxiYWNrU2NoZWR1bGVkID0gITApLCByZXF1ZXN0SG9zdENhbGxiYWNrKCkpO1xuICAgIH07XG4gICAgZXhwb3J0cy51bnN0YWJsZV9mb3JjZUZyYW1lUmF0ZSA9IGZ1bmN0aW9uIChmcHMpIHtcbiAgICAgIDAgPiBmcHMgfHwgMTI1IDwgZnBzXG4gICAgICAgID8gY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgIFwiZm9yY2VGcmFtZVJhdGUgdGFrZXMgYSBwb3NpdGl2ZSBpbnQgYmV0d2VlbiAwIGFuZCAxMjUsIGZvcmNpbmcgZnJhbWUgcmF0ZXMgaGlnaGVyIHRoYW4gMTI1IGZwcyBpcyBub3Qgc3VwcG9ydGVkXCJcbiAgICAgICAgICApXG4gICAgICAgIDogKGZyYW1lSW50ZXJ2YWwgPSAwIDwgZnBzID8gTWF0aC5mbG9vcigxZTMgLyBmcHMpIDogNSk7XG4gICAgfTtcbiAgICBleHBvcnRzLnVuc3RhYmxlX2dldEN1cnJlbnRQcmlvcml0eUxldmVsID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIGN1cnJlbnRQcmlvcml0eUxldmVsO1xuICAgIH07XG4gICAgZXhwb3J0cy51bnN0YWJsZV9nZXRGaXJzdENhbGxiYWNrTm9kZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBwZWVrKHRhc2tRdWV1ZSk7XG4gICAgfTtcbiAgICBleHBvcnRzLnVuc3RhYmxlX25leHQgPSBmdW5jdGlvbiAoZXZlbnRIYW5kbGVyKSB7XG4gICAgICBzd2l0Y2ggKGN1cnJlbnRQcmlvcml0eUxldmVsKSB7XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgY2FzZSAyOlxuICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgdmFyIHByaW9yaXR5TGV2ZWwgPSAzO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHByaW9yaXR5TGV2ZWwgPSBjdXJyZW50UHJpb3JpdHlMZXZlbDtcbiAgICAgIH1cbiAgICAgIHZhciBwcmV2aW91c1ByaW9yaXR5TGV2ZWwgPSBjdXJyZW50UHJpb3JpdHlMZXZlbDtcbiAgICAgIGN1cnJlbnRQcmlvcml0eUxldmVsID0gcHJpb3JpdHlMZXZlbDtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBldmVudEhhbmRsZXIoKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIGN1cnJlbnRQcmlvcml0eUxldmVsID0gcHJldmlvdXNQcmlvcml0eUxldmVsO1xuICAgICAgfVxuICAgIH07XG4gICAgZXhwb3J0cy51bnN0YWJsZV9wYXVzZUV4ZWN1dGlvbiA9IGZ1bmN0aW9uICgpIHt9O1xuICAgIGV4cG9ydHMudW5zdGFibGVfcmVxdWVzdFBhaW50ID0gZnVuY3Rpb24gKCkge307XG4gICAgZXhwb3J0cy51bnN0YWJsZV9ydW5XaXRoUHJpb3JpdHkgPSBmdW5jdGlvbiAocHJpb3JpdHlMZXZlbCwgZXZlbnRIYW5kbGVyKSB7XG4gICAgICBzd2l0Y2ggKHByaW9yaXR5TGV2ZWwpIHtcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICBjYXNlIDI6XG4gICAgICAgIGNhc2UgMzpcbiAgICAgICAgY2FzZSA0OlxuICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgcHJpb3JpdHlMZXZlbCA9IDM7XG4gICAgICB9XG4gICAgICB2YXIgcHJldmlvdXNQcmlvcml0eUxldmVsID0gY3VycmVudFByaW9yaXR5TGV2ZWw7XG4gICAgICBjdXJyZW50UHJpb3JpdHlMZXZlbCA9IHByaW9yaXR5TGV2ZWw7XG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gZXZlbnRIYW5kbGVyKCk7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBjdXJyZW50UHJpb3JpdHlMZXZlbCA9IHByZXZpb3VzUHJpb3JpdHlMZXZlbDtcbiAgICAgIH1cbiAgICB9O1xuICAgIGV4cG9ydHMudW5zdGFibGVfc2NoZWR1bGVDYWxsYmFjayA9IGZ1bmN0aW9uIChcbiAgICAgIHByaW9yaXR5TGV2ZWwsXG4gICAgICBjYWxsYmFjayxcbiAgICAgIG9wdGlvbnNcbiAgICApIHtcbiAgICAgIHZhciBjdXJyZW50VGltZSA9IGV4cG9ydHMudW5zdGFibGVfbm93KCk7XG4gICAgICBcIm9iamVjdFwiID09PSB0eXBlb2Ygb3B0aW9ucyAmJiBudWxsICE9PSBvcHRpb25zXG4gICAgICAgID8gKChvcHRpb25zID0gb3B0aW9ucy5kZWxheSksXG4gICAgICAgICAgKG9wdGlvbnMgPVxuICAgICAgICAgICAgXCJudW1iZXJcIiA9PT0gdHlwZW9mIG9wdGlvbnMgJiYgMCA8IG9wdGlvbnNcbiAgICAgICAgICAgICAgPyBjdXJyZW50VGltZSArIG9wdGlvbnNcbiAgICAgICAgICAgICAgOiBjdXJyZW50VGltZSkpXG4gICAgICAgIDogKG9wdGlvbnMgPSBjdXJyZW50VGltZSk7XG4gICAgICBzd2l0Y2ggKHByaW9yaXR5TGV2ZWwpIHtcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgIHZhciB0aW1lb3V0ID0gLTE7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMjpcbiAgICAgICAgICB0aW1lb3V0ID0gMjUwO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgdGltZW91dCA9IDEwNzM3NDE4MjM7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgNDpcbiAgICAgICAgICB0aW1lb3V0ID0gMWU0O1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHRpbWVvdXQgPSA1ZTM7XG4gICAgICB9XG4gICAgICB0aW1lb3V0ID0gb3B0aW9ucyArIHRpbWVvdXQ7XG4gICAgICBwcmlvcml0eUxldmVsID0ge1xuICAgICAgICBpZDogdGFza0lkQ291bnRlcisrLFxuICAgICAgICBjYWxsYmFjazogY2FsbGJhY2ssXG4gICAgICAgIHByaW9yaXR5TGV2ZWw6IHByaW9yaXR5TGV2ZWwsXG4gICAgICAgIHN0YXJ0VGltZTogb3B0aW9ucyxcbiAgICAgICAgZXhwaXJhdGlvblRpbWU6IHRpbWVvdXQsXG4gICAgICAgIHNvcnRJbmRleDogLTFcbiAgICAgIH07XG4gICAgICBvcHRpb25zID4gY3VycmVudFRpbWVcbiAgICAgICAgPyAoKHByaW9yaXR5TGV2ZWwuc29ydEluZGV4ID0gb3B0aW9ucyksXG4gICAgICAgICAgcHVzaCh0aW1lclF1ZXVlLCBwcmlvcml0eUxldmVsKSxcbiAgICAgICAgICBudWxsID09PSBwZWVrKHRhc2tRdWV1ZSkgJiZcbiAgICAgICAgICAgIHByaW9yaXR5TGV2ZWwgPT09IHBlZWsodGltZXJRdWV1ZSkgJiZcbiAgICAgICAgICAgIChpc0hvc3RUaW1lb3V0U2NoZWR1bGVkXG4gICAgICAgICAgICAgID8gKGxvY2FsQ2xlYXJUaW1lb3V0KHRhc2tUaW1lb3V0SUQpLCAodGFza1RpbWVvdXRJRCA9IC0xKSlcbiAgICAgICAgICAgICAgOiAoaXNIb3N0VGltZW91dFNjaGVkdWxlZCA9ICEwKSxcbiAgICAgICAgICAgIHJlcXVlc3RIb3N0VGltZW91dChoYW5kbGVUaW1lb3V0LCBvcHRpb25zIC0gY3VycmVudFRpbWUpKSlcbiAgICAgICAgOiAoKHByaW9yaXR5TGV2ZWwuc29ydEluZGV4ID0gdGltZW91dCksXG4gICAgICAgICAgcHVzaCh0YXNrUXVldWUsIHByaW9yaXR5TGV2ZWwpLFxuICAgICAgICAgIGlzSG9zdENhbGxiYWNrU2NoZWR1bGVkIHx8XG4gICAgICAgICAgICBpc1BlcmZvcm1pbmdXb3JrIHx8XG4gICAgICAgICAgICAoKGlzSG9zdENhbGxiYWNrU2NoZWR1bGVkID0gITApLCByZXF1ZXN0SG9zdENhbGxiYWNrKCkpKTtcbiAgICAgIHJldHVybiBwcmlvcml0eUxldmVsO1xuICAgIH07XG4gICAgZXhwb3J0cy51bnN0YWJsZV9zaG91bGRZaWVsZCA9IHNob3VsZFlpZWxkVG9Ib3N0O1xuICAgIGV4cG9ydHMudW5zdGFibGVfd3JhcENhbGxiYWNrID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gICAgICB2YXIgcGFyZW50UHJpb3JpdHlMZXZlbCA9IGN1cnJlbnRQcmlvcml0eUxldmVsO1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHByZXZpb3VzUHJpb3JpdHlMZXZlbCA9IGN1cnJlbnRQcmlvcml0eUxldmVsO1xuICAgICAgICBjdXJyZW50UHJpb3JpdHlMZXZlbCA9IHBhcmVudFByaW9yaXR5TGV2ZWw7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgcmV0dXJuIGNhbGxiYWNrLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgY3VycmVudFByaW9yaXR5TGV2ZWwgPSBwcmV2aW91c1ByaW9yaXR5TGV2ZWw7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfTtcbiAgICBcInVuZGVmaW5lZFwiICE9PSB0eXBlb2YgX19SRUFDVF9ERVZUT09MU19HTE9CQUxfSE9PS19fICYmXG4gICAgICBcImZ1bmN0aW9uXCIgPT09XG4gICAgICAgIHR5cGVvZiBfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX18ucmVnaXN0ZXJJbnRlcm5hbE1vZHVsZVN0b3AgJiZcbiAgICAgIF9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXy5yZWdpc3RlckludGVybmFsTW9kdWxlU3RvcChFcnJvcigpKTtcbiAgfSkoKTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/react-reconciler/node_modules/scheduler/cjs/scheduler.development.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/react-reconciler/node_modules/scheduler/index.js":
/*!***********************************************************************!*\
  !*** ./node_modules/react-reconciler/node_modules/scheduler/index.js ***!
  \***********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nif (false) {} else {\n  module.exports = __webpack_require__(/*! ./cjs/scheduler.development.js */ \"(ssr)/./node_modules/react-reconciler/node_modules/scheduler/cjs/scheduler.development.js\");\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmVhY3QtcmVjb25jaWxlci9ub2RlX21vZHVsZXMvc2NoZWR1bGVyL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLElBQUksS0FBcUMsRUFBRSxFQUUxQyxDQUFDO0FBQ0YsRUFBRSx1S0FBMEQ7QUFDNUQiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcUmF2aXNoIFNpbmdoXFxFQ09GXFxlY29cXGVjby1jeWNsZVxcbm9kZV9tb2R1bGVzXFxyZWFjdC1yZWNvbmNpbGVyXFxub2RlX21vZHVsZXNcXHNjaGVkdWxlclxcaW5kZXguanMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdwcm9kdWN0aW9uJykge1xuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vY2pzL3NjaGVkdWxlci5wcm9kdWN0aW9uLmpzJyk7XG59IGVsc2Uge1xuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vY2pzL3NjaGVkdWxlci5kZXZlbG9wbWVudC5qcycpO1xufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/react-reconciler/node_modules/scheduler/index.js\n");

/***/ })

};
;